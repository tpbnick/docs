<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://nicklyss.com/media/uploads/2020/12/nord.png><meta name=generator content="mkdocs-1.1, mkdocs-material-5.5.12"><title>Data Structures Overview - Nick's Docs</title><link rel=stylesheet href=../assets/stylesheets/main.4dd2dd8d.min.css><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback"><style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style><link rel=stylesheet href=../stylesheets/extra.css></head> <body dir=ltr> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay for=__drawer></label> <div data-md-component=skip> <a href=#data-structures class=md-skip> Skip to content </a> </div> <div data-md-component=announce> </div> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid" aria-label=Header> <a href=.. title="Nick's Docs" class="md-header-nav__button md-logo" aria-label="Nick's Docs"> <img src=https://nicklyss.com/media/uploads/2020/12/nord2.png alt=logo> </a> <label class="md-header-nav__button md-icon" for=__drawer> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg> </label> <div class=md-header-nav__title data-md-component=header-title> <div class=md-header-nav__ellipsis> <span class="md-header-nav__topic md-ellipsis"> Nick's Docs </span> <span class="md-header-nav__topic md-ellipsis"> Data Structures Overview </span> </div> </div> <label class="md-header-nav__button md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> </label> <div class=md-search data-md-component=search role=dialog> <label class=md-search__overlay for=__search></label> <div class=md-search__inner role=search> <form class=md-search__form name=search> <input type=text class=md-search__input name=query aria-label=Search placeholder=Search autocapitalize=off autocorrect=off autocomplete=off spellcheck=false data-md-component=search-query data-md-state=active> <label class="md-search__icon md-icon" for=__search> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </label> <button type=reset class="md-search__icon md-icon" aria-label=Clear data-md-component=search-reset tabindex=-1> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg> </button> </form> <div class=md-search__output> <div class=md-search__scrollwrap data-md-scrollfix> <div class=md-search-result data-md-component=search-result> <div class=md-search-result__meta> Initializing search </div> <ol class=md-search-result__list></ol> </div> </div> </div> </div> </div> </nav> </header> <div class=md-container data-md-component=container> <main class=md-main data-md-component=main> <div class="md-main__inner md-grid"> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" aria-label=Navigation data-md-level=0> <label class=md-nav__title for=__drawer> <a href=.. title="Nick's Docs" class="md-nav__button md-logo" aria-label="Nick's Docs"> <img src=https://nicklyss.com/media/uploads/2020/12/nord2.png alt=logo> </a> Nick's Docs </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=.. title=Home class=md-nav__link> Home </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-2 type=checkbox id=nav-2> <label class=md-nav__link for=nav-2> Nick's Portfolio <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Nick's Portfolio" data-md-level=1> <label class=md-nav__title for=nav-2> <span class="md-nav__icon md-icon"></span> Nick's Portfolio </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../portfolio/ title="Main Portfolio" class=md-nav__link> Main Portfolio </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-2-2 type=checkbox id=nav-2-2> <label class=md-nav__link for=nav-2-2> Google Chrome User Guide <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Google Chrome User Guide" data-md-level=2> <label class=md-nav__title for=nav-2-2> <span class="md-nav__icon md-icon"></span> Google Chrome User Guide </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../chrome/ title="What is Google Chrome?" class=md-nav__link> What is Google Chrome? </a> </li> <li class=md-nav__item> <a href=../chromeinstall/ title="Google Chrome Install" class=md-nav__link> Google Chrome Install </a> </li> <li class=md-nav__item> <a href=../chromemedia/ title="Google Chrome Media" class=md-nav__link> Google Chrome Media </a> </li> <li class=md-nav__item> <a href=../glossary/ title=Glossary class=md-nav__link> Glossary </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3 type=checkbox id=nav-3 checked> <label class=md-nav__link for=nav-3> Programming Notes <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Programming Notes" data-md-level=1> <label class=md-nav__title for=nav-3> <span class="md-nav__icon md-icon"></span> Programming Notes </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../notes/ title="Notes Overview" class=md-nav__link> Notes Overview </a> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3-2 type=checkbox id=nav-3-2 checked> <label class=md-nav__link for=nav-3-2> C <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=C data-md-level=2> <label class=md-nav__title for=nav-3-2> <span class="md-nav__icon md-icon"></span> C </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../c/ title="C Basics" class=md-nav__link> C Basics </a> </li> <li class=md-nav__item> <a href=../c-arrays/ title=Arrays class=md-nav__link> Arrays </a> </li> <li class=md-nav__item> <a href=../c-functions/ title=Functions class=md-nav__link> Functions </a> </li> <li class=md-nav__item> <a href=../c-cl-arguments/ title="Command Line Arguments" class=md-nav__link> Command Line Arguments </a> </li> <li class=md-nav__item> <a href=../c-variable-scope/ title="Variables and Scope" class=md-nav__link> Variables and Scope </a> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3-2-6 type=checkbox id=nav-3-2-6> <label class=md-nav__link for=nav-3-2-6> Algorithms <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Algorithms data-md-level=3> <label class=md-nav__title for=nav-3-2-6> <span class="md-nav__icon md-icon"></span> Algorithms </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../c-algorithms/ title="Algorithm Overview" class=md-nav__link> Algorithm Overview </a> </li> <li class=md-nav__item> <a href=../c-algorithms-problems/ title="Algorithm Problems" class=md-nav__link> Algorithm Problems </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3-2-7 type=checkbox id=nav-3-2-7> <label class=md-nav__link for=nav-3-2-7> Memory <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Memory data-md-level=3> <label class=md-nav__title for=nav-3-2-7> <span class="md-nav__icon md-icon"></span> Memory </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../c-memory/ title="Memory Overview" class=md-nav__link> Memory Overview </a> </li> <li class=md-nav__item> <a href=../c-memory-problems/ title="Memory Problems" class=md-nav__link> Memory Problems </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--active md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3-2-8 type=checkbox id=nav-3-2-8 checked> <label class=md-nav__link for=nav-3-2-8> Data Structures <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label="Data Structures" data-md-level=3> <label class=md-nav__title for=nav-3-2-8> <span class="md-nav__icon md-icon"></span> Data Structures </label> <ul class=md-nav__list data-md-scrollfix> <li class="md-nav__item md-nav__item--active"> <input class="md-nav__toggle md-toggle" data-md-toggle=toc type=checkbox id=__toc> <label class="md-nav__link md-nav__link--active" for=__toc> Data Structures Overview <span class="md-nav__icon md-icon"></span> </label> <a href=./ title="Data Structures Overview" class="md-nav__link md-nav__link--active"> Data Structures Overview </a> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#data-structures-summary class=md-nav__link> Data Structures Summary </a> <nav class=md-nav aria-label="Data Structures Summary"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#arrays class=md-nav__link> Arrays </a> </li> <li class=md-nav__item> <a href=#linked-lists class=md-nav__link> Linked lists </a> </li> <li class=md-nav__item> <a href=#hash-tables class=md-nav__link> Hash tables </a> </li> <li class=md-nav__item> <a href=#tries class=md-nav__link> Tries </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#pointers class=md-nav__link> Pointers </a> </li> <li class=md-nav__item> <a href=#resizing-arrays class=md-nav__link> Resizing arrays </a> </li> <li class=md-nav__item> <a href=#data-structures_1 class=md-nav__link> Data Structures </a> </li> <li class=md-nav__item> <a href=#linked-lists_1 class=md-nav__link> Linked Lists </a> <nav class=md-nav aria-label="Linked Lists"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#create-a-linked-list class=md-nav__link> Create a linked list </a> </li> <li class=md-nav__item> <a href=#search-through-a-linked-list-to-find-an-element class=md-nav__link> Search through a linked list to find an element </a> </li> <li class=md-nav__item> <a href=#insert-a-new-node-into-the-linked-list class=md-nav__link> Insert a new node into the linked list </a> </li> <li class=md-nav__item> <a href=#delete-a-single-element-from-a-linked-list class=md-nav__link> Delete a single element from a linked list </a> </li> <li class=md-nav__item> <a href=#delete-an-entire-linked-list class=md-nav__link> Delete an entire linked list </a> </li> <li class=md-nav__item> <a href=#additional-linked-list-notes class=md-nav__link> Additional linked list notes </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#hash-table class=md-nav__link> Hash Table </a> </li> <li class=md-nav__item> <a href=#tries_1 class=md-nav__link> Tries </a> </li> <li class=md-nav__item> <a href=#more-data-structures class=md-nav__link> More data structures </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../c-data-structures-problems/ title="Data Structures Problem" class=md-nav__link> Data Structures Problem </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3-3 type=checkbox id=nav-3-3> <label class=md-nav__link for=nav-3-3> Python <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Python data-md-level=2> <label class=md-nav__title for=nav-3-3> <span class="md-nav__icon md-icon"></span> Python </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../py/ title="Python Basics" class=md-nav__link> Python Basics </a> </li> <li class=md-nav__item> <a href=../py-data-types/ title="Variables and Simple Data Types" class=md-nav__link> Variables and Simple Data Types </a> </li> <li class=md-nav__item> <a href=../py-lists/ title=Lists class=md-nav__link> Lists </a> </li> <li class=md-nav__item> <a href=../py-working-with-lists/ title="Working with Lists" class=md-nav__link> Working with Lists </a> </li> <li class=md-nav__item> <a href=../py-if-statements/ title="If Statements" class=md-nav__link> If Statements </a> </li> <li class=md-nav__item> <a href=../py-dictionaries/ title=Dictionaries class=md-nav__link> Dictionaries </a> </li> <li class=md-nav__item> <a href=../py-user-input-while-loops/ title="User Input and while Loops" class=md-nav__link> User Input and while Loops </a> </li> <li class=md-nav__item> <a href=../py-functions/ title=Functions class=md-nav__link> Functions </a> </li> <li class=md-nav__item> <a href=../py-classes/ title=Classes class=md-nav__link> Classes </a> </li> <li class=md-nav__item> <a href=../py-random/ title="Random Programs" class=md-nav__link> Random Programs </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3-4 type=checkbox id=nav-3-4> <label class=md-nav__link for=nav-3-4> SQL <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=SQL data-md-level=2> <label class=md-nav__title for=nav-3-4> <span class="md-nav__icon md-icon"></span> SQL </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../sql/ title="SQL Basics" class=md-nav__link> SQL Basics </a> </li> <li class=md-nav__item> <a href=../sql-joins-and-other-queries/ title="Joins and Other Query Types" class=md-nav__link> Joins and Other Query Types </a> </li> <li class=md-nav__item> <a href=../sql-random/ title="Random Problems" class=md-nav__link> Random Problems </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3-5 type=checkbox id=nav-3-5> <label class=md-nav__link for=nav-3-5> JavaScript <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=JavaScript data-md-level=2> <label class=md-nav__title for=nav-3-5> <span class="md-nav__icon md-icon"></span> JavaScript </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../js/ title="JavaScript Basics" class=md-nav__link> JavaScript Basics </a> </li> <li class=md-nav__item> <a href=../js-data-types/ title="Variables and Simple Data Types" class=md-nav__link> Variables and Simple Data Types </a> </li> </ul> </nav> </li> <li class="md-nav__item md-nav__item--nested"> <input class="md-nav__toggle md-toggle" data-md-toggle=nav-3-6 type=checkbox id=nav-3-6> <label class=md-nav__link for=nav-3-6> Random <span class="md-nav__icon md-icon"></span> </label> <nav class=md-nav aria-label=Random data-md-level=2> <label class=md-nav__title for=nav-3-6> <span class="md-nav__icon md-icon"></span> Random </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../api/ title="API Overview" class=md-nav__link> API Overview </a> </li> <li class=md-nav__item> <a href=../django/ title=Django class=md-nav__link> Django </a> </li> </ul> </nav> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=../about/ title=About class=md-nav__link> About </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary" aria-label="Table of contents"> <label class=md-nav__title for=__toc> <span class="md-nav__icon md-icon"></span> Table of contents </label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#data-structures-summary class=md-nav__link> Data Structures Summary </a> <nav class=md-nav aria-label="Data Structures Summary"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#arrays class=md-nav__link> Arrays </a> </li> <li class=md-nav__item> <a href=#linked-lists class=md-nav__link> Linked lists </a> </li> <li class=md-nav__item> <a href=#hash-tables class=md-nav__link> Hash tables </a> </li> <li class=md-nav__item> <a href=#tries class=md-nav__link> Tries </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#pointers class=md-nav__link> Pointers </a> </li> <li class=md-nav__item> <a href=#resizing-arrays class=md-nav__link> Resizing arrays </a> </li> <li class=md-nav__item> <a href=#data-structures_1 class=md-nav__link> Data Structures </a> </li> <li class=md-nav__item> <a href=#linked-lists_1 class=md-nav__link> Linked Lists </a> <nav class=md-nav aria-label="Linked Lists"> <ul class=md-nav__list> <li class=md-nav__item> <a href=#create-a-linked-list class=md-nav__link> Create a linked list </a> </li> <li class=md-nav__item> <a href=#search-through-a-linked-list-to-find-an-element class=md-nav__link> Search through a linked list to find an element </a> </li> <li class=md-nav__item> <a href=#insert-a-new-node-into-the-linked-list class=md-nav__link> Insert a new node into the linked list </a> </li> <li class=md-nav__item> <a href=#delete-a-single-element-from-a-linked-list class=md-nav__link> Delete a single element from a linked list </a> </li> <li class=md-nav__item> <a href=#delete-an-entire-linked-list class=md-nav__link> Delete an entire linked list </a> </li> <li class=md-nav__item> <a href=#additional-linked-list-notes class=md-nav__link> Additional linked list notes </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#hash-table class=md-nav__link> Hash Table </a> </li> <li class=md-nav__item> <a href=#tries_1 class=md-nav__link> Tries </a> </li> <li class=md-nav__item> <a href=#more-data-structures class=md-nav__link> More data structures </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <h1 id=data-structures>Data Structures<a class=headerlink href=#data-structures title="Permanent link">&para;</a></h1> <h2 id=data-structures-summary>Data Structures Summary<a class=headerlink href=#data-structures-summary title="Permanent link">&para;</a></h2> <p>By this point we've now examined four different ways to store sets of data: </p> <ul> <li> <p><a href=#arrays>Arrays</a></p> </li> <li> <p><a href=#linked-lists>Linked lists</a></p> </li> <li> <p><a href=#hash-tables>Hash tables</a></p> </li> <li> <p><a href=#tries>Tries</a> </p> </li> </ul> <p>There are even some variations on these (trees and heaps, quite similar to tries, stacks and queues quite similar to arrays or linked lists, etc.) but this will generally cover most of what we're looking at in C. </p> <h3 id=arrays>Arrays<a class=headerlink href=#arrays title="Permanent link">&para;</a></h3> <ul> <li> <p>Insertion is bad - lots of shifting to fit an element in the middle.</p> </li> <li> <p>Deletion is bad - lots of shifting after removing an element.</p> </li> <li> <p>Lookup is great - random access, constant time.</p> </li> <li> <p>Relatively easy to sort. </p> </li> <li> <p>Relatively small size-wise. </p> </li> <li> <p>Stuck with a fixed size, no flexibility.</p> </li> </ul> <h3 id=linked-lists>Linked lists<a class=headerlink href=#linked-lists title="Permanent link">&para;</a></h3> <ul> <li> <p>Insertion is easy - just tack onto the front.</p> </li> <li> <p>Deletion is easy - once you find the element.</p> </li> <li> <p>Lookup is bad - have to rely on linear search.</p> </li> <li> <p>Relatively difficult to sort - unless you're willing to compromise on super-fast insertion and instead sort as you construct.</p> </li> <li> <p>Relatively small size-wise (not as small as arrays). </p> </li> </ul> <h3 id=hash-tables>Hash tables<a class=headerlink href=#hash-tables title="Permanent link">&para;</a></h3> <ul> <li> <p>Insertion is a two-step process - hash, then add.</p> </li> <li> <p>Deletion is easy - once you find the element.</p> </li> <li> <p>Lookup is on average better than with linked lists because you have the benefit of real-world constant factor.</p> </li> <li> <p>Not an ideal data structure if sorting is the goal - just use an array.</p> </li> <li> <p>Can run the gamut on size. </p> </li> </ul> <h3 id=tries>Tries<a class=headerlink href=#tries title="Permanent link">&para;</a></h3> <ul> <li> <p>Insertion is complex - a lot of dynamic memory allocation, but gets easier as you go.</p> </li> <li> <p>Deletion is easy - just free a node.</p> </li> <li> <p>Lookup is fast - not quite as fast as an array, but almost.</p> </li> <li> <p>Already sorted - sorts as you build in almost all situations.</p> </li> <li> <p>Rapidly becomes huge, even with very little data present, not great if space is at a premium. </p> </li> </ul> <h2 id=pointers>Pointers<a class=headerlink href=#pointers title="Permanent link">&para;</a></h2> <p>In the <a href=../c-memory/ >memory</a> notes, we learned about pointers, <code>malloc</code>, and other useful tools for working with memory. </p> <p>Let's review the following snipped of code: </p> <p><div class=highlight><pre><span></span><code><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=o>*</span><span class=n>x</span><span class=p>;</span>
    <span class=kt>int</span> <span class=o>*</span><span class=n>y</span><span class=p>;</span>

    <span class=n>x</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>

    <span class=o>*</span><span class=n>x</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
    <span class=o>*</span><span class=n>y</span> <span class=o>=</span> <span class=mi>13</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> Here, the first two lines of code in our <code>main</code> function are declaring two pointers, <code>x</code> and <code>y</code>. Then, we allocate enough memory for an <code>int</code> with <code>malloc</code>, and stores the address returned by <code>malloc</code> into <code>x</code>. </p> <p>With <code>*x = 42;</code>, we got to the address pointed to by <code>x</code>, and stores the value of <code>42</code> into that location. </p> <p>The final line, though, is buggy since we don't know what the value of <code>y</code> is, since we never set a value for it. Instead , we can write: </p> <div class=highlight><pre><span></span><code><span class=n>y</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
<span class=o>*</span><span class=n>y</span> <span class=o>=</span> <span class=mi>13</span><span class=p>;</span>
</code></pre></div> <p>For a more fun way to understand the above, take a look at the short clip, <a href="https://www.youtube.com/watch?v=3uLKjb973HU">Pointer Fun with Blinky</a>. </p> <h2 id=resizing-arrays>Resizing arrays<a class=headerlink href=#resizing-arrays title="Permanent link">&para;</a></h2> <p>In the <a href=../c-arrays/ >arrays</a> notes, we learned about arrays, where we could store the same kind of value in a list side-by-side. But we need to declare the size of arrays when we create them, and when we want to increase the size of the array, the memory surrounding it might be taken up by some other data. </p> <p>One solution might be to allocate more memory in a larger area that's free, and move our array there, where it has more space. This sounds like it could work, but we'll need to copy our array, which becomes an operation with running time of <em>O(n)</em>, since we need to copy each of <em>n</em> elements in an array. </p> <p>We might write a program like the following, to do this in code: </p> <details class=example><summary>copy array code</summary><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre></div></td><td class=code><div class=highlight><pre><span></span><code><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp></span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// Here, we allocate enough memory to fit three integers, and our variable</span>
    <span class=c1>// list will point to the first integer.</span>
    <span class=kt>int</span> <span class=o>*</span><span class=n>list</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
    <span class=c1>// We should check that we allocated memory correctly, since malloc might</span>
    <span class=c1>// fail to get us enough free memory.</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>list</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// With this syntax, the compiler will do pointer arithmetic for us, and</span>
    <span class=c1>// calculate the byte in memory that list[0], list[1], and list[2] maps to,</span>
    <span class=c1>// since integers are 4 bytes large.</span>
    <span class=n>list</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>list</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
    <span class=n>list</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>

    <span class=c1>// Now, if we want to resize our array to fit 4 integers, we&#39;ll try to allocate</span>
    <span class=c1>// enough memory for them, and temporarily use tmp to point to the first:</span>
    <span class=kt>int</span> <span class=o>*</span><span class=n>tmp</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>4</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>tmp</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=c1>// Now, we copy integers from the old array into the new array ...</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>tmp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>list</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
    <span class=p>}</span>

    <span class=c1>// ... and add the fourth integer:</span>
    <span class=n>tmp</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>

    <span class=c1>// We should free the original memory for list, which is why we need a</span>
    <span class=c1>// temporary variable to point to the new array ...</span>
    <span class=n>free</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>

    <span class=c1>// ... and now we can set our list variable to point to the new array that</span>
    <span class=c1>// tmp points to:</span>
    <span class=n>list</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>

    <span class=c1>// Now, we can print the new array:</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&quot;%i</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>list</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
    <span class=p>}</span>

    <span class=c1>// And finally, free the memory for the new array.</span>
    <span class=n>free</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> </td></tr></table> </details> <p>It turns out that there’s actually a helpful function, <code>realloc</code>, which will reallocate some memory: </p> <details class=example><summary><code>realloc</code> example</summary><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class=code><div class=highlight><pre><span></span><code><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp></span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=o>*</span><span class=n>list</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=mi>3</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>list</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>list</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>list</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
    <span class=n>list</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>

    <span class=c1>// Here, we give realloc our original array that list points to, and it will</span>
    <span class=c1>// return a new address for a new array, with the old data copied over:</span>
    <span class=kt>int</span> <span class=o>*</span><span class=n>tmp</span> <span class=o>=</span> <span class=n>realloc</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=mi>4</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>tmp</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// Now, all we need to do is remember the location of the new array:</span>
    <span class=n>list</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>

    <span class=n>list</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>

    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>4</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&quot;%i</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>list</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
    <span class=p>}</span>

    <span class=n>free</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>
<span class=p>}</span>
</code></pre></div> </td></tr></table> </details> <h2 id=data-structures_1>Data Structures<a class=headerlink href=#data-structures_1 title="Permanent link">&para;</a></h2> <p><strong>Data structures</strong> are programming constructs that allow us to store information in different layouts in our computer’s memory. </p> <p>To build a data structure, we’ll need some tools we’ve seen: </p> <ul> <li> <p><code>struct</code> to create custom data types</p> </li> <li> <p><code>.</code> to access properties in structure</p> </li> <li> <p><code>*</code> to go to an address in memory pointed to by a pointer</p> </li> </ul> <h2 id=linked-lists_1>Linked Lists<a class=headerlink href=#linked-lists_1 title="Permanent link">&para;</a></h2> <p>So far, we've only had one kind of data structure for representing collections of like values - <code>struct</code> - which give us "containers" for holding variables of different types, typically.<br> Arrays are great for element lookup, but unless we want to insert at the very end of an array, inserting elements is quite costly. Arrays also suffer from great inflexibility - what happens if we need a larger array than we thought? </p> <p>Through clever use of pointers, dynamic memory allocation and <code>struct</code>s, we can put the pieces together to develop a new kind of data structure that gives us the ability to grow and shrink a collection of like values to fit our needs. </p> <p>We call this combination of elements, when used in this way, a <strong>linked list</strong>. </p> <p>A linked list <strong>node</strong> is a special kind of <code>struct</code> with two members: </p> <ul> <li> <p>Data of some type (<code>int</code>, <code>char</code>, <code>float</code>...)</p> </li> <li> <p>A pointer to another node of the same type </p> </li> </ul> <p>In this way, a set of nodes together can be thought of as forming a chain of elements that we can follow from beginning to end. </p> <p>With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory: </p> <p><img alt=linked-list src=https://nicklyss.com/wp-content/uploads/2020/06/linked_list.png> </p> <ul> <li>This is different than an array since our values are no longer next to one another in memory. </li> </ul> <p><img alt=linked-list-with-addresses src=https://nicklyss.com/wp-content/uploads/2020/06/linked_list_with_addresses.png> </p> <ul> <li>This uses two chunks of memory, where the second chunk is used to point at the next chunk of memory. By the way, <code>NUL</code> refers to <code>\0</code>, a character that ends a string, and <code>NULL</code> refers to an address of all zeros, or a null pointer that we can think of as pointing nowhere. These chunks are linked by the pointers in the second chunk of memory. </li> </ul> <p>In order to work with linked lists effectively, there are a number of operations that we need to understand: </p> <ol> <li> <p><a href=#create-a-linked-list>Create a linked list when it doesn't already exist</a>.</p> </li> <li> <p><a href=#search-through-a-linked-list-to-find-an-element>Search through a linked list to find an element</a>.</p> </li> <li> <p><a href=#insert-a-new-node-into-the-linked-list>Insert a new node into the linked list</a>.</p> </li> <li> <p><a href=#delete-a-single-element-from-a-linked-list>Delete a single element from a linked list</a>.</p> </li> <li> <p><a href=#delete-an-entire-linked-list>Delete an entire linked list</a>. </p> </li> </ol> <h3 id=create-a-linked-list>Create a linked list<a class=headerlink href=#create-a-linked-list title="Permanent link">&para;</a></h3> <p><div class=highlight><pre><span></span><code><span class=n>sllnode</span><span class=o>*</span> <span class=nf>create</span><span class=p>(</span><span class=n>VALUE</span> <span class=n>val</span><span class=p>);</span> <span class=c1>// ssl stands for &quot;single-linked list&quot; in the following code</span>
</code></pre></div> Steps involved: </p> <ul> <li> <p>Dynamically allocate space for a new <code>sllnode</code>.</p> </li> <li> <p>Check to make sure we didn't run out of memory.</p> </li> <li> <p>Initialize the node's <code>val</code> field.</p> </li> <li> <p>Initialize the node's <code>next</code> field.</p> </li> <li> <p>Return a pointer to the newly created <code>sllnode</code>.</p> </li> </ul> <h3 id=search-through-a-linked-list-to-find-an-element>Search through a linked list to find an element<a class=headerlink href=#search-through-a-linked-list-to-find-an-element title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=kt>bool</span> <span class=nf>find</span><span class=p>(</span><span class=n>sllnode</span><span class=o>*</span> <span class=n>head</span><span class=p>,</span> <span class=n>VALUE</span> <span class=n>val</span><span class=p>);</span>
</code></pre></div> <p>Steps involved: </p> <ul> <li> <p>Create a traversal pointer pointing to the list's head.</p> </li> <li> <p>If the current node's <code>val</code> field is what we're looking for, report success.</p> </li> <li> <p>If not, set the traversal point to the next pointer in the list and go back to step 2 (above).</p> </li> <li> <p>If you've reached the end of the list, report failure. </p> </li> </ul> <h3 id=insert-a-new-node-into-the-linked-list>Insert a new node into the linked list<a class=headerlink href=#insert-a-new-node-into-the-linked-list title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=n>sllnode</span><span class=o>*</span> <span class=nf>insert</span><span class=p>(</span><span class=n>sllnode</span><span class=o>*</span> <span class=n>head</span><span class=p>,</span> <span class=n>VALUE</span> <span class=n>val</span><span class=p>);</span>
</code></pre></div> <p>Steps involved: </p> <ul> <li> <p>Dynamically allocate space for a new <code>sllnode</code>.</p> </li> <li> <p>Check to make sure we didn't run out of memory.</p> </li> <li> <p>Populate and insert the node at the beginning of the linked list. </p> </li> <li> <p>Return a pointer to the new head of the linked list. </p> </li> </ul> <h3 id=delete-a-single-element-from-a-linked-list>Delete a single element from a linked list<a class=headerlink href=#delete-a-single-element-from-a-linked-list title="Permanent link">&para;</a></h3> <p>Deleting a single element from a singley-linked list can be a little tricky because it can cause different problems. There are solutions for this in doubley-linked lists.</p> <h3 id=delete-an-entire-linked-list>Delete an entire linked list<a class=headerlink href=#delete-an-entire-linked-list title="Permanent link">&para;</a></h3> <div class=highlight><pre><span></span><code><span class=kt>void</span> <span class=nf>destroy</span><span class=p>(</span><span class=n>sllnode</span><span class=o>*</span> <span class=n>head</span><span class=p>);</span>
</code></pre></div> <p>Steps involved: </p> <ul> <li> <p>If you've reached a null pointer, stop.</p> </li> <li> <p>Delete the rest of the list.</p> </li> <li> <p>Free the current node.</p> </li> </ul> <h3 id=additional-linked-list-notes>Additional linked list notes<a class=headerlink href=#additional-linked-list-notes title="Permanent link">&para;</a></h3> <p>Unlike with arrays, we no longer randomly access elements in a linked list. For example, we can no longer access the 5<sup>th</sup> element of the list by calculating where it is, in constant time. (Since we know arrays store elements back-to-back, we can add 1, or 4, or the size of our element, to calculate addresses.) Instead, we have to follow each element’s pointer, one at a time. And we need to allocate twice as much memory as we needed before for each element. </p> <p>In code, we might create our own struct called <code>node</code> (like a node from a graph in mathematics), and we need to store both an <code>int</code> and a pointer to the next <code>node</code> called <code>next</code>. </p> <div class=highlight><pre><span></span><code><span class=k>typedef</span> <span class=k>struct</span> <span class=n>node</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>number</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>node</span><span class=p>;</span> <span class=c1>// this is the nickname for struct node</span>
</code></pre></div> <ul> <li>We start this struct with <code>typedef struct node</code> so that we can refer to a <code>node</code> inside our struct. </li> </ul> <p>We can build a linked list in code starting with our struct. First, we'll want to remember an empty list, so we can use the null pointer: <code>node *list = NULL;</code>. </p> <p>To add an element, first we'll need to allocate some memory for a node, and set its values: </p> <p><div class=highlight><pre><span></span><code><span class=n>node</span> <span class=o>*</span><span class=n>n</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>node</span><span class=p>));</span>
<span class=c1>// We want to make sure malloc succeeded in getting memory for us:</span>
<span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// This (-&gt;) is equivalent to (*n).number, where we first go to the node pointed</span>
    <span class=c1>// to by n, and then set the number property. In C, we can also use this</span>
    <span class=c1>// arrow notation:</span>
    <span class=n>n</span><span class=o>-&gt;</span><span class=n>number</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
    <span class=c1>// Then we need to store a pointer to the next node in our list, but the</span>
    <span class=c1>// new node won&#39;t point to anything (for now):</span>
    <span class=n>n</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div> Now our list can point to this node: <code>list = n;</code>: </p> <p><img alt=list-with-one-node src=https://nicklyss.com/wp-content/uploads/2020/06/list_with_one_node.png> </p> <p>To add to our lsit, we'll create a new node the same way, perhaps with the value 4. But now we need to update the pointer in our first node to point to it. </p> <p>since our <code>list</code> pointer points only to the first node (and we can't be sure that the list only has one node), we need to "follow the breadcrumbs" and follow each node's next pointer: </p> <div class=highlight><pre><span></span><code><span class=c1>// Create temporary pointer to what list is pointing to</span>
<span class=n>node</span> <span class=o>*</span><span class=n>tmp</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span>
<span class=c1>// As long as the node has a next pointer ...</span>
<span class=k>while</span> <span class=p>(</span><span class=n>tmp</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// ... set the temporary to the next node</span>
    <span class=n>tmp</span> <span class=o>=</span> <span class=n>tmp</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
<span class=p>}</span>
<span class=c1>// Now, tmp points to the last node in our list, and we can update its next</span>
<span class=c1>// pointer to point to our new node.</span>
</code></pre></div> <p>If we want to insert a node to the front of our linked list, we would need to carefully update our node to point to the one following it, before updating the list. Otherwise, we'll lose the rest of our list:<br> <div class=highlight><pre><span></span><code><span class=c1>// Here, we&#39;re inserting a node into the front of the list, so we want its</span>
<span class=c1>// next pointer to point to the original list, before pointing the list to</span>
<span class=c1>// n:</span>
<span class=n>n</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span>
<span class=n>list</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</code></pre></div></p> <p>And to insert a node in the middle of our list, we can go through the list, following each element one at a time, comparing its values, and changing the <code>next</code> pointers carefully as well. </p> <p>We can combine all of our snippets of code into a complete program: </p> <details class=example><summary>node example</summary><table class=highlighttable><tr><td class=linenos><div class=linenodiv><pre><span></span> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76</pre></div></td><td class=code><div class=highlight><pre><span></span><code><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp></span>
<span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp></span>

<span class=c1>// Represents a node</span>
<span class=k>typedef</span> <span class=k>struct</span> <span class=n>node</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>number</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
<span class=p>}</span>
<span class=n>node</span><span class=p>;</span>

<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// List of size 0, initially not pointing to anything</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>list</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>

    <span class=c1>// Add number to list</span>
    <span class=n>node</span> <span class=o>*</span><span class=n>n</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>node</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>n</span><span class=o>-&gt;</span><span class=n>number</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>n</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=c1>// We create our first node, store the value 1 in it, and leave the next</span>
    <span class=c1>// pointer to point to nothing. Then, our list variable can point to it.</span>
    <span class=n>list</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>

    <span class=c1>// Add number to list</span>
    <span class=n>n</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>node</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>n</span><span class=o>-&gt;</span><span class=n>number</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
    <span class=n>n</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=c1>// Now, we go our first node that list points to, and sets the next pointer</span>
    <span class=c1>// on it to point to our new node, adding it to the end of the list:</span>
    <span class=n>list</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>

    <span class=c1>// Add number to list</span>
    <span class=n>n</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=n>node</span><span class=p>));</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=n>n</span><span class=o>-&gt;</span><span class=n>number</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
    <span class=n>n</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
    <span class=c1>// We can follow multiple nodes with this syntax, using the next pointer</span>
    <span class=c1>// over and over, to add our third new node to the end of the list:</span>
    <span class=n>list</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
    <span class=c1>// Normally, though, we would want a loop and a temporary variable to add</span>
    <span class=c1>// a new node to our list.</span>

    <span class=c1>// Print list</span>
    <span class=c1>// Here we can iterate over all the nodes in our list with a temporary</span>
    <span class=c1>// variable. First, we have a temporary pointer, tmp, that points to the</span>
    <span class=c1>// list. Then, our condition for continuing is that tmp is not NULL, and</span>
    <span class=c1>// finally, we update tmp to the next pointer of itself.</span>
    <span class=k>for</span> <span class=p>(</span><span class=n>node</span> <span class=o>*</span><span class=n>tmp</span> <span class=o>=</span> <span class=n>list</span><span class=p>;</span> <span class=n>tmp</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>tmp</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=c1>// Within the node, we&#39;ll just print the number stored:</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&quot;%i</span><span class=se>\n</span><span class=s>&quot;</span><span class=p>,</span> <span class=n>tmp</span><span class=o>-&gt;</span><span class=n>number</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=c1>// Free list</span>
    <span class=c1>// Since we&#39;re freeing each node as we go along, we&#39;ll use a while loop</span>
    <span class=c1>// and follow each node&#39;s next pointer before freeing it, but we&#39;ll see</span>
    <span class=c1>// this in more detail in Problem Set 5.</span>
    <span class=k>while</span> <span class=p>(</span><span class=n>list</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>node</span> <span class=o>*</span><span class=n>tmp</span> <span class=o>=</span> <span class=n>list</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
        <span class=n>free</span><span class=p>(</span><span class=n>list</span><span class=p>);</span>
        <span class=n>list</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> </td></tr></table> </details> <h2 id=hash-table>Hash Table<a class=headerlink href=#hash-table title="Permanent link">&para;</a></h2> <p><strong>Hash tables</strong> combine the random access ability of an array with the dynamism of a linked list. </p> <p>This means (assuming we define our hash table well):</p> <ul> <li> <p>Insetion can start to tend toward Θ(1)</p> </li> <li> <p>Deletion can start to tend toward Θ(1)</p> </li> <li> <p>Lookup can start to tend toward Θ(1)</p> </li> </ul> <p>Θ above stands for the average case. </p> <p>We're gaining the advantages of both types of data structure (arrays &amp; linked lists), while mitigating the disadvantages. </p> <p>To get this performance upgrade, we create a new structure whereby when we insert data into the structure, the data itself gives us a clue about where we will find the data, should we need to look it up later. </p> <p>A hash table amounts to a combination of two things: </p> <ul> <li> <p>First, a <strong>hash function</strong>, which returns a nonnegative integer value called a <em>hash code</em>.</p> </li> <li> <p>Second, an <strong>array</strong> capable of storing data of the type we wish to place into the data structure. </p> </li> </ul> <p>The idea is that we run our data through the hash function, and then store the data in the element of the array represented by the returned hash code. </p> <p>We can implement this in a hash table with an array of 26 pointers, each of which points to a linked list for a letter of the alphabet: </p> <p><img alt=hash-table src=https://nicklyss.com/wp-content/uploads/2020/06/hash_table.png> </p> <p>Since we have random access with arrays, we can add elements quickly, and also index quickly into a bucket. </p> <p>A bucket might have might have multiple matching values, so we'll use a linked list to store all of them horizontally. (We call this a collision, when two values match in the same way.) </p> <p>This is called a hash table because we use a hash function, which takes some input and maps it to a bucket it should go in. In our example, the hash function is just at the first letter of the name, so it might return <code>0</code> for "Albus" and <code>25</code> for "Zacharias". </p> <p>But in the worst case, all the names might start with the same letter, so we might end up with the equivalent of a single linked list again. We might look at the first two letters, and allocate enough buckets for 26x26 possible hashed values, or even the first three letters, and now we’ll need 26x26x26 buckets. But we could still have a worst case where all our values start with the same three characters, so the running time for search is <em>O</em>(<em>n</em>). In practice, though, we can get closer to <em>O</em>(1) if we have about as many buckets as possible values, especially if we have an ideal hash function, where we can sort our inputs into unique buckets. </p> <h2 id=tries_1>Tries<a class=headerlink href=#tries_1 title="Permanent link">&para;</a></h2> <p>We can use another data structure called a <strong>trie</strong> (prounounced like "try", and is short for "retrieval"): </p> <p><img alt=trie src=https://nicklyss.com/wp-content/uploads/2020/06/trie.png> </p> <p>Tries combine structures and poiinters together to store data in an interesting way. The data to be searched for in the trie is now a roadmap. If you can follow the map from beginning to end, the data exists in the trie, if you can't, it does not exist in the trie. Unlike with a hash table, there are no collisions, and no two pieces of data (unless they are identical) have the same path. </p> <p>Imagine we want to store a dictionary of words efficiently, and be able to access each one in constant time. A trie is like a tree, but each node is an array. Each array will have each letter, A-Z, stored. For each word, the first letter will point to an array, where the next valid letter will point to another array, and so on, until we reach something indicating the end of a valid word. If our word isn’t in the trie, then one of the arrays won’t have a pointer or terminating character for our word. Now, even if our data structure has lots of words, the lookup time will be just the length of the word we’re looking for, and this might be a fixed maximum so we have <em>O</em>(1) for searching and insertion. The cost for this, though, is 26 times as much memory as we need for each character. </p> <h2 id=more-data-structures>More data structures<a class=headerlink href=#more-data-structures title="Permanent link">&para;</a></h2> <p>A <strong>tree</strong> is another data structure where each node points to two other nodes, one to the left (with a smaller value) and one to the right (with a larger value): </p> <p><img alt=binary-search-tree src=https://nicklyss.com/wp-content/uploads/2020/06/binary_search_tree.png> </p> <p>Notice that there are now two dimensions to this data structure, where some nodes are on different "levels" than others. We can imagine implementing this with a more complex version of a node in a linked list, where each node has not one but two pointers, one to the value in the "middle of the left half" and one to the value in the "middle of the right half". Note: all elements to the left of the node are smaller and all elements to the right are greater. </p> <p>This is called a binary search tree because each node has at most two children, or nodes it is pointing to, and a search tree because it's sorted in a way that allows us to search correctly. </p> <p>And like a linked list, we'll want to keep a pointer to just the beginning of the list, but in this case we want to point to the root, or top center node of the tree (the 4 in the image above). </p> <p>Now, we can easily do binary search, and since each node is pointing to another, we can also insert nodes into the tree without moving all of them around as we would have to do with an array. Recursively searching this tree would look something like: </p> <p><div class=highlight><pre><span></span><code><span class=k>typedef</span> <span class=k>struct</span> <span class=n>node</span>
<span class=p>{</span>
    <span class=kt>int</span> <span class=n>number</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>left</span><span class=p>;</span>
    <span class=k>struct</span> <span class=n>node</span> <span class=o>*</span><span class=n>right</span><span class=p>;</span>
<span class=p>}</span> <span class=n>node</span><span class=p>;</span>

<span class=c1>// Here, *tree is a pointer to the root of our tree.</span>
<span class=kt>bool</span> <span class=nf>search</span><span class=p>(</span><span class=n>node</span> <span class=o>*</span><span class=n>tree</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>// We need a base case, if the current tree (or part of the tree) is NULL,</span>
    <span class=c1>// to return false:</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>tree</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>// Now, depending on if the number in the current node is bigger or smaller,</span>
    <span class=c1>// we can just look at the left or right side of the tree:</span>
    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=mi>50</span> <span class=o>&lt;</span> <span class=n>tree</span><span class=o>-&gt;</span><span class=n>number</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>tree</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=mi>50</span> <span class=o>&gt;</span> <span class=n>tree</span><span class=o>-&gt;</span><span class=n>number</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=k>return</span> <span class=n>search</span><span class=p>(</span><span class=n>tree</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=c1>// Otherwise, the number must be equal to what we&#39;re looking for:</span>
    <span class=k>else</span> <span class=p>{</span>
        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div> The running time of searching a tree is <em>O</em>(log <em>n</em>) and inserting nodes while keeping the tree balances is also <em>O</em>(log <em>n</em>). By spending a bit more memory and time to maintain the tree, we've now gained faster searching compared to a plain linked list. </p> <p>There are even higher-level constructs, <strong>abstract data structures</strong>, where we use our building blocks of arrays, linked lists, hash tables, and tries to implement a solution to some problem. </p> <p>For example, one abstract data structure is a <strong>queue</strong>, where we want to be able to add values and remove values in a first-in-first-out (FIFO) way. To add a value we might enqueue it, and to remove a value we would dequeue it. And we can implement this with an array that we resize as we add items, or a linked list where we append values to the end. </p> <p>An “opposite” data structure would be a <strong>stack</strong>, where items most recently added (pushed) are removed (popped) first, in a last-in-first-out (LIFO) way. Our email inbox is a stack, where our most recent emails are at the top. </p> <p>Another example is a <strong>dictionary</strong>, where we can map keys to values, or strings to values, and we can implement one with a hash table where a word comes with some other information (like its definition or meaning). </p> </article> </div> </div> </main> <footer class=md-footer> <div class=md-footer-nav> <nav class="md-footer-nav__inner md-grid" aria-label=Footer> <a href=../c-memory-problems/ title="Memory Problems" class="md-footer-nav__link md-footer-nav__link--prev" rel=prev> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg> </div> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Previous </span> Memory Problems </div> </div> </a> <a href=../c-data-structures-problems/ title="Data Structures Problem" class="md-footer-nav__link md-footer-nav__link--next" rel=next> <div class=md-footer-nav__title> <div class=md-ellipsis> <span class=md-footer-nav__direction> Next </span> Data Structures Problem </div> </div> <div class="md-footer-nav__button md-icon"> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4z"/></svg> </div> </a> </nav> </div> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> </div> </a> </div> <div class=md-footer-social> <a href=https://www.linkedin.com/in/nicholas-platt/ target=_blank rel=noopener title=www.linkedin.com class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg> </a> <a href=https://github.com/tpbnick target=_blank rel=noopener title=github.com class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 496 512"><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg> </a> <a href=https://www.instagram.com/nickplattfour/ target=_blank rel=noopener title=www.instagram.com class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 448 512"><path d="M224.1 141c-63.6 0-114.9 51.3-114.9 114.9s51.3 114.9 114.9 114.9S339 319.5 339 255.9 287.7 141 224.1 141zm0 189.6c-41.1 0-74.7-33.5-74.7-74.7s33.5-74.7 74.7-74.7 74.7 33.5 74.7 74.7-33.6 74.7-74.7 74.7zm146.4-194.3c0 14.9-12 26.8-26.8 26.8-14.9 0-26.8-12-26.8-26.8s12-26.8 26.8-26.8 26.8 12 26.8 26.8zm76.1 27.2c-1.7-35.9-9.9-67.7-36.2-93.9-26.2-26.2-58-34.4-93.9-36.2-37-2.1-147.9-2.1-184.9 0-35.8 1.7-67.6 9.9-93.9 36.1s-34.4 58-36.2 93.9c-2.1 37-2.1 147.9 0 184.9 1.7 35.9 9.9 67.7 36.2 93.9s58 34.4 93.9 36.2c37 2.1 147.9 2.1 184.9 0 35.9-1.7 67.7-9.9 93.9-36.2 26.2-26.2 34.4-58 36.2-93.9 2.1-37 2.1-147.8 0-184.8zM398.8 388c-7.8 19.6-22.9 34.7-42.6 42.6-29.5 11.7-99.5 9-132.1 9s-102.7 2.6-132.1-9c-19.6-7.8-34.7-22.9-42.6-42.6-11.7-29.5-9-99.5-9-132.1s-2.6-102.7 9-132.1c7.8-19.6 22.9-34.7 42.6-42.6 29.5-11.7 99.5-9 132.1-9s102.7-2.6 132.1 9c19.6 7.8 34.7 22.9 42.6 42.6 11.7 29.5 9 99.5 9 132.1s2.7 102.7-9 132.1z"/></svg> </a> <a href=mailto:nickplatt4@gmail.com target=_blank rel=noopener title class=md-footer-social__link> <svg xmlns=http://www.w3.org/2000/svg viewbox="0 0 512 512"><path d="M464 64H48C21.49 64 0 85.49 0 112v288c0 26.51 21.49 48 48 48h416c26.51 0 48-21.49 48-48V112c0-26.51-21.49-48-48-48zm0 48v40.805c-22.422 18.259-58.168 46.651-134.587 106.49-16.841 13.247-50.201 45.072-73.413 44.701-23.208.375-56.579-31.459-73.413-44.701C106.18 199.465 70.425 171.067 48 152.805V112h416zM48 400V214.398c22.914 18.251 55.409 43.862 104.938 82.646 21.857 17.205 60.134 55.186 103.062 54.955 42.717.231 80.509-37.199 103.053-54.947 49.528-38.783 82.032-64.401 104.947-82.653V400H48z"/></svg> </a> </div> </div> </div> </footer> </div> <script src=../assets/javascripts/vendor.3636a4ec.min.js></script> <script src=../assets/javascripts/bundle.e9fe3281.min.js></script><script id=__lang type=application/json>{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents"}</script> <script>
        app = initialize({
          base: "..",
          features: ["navigation.tabs", "navigation.instant", "navigation.sections", "navigation.tabs.sticky"],
          search: Object.assign({
            worker: "../assets/javascripts/worker/search.5eca75d3.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script> <script src=../javascripts/extra.js></script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>