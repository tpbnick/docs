{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Nick's Docs This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here . Portfolio Quick Links: Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018) Programming Notes C C Basics Arrays Functions Command Line Arguments Variables and Scope Quick Links IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Home"},{"location":"#welcome-to-nicks-docs","text":"This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here .","title":"Welcome to Nick's Docs"},{"location":"#portfolio-quick-links","text":"Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018)","title":"Portfolio Quick Links:"},{"location":"#programming-notes","text":"C C Basics Arrays Functions Command Line Arguments Variables and Scope","title":"Programming Notes"},{"location":"#quick-links","text":"IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Quick Links"},{"location":"about/","text":"About About Me .aligncenter{ text-align: center; border-radius: 15px; } Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I plan on obtaining a Master's in Software Engineering in the near future. I have basic knowledge in HTML, CSS, JavaScript, Python, Markdown, and C (hopefully more to come in the near future). If you have any questions, please feel free to reach out to me through the contact info below. Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#about-me","text":".aligncenter{ text-align: center; border-radius: 15px; } Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I plan on obtaining a Master's in Software Engineering in the near future. I have basic knowledge in HTML, CSS, JavaScript, Python, Markdown, and C (hopefully more to come in the near future). If you have any questions, please feel free to reach out to me through the contact info below.","title":"About Me"},{"location":"about/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Contact"},{"location":"c-arrays/","text":"Arrays What are Arrays? Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you. Array Declarations \u2003\u2003 type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages. Basic Array Program Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average). Other Array Tips Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything. Reading Levels Program According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); }","title":"Arrays"},{"location":"c-arrays/#arrays","text":"","title":"Arrays"},{"location":"c-arrays/#what-are-arrays","text":"Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you.","title":"What are Arrays?"},{"location":"c-arrays/#array-declarations","text":"type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages.","title":"Array Declarations"},{"location":"c-arrays/#basic-array-program","text":"Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average).","title":"Basic Array Program"},{"location":"c-arrays/#other-array-tips","text":"Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything.","title":"Other Array Tips"},{"location":"c-arrays/#reading-levels-program","text":"According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); }","title":"Reading Levels Program"},{"location":"c-cl-arguments/","text":"Command Line Arugments Overview Command Line Arguments So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc - 1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-cl-arguments/#command-line-arugments-overview","text":"","title":"Command Line Arugments Overview"},{"location":"c-cl-arguments/#command-line-arguments","text":"So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc - 1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-functions/","text":"Functions What are functions? C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented. Why us functions? Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need! Function Declarations The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number. Function Definitions The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back } Function Calls To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; } Function Miscellany Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type. Practice Problem We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Functions"},{"location":"c-functions/#functions","text":"","title":"Functions"},{"location":"c-functions/#what-are-functions","text":"C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented.","title":"What are functions?"},{"location":"c-functions/#why-us-functions","text":"Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need!","title":"Why us functions?"},{"location":"c-functions/#function-declarations","text":"The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number.","title":"Function Declarations"},{"location":"c-functions/#function-definitions","text":"The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back }","title":"Function Definitions"},{"location":"c-functions/#function-calls","text":"To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; }","title":"Function Calls"},{"location":"c-functions/#function-miscellany","text":"Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type.","title":"Function Miscellany"},{"location":"c-functions/#practice-problem","text":"We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Practice Problem"},{"location":"c-variable-scope/","text":"Variables and Scope Variable Scope Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; } Why do local and global distinctions matter? For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Variables and Scope"},{"location":"c-variable-scope/#variables-and-scope","text":"","title":"Variables and Scope"},{"location":"c-variable-scope/#variable-scope","text":"Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; }","title":"Variable Scope"},{"location":"c-variable-scope/#why-do-local-and-global-distinctions-matter","text":"For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Why do local and global distinctions matter?"},{"location":"c/","text":"C Basics Basic Data Types int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\"). Creating a Variable To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ; Using a Variable After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment Operators In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==). Conditional Statements Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); } Loops Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled. First Code #include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename* Hello, *name*! Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); } Mario Problem Set Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n - 1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } } Cash Problem Set When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { loat dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"C Basics"},{"location":"c/#c-basics","text":"","title":"C Basics"},{"location":"c/#basic-data-types","text":"int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\").","title":"Basic Data Types"},{"location":"c/#creating-a-variable","text":"To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ;","title":"Creating a Variable"},{"location":"c/#using-a-variable","text":"After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment","title":"Using a Variable"},{"location":"c/#operators","text":"In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==).","title":"Operators"},{"location":"c/#conditional-statements","text":"Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); }","title":"Conditional Statements"},{"location":"c/#loops","text":"Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled.","title":"Loops"},{"location":"c/#first-code","text":"#include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename*","title":"First Code"},{"location":"c/#hello-name","text":"Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); }","title":"Hello, *name*!"},{"location":"c/#mario-problem-set","text":"Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n - 1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } }","title":"Mario Problem Set"},{"location":"c/#cash-problem-set","text":"When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { loat dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"Cash Problem Set"},{"location":"chrome/","text":"What is Google Chrome? Google Chrome Overview Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"What is Google Chrome?"},{"location":"chrome/#what-is-google-chrome","text":"","title":"What is Google Chrome?"},{"location":"chrome/#google-chrome-overview","text":"Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"Google Chrome Overview"},{"location":"chromeinstall/","text":"How to Install Google Chrome Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"Google Chrome Install"},{"location":"chromeinstall/#how-to-install-google-chrome","text":"Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"How to Install Google Chrome"},{"location":"chromemedia/","text":"Google Chrome Media Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"chromemedia/#google-chrome-media","text":"Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"glossary/","text":"Below is a list of key words and their definitions: Bookmark - A bookmark is a saved shortcut that directs your browser to a specific webpage. It stores the title, URL, and favicon of the corresponding page. Saving bookmarks allows you to easily access your favorite locations on the Web. Browser - Software programs that enable you to view web pages and other documents on the Internet. They \"translate\" HTML-encoded files into the text, images, sounds, and other features you see. Google Chrome is a browser. Cache - In browsers, \"cache\" is used to identify a space where web pages you have visited are stored in your computer. A copy of documents you retrieve is stored in cache. When you use GO, BACK, or any other means to revisit a document, the browser first checks to see if it is in cache and will retrieve it from there because it is much faster than retrieving it from the server. Cookie - An HTTP cookie is a small piece of data sent from a website and stored on the user's computer by the user's web browser while the user is browsing. Cookies were designed to be a reliable mechanism for websites to remember stateful information or to record the user's browsing activity. Extension - Extensions are small software programs that customize the browsing experience. They enable users to tailor Chrome functionality and behavior to individual needs or preferences. They are built on web technologies such as HTML, JavaScript, and CSS. HTML - HTML stands for Hyper Text Markup Language. HTML is the standard markup language for Web pages, which are the building blocks of most web pages. Link - A link (short for hyperlink) is an HTML object that allows you to jump to a new location when you click or tap it. Links are found on almost every webpage and provide a simple means of navigating between pages on the web. Links can be attached to text, images, or other HTML elements. URL - URL stands for Uniform Resource Locator. A URL is nothing more than the address of a given unique resource on the Web (e.g. website, page, or file). In theory, each valid URL points to a unique resource.","title":"Glossary"},{"location":"portfolio/","text":"Nicholas Platt's Portfolio Resume Portfolio Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types. Images Custom Keyboard PCB with Switch Slot Callouts Example 2 Example 3 Example 4 Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Main Portfolio"},{"location":"portfolio/#nicholas-platts-portfolio","text":"","title":"Nicholas Platt's Portfolio"},{"location":"portfolio/#resume","text":"","title":"Resume"},{"location":"portfolio/#portfolio","text":"Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types.","title":"Portfolio"},{"location":"portfolio/#images","text":"Custom Keyboard PCB with Switch Slot Callouts Example 2 Example 3 Example 4","title":"Images"},{"location":"portfolio/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Contact"}]}