{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Nick's Docs This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here . Portfolio Quick Links: Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018) Programming Notes C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms C++ Coming Soon! Python Coming Soon! Go Coming Soon! R Coming Soon! SQL Coming Soon! Quick Links IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Home"},{"location":"#welcome-to-nicks-docs","text":"This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here .","title":"Welcome to Nick's Docs"},{"location":"#portfolio-quick-links","text":"Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018)","title":"Portfolio Quick Links:"},{"location":"#programming-notes","text":"C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms C++ Coming Soon! Python Coming Soon! Go Coming Soon! R Coming Soon! SQL Coming Soon!","title":"Programming Notes"},{"location":"#quick-links","text":"IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Quick Links"},{"location":"about/","text":"About About Me .aligncenter{ text-align: center; border-radius: 15px; } Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I plan on obtaining a Master's in Software Engineering in the near future. I have basic knowledge in HTML, CSS, JavaScript, Python, Markdown, and C (hopefully more to come in the near future). If you have any questions, please feel free to reach out to me through the contact info below. Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#about-me","text":".aligncenter{ text-align: center; border-radius: 15px; } Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I plan on obtaining a Master's in Software Engineering in the near future. I have basic knowledge in HTML, CSS, JavaScript, Python, Markdown, and C (hopefully more to come in the near future). If you have any questions, please feel free to reach out to me through the contact info below.","title":"About Me"},{"location":"about/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Contact"},{"location":"c-algorithms/","text":"Algorithms Searching In computer science, a search algorithm is any algorithm which solves the search problem, namely, to retrieve information stored within some data structure, or calculates in the search space of a problem domain, either with discrete or continuous values. For now, we are going to go over two different types of searches: Linear Search Binary Search For the following examples, we are going to be using a row of lockers with numbers inside (an array) and we will look through them to find something, while returning a boolean ( true or false ) as a result. A linear search is where we move in a line (usually start to end or end to start). Now lets look through the lockers to find one with the number 50 inside. Some pseudocode for linear search could be written as: For i from 0 to n\u20131 // from start (0) to end (n-1) If i'th element is 50 Return true // if the i'th element is 50 - return true Return false // if not 50, return false A binary search is where we start in the middle and move left or right, depending on what we're looking for. Some pseudocode for binary search could be written as: If no items Return false If middle item is 50 Return true Else if 50 < middle item Search left half Else if 50 > middle item Search right half Big O Computer scientists have created a way to describe algorithms (how well it is designed), and it's generally called big O . The more formal way to describe this is with big O notation, which we can think of as \u201con the order of\u201d. For example, if our algorithm is linear search, it will take approximately O( n ) steps, \u201con the order of n \u201d. In fact, even an algorithm that looks at two items at a time and takes n /2 steps has O( n ). This is because, as n gets bigger and bigger, only the largest term, n , matters. There are some common running times (how many seconds does it take, how many steps does it take, etc.): (lower is better) O( n 2 ) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) Computer scientists might also use big \u03a9, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big O is the upper bound of number of steps, or the worst case, and typically what we care about more.) With linear search, for example, the worst case is n steps, but the best case is 1 step since our item might happen to be the first item we check. The best case for binary search, too, is 1 since our item might be in the middle of the array. And we have a similar set of the most common big \u03a9 running times: (lower is better) \u03a9(n2) \u03a9(n log n) \u03a9(n) (counting the number of items) \u03a9(log n) \u03a9(1) (linear search, binary search) Linear Search Now let's create a program to better visualize a lienar search: #include <cs50.h> #include <stdio.h> int main ( void ) { int numbers [ 6 ] = { 4 , 8 , 15 , 16 , 23 , 42 }; for ( int i = 0 ; i < 6 ; i ++ ) { if ( numbers [ i ] == 50 ) { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Here we initialize an array with some values, and we check the items in the array one at a time, in order. And in each case, depending on whether the value was found or not, we can return an exit code of either 0 (for success) or 1 (for failure). We can do the same for names: #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma is the name we're looking for. note the use of strcmp { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can\u2019t compare strings directly, since they\u2019re not a simple data type but rather an array of many characters, and we need to compare them differently. Luckily, the string library has a strcmp function which compares strings for us and returns 0 if they\u2019re the same, so we can use that. Now lets implement a phone book with the same ideas: #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; string numbers [ 4 ] = { \"617\u2013555\u20130100\" , \"617\u2013555\u20130101\" , \"617\u2013555\u20130102\" , \"617\u2013555\u20130103\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma's phone number is what we're looking for { printf ( \"Found %s \\n \" , numbers [ i ]); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Now, if the name at a certain index in the names array matches who we\u2019re looking for, we\u2019ll return the phone number in the numbers array, at the same index. But that means we need to particularly careful to make sure that each number corresponds to the name at each index, especially if we add or remove names and numbers. Let's improve the above code using our own custom data type! Structs We can make our own custom data types called structs : #include <cs50.h> #include <stdio.h> #include <string.h> typedef struct { string name ; string number ; } person ; // we are encapsulating both the strings name and number inside our struct \"person\" int main ( void ) { person people [ 4 ]; people [ 0 ]. name = \"EMMA\" ; people [ 0 ]. number = \"617\u2013555\u20130100\" ; people [ 1 ]. name = \"RODRIGO\" ; people [ 1 ]. number = \"617\u2013555\u20130101\" ; people [ 2 ]. name = \"BRIAN\" ; people [ 2 ]. number = \"617\u2013555\u20130102\" ; people [ 3 ]. name = \"DAVID\" ; people [ 3 ]. number = \"617\u2013555\u20130103\" ; // Search for EMMA for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( people [ i ]. name , \"EMMA\" ) == 0 ) { printf ( \"Found %s \\n \" , people [ i ]. number ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can think of structs as containers, inside of which are multiple other data types. Here, we create our own type with a struct called person , which will have a string called name and a string called number . Then, we can create an array of these struct types and initialize the values inside each of them, using a new syntax, . , to access the properties of each person . In our loop, we can now be more certain that the number corresponds to the name since they are from the same person element. Sorting The process of Sorting can be explained as a technique of rearranging the elements in any particular order, which can be set ready for further processing by the program logic. In C, there are multiple sorting algorithms available, which can be incorporated inside the code. Bubble Sort Let's take 8 random numbers ( 6 , 3 , 8 , 5 , 2 , 7 , 4 , 1 ) and try to sort them in C. First, we can look at the first two numbers and swap them so they are in order: 6 3 8 5 2 7 4 1 3 6 8 5 2 7 4 1 The next pair, 6 and 8 , are in order, so we don\u2019t need to swap them. The next pair, 8 and 5 , need to be swapped: 3 6 8 5 2 7 4 1 3 6 5 8 2 7 4 1 We continue until we reach the end of the list: 3 6 5 8 2 7 4 1 3 6 5 2 8 7 4 1 3 6 5 2 7 8 4 1 3 6 5 2 7 4 8 1 3 6 5 2 7 4 1 8 Our list isn\u2019t sorted yet, but we\u2019re slightly closer to the solution because the biggest value, 8 , has been shifted all the way to the right. We repeat this with another pass through the list, over and over, until it is sorted correctly. This algorithm is called bubble sort , where large values \u201cbubble\u201d to the right. The pseudocode for this might look like: Repeat n\u20131 times For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Since we are comparing the i'th and i+1'th element, we only need to go up to n \u2013 2 for i . Then, we swap the two elements if they\u2019re out of order. And we can stop after we\u2019ve made n \u2013 1 passes, since we know the largest n \u20131 elements will have bubbled to the right. We have n \u2013 2 steps for the inner loop, and n \u2013 1 loops, so we get n 2 \u2013 3 n + 2 steps total. But the largest factor, or dominant term, is n 2 , as n gets larger and larger, so we can say that bubble sort is O ( n 2 ). We\u2019ve seen running times like the following, and so even though binary search is much faster than linear search, it might not be worth the one\u2013time cost of sorting the list first, unless we do lots of searches over time: O( n 2 ) (bubble sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) And \u03a9 for bubble sort is still n 2 , since we still check each pair of elements for n \u2013 1 passes. Selection Sort We can take another approach with the same set of numbers: 6 3 8 5 2 7 4 1 First, we\u2019ll look at each number, and remember the smallest one we\u2019ve seen. Then, we can swap it with the first number in our list, since we know it\u2019s the smallest: 6 3 8 5 2 7 4 1 1 3 8 5 2 7 4 6 Now we know at least the first element of our list is in the right place, so we can look for the smallest element among the rest, and swap it with the next unsorted element (now the second element): 1 3 8 5 2 7 4 6 1 2 8 5 3 7 4 6 We can repeat this over and over, until we have a sorted list. This algorithm is called selection sort , and we might write pseudocode like this: For i from 0 to n\u20131 Find smallest item between i'th item and last item Swap smallest item with i'th item With big O notation, we still have running time of O ( n 2 ), since we were looking at roughly all n elements to find the smallest, and making n passes to sort all the elements. So it turns out that selection sort is fundamentally about the same as bubble sort in running time: O( n 2 ) (bubble sort, selection sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) The best case, \u03a9, is also n 2 . We can go back to bubble sort and change its algorithm to be something like this, which will allow us to stop early if all the elements are sorted: Repeat until no swaps For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Now, we only need to look at each element once, so the best case is now \u03a9( n ): \u03a9(n2) (selection sort) \u03a9(n log n) \u03a9(n) (bubble sort) \u03a9(log n) \u03a9(1) (linear search, binary search) We can use a visualization tool, found here , with animations for how the elements move within arrays for both bubble sort and insertion sort. Recursion Recall that in week 0, we had pseudocode for finding a name in a phone book, where we had lines telling us to \u201cgo back\u201d and repeat some steps: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 Open to middle of left half of book 8 **Go back to line 3** 9 Else if Smith is later in book 10 Open to middle of right half of book 11 **Go back to line 3** 12 Else 13 Quit We could instead just repeat our entire algorithm on the half of the book we have left: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 **Search left half of book** 8 Else if Smith is later in book 9 **Search right half of book** 10 Else 11 Quit This seems like a cyclical process that will never end, but we\u2019re actually dividing the problem in half each time, and stopping once there\u2019s no more book left. Recursion occurs when a function or algorithm refers to itself (references its own name in the code), as in the new pseudocode above. In week 1, too, we implemented a \u201cpyramid\u201d of blocks in the following shape : # ## ### #### This was the code we created for that problem set: #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // Draw pyramid of height h for ( int i = 1 ; i <= h ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } } Here, we use for loops to print each block in each row. But notice that a pyramid of height 4 is actually a pyramid of height 3, with an extra row of 4 blocks added on. And a pyramid of height 3 is a pyramid of height 2, with an extra row of 3 blocks. A pyramid of height 2 is a pyramid of height 1, with an extra row of 2 blocks. And finally, a pyramid of height 1 is just a pyramid of height 0, or nothing, with another row of a single block added on. With this idea in mind, we can write: #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // If nothing to draw if ( h == 0 ) { return ; } // Draw pyramid of height h - 1 draw ( h - 1 ); // Notice how we are referring to itself (draw) within the code // Draw one more row of width h for ( int i = 0 ; i < h ; i ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } Now, our draw function first calls itself recursively , drawing a pyramid of height h - 1 . But even before that, we need to stop if h is 0, since there won\u2019t be anything left to drawn. After, we draw the next row, or a row of width h . Merge Sort We can take the idea of recusion to sorting, with another algorithm called merge sort. The pseudocode might look like: If only one item Return Else Sort left half of items Sort right half of items Merge sorted halves We will use an unsorted list to demonstrate merge sorting: 7 4 5 2 6 3 8 1 First, we'll sort the left half (the first four elements): 7 4 5 2 | 6 3 8 1 - - - - Well, to sort that, we need to sort the left half of the left half first: 7 4 | 5 2 | 6 3 8 1 - - Now, we have just one item, 7 , in the left half, and one item, 4 , in the right half. So we\u2019ll merge that together, by taking the smallest item from each list first: - - | 5 2 | 6 3 8 1 4 7 And now we go back to the right half of the left half, and sort it: - - | - - | 6 3 8 1 4 7 2 5 Now, both halves of the left half are sorted, so we can merge the two of them together. We look at the start of each list, and take 2 since it\u2019s smaller than 4 . Then, we take 4 , since it\u2019s now the smallest item at the front of both lists. Then, we take 5 , and finally, 7 , to get: - - - - | 6 3 8 1 - - - - 2 4 5 7 Next, we do the same thing for the right half of numbers and end up with: - - - - | - - - - - - - - - - - - 2 4 5 7 1 3 6 8 And finally, we can merge both halves of the whole list, following the same steps as before. Notice that we don\u2019t need to check all the elements of each half to find the smallest, since we know that each half is already sorted. Instead, we just take the smallest element of the two at the start of each half. It took a lot of steps, but it actually took fewer steps than the other algorithms we\u2019ve seen so far. We broke our list in half each time, until we were \u201csorting\u201d eight lists with one element each. Since our algorithm divided the problem in half each time, its running time is logarithmic with O(log n). And after we sorted each half (or half of a half), we needed to merge together all the elements, with n steps since we had to look at each element once. So our total running time is O ( n log n ): O( n 2 ) (bubble sort, selection sort) O( n log n ) (merge search) O( n ) (linear search) O(log n ) (binary search) O(1) To see this in real time, watch this video to see multiple sorting algorithms running at the same time:","title":"Algorithms"},{"location":"c-algorithms/#algorithms","text":"","title":"Algorithms"},{"location":"c-algorithms/#searching","text":"In computer science, a search algorithm is any algorithm which solves the search problem, namely, to retrieve information stored within some data structure, or calculates in the search space of a problem domain, either with discrete or continuous values. For now, we are going to go over two different types of searches: Linear Search Binary Search For the following examples, we are going to be using a row of lockers with numbers inside (an array) and we will look through them to find something, while returning a boolean ( true or false ) as a result. A linear search is where we move in a line (usually start to end or end to start). Now lets look through the lockers to find one with the number 50 inside. Some pseudocode for linear search could be written as: For i from 0 to n\u20131 // from start (0) to end (n-1) If i'th element is 50 Return true // if the i'th element is 50 - return true Return false // if not 50, return false A binary search is where we start in the middle and move left or right, depending on what we're looking for. Some pseudocode for binary search could be written as: If no items Return false If middle item is 50 Return true Else if 50 < middle item Search left half Else if 50 > middle item Search right half","title":"Searching"},{"location":"c-algorithms/#big-o","text":"Computer scientists have created a way to describe algorithms (how well it is designed), and it's generally called big O . The more formal way to describe this is with big O notation, which we can think of as \u201con the order of\u201d. For example, if our algorithm is linear search, it will take approximately O( n ) steps, \u201con the order of n \u201d. In fact, even an algorithm that looks at two items at a time and takes n /2 steps has O( n ). This is because, as n gets bigger and bigger, only the largest term, n , matters. There are some common running times (how many seconds does it take, how many steps does it take, etc.): (lower is better) O( n 2 ) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) Computer scientists might also use big \u03a9, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big O is the upper bound of number of steps, or the worst case, and typically what we care about more.) With linear search, for example, the worst case is n steps, but the best case is 1 step since our item might happen to be the first item we check. The best case for binary search, too, is 1 since our item might be in the middle of the array. And we have a similar set of the most common big \u03a9 running times: (lower is better) \u03a9(n2) \u03a9(n log n) \u03a9(n) (counting the number of items) \u03a9(log n) \u03a9(1) (linear search, binary search)","title":"Big O"},{"location":"c-algorithms/#linear-search","text":"Now let's create a program to better visualize a lienar search: #include <cs50.h> #include <stdio.h> int main ( void ) { int numbers [ 6 ] = { 4 , 8 , 15 , 16 , 23 , 42 }; for ( int i = 0 ; i < 6 ; i ++ ) { if ( numbers [ i ] == 50 ) { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Here we initialize an array with some values, and we check the items in the array one at a time, in order. And in each case, depending on whether the value was found or not, we can return an exit code of either 0 (for success) or 1 (for failure). We can do the same for names: #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma is the name we're looking for. note the use of strcmp { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can\u2019t compare strings directly, since they\u2019re not a simple data type but rather an array of many characters, and we need to compare them differently. Luckily, the string library has a strcmp function which compares strings for us and returns 0 if they\u2019re the same, so we can use that. Now lets implement a phone book with the same ideas: #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; string numbers [ 4 ] = { \"617\u2013555\u20130100\" , \"617\u2013555\u20130101\" , \"617\u2013555\u20130102\" , \"617\u2013555\u20130103\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma's phone number is what we're looking for { printf ( \"Found %s \\n \" , numbers [ i ]); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Now, if the name at a certain index in the names array matches who we\u2019re looking for, we\u2019ll return the phone number in the numbers array, at the same index. But that means we need to particularly careful to make sure that each number corresponds to the name at each index, especially if we add or remove names and numbers. Let's improve the above code using our own custom data type!","title":"Linear Search"},{"location":"c-algorithms/#structs","text":"We can make our own custom data types called structs : #include <cs50.h> #include <stdio.h> #include <string.h> typedef struct { string name ; string number ; } person ; // we are encapsulating both the strings name and number inside our struct \"person\" int main ( void ) { person people [ 4 ]; people [ 0 ]. name = \"EMMA\" ; people [ 0 ]. number = \"617\u2013555\u20130100\" ; people [ 1 ]. name = \"RODRIGO\" ; people [ 1 ]. number = \"617\u2013555\u20130101\" ; people [ 2 ]. name = \"BRIAN\" ; people [ 2 ]. number = \"617\u2013555\u20130102\" ; people [ 3 ]. name = \"DAVID\" ; people [ 3 ]. number = \"617\u2013555\u20130103\" ; // Search for EMMA for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( people [ i ]. name , \"EMMA\" ) == 0 ) { printf ( \"Found %s \\n \" , people [ i ]. number ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can think of structs as containers, inside of which are multiple other data types. Here, we create our own type with a struct called person , which will have a string called name and a string called number . Then, we can create an array of these struct types and initialize the values inside each of them, using a new syntax, . , to access the properties of each person . In our loop, we can now be more certain that the number corresponds to the name since they are from the same person element.","title":"Structs"},{"location":"c-algorithms/#sorting","text":"The process of Sorting can be explained as a technique of rearranging the elements in any particular order, which can be set ready for further processing by the program logic. In C, there are multiple sorting algorithms available, which can be incorporated inside the code.","title":"Sorting"},{"location":"c-algorithms/#bubble-sort","text":"Let's take 8 random numbers ( 6 , 3 , 8 , 5 , 2 , 7 , 4 , 1 ) and try to sort them in C. First, we can look at the first two numbers and swap them so they are in order: 6 3 8 5 2 7 4 1 3 6 8 5 2 7 4 1 The next pair, 6 and 8 , are in order, so we don\u2019t need to swap them. The next pair, 8 and 5 , need to be swapped: 3 6 8 5 2 7 4 1 3 6 5 8 2 7 4 1 We continue until we reach the end of the list: 3 6 5 8 2 7 4 1 3 6 5 2 8 7 4 1 3 6 5 2 7 8 4 1 3 6 5 2 7 4 8 1 3 6 5 2 7 4 1 8 Our list isn\u2019t sorted yet, but we\u2019re slightly closer to the solution because the biggest value, 8 , has been shifted all the way to the right. We repeat this with another pass through the list, over and over, until it is sorted correctly. This algorithm is called bubble sort , where large values \u201cbubble\u201d to the right. The pseudocode for this might look like: Repeat n\u20131 times For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Since we are comparing the i'th and i+1'th element, we only need to go up to n \u2013 2 for i . Then, we swap the two elements if they\u2019re out of order. And we can stop after we\u2019ve made n \u2013 1 passes, since we know the largest n \u20131 elements will have bubbled to the right. We have n \u2013 2 steps for the inner loop, and n \u2013 1 loops, so we get n 2 \u2013 3 n + 2 steps total. But the largest factor, or dominant term, is n 2 , as n gets larger and larger, so we can say that bubble sort is O ( n 2 ). We\u2019ve seen running times like the following, and so even though binary search is much faster than linear search, it might not be worth the one\u2013time cost of sorting the list first, unless we do lots of searches over time: O( n 2 ) (bubble sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) And \u03a9 for bubble sort is still n 2 , since we still check each pair of elements for n \u2013 1 passes.","title":"Bubble Sort"},{"location":"c-algorithms/#selection-sort","text":"We can take another approach with the same set of numbers: 6 3 8 5 2 7 4 1 First, we\u2019ll look at each number, and remember the smallest one we\u2019ve seen. Then, we can swap it with the first number in our list, since we know it\u2019s the smallest: 6 3 8 5 2 7 4 1 1 3 8 5 2 7 4 6 Now we know at least the first element of our list is in the right place, so we can look for the smallest element among the rest, and swap it with the next unsorted element (now the second element): 1 3 8 5 2 7 4 6 1 2 8 5 3 7 4 6 We can repeat this over and over, until we have a sorted list. This algorithm is called selection sort , and we might write pseudocode like this: For i from 0 to n\u20131 Find smallest item between i'th item and last item Swap smallest item with i'th item With big O notation, we still have running time of O ( n 2 ), since we were looking at roughly all n elements to find the smallest, and making n passes to sort all the elements. So it turns out that selection sort is fundamentally about the same as bubble sort in running time: O( n 2 ) (bubble sort, selection sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) The best case, \u03a9, is also n 2 . We can go back to bubble sort and change its algorithm to be something like this, which will allow us to stop early if all the elements are sorted: Repeat until no swaps For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Now, we only need to look at each element once, so the best case is now \u03a9( n ): \u03a9(n2) (selection sort) \u03a9(n log n) \u03a9(n) (bubble sort) \u03a9(log n) \u03a9(1) (linear search, binary search) We can use a visualization tool, found here , with animations for how the elements move within arrays for both bubble sort and insertion sort.","title":"Selection Sort"},{"location":"c-algorithms/#recursion","text":"Recall that in week 0, we had pseudocode for finding a name in a phone book, where we had lines telling us to \u201cgo back\u201d and repeat some steps: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 Open to middle of left half of book 8 **Go back to line 3** 9 Else if Smith is later in book 10 Open to middle of right half of book 11 **Go back to line 3** 12 Else 13 Quit We could instead just repeat our entire algorithm on the half of the book we have left: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 **Search left half of book** 8 Else if Smith is later in book 9 **Search right half of book** 10 Else 11 Quit This seems like a cyclical process that will never end, but we\u2019re actually dividing the problem in half each time, and stopping once there\u2019s no more book left. Recursion occurs when a function or algorithm refers to itself (references its own name in the code), as in the new pseudocode above. In week 1, too, we implemented a \u201cpyramid\u201d of blocks in the following shape : # ## ### #### This was the code we created for that problem set: #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // Draw pyramid of height h for ( int i = 1 ; i <= h ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } } Here, we use for loops to print each block in each row. But notice that a pyramid of height 4 is actually a pyramid of height 3, with an extra row of 4 blocks added on. And a pyramid of height 3 is a pyramid of height 2, with an extra row of 3 blocks. A pyramid of height 2 is a pyramid of height 1, with an extra row of 2 blocks. And finally, a pyramid of height 1 is just a pyramid of height 0, or nothing, with another row of a single block added on. With this idea in mind, we can write: #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // If nothing to draw if ( h == 0 ) { return ; } // Draw pyramid of height h - 1 draw ( h - 1 ); // Notice how we are referring to itself (draw) within the code // Draw one more row of width h for ( int i = 0 ; i < h ; i ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } Now, our draw function first calls itself recursively , drawing a pyramid of height h - 1 . But even before that, we need to stop if h is 0, since there won\u2019t be anything left to drawn. After, we draw the next row, or a row of width h .","title":"Recursion"},{"location":"c-algorithms/#merge-sort","text":"We can take the idea of recusion to sorting, with another algorithm called merge sort. The pseudocode might look like: If only one item Return Else Sort left half of items Sort right half of items Merge sorted halves We will use an unsorted list to demonstrate merge sorting: 7 4 5 2 6 3 8 1 First, we'll sort the left half (the first four elements): 7 4 5 2 | 6 3 8 1 - - - - Well, to sort that, we need to sort the left half of the left half first: 7 4 | 5 2 | 6 3 8 1 - - Now, we have just one item, 7 , in the left half, and one item, 4 , in the right half. So we\u2019ll merge that together, by taking the smallest item from each list first: - - | 5 2 | 6 3 8 1 4 7 And now we go back to the right half of the left half, and sort it: - - | - - | 6 3 8 1 4 7 2 5 Now, both halves of the left half are sorted, so we can merge the two of them together. We look at the start of each list, and take 2 since it\u2019s smaller than 4 . Then, we take 4 , since it\u2019s now the smallest item at the front of both lists. Then, we take 5 , and finally, 7 , to get: - - - - | 6 3 8 1 - - - - 2 4 5 7 Next, we do the same thing for the right half of numbers and end up with: - - - - | - - - - - - - - - - - - 2 4 5 7 1 3 6 8 And finally, we can merge both halves of the whole list, following the same steps as before. Notice that we don\u2019t need to check all the elements of each half to find the smallest, since we know that each half is already sorted. Instead, we just take the smallest element of the two at the start of each half. It took a lot of steps, but it actually took fewer steps than the other algorithms we\u2019ve seen so far. We broke our list in half each time, until we were \u201csorting\u201d eight lists with one element each. Since our algorithm divided the problem in half each time, its running time is logarithmic with O(log n). And after we sorted each half (or half of a half), we needed to merge together all the elements, with n steps since we had to look at each element once. So our total running time is O ( n log n ): O( n 2 ) (bubble sort, selection sort) O( n log n ) (merge search) O( n ) (linear search) O(log n ) (binary search) O(1) To see this in real time, watch this video to see multiple sorting algorithms running at the same time:","title":"Merge Sort"},{"location":"c-arrays/","text":"Arrays What are Arrays? Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you. Array Declarations \u2003\u2003 type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages. Basic Array Program Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average). Other Array Tips Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything. Reading Levels Program According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); } Caesar's Cipher We will now create a program that will take text and run it through Caesar's encryption method. Supposedly, Caesar (yes, that Caesar) used to \u201cencrypt\u201d (i.e., conceal in a reversible way) confidential messages by shifting each letter therein by some number of places. For instance, he might write A as B, B as C, C as D, \u2026, and, wrapping around alphabetically, Z as A. And so, to say HELLO to someone, Caesar might write IFMMP. Upon receiving such messages from Caesar, recipients would have to \u201cdecrypt\u201d them by shifting letters in the opposite direction by the same number of places. The secrecy of this \u201ccryptosystem\u201d relied on only Caesar and the recipients knowing a secret, the number of places by which Caesar had shifted his letters (e.g., 1). Not particularly secure by modern standards, but, hey, if you\u2019re perhaps the first in the world to do it, pretty secure! Note Unencrypted text is generally called plaintext . Encrypted text is generally called ciphertext . And the secret used is called a key . To be clear, then, here\u2019s how encrypting HELLO with a key of 1 yields IFMMP : plaintext H E L L O + key 1 1 1 1 1 = ciphertext I F M M P More formally, Caesar\u2019s algorithm (i.e., cipher) encrypts messages by \u201crotating\u201d each letter by k positions. More formally, if p is some plaintext (i.e., an unencrypted message), p i is the i th character in p , and k is a secret key (i.e., a non-negative integer), then each letter, c i , in the ciphertext, c , is computed as: c i = (p i + k) % 26 wherein % 26 here means \u201cremainder when dividing by 26.\u201d This formula perhaps makes the cipher seem more complicated than it is, but it\u2019s really just a concise way of expressing the algorithm precisely. Indeed, for the sake of discussion, think of A (or a) as 0, B (or b) as 1, \u2026, H (or h) as 7, I (or i) as 8, \u2026, and Z (or z) as 25. Suppose that Caesar just wants to say Hi to someone confidentially using, this time, a key, k , of 3. And so his plaintext, p , is Hi, in which case his plaintext\u2019s first character, p 0 , is H (aka 7), and his plaintext\u2019s second character, p 1 , is i (aka 8). His ciphertext\u2019s first character, c 0 , is thus K, and his ciphertext\u2019s second character, c 1 , is thus L. Can you see why? Here are a few examples of how the program might work. For example, if the user inputs a key of 1 and a plaintext of HELLO : $ ./caesar 1 plaintext: HELLO ciphertext: IFMMP Here\u2019s how the program might work if the user provides a key of 13 and a plaintext of hello, world : $ ./caesar 13 plaintext: hello, world ciphertext: uryyb, jbeyq Now let's get coding! We need our program to do the following: Get Key (the amount to shift the text by) Get plaintext Encipher Print ciphertext Note We will preserve case for letters (Keep capital letters capital, and lowercase lowercase). We will also wrap the alphabet (If we go beyond the boundaries of the alphabet, it will just start over). Let's walkthrough each piece of the program. Get the Key We will be taking the key as a command line argument : $ ./caesar 3 Remember that in C our main function can take arguments using the following: int main ( int argc , string argv []) { // code here } Getting the Key Ensure single command-line argument (print error message if command-line argument is out of bounds) Make sure argument contains only digit characters Convert argument to an integer We will also need to convert the string from the command line argument into a number using the atoi function, declared in <stdlib.h> . Getting the Plaintext We will simply use the get_string function to get user input for the plaintext. Encipher the Plaintext If it's alphabetic, shift the plaintext character by key, preserving the case. If it's not alphabetic, leave the character as-is. We can use the following functions to help us identify character type: isalpha , isupper , and islower . These functions will return a boolean value ( true or false ). Here is the correct program: #include <stdio.h> #include <cs50.h> #include <stdlib.h> #include <string.h> #include <ctype.h> bool check_key ( string s ); int main ( int argc , string argv []) //argc takes in the number of arguments and argv creates an array for the arguments themselves. { if ( argc != 2 || ! check_key ( argv [ 1 ])) // checking if the number of arguments is not 2 and if the key is valid { printf ( \"Usage: ./caesar key\" ); // if the input is not valid, it will print an error message with the correct way to enter return 1 ; } int key = atoi ( argv [ 1 ]); // converts from ASCII to integer string plaintext = get_string ( \"plaintext: \" ); printf ( \"ciphertext: \" ); for ( int i = 0 , len = strlen ( plaintext ); i < len ; i ++ ) { char c = plaintext [ i ]; if ( isalpha ( c )) { char m = 'A' ; if ( islower ( c )) m = 'a' ; printf ( \"%c\" , ( c - m + key ) % 26 + m ); // inputs the plaintext into Caesar's cipher } else printf ( \"%c\" , c ); // if the character is not alphabetic, it will print it as is } printf ( \" \\n \" ); } bool check_key ( string s ) // this string checks to see if the key is valid { for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) if ( ! isdigit ( s [ i ])) // if its not a digit, return false return false ; return true ; }","title":"Arrays"},{"location":"c-arrays/#arrays","text":"","title":"Arrays"},{"location":"c-arrays/#what-are-arrays","text":"Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you.","title":"What are Arrays?"},{"location":"c-arrays/#array-declarations","text":"type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages.","title":"Array Declarations"},{"location":"c-arrays/#basic-array-program","text":"Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average).","title":"Basic Array Program"},{"location":"c-arrays/#other-array-tips","text":"Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything.","title":"Other Array Tips"},{"location":"c-arrays/#reading-levels-program","text":"According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); }","title":"Reading Levels Program"},{"location":"c-arrays/#caesars-cipher","text":"We will now create a program that will take text and run it through Caesar's encryption method. Supposedly, Caesar (yes, that Caesar) used to \u201cencrypt\u201d (i.e., conceal in a reversible way) confidential messages by shifting each letter therein by some number of places. For instance, he might write A as B, B as C, C as D, \u2026, and, wrapping around alphabetically, Z as A. And so, to say HELLO to someone, Caesar might write IFMMP. Upon receiving such messages from Caesar, recipients would have to \u201cdecrypt\u201d them by shifting letters in the opposite direction by the same number of places. The secrecy of this \u201ccryptosystem\u201d relied on only Caesar and the recipients knowing a secret, the number of places by which Caesar had shifted his letters (e.g., 1). Not particularly secure by modern standards, but, hey, if you\u2019re perhaps the first in the world to do it, pretty secure! Note Unencrypted text is generally called plaintext . Encrypted text is generally called ciphertext . And the secret used is called a key . To be clear, then, here\u2019s how encrypting HELLO with a key of 1 yields IFMMP : plaintext H E L L O + key 1 1 1 1 1 = ciphertext I F M M P More formally, Caesar\u2019s algorithm (i.e., cipher) encrypts messages by \u201crotating\u201d each letter by k positions. More formally, if p is some plaintext (i.e., an unencrypted message), p i is the i th character in p , and k is a secret key (i.e., a non-negative integer), then each letter, c i , in the ciphertext, c , is computed as: c i = (p i + k) % 26 wherein % 26 here means \u201cremainder when dividing by 26.\u201d This formula perhaps makes the cipher seem more complicated than it is, but it\u2019s really just a concise way of expressing the algorithm precisely. Indeed, for the sake of discussion, think of A (or a) as 0, B (or b) as 1, \u2026, H (or h) as 7, I (or i) as 8, \u2026, and Z (or z) as 25. Suppose that Caesar just wants to say Hi to someone confidentially using, this time, a key, k , of 3. And so his plaintext, p , is Hi, in which case his plaintext\u2019s first character, p 0 , is H (aka 7), and his plaintext\u2019s second character, p 1 , is i (aka 8). His ciphertext\u2019s first character, c 0 , is thus K, and his ciphertext\u2019s second character, c 1 , is thus L. Can you see why? Here are a few examples of how the program might work. For example, if the user inputs a key of 1 and a plaintext of HELLO : $ ./caesar 1 plaintext: HELLO ciphertext: IFMMP Here\u2019s how the program might work if the user provides a key of 13 and a plaintext of hello, world : $ ./caesar 13 plaintext: hello, world ciphertext: uryyb, jbeyq Now let's get coding! We need our program to do the following: Get Key (the amount to shift the text by) Get plaintext Encipher Print ciphertext Note We will preserve case for letters (Keep capital letters capital, and lowercase lowercase). We will also wrap the alphabet (If we go beyond the boundaries of the alphabet, it will just start over). Let's walkthrough each piece of the program. Get the Key We will be taking the key as a command line argument : $ ./caesar 3 Remember that in C our main function can take arguments using the following: int main ( int argc , string argv []) { // code here } Getting the Key Ensure single command-line argument (print error message if command-line argument is out of bounds) Make sure argument contains only digit characters Convert argument to an integer We will also need to convert the string from the command line argument into a number using the atoi function, declared in <stdlib.h> . Getting the Plaintext We will simply use the get_string function to get user input for the plaintext. Encipher the Plaintext If it's alphabetic, shift the plaintext character by key, preserving the case. If it's not alphabetic, leave the character as-is. We can use the following functions to help us identify character type: isalpha , isupper , and islower . These functions will return a boolean value ( true or false ). Here is the correct program: #include <stdio.h> #include <cs50.h> #include <stdlib.h> #include <string.h> #include <ctype.h> bool check_key ( string s ); int main ( int argc , string argv []) //argc takes in the number of arguments and argv creates an array for the arguments themselves. { if ( argc != 2 || ! check_key ( argv [ 1 ])) // checking if the number of arguments is not 2 and if the key is valid { printf ( \"Usage: ./caesar key\" ); // if the input is not valid, it will print an error message with the correct way to enter return 1 ; } int key = atoi ( argv [ 1 ]); // converts from ASCII to integer string plaintext = get_string ( \"plaintext: \" ); printf ( \"ciphertext: \" ); for ( int i = 0 , len = strlen ( plaintext ); i < len ; i ++ ) { char c = plaintext [ i ]; if ( isalpha ( c )) { char m = 'A' ; if ( islower ( c )) m = 'a' ; printf ( \"%c\" , ( c - m + key ) % 26 + m ); // inputs the plaintext into Caesar's cipher } else printf ( \"%c\" , c ); // if the character is not alphabetic, it will print it as is } printf ( \" \\n \" ); } bool check_key ( string s ) // this string checks to see if the key is valid { for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) if ( ! isdigit ( s [ i ])) // if its not a digit, return false return false ; return true ; }","title":"Caesar's Cipher"},{"location":"c-cl-arguments/","text":"Command Line Arugments Overview Command Line Arguments So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc - 1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-cl-arguments/#command-line-arugments-overview","text":"","title":"Command Line Arugments Overview"},{"location":"c-cl-arguments/#command-line-arguments","text":"So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc - 1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-functions/","text":"Functions What are functions? C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented. Why us functions? Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need! Function Declarations The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number. Function Definitions The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back } Function Calls To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; } Function Miscellany Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type. Practice Problem We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Functions"},{"location":"c-functions/#functions","text":"","title":"Functions"},{"location":"c-functions/#what-are-functions","text":"C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented.","title":"What are functions?"},{"location":"c-functions/#why-us-functions","text":"Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need!","title":"Why us functions?"},{"location":"c-functions/#function-declarations","text":"The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number.","title":"Function Declarations"},{"location":"c-functions/#function-definitions","text":"The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back }","title":"Function Definitions"},{"location":"c-functions/#function-calls","text":"To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; }","title":"Function Calls"},{"location":"c-functions/#function-miscellany","text":"Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type.","title":"Function Miscellany"},{"location":"c-functions/#practice-problem","text":"We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Practice Problem"},{"location":"c-variable-scope/","text":"Variables and Scope Variable Scope Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; } Why do local and global distinctions matter? For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Variables and Scope"},{"location":"c-variable-scope/#variables-and-scope","text":"","title":"Variables and Scope"},{"location":"c-variable-scope/#variable-scope","text":"Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; }","title":"Variable Scope"},{"location":"c-variable-scope/#why-do-local-and-global-distinctions-matter","text":"For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Why do local and global distinctions matter?"},{"location":"c/","text":"C Basics Basic Data Types int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\"). Creating a Variable To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ; Using a Variable After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment Operators In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==). Conditional Statements Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); } Loops Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled. First Code #include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename* Hello, *name*! Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); } Mario Problem Set Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n - 1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } } Cash Problem Set When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { loat dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"C Basics"},{"location":"c/#c-basics","text":"","title":"C Basics"},{"location":"c/#basic-data-types","text":"int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\").","title":"Basic Data Types"},{"location":"c/#creating-a-variable","text":"To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ;","title":"Creating a Variable"},{"location":"c/#using-a-variable","text":"After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment","title":"Using a Variable"},{"location":"c/#operators","text":"In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==).","title":"Operators"},{"location":"c/#conditional-statements","text":"Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); }","title":"Conditional Statements"},{"location":"c/#loops","text":"Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled.","title":"Loops"},{"location":"c/#first-code","text":"#include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename*","title":"First Code"},{"location":"c/#hello-name","text":"Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); }","title":"Hello, *name*!"},{"location":"c/#mario-problem-set","text":"Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n - 1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } }","title":"Mario Problem Set"},{"location":"c/#cash-problem-set","text":"When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { loat dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"Cash Problem Set"},{"location":"chrome/","text":"What is Google Chrome? Google Chrome Overview Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"What is Google Chrome?"},{"location":"chrome/#what-is-google-chrome","text":"","title":"What is Google Chrome?"},{"location":"chrome/#google-chrome-overview","text":"Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"Google Chrome Overview"},{"location":"chromeinstall/","text":"How to Install Google Chrome Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"Google Chrome Install"},{"location":"chromeinstall/#how-to-install-google-chrome","text":"Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"How to Install Google Chrome"},{"location":"chromemedia/","text":"Google Chrome Media Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"chromemedia/#google-chrome-media","text":"Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"glossary/","text":"Below is a list of key words and their definitions: Bookmark - A bookmark is a saved shortcut that directs your browser to a specific webpage. It stores the title, URL, and favicon of the corresponding page. Saving bookmarks allows you to easily access your favorite locations on the Web. Browser - Software programs that enable you to view web pages and other documents on the Internet. They \"translate\" HTML-encoded files into the text, images, sounds, and other features you see. Google Chrome is a browser. Cache - In browsers, \"cache\" is used to identify a space where web pages you have visited are stored in your computer. A copy of documents you retrieve is stored in cache. When you use GO, BACK, or any other means to revisit a document, the browser first checks to see if it is in cache and will retrieve it from there because it is much faster than retrieving it from the server. Cookie - An HTTP cookie is a small piece of data sent from a website and stored on the user's computer by the user's web browser while the user is browsing. Cookies were designed to be a reliable mechanism for websites to remember stateful information or to record the user's browsing activity. Extension - Extensions are small software programs that customize the browsing experience. They enable users to tailor Chrome functionality and behavior to individual needs or preferences. They are built on web technologies such as HTML, JavaScript, and CSS. HTML - HTML stands for Hyper Text Markup Language. HTML is the standard markup language for Web pages, which are the building blocks of most web pages. Link - A link (short for hyperlink) is an HTML object that allows you to jump to a new location when you click or tap it. Links are found on almost every webpage and provide a simple means of navigating between pages on the web. Links can be attached to text, images, or other HTML elements. URL - URL stands for Uniform Resource Locator. A URL is nothing more than the address of a given unique resource on the Web (e.g. website, page, or file). In theory, each valid URL points to a unique resource.","title":"Glossary"},{"location":"portfolio/","text":"Nicholas Platt's Portfolio Resume Portfolio Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types. Images Custom Keyboard PCB with Switch Slot Callouts Example 2 Example 3 Example 4 Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Main Portfolio"},{"location":"portfolio/#nicholas-platts-portfolio","text":"","title":"Nicholas Platt's Portfolio"},{"location":"portfolio/#resume","text":"","title":"Resume"},{"location":"portfolio/#portfolio","text":"Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types.","title":"Portfolio"},{"location":"portfolio/#images","text":"Custom Keyboard PCB with Switch Slot Callouts Example 2 Example 3 Example 4","title":"Images"},{"location":"portfolio/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Contact"}]}