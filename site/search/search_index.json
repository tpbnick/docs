{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Nick's Docs This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here . Portfolio Quick Links: Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018) Programming Notes C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures C++ Coming Soon! Python Coming Soon! Go Coming Soon! R Coming Soon! SQL Coming Soon! Quick Links IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Home"},{"location":"#welcome-to-nicks-docs","text":"This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here .","title":"Welcome to Nick's Docs"},{"location":"#portfolio-quick-links","text":"Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018)","title":"Portfolio Quick Links:"},{"location":"#programming-notes","text":"C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures C++ Coming Soon! Python Coming Soon! Go Coming Soon! R Coming Soon! SQL Coming Soon!","title":"Programming Notes"},{"location":"#quick-links","text":"IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Quick Links"},{"location":"about/","text":"About About Me .aligncenter{ text-align: center; border-radius: 15px; } Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I plan on obtaining a Master's in Software Engineering in the near future. I have basic knowledge in HTML, CSS, JavaScript, Python, Markdown, and C (hopefully more to come in the near future). If you have any questions, please feel free to reach out to me through the contact info below. Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#about-me","text":".aligncenter{ text-align: center; border-radius: 15px; } Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I plan on obtaining a Master's in Software Engineering in the near future. I have basic knowledge in HTML, CSS, JavaScript, Python, Markdown, and C (hopefully more to come in the near future). If you have any questions, please feel free to reach out to me through the contact info below.","title":"About Me"},{"location":"about/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Contact"},{"location":"c-algorithms-problems/","text":"Algorithm Problems Plurality Problem Now let's take our new knowledge of algorithms and create a program that runs a plurality election that will yield the following output: $ ./plurality Alice Bob Charlie Number of voters: 4 Vote: Alice Vote: Bob Vote: Charlie Vote: Alice Alice Background Elections come in all shapes and sizes. In the UK, the Prime Minister is officially appointed by the monarch, who generally chooses the leader of the political party that wins the most seats in the House of Commons. The United States uses a multi-step Electoral College process where citizens vote on how each state should allocate Electors who then elect the President. Perhaps the simplest way to hold an election, though, is via a method commonly known as the \u201cplurality vote\u201d (also known as \u201cfirst-past-the-post\u201d or \u201cwinner take all\u201d). In the plurality vote, every voter gets to vote for one candidate. At the end of the election, whichever candidate has the greatest number of votes is declared the winner of the election. Getting Started We are going to take the following code and complete the vote and print_winner functions: #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } // Update vote totals given a new vote bool vote ( string name ) { // TODO return false ; } // Print the winner (or winners) of the election void print_winner ( void ) { // TODO return ; } We can make up the following code for the vote and print_winner functions that solves the problem: #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } int get_index ( string name ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( name , candidates [ i ]. name ) == 0 ) return i ; } return - 1 ; } // Update vote totals given a new vote bool vote ( string name ) { int candidate_index = get_index ( name ); // gets the index for name user inputs if ( candidate_index != - 1 ) { candidates [ candidate_index ]. votes ++ ; // increments vote count for each candidate return true ; } return false ; } int get_max ( void ) { int max_votes = candidates [ 0 ]. votes ; for ( int i = 1 ; i < candidate_count ; i ++ ) if ( candidates [ i ]. votes > max_votes ) max_votes = candidates [ i ]. votes ; return max_votes ; } // Print the winner (or winners) of the election void print_winner ( void ) { int max_votes = get_max (); // see who has the most voites for ( int i = 0 ; i < candidate_count ; i ++ ) // prints name of candidate with most votes { if ( candidates [ i ]. votes == max_votes ) printf ( \"%s \\n \" , candidates [ i ]. name ); } } Runoff Now let's take the previous problem and make it a little more intricate. You already know about plurality elections, which follow a very simple algorithm for determining the winner of an election: every voter gets one vote, and the candidate with the most votes wins. But the plurality vote does have some disadvantages. What happens, for instance, in an election with three candidates, and the ballots below are cast? Ballot Ballot Ballot Ballot Ballot Alice Alice Bob Bob Charlie A plurality vote would here declare a tie between Alice and Bob, since each has two votes. But is that the right outcome? There\u2019s another kind of voting system known as a ranked-choice voting system. In a ranked-choice system, voters can vote for more than one candidate. Instead of just voting for their top choice, they can rank the candidates in order of preference. The resulting ballots might therefore look like the below. Ballot Ballot Ballot Ballot Ballot 1.Alice 1.Alice 1.Bob 1.Bob 1.Charlie 2.Bob 2.Charlie 2.Alice 2.Alice 2.Alice 3.Charlie 3.Bob 3.Charlie 3.Charlie 3.Bob Here, each voter, in addition to specifying their first preference candidate, has also indicated their second and third choices. And now, what was previously a tied election could now have a winner. The race was originally tied between Alice and Bob, so Charlie was out of the running. But the voter who chose Charlie preferred Alice over Bob, so Alice could here be declared the winner. One such ranked choice voting system is the instant runoff system. In an instant runoff election, voters can rank as many candidates as they wish. If any candidate has a majority (more than 50%) of the first preference votes, that candidate is declared the winner of the election. Let's look at the following code and see how we can implement this type of voting system. We will need to fill in the correct code for the following functions: vote , tabulate , print_winner , find_min , is_tie , and eliminate . #include <cs50.h> #include <stdio.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; int candidate_count ; // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO return ; } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO return 0 ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO return false ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO return ; } Let's take a look at the vote , tabulate , print_winner , find_min , is_tie , and eliminate functions to see what exactly we need to do. vote The function takes arguments voter , rank , and name . If name is a match for the name of a valid candidate, then you should update the global preferences array to indicate that the voter voter has that candidate as their rank preference (where 0 is the first preference, 1 is the second preference, etc.). If the preference is successfully recorded, the function should return true ; the function should return false otherwise (if, for instance, name is not the name of one of the candidates). You may assume that no two candidates will have the same name. tabulate The function should update the number of votes each candidate has at this stage in the runoff. Recall that at each stage in the runoff, every voter effectively votes for their top-preferred candidate who has not already been eliminated. print_winner If any candidate has more than half of the vote, their name should be printed to stdout and the function should return true . If nobody has won the election yet, the function should return false . find_min The function should return the minimum vote total for any candidate who is still in the election. is_tie The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should return true if every candidate remaining in the election has the same number of votes, and should return false otherwise. eliminate The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should eliminate the candidate (or candidates) who have min number of votes. Your program should behave per the example below: ./runoff Alice Bob Charlie Number of voters: 5 Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Charlie Rank 2: Alice Rank 3: Bob Alice The correct code looks as follows: #include <cs50.h> #include <stdio.h> #include <string.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; // global variable int candidate_count ; // global variable // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( candidates [ i ]. name , name ) == 0 ) { preferences [ voter ][ rank ] = i ; return true ; } } return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO for ( int i = 0 ; i < voter_count ; i ++ ) { for ( int j = 0 ; j < candidate_count ; j ++ ) // j is rank { int candidate_index = preferences [ i ][ j ]; if ( ! candidates [ candidate_index ]. eliminated ) { candidates [ candidate_index ]. votes ++ ; // update vote count if candidate has not been eliminated break ; } } } } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( candidates [ i ]. votes > ( voter_count / 2 )) // checks to see if one candidate has over half the votes { printf ( \"%s \\n \" , candidates [ i ]. name ); return true ; } } return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO int min = 0 ; // start from zero bool find_first = false ; for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) // see if candidate has been eliminated { if ( ! find_first ) { min = candidates [ i ]. votes ; find_first = true ; } else if ( candidates [ i ]. votes < min ) { min = candidates [ i ]. votes ; } } } return min ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) if ( candidates [ i ]. votes != min ) return false ; } return true ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { if ( candidates [ i ]. votes == min ) candidates [ i ]. eliminated = true ; } } }","title":"Algorithm Problems"},{"location":"c-algorithms-problems/#algorithm-problems","text":"","title":"Algorithm Problems"},{"location":"c-algorithms-problems/#plurality-problem","text":"Now let's take our new knowledge of algorithms and create a program that runs a plurality election that will yield the following output: $ ./plurality Alice Bob Charlie Number of voters: 4 Vote: Alice Vote: Bob Vote: Charlie Vote: Alice Alice Background Elections come in all shapes and sizes. In the UK, the Prime Minister is officially appointed by the monarch, who generally chooses the leader of the political party that wins the most seats in the House of Commons. The United States uses a multi-step Electoral College process where citizens vote on how each state should allocate Electors who then elect the President. Perhaps the simplest way to hold an election, though, is via a method commonly known as the \u201cplurality vote\u201d (also known as \u201cfirst-past-the-post\u201d or \u201cwinner take all\u201d). In the plurality vote, every voter gets to vote for one candidate. At the end of the election, whichever candidate has the greatest number of votes is declared the winner of the election. Getting Started We are going to take the following code and complete the vote and print_winner functions: #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } // Update vote totals given a new vote bool vote ( string name ) { // TODO return false ; } // Print the winner (or winners) of the election void print_winner ( void ) { // TODO return ; } We can make up the following code for the vote and print_winner functions that solves the problem: #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } int get_index ( string name ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( name , candidates [ i ]. name ) == 0 ) return i ; } return - 1 ; } // Update vote totals given a new vote bool vote ( string name ) { int candidate_index = get_index ( name ); // gets the index for name user inputs if ( candidate_index != - 1 ) { candidates [ candidate_index ]. votes ++ ; // increments vote count for each candidate return true ; } return false ; } int get_max ( void ) { int max_votes = candidates [ 0 ]. votes ; for ( int i = 1 ; i < candidate_count ; i ++ ) if ( candidates [ i ]. votes > max_votes ) max_votes = candidates [ i ]. votes ; return max_votes ; } // Print the winner (or winners) of the election void print_winner ( void ) { int max_votes = get_max (); // see who has the most voites for ( int i = 0 ; i < candidate_count ; i ++ ) // prints name of candidate with most votes { if ( candidates [ i ]. votes == max_votes ) printf ( \"%s \\n \" , candidates [ i ]. name ); } }","title":"Plurality Problem"},{"location":"c-algorithms-problems/#runoff","text":"Now let's take the previous problem and make it a little more intricate. You already know about plurality elections, which follow a very simple algorithm for determining the winner of an election: every voter gets one vote, and the candidate with the most votes wins. But the plurality vote does have some disadvantages. What happens, for instance, in an election with three candidates, and the ballots below are cast? Ballot Ballot Ballot Ballot Ballot Alice Alice Bob Bob Charlie A plurality vote would here declare a tie between Alice and Bob, since each has two votes. But is that the right outcome? There\u2019s another kind of voting system known as a ranked-choice voting system. In a ranked-choice system, voters can vote for more than one candidate. Instead of just voting for their top choice, they can rank the candidates in order of preference. The resulting ballots might therefore look like the below. Ballot Ballot Ballot Ballot Ballot 1.Alice 1.Alice 1.Bob 1.Bob 1.Charlie 2.Bob 2.Charlie 2.Alice 2.Alice 2.Alice 3.Charlie 3.Bob 3.Charlie 3.Charlie 3.Bob Here, each voter, in addition to specifying their first preference candidate, has also indicated their second and third choices. And now, what was previously a tied election could now have a winner. The race was originally tied between Alice and Bob, so Charlie was out of the running. But the voter who chose Charlie preferred Alice over Bob, so Alice could here be declared the winner. One such ranked choice voting system is the instant runoff system. In an instant runoff election, voters can rank as many candidates as they wish. If any candidate has a majority (more than 50%) of the first preference votes, that candidate is declared the winner of the election. Let's look at the following code and see how we can implement this type of voting system. We will need to fill in the correct code for the following functions: vote , tabulate , print_winner , find_min , is_tie , and eliminate . #include <cs50.h> #include <stdio.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; int candidate_count ; // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO return ; } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO return 0 ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO return false ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO return ; } Let's take a look at the vote , tabulate , print_winner , find_min , is_tie , and eliminate functions to see what exactly we need to do. vote The function takes arguments voter , rank , and name . If name is a match for the name of a valid candidate, then you should update the global preferences array to indicate that the voter voter has that candidate as their rank preference (where 0 is the first preference, 1 is the second preference, etc.). If the preference is successfully recorded, the function should return true ; the function should return false otherwise (if, for instance, name is not the name of one of the candidates). You may assume that no two candidates will have the same name. tabulate The function should update the number of votes each candidate has at this stage in the runoff. Recall that at each stage in the runoff, every voter effectively votes for their top-preferred candidate who has not already been eliminated. print_winner If any candidate has more than half of the vote, their name should be printed to stdout and the function should return true . If nobody has won the election yet, the function should return false . find_min The function should return the minimum vote total for any candidate who is still in the election. is_tie The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should return true if every candidate remaining in the election has the same number of votes, and should return false otherwise. eliminate The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should eliminate the candidate (or candidates) who have min number of votes. Your program should behave per the example below: ./runoff Alice Bob Charlie Number of voters: 5 Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Charlie Rank 2: Alice Rank 3: Bob Alice The correct code looks as follows: #include <cs50.h> #include <stdio.h> #include <string.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; // global variable int candidate_count ; // global variable // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( candidates [ i ]. name , name ) == 0 ) { preferences [ voter ][ rank ] = i ; return true ; } } return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO for ( int i = 0 ; i < voter_count ; i ++ ) { for ( int j = 0 ; j < candidate_count ; j ++ ) // j is rank { int candidate_index = preferences [ i ][ j ]; if ( ! candidates [ candidate_index ]. eliminated ) { candidates [ candidate_index ]. votes ++ ; // update vote count if candidate has not been eliminated break ; } } } } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( candidates [ i ]. votes > ( voter_count / 2 )) // checks to see if one candidate has over half the votes { printf ( \"%s \\n \" , candidates [ i ]. name ); return true ; } } return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO int min = 0 ; // start from zero bool find_first = false ; for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) // see if candidate has been eliminated { if ( ! find_first ) { min = candidates [ i ]. votes ; find_first = true ; } else if ( candidates [ i ]. votes < min ) { min = candidates [ i ]. votes ; } } } return min ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) if ( candidates [ i ]. votes != min ) return false ; } return true ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { if ( candidates [ i ]. votes == min ) candidates [ i ]. eliminated = true ; } } }","title":"Runoff"},{"location":"c-algorithms/","text":"Algorithms An algorithm is step-by-step set of instructions for completing a task. Searching In computer science, a search algorithm is any algorithm which solves the search problem, namely, to retrieve information stored within some data structure, or calculates in the search space of a problem domain, either with discrete or continuous values. For now, we are going to go over two different types of searches: Linear Search Binary Search For the following examples, we are going to be using a row of lockers with numbers inside (an array) and we will look through them to find something, while returning a boolean ( true or false ) as a result. A linear search is where we move in a line (usually start to end or end to start). The idea of the algorithm is to iterate across the array from left to right, searching for a specified element. Worst-case scenario : We have to look through the entire array of n elements, either because the target element is the last element of the array or doesn't exist in the array at all. Best-case scenario : The target element is the first element of the array, and so we can stop looking immediately after we start. Now lets look through the lockers to find one with the number 50 inside. Some pseudocode for linear search could be written as: For i from 0 to n\u20131 // from start (0) to end (n-1) If i'th element is 50 Return true // if the i'th element is 50 - return true Return false // if not 50, return false A binary search is where we start in the middle and move left or right, depending on what we're looking for. \"Divide & Conquer\". In order to leverage the power of binary search, our array must be sorted , else we cannot make assumptions about the array's content. Worst-case scenario : We have to divide a list of n elements in half repeatedly to find the target element, either because the target element will be found at the end of the last division or doesn't exist in the array at all. Best-case scenario : The target element is at the midpoint of the full array, and so we can stop looking immediately after we start. Some pseudocode for binary search could be written as: If no items Return false If middle item is 50 Return true Else if 50 < middle item Search left half Else if 50 > middle item Search right half Big O Computer scientists have created a way to describe algorithms (how well it is designed), and it's generally called big O . The more formal way to describe this is with big O notation, which we can think of as \u201con the order of\u201d. For example, if our algorithm is linear search, it will take approximately O( n ) steps, \u201con the order of n \u201d. In fact, even an algorithm that looks at two items at a time and takes n /2 steps has O( n ). This is because, as n gets bigger and bigger, only the largest term, n , matters. There are some common running times (how many seconds does it take, how many steps does it take, etc.): (lower is better) O( n 2 ) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) Computer scientists might also use big \u03a9, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big O is the upper bound of number of steps, or the worst case, and typically what we care about more.) With linear search, for example, the worst case is n steps, but the best case is 1 step since our item might happen to be the first item we check. The best case for binary search, too, is 1 since our item might be in the middle of the array. And we have a similar set of the most common big \u03a9 running times: (lower is better) \u03a9(n2) \u03a9(n log n) \u03a9(n) (counting the number of items) \u03a9(log n) \u03a9(1) (linear search, binary search) Linear Search Now let's create a program to better visualize a lienar search: #include <cs50.h> #include <stdio.h> int main ( void ) { int numbers [ 6 ] = { 4 , 8 , 15 , 16 , 23 , 42 }; for ( int i = 0 ; i < 6 ; i ++ ) { if ( numbers [ i ] == 50 ) { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Here we initialize an array with some values, and we check the items in the array one at a time, in order. And in each case, depending on whether the value was found or not, we can return an exit code of either 0 (for success) or 1 (for failure). We can do the same for names: #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma is the name we're looking for. note the use of strcmp { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can\u2019t compare strings directly, since they\u2019re not a simple data type but rather an array of many characters, and we need to compare them differently. Luckily, the string library has a strcmp function which compares strings for us and returns 0 if they\u2019re the same, so we can use that. Now lets implement a phone book with the same ideas: #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; string numbers [ 4 ] = { \"617\u2013555\u20130100\" , \"617\u2013555\u20130101\" , \"617\u2013555\u20130102\" , \"617\u2013555\u20130103\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma's phone number is what we're looking for { printf ( \"Found %s \\n \" , numbers [ i ]); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Now, if the name at a certain index in the names array matches who we\u2019re looking for, we\u2019ll return the phone number in the numbers array, at the same index. But that means we need to particularly careful to make sure that each number corresponds to the name at each index, especially if we add or remove names and numbers. Let's improve the above code using our own custom data type! Structs We can make our own custom data types called structs : #include <cs50.h> #include <stdio.h> #include <string.h> typedef struct { string name ; string number ; } person ; // we are encapsulating both the strings name and number inside our struct \"person\" int main ( void ) { person people [ 4 ]; people [ 0 ]. name = \"EMMA\" ; people [ 0 ]. number = \"617\u2013555\u20130100\" ; people [ 1 ]. name = \"RODRIGO\" ; people [ 1 ]. number = \"617\u2013555\u20130101\" ; people [ 2 ]. name = \"BRIAN\" ; people [ 2 ]. number = \"617\u2013555\u20130102\" ; people [ 3 ]. name = \"DAVID\" ; people [ 3 ]. number = \"617\u2013555\u20130103\" ; // Search for EMMA for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( people [ i ]. name , \"EMMA\" ) == 0 ) { printf ( \"Found %s \\n \" , people [ i ]. number ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can think of structs as containers, inside of which are multiple other data types. Here, we create our own type with a struct called person , which will have a string called name and a string called number . Then, we can create an array of these struct types and initialize the values inside each of them, using a new syntax, . , to access the properties of each person . In our loop, we can now be more certain that the number corresponds to the name since they are from the same person element. Sorting The process of Sorting can be explained as a technique of rearranging the elements in any particular order, which can be set ready for further processing by the program logic. In C, there are multiple sorting algorithms available, which can be incorporated inside the code. Bubble Sort In bubble stort, the idea of the algorithm is to move higher valued elements generally towards the right and lower value elements generally towards the left. Let's take 8 random numbers ( 6 , 3 , 8 , 5 , 2 , 7 , 4 , 1 ) and try to sort them in C. First, we can look at the first two numbers and swap them so they are in order: 6 3 8 5 2 7 4 1 3 6 8 5 2 7 4 1 The next pair, 6 and 8 , are in order, so we don\u2019t need to swap them. The next pair, 8 and 5 , need to be swapped: 3 6 8 5 2 7 4 1 3 6 5 8 2 7 4 1 We continue until we reach the end of the list: 3 6 5 8 2 7 4 1 3 6 5 2 8 7 4 1 3 6 5 2 7 8 4 1 3 6 5 2 7 4 8 1 3 6 5 2 7 4 1 8 Our list isn\u2019t sorted yet, but we\u2019re slightly closer to the solution because the biggest value, 8 , has been shifted all the way to the right. We repeat this with another pass through the list, over and over, until it is sorted correctly. The pseudocode for this might look like: Repeat n\u20131 times For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Since we are comparing the i'th and i+1'th element, we only need to go up to n \u2013 2 for i . Then, we swap the two elements if they\u2019re out of order. And we can stop after we\u2019ve made n \u2013 1 passes, since we know the largest n \u20131 elements will have bubbled to the right. We have n \u2013 2 steps for the inner loop, and n \u2013 1 loops, so we get n 2 \u2013 3 n + 2 steps total. But the largest factor, or dominant term, is n 2 , as n gets larger and larger, so we can say that bubble sort is O ( n 2 ). Worst-case scenario : The array is in rever order; we have to \"bubble\" each of the n elements all the way across the array, and since we can only fully bubble one element into position per pass, we must do this n times. Best-case scenario : The array is already perfectly sorted, and we make no swaps on the first pass. We\u2019ve seen running times like the following, and so even though binary search is much faster than linear search, it might not be worth the one\u2013time cost of sorting the list first, unless we do lots of searches over time: O( n 2 ) (bubble sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) And \u03a9 for bubble sort is still n 2 , since we still check each pair of elements for n \u2013 1 passes. Selection Sort In selection sort, the idea of the algorithm is to find the smallest unsorted element and add it to the end of the sorted list. This basically builds a sorted list, one element at a time. We can take another approach with the same set of numbers: 6 3 8 5 2 7 4 1 First, we\u2019ll look at each number, and remember the smallest one we\u2019ve seen. Then, we can swap it with the first number in our list, since we know it\u2019s the smallest: 6 3 8 5 2 7 4 1 1 3 8 5 2 7 4 6 Now we know at least the first element of our list is in the right place, so we can look for the smallest element among the rest, and swap it with the next unsorted element (now the second element): 1 3 8 5 2 7 4 6 1 2 8 5 3 7 4 6 We can repeat this over and over, until we have a sorted list. The pseudocode for this might look like: For i from 0 to n\u20131 Find smallest item between i'th item and last item Swap smallest item with i'th item With big O notation, we still have running time of O ( n 2 ), since we were looking at roughly all n elements to find the smallest, and making n passes to sort all the elements. Worst-case scenario : We have to iterate over each of the n elements of the array (to find the smallest unsorted element) and we must repeat this process n times, since only one element gets sorted on each pass. Best-case scenario : Exactly the same! There's no way to gurantee this array is sorted until we go through this process for all the elements. So it turns out that selection sort is fundamentally about the same as bubble sort in running time: O( n 2 ) (bubble sort, selection sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) The best case, \u03a9, is also n 2 . We can go back to bubble sort and change its algorithm to be something like this, which will allow us to stop early if all the elements are sorted: Repeat until no swaps For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Now, we only need to look at each element once, so the best case is now \u03a9( n ): \u03a9(n 2 ) (selection sort) \u03a9( n log n ) \u03a9( n ) (bubble sort) \u03a9(log n ) \u03a9(1) (linear search, binary search) Insertion Sort In insertion sort, the idea of the algorithm is to build your sorted array in place, shifting elements out of the way if necessary to make room as you go. This is different to bubble sort and selection sort, where we slide actually slide elements out of the way while sorting. In pseudo code: Call the first element of the array \"sorted\". Repeat until all elements are sorted: Look at the next unsorted element. Insert into the \"sorted\" portion by shifting the requisite number of elements. Worst-case scenario : The array is in reverse order; we have to shift each of the n elements n positions each time we make an insertion. Best-case scenario : The array is already perfectly sorted, and we simply keep moving the line between \"unsorted\" and \"sorted\" as we examine each element. Insertion sort can be seen as: O( n 2 ) and \u03a9( n ). We can use a visualization tool, found here , with animations for how the elements move within arrays for both bubble sort and insertion sort. Recursion Recall that in week 0, we had pseudocode for finding a name in a phone book, where we had lines telling us to \u201cgo back\u201d and repeat some steps: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 Open to middle of left half of book 8 **Go back to line 3** 9 Else if Smith is later in book 10 Open to middle of right half of book 11 **Go back to line 3** 12 Else 13 Quit We could instead just repeat our entire algorithm on the half of the book we have left: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 **Search left half of book** 8 Else if Smith is later in book 9 **Search right half of book** 10 Else 11 Quit This seems like a cyclical process that will never end, but we\u2019re actually dividing the problem in half each time, and stopping once there\u2019s no more book left. Recursion occurs when a function or algorithm refers to itself (references its own name in the code), as in the new pseudocode above. Let's try to visualize this with simple code. The factorial function ( n !) is defined over all positive integers. n ! equals all of the positive integers less than or equal to n , multiplied together. Thinking in terms programming, we'll define the mathematical function n ! as fact(n) . fact(1) = 1 fact(2) = 2 * 1 fact(3) = 3 * 2 * 1 fact(4) = 4 * 3 * 2 * 1 ... This can also be seen as: fact(1) = 1 fact(2) = 2 * fact(1) fact(3) = 3 * fact(2) fact(4) = 4 * fact(3) ... This can be seen as fact(n) = n * fact(n-1) . This forms the basis for a recusive definition of the factorial function. Every recursive function has two cases that could apply, given any input: The base case , which when triggered will terminate the recursive process. The recursive case , which is where the recursion will actually occur. We can see this in the following code: //recursive version int fact ( int n ) { if ( n == 1 ) // base case { return 1 ; } else // recursive case { return n * fact ( n - 1 ); } } In general, but not always, recursive functions replace loops in non-recursive functions: Below is the iterative version of the same code above (notice how much simpler the recursive version is). //iterative version int fact2 ( int n ) { int product = 1 ; while w ( n > 0 ) { product *= n ; n -- ; } return product ; } In week 1, we implemented a \u201cpyramid\u201d of blocks in the following shape : # ## ### #### This was the code we created for that problem set: #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // Draw pyramid of height h for ( int i = 1 ; i <= h ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } } Here, we use for loops to print each block in each row. But notice that a pyramid of height 4 is actually a pyramid of height 3, with an extra row of 4 blocks added on. And a pyramid of height 3 is a pyramid of height 2, with an extra row of 3 blocks. A pyramid of height 2 is a pyramid of height 1, with an extra row of 2 blocks. And finally, a pyramid of height 1 is just a pyramid of height 0, or nothing, with another row of a single block added on. With this idea in mind, we can write: #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // If nothing to draw if ( h == 0 ) { return ; } // Draw pyramid of height h - 1 draw ( h - 1 ); // Notice how we are referring to itself (draw) within the code // Draw one more row of width h for ( int i = 0 ; i < h ; i ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } Now, our draw function first calls itself recursively , drawing a pyramid of height h - 1 . But even before that, we need to stop if h is 0, since there won\u2019t be anything left to drawn. After, we draw the next row, or a row of width h . Merge Sort In merge sort, the idea of the algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order. We can take the idea of recusion to sorting, with another algorithm called merge sort. The pseudocode might look like: If only one item Return Else Sort left half of items (assuming n > 1) Sort right half of items (assuming n > 1) Merge sorted halves We will use an unsorted list to demonstrate merge sorting: 7 4 5 2 6 3 8 1 First, we'll sort the left half (the first four elements): 7 4 5 2 | 6 3 8 1 - - - - Well, to sort that, we need to sort the left half of the left half first: 7 4 | 5 2 | 6 3 8 1 - - Now, we have just one item, 7 , in the left half, and one item, 4 , in the right half. So we\u2019ll merge that together, by taking the smallest item from each list first: - - | 5 2 | 6 3 8 1 4 7 And now we go back to the right half of the left half, and sort it: - - | - - | 6 3 8 1 4 7 2 5 Now, both halves of the left half are sorted, so we can merge the two of them together. We look at the start of each list, and take 2 since it\u2019s smaller than 4 . Then, we take 4 , since it\u2019s now the smallest item at the front of both lists. Then, we take 5 , and finally, 7 , to get: - - - - | 6 3 8 1 - - - - 2 4 5 7 Next, we do the same thing for the right half of numbers and end up with: - - - - | - - - - - - - - - - - - 2 4 5 7 1 3 6 8 And finally, we can merge both halves of the whole list, following the same steps as before. Notice that we don\u2019t need to check all the elements of each half to find the smallest, since we know that each half is already sorted. Instead, we just take the smallest element of the two at the start of each half. It took a lot of steps, but it actually took fewer steps than the other algorithms we\u2019ve seen so far. We broke our list in half each time, until we were \u201csorting\u201d eight lists with one element each. Since our algorithm divided the problem in half each time, its running time is logarithmic with O(log n). And after we sorted each half (or half of a half), we needed to merge together all the elements, with n steps since we had to look at each element once. Worst-case scenario : We have to split n elements up and then recombine them, effectively doubling the sorted subarrays as we build them. (Combining sorted 1-element arrays into 2-element arrays, combining soorted 2-element arrays into 4-element arrays...) - O ( n log n ). Best-case scenario : The array is already perfectly sorted. But we still have to split and recombine it back together with this algorithm. - \u03a9( n log n ). So our total running time is O ( n log n ): O( n 2 ) (bubble sort, selection sort) O( n log n ) (merge search) O( n ) (linear search) O(log n ) (binary search) O(1) To see this in real time, watch this video to see multiple sorting algorithms running at the same time. Algorithms Summary Algorithm Name Basic Concept O \u03a9 Selection Sort Find the smallest unsorted element in an array and swap it with the first unsorted element of that array. n 2 n 2 Bubble Sort Swap adjacent pairs of elements if they are out of order, effectively \"bubbling\" larger elements to the right and smaller ones to the left. n 2 n Insertion Sort Proceed through the array from left-to-right, shifting elements as necessary to insert each element into its correct place. n 2 n Merge Sort Split the full array into subarrays, then merge those subarrays back together in the correct order. n log n n log n Linear Search Iterate across the array from left-to-right, trying to find the target element. n 1 Binary Search Given a sorted array, divide and conquer by systematically eliminating half of the remaining elements in the search for the target element. log n 1 Algorithm Problems To see the problem sets for the covered algorithms, please click here .","title":"Algorithm Overview"},{"location":"c-algorithms/#algorithms","text":"An algorithm is step-by-step set of instructions for completing a task.","title":"Algorithms"},{"location":"c-algorithms/#searching","text":"In computer science, a search algorithm is any algorithm which solves the search problem, namely, to retrieve information stored within some data structure, or calculates in the search space of a problem domain, either with discrete or continuous values. For now, we are going to go over two different types of searches: Linear Search Binary Search For the following examples, we are going to be using a row of lockers with numbers inside (an array) and we will look through them to find something, while returning a boolean ( true or false ) as a result. A linear search is where we move in a line (usually start to end or end to start). The idea of the algorithm is to iterate across the array from left to right, searching for a specified element. Worst-case scenario : We have to look through the entire array of n elements, either because the target element is the last element of the array or doesn't exist in the array at all. Best-case scenario : The target element is the first element of the array, and so we can stop looking immediately after we start. Now lets look through the lockers to find one with the number 50 inside. Some pseudocode for linear search could be written as: For i from 0 to n\u20131 // from start (0) to end (n-1) If i'th element is 50 Return true // if the i'th element is 50 - return true Return false // if not 50, return false A binary search is where we start in the middle and move left or right, depending on what we're looking for. \"Divide & Conquer\". In order to leverage the power of binary search, our array must be sorted , else we cannot make assumptions about the array's content. Worst-case scenario : We have to divide a list of n elements in half repeatedly to find the target element, either because the target element will be found at the end of the last division or doesn't exist in the array at all. Best-case scenario : The target element is at the midpoint of the full array, and so we can stop looking immediately after we start. Some pseudocode for binary search could be written as: If no items Return false If middle item is 50 Return true Else if 50 < middle item Search left half Else if 50 > middle item Search right half","title":"Searching"},{"location":"c-algorithms/#big-o","text":"Computer scientists have created a way to describe algorithms (how well it is designed), and it's generally called big O . The more formal way to describe this is with big O notation, which we can think of as \u201con the order of\u201d. For example, if our algorithm is linear search, it will take approximately O( n ) steps, \u201con the order of n \u201d. In fact, even an algorithm that looks at two items at a time and takes n /2 steps has O( n ). This is because, as n gets bigger and bigger, only the largest term, n , matters. There are some common running times (how many seconds does it take, how many steps does it take, etc.): (lower is better) O( n 2 ) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) Computer scientists might also use big \u03a9, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big O is the upper bound of number of steps, or the worst case, and typically what we care about more.) With linear search, for example, the worst case is n steps, but the best case is 1 step since our item might happen to be the first item we check. The best case for binary search, too, is 1 since our item might be in the middle of the array. And we have a similar set of the most common big \u03a9 running times: (lower is better) \u03a9(n2) \u03a9(n log n) \u03a9(n) (counting the number of items) \u03a9(log n) \u03a9(1) (linear search, binary search)","title":"Big O"},{"location":"c-algorithms/#linear-search","text":"Now let's create a program to better visualize a lienar search: #include <cs50.h> #include <stdio.h> int main ( void ) { int numbers [ 6 ] = { 4 , 8 , 15 , 16 , 23 , 42 }; for ( int i = 0 ; i < 6 ; i ++ ) { if ( numbers [ i ] == 50 ) { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Here we initialize an array with some values, and we check the items in the array one at a time, in order. And in each case, depending on whether the value was found or not, we can return an exit code of either 0 (for success) or 1 (for failure). We can do the same for names: #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma is the name we're looking for. note the use of strcmp { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can\u2019t compare strings directly, since they\u2019re not a simple data type but rather an array of many characters, and we need to compare them differently. Luckily, the string library has a strcmp function which compares strings for us and returns 0 if they\u2019re the same, so we can use that. Now lets implement a phone book with the same ideas: #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; string numbers [ 4 ] = { \"617\u2013555\u20130100\" , \"617\u2013555\u20130101\" , \"617\u2013555\u20130102\" , \"617\u2013555\u20130103\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma's phone number is what we're looking for { printf ( \"Found %s \\n \" , numbers [ i ]); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Now, if the name at a certain index in the names array matches who we\u2019re looking for, we\u2019ll return the phone number in the numbers array, at the same index. But that means we need to particularly careful to make sure that each number corresponds to the name at each index, especially if we add or remove names and numbers. Let's improve the above code using our own custom data type!","title":"Linear Search"},{"location":"c-algorithms/#structs","text":"We can make our own custom data types called structs : #include <cs50.h> #include <stdio.h> #include <string.h> typedef struct { string name ; string number ; } person ; // we are encapsulating both the strings name and number inside our struct \"person\" int main ( void ) { person people [ 4 ]; people [ 0 ]. name = \"EMMA\" ; people [ 0 ]. number = \"617\u2013555\u20130100\" ; people [ 1 ]. name = \"RODRIGO\" ; people [ 1 ]. number = \"617\u2013555\u20130101\" ; people [ 2 ]. name = \"BRIAN\" ; people [ 2 ]. number = \"617\u2013555\u20130102\" ; people [ 3 ]. name = \"DAVID\" ; people [ 3 ]. number = \"617\u2013555\u20130103\" ; // Search for EMMA for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( people [ i ]. name , \"EMMA\" ) == 0 ) { printf ( \"Found %s \\n \" , people [ i ]. number ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can think of structs as containers, inside of which are multiple other data types. Here, we create our own type with a struct called person , which will have a string called name and a string called number . Then, we can create an array of these struct types and initialize the values inside each of them, using a new syntax, . , to access the properties of each person . In our loop, we can now be more certain that the number corresponds to the name since they are from the same person element.","title":"Structs"},{"location":"c-algorithms/#sorting","text":"The process of Sorting can be explained as a technique of rearranging the elements in any particular order, which can be set ready for further processing by the program logic. In C, there are multiple sorting algorithms available, which can be incorporated inside the code.","title":"Sorting"},{"location":"c-algorithms/#bubble-sort","text":"In bubble stort, the idea of the algorithm is to move higher valued elements generally towards the right and lower value elements generally towards the left. Let's take 8 random numbers ( 6 , 3 , 8 , 5 , 2 , 7 , 4 , 1 ) and try to sort them in C. First, we can look at the first two numbers and swap them so they are in order: 6 3 8 5 2 7 4 1 3 6 8 5 2 7 4 1 The next pair, 6 and 8 , are in order, so we don\u2019t need to swap them. The next pair, 8 and 5 , need to be swapped: 3 6 8 5 2 7 4 1 3 6 5 8 2 7 4 1 We continue until we reach the end of the list: 3 6 5 8 2 7 4 1 3 6 5 2 8 7 4 1 3 6 5 2 7 8 4 1 3 6 5 2 7 4 8 1 3 6 5 2 7 4 1 8 Our list isn\u2019t sorted yet, but we\u2019re slightly closer to the solution because the biggest value, 8 , has been shifted all the way to the right. We repeat this with another pass through the list, over and over, until it is sorted correctly. The pseudocode for this might look like: Repeat n\u20131 times For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Since we are comparing the i'th and i+1'th element, we only need to go up to n \u2013 2 for i . Then, we swap the two elements if they\u2019re out of order. And we can stop after we\u2019ve made n \u2013 1 passes, since we know the largest n \u20131 elements will have bubbled to the right. We have n \u2013 2 steps for the inner loop, and n \u2013 1 loops, so we get n 2 \u2013 3 n + 2 steps total. But the largest factor, or dominant term, is n 2 , as n gets larger and larger, so we can say that bubble sort is O ( n 2 ). Worst-case scenario : The array is in rever order; we have to \"bubble\" each of the n elements all the way across the array, and since we can only fully bubble one element into position per pass, we must do this n times. Best-case scenario : The array is already perfectly sorted, and we make no swaps on the first pass. We\u2019ve seen running times like the following, and so even though binary search is much faster than linear search, it might not be worth the one\u2013time cost of sorting the list first, unless we do lots of searches over time: O( n 2 ) (bubble sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) And \u03a9 for bubble sort is still n 2 , since we still check each pair of elements for n \u2013 1 passes.","title":"Bubble Sort"},{"location":"c-algorithms/#selection-sort","text":"In selection sort, the idea of the algorithm is to find the smallest unsorted element and add it to the end of the sorted list. This basically builds a sorted list, one element at a time. We can take another approach with the same set of numbers: 6 3 8 5 2 7 4 1 First, we\u2019ll look at each number, and remember the smallest one we\u2019ve seen. Then, we can swap it with the first number in our list, since we know it\u2019s the smallest: 6 3 8 5 2 7 4 1 1 3 8 5 2 7 4 6 Now we know at least the first element of our list is in the right place, so we can look for the smallest element among the rest, and swap it with the next unsorted element (now the second element): 1 3 8 5 2 7 4 6 1 2 8 5 3 7 4 6 We can repeat this over and over, until we have a sorted list. The pseudocode for this might look like: For i from 0 to n\u20131 Find smallest item between i'th item and last item Swap smallest item with i'th item With big O notation, we still have running time of O ( n 2 ), since we were looking at roughly all n elements to find the smallest, and making n passes to sort all the elements. Worst-case scenario : We have to iterate over each of the n elements of the array (to find the smallest unsorted element) and we must repeat this process n times, since only one element gets sorted on each pass. Best-case scenario : Exactly the same! There's no way to gurantee this array is sorted until we go through this process for all the elements. So it turns out that selection sort is fundamentally about the same as bubble sort in running time: O( n 2 ) (bubble sort, selection sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) The best case, \u03a9, is also n 2 . We can go back to bubble sort and change its algorithm to be something like this, which will allow us to stop early if all the elements are sorted: Repeat until no swaps For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Now, we only need to look at each element once, so the best case is now \u03a9( n ): \u03a9(n 2 ) (selection sort) \u03a9( n log n ) \u03a9( n ) (bubble sort) \u03a9(log n ) \u03a9(1) (linear search, binary search)","title":"Selection Sort"},{"location":"c-algorithms/#insertion-sort","text":"In insertion sort, the idea of the algorithm is to build your sorted array in place, shifting elements out of the way if necessary to make room as you go. This is different to bubble sort and selection sort, where we slide actually slide elements out of the way while sorting. In pseudo code: Call the first element of the array \"sorted\". Repeat until all elements are sorted: Look at the next unsorted element. Insert into the \"sorted\" portion by shifting the requisite number of elements. Worst-case scenario : The array is in reverse order; we have to shift each of the n elements n positions each time we make an insertion. Best-case scenario : The array is already perfectly sorted, and we simply keep moving the line between \"unsorted\" and \"sorted\" as we examine each element. Insertion sort can be seen as: O( n 2 ) and \u03a9( n ). We can use a visualization tool, found here , with animations for how the elements move within arrays for both bubble sort and insertion sort.","title":"Insertion Sort"},{"location":"c-algorithms/#recursion","text":"Recall that in week 0, we had pseudocode for finding a name in a phone book, where we had lines telling us to \u201cgo back\u201d and repeat some steps: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 Open to middle of left half of book 8 **Go back to line 3** 9 Else if Smith is later in book 10 Open to middle of right half of book 11 **Go back to line 3** 12 Else 13 Quit We could instead just repeat our entire algorithm on the half of the book we have left: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 **Search left half of book** 8 Else if Smith is later in book 9 **Search right half of book** 10 Else 11 Quit This seems like a cyclical process that will never end, but we\u2019re actually dividing the problem in half each time, and stopping once there\u2019s no more book left. Recursion occurs when a function or algorithm refers to itself (references its own name in the code), as in the new pseudocode above. Let's try to visualize this with simple code. The factorial function ( n !) is defined over all positive integers. n ! equals all of the positive integers less than or equal to n , multiplied together. Thinking in terms programming, we'll define the mathematical function n ! as fact(n) . fact(1) = 1 fact(2) = 2 * 1 fact(3) = 3 * 2 * 1 fact(4) = 4 * 3 * 2 * 1 ... This can also be seen as: fact(1) = 1 fact(2) = 2 * fact(1) fact(3) = 3 * fact(2) fact(4) = 4 * fact(3) ... This can be seen as fact(n) = n * fact(n-1) . This forms the basis for a recusive definition of the factorial function. Every recursive function has two cases that could apply, given any input: The base case , which when triggered will terminate the recursive process. The recursive case , which is where the recursion will actually occur. We can see this in the following code: //recursive version int fact ( int n ) { if ( n == 1 ) // base case { return 1 ; } else // recursive case { return n * fact ( n - 1 ); } } In general, but not always, recursive functions replace loops in non-recursive functions: Below is the iterative version of the same code above (notice how much simpler the recursive version is). //iterative version int fact2 ( int n ) { int product = 1 ; while w ( n > 0 ) { product *= n ; n -- ; } return product ; } In week 1, we implemented a \u201cpyramid\u201d of blocks in the following shape : # ## ### #### This was the code we created for that problem set: #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // Draw pyramid of height h for ( int i = 1 ; i <= h ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } } Here, we use for loops to print each block in each row. But notice that a pyramid of height 4 is actually a pyramid of height 3, with an extra row of 4 blocks added on. And a pyramid of height 3 is a pyramid of height 2, with an extra row of 3 blocks. A pyramid of height 2 is a pyramid of height 1, with an extra row of 2 blocks. And finally, a pyramid of height 1 is just a pyramid of height 0, or nothing, with another row of a single block added on. With this idea in mind, we can write: #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // If nothing to draw if ( h == 0 ) { return ; } // Draw pyramid of height h - 1 draw ( h - 1 ); // Notice how we are referring to itself (draw) within the code // Draw one more row of width h for ( int i = 0 ; i < h ; i ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } Now, our draw function first calls itself recursively , drawing a pyramid of height h - 1 . But even before that, we need to stop if h is 0, since there won\u2019t be anything left to drawn. After, we draw the next row, or a row of width h .","title":"Recursion"},{"location":"c-algorithms/#merge-sort","text":"In merge sort, the idea of the algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order. We can take the idea of recusion to sorting, with another algorithm called merge sort. The pseudocode might look like: If only one item Return Else Sort left half of items (assuming n > 1) Sort right half of items (assuming n > 1) Merge sorted halves We will use an unsorted list to demonstrate merge sorting: 7 4 5 2 6 3 8 1 First, we'll sort the left half (the first four elements): 7 4 5 2 | 6 3 8 1 - - - - Well, to sort that, we need to sort the left half of the left half first: 7 4 | 5 2 | 6 3 8 1 - - Now, we have just one item, 7 , in the left half, and one item, 4 , in the right half. So we\u2019ll merge that together, by taking the smallest item from each list first: - - | 5 2 | 6 3 8 1 4 7 And now we go back to the right half of the left half, and sort it: - - | - - | 6 3 8 1 4 7 2 5 Now, both halves of the left half are sorted, so we can merge the two of them together. We look at the start of each list, and take 2 since it\u2019s smaller than 4 . Then, we take 4 , since it\u2019s now the smallest item at the front of both lists. Then, we take 5 , and finally, 7 , to get: - - - - | 6 3 8 1 - - - - 2 4 5 7 Next, we do the same thing for the right half of numbers and end up with: - - - - | - - - - - - - - - - - - 2 4 5 7 1 3 6 8 And finally, we can merge both halves of the whole list, following the same steps as before. Notice that we don\u2019t need to check all the elements of each half to find the smallest, since we know that each half is already sorted. Instead, we just take the smallest element of the two at the start of each half. It took a lot of steps, but it actually took fewer steps than the other algorithms we\u2019ve seen so far. We broke our list in half each time, until we were \u201csorting\u201d eight lists with one element each. Since our algorithm divided the problem in half each time, its running time is logarithmic with O(log n). And after we sorted each half (or half of a half), we needed to merge together all the elements, with n steps since we had to look at each element once. Worst-case scenario : We have to split n elements up and then recombine them, effectively doubling the sorted subarrays as we build them. (Combining sorted 1-element arrays into 2-element arrays, combining soorted 2-element arrays into 4-element arrays...) - O ( n log n ). Best-case scenario : The array is already perfectly sorted. But we still have to split and recombine it back together with this algorithm. - \u03a9( n log n ). So our total running time is O ( n log n ): O( n 2 ) (bubble sort, selection sort) O( n log n ) (merge search) O( n ) (linear search) O(log n ) (binary search) O(1) To see this in real time, watch this video to see multiple sorting algorithms running at the same time.","title":"Merge Sort"},{"location":"c-algorithms/#algorithms-summary","text":"Algorithm Name Basic Concept O \u03a9 Selection Sort Find the smallest unsorted element in an array and swap it with the first unsorted element of that array. n 2 n 2 Bubble Sort Swap adjacent pairs of elements if they are out of order, effectively \"bubbling\" larger elements to the right and smaller ones to the left. n 2 n Insertion Sort Proceed through the array from left-to-right, shifting elements as necessary to insert each element into its correct place. n 2 n Merge Sort Split the full array into subarrays, then merge those subarrays back together in the correct order. n log n n log n Linear Search Iterate across the array from left-to-right, trying to find the target element. n 1 Binary Search Given a sorted array, divide and conquer by systematically eliminating half of the remaining elements in the search for the target element. log n 1","title":"Algorithms Summary"},{"location":"c-algorithms/#algorithm-problems","text":"To see the problem sets for the covered algorithms, please click here .","title":"Algorithm Problems"},{"location":"c-arrays/","text":"Arrays What are Arrays? Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you. Array Declarations \u2003\u2003 type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages. Basic Array Program Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average). Other Array Tips Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything. Reading Levels Program According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); } Caesar's Cipher We will now create a program that will take text and run it through Caesar's encryption method. Supposedly, Caesar (yes, that Caesar) used to \u201cencrypt\u201d (i.e., conceal in a reversible way) confidential messages by shifting each letter therein by some number of places. For instance, he might write A as B, B as C, C as D, \u2026, and, wrapping around alphabetically, Z as A. And so, to say HELLO to someone, Caesar might write IFMMP. Upon receiving such messages from Caesar, recipients would have to \u201cdecrypt\u201d them by shifting letters in the opposite direction by the same number of places. The secrecy of this \u201ccryptosystem\u201d relied on only Caesar and the recipients knowing a secret, the number of places by which Caesar had shifted his letters (e.g., 1). Not particularly secure by modern standards, but, hey, if you\u2019re perhaps the first in the world to do it, pretty secure! Note Unencrypted text is generally called plaintext . Encrypted text is generally called ciphertext . And the secret used is called a key . To be clear, then, here\u2019s how encrypting HELLO with a key of 1 yields IFMMP : plaintext H E L L O + key 1 1 1 1 1 = ciphertext I F M M P More formally, Caesar\u2019s algorithm (i.e., cipher) encrypts messages by \u201crotating\u201d each letter by k positions. More formally, if p is some plaintext (i.e., an unencrypted message), p i is the i th character in p , and k is a secret key (i.e., a non-negative integer), then each letter, c i , in the ciphertext, c , is computed as: c i = (p i + k) % 26 wherein % 26 here means \u201cremainder when dividing by 26.\u201d This formula perhaps makes the cipher seem more complicated than it is, but it\u2019s really just a concise way of expressing the algorithm precisely. Indeed, for the sake of discussion, think of A (or a) as 0, B (or b) as 1, \u2026, H (or h) as 7, I (or i) as 8, \u2026, and Z (or z) as 25. Suppose that Caesar just wants to say Hi to someone confidentially using, this time, a key, k , of 3. And so his plaintext, p , is Hi, in which case his plaintext\u2019s first character, p 0 , is H (aka 7), and his plaintext\u2019s second character, p 1 , is i (aka 8). His ciphertext\u2019s first character, c 0 , is thus K, and his ciphertext\u2019s second character, c 1 , is thus L. Can you see why? Here are a few examples of how the program might work. For example, if the user inputs a key of 1 and a plaintext of HELLO : $ ./caesar 1 plaintext: HELLO ciphertext: IFMMP Here\u2019s how the program might work if the user provides a key of 13 and a plaintext of hello, world : $ ./caesar 13 plaintext: hello, world ciphertext: uryyb, jbeyq Now let's get coding! We need our program to do the following: Get Key (the amount to shift the text by) Get plaintext Encipher Print ciphertext Note We will preserve case for letters (Keep capital letters capital, and lowercase lowercase). We will also wrap the alphabet (If we go beyond the boundaries of the alphabet, it will just start over). Let's walkthrough each piece of the program. Get the Key We will be taking the key as a command line argument : $ ./caesar 3 Remember that in C our main function can take arguments using the following: int main ( int argc , string argv []) { // code here } Getting the Key Ensure single command-line argument (print error message if command-line argument is out of bounds) Make sure argument contains only digit characters Convert argument to an integer We will also need to convert the string from the command line argument into a number using the atoi function, declared in <stdlib.h> . Getting the Plaintext We will simply use the get_string function to get user input for the plaintext. Encipher the Plaintext If it's alphabetic, shift the plaintext character by key, preserving the case. If it's not alphabetic, leave the character as-is. We can use the following functions to help us identify character type: isalpha , isupper , and islower . These functions will return a boolean value ( true or false ). Here is the correct program: #include <stdio.h> #include <cs50.h> #include <stdlib.h> #include <string.h> #include <ctype.h> bool check_key ( string s ); int main ( int argc , string argv []) //argc takes in the number of arguments and argv creates an array for the arguments themselves. { if ( argc != 2 || ! check_key ( argv [ 1 ])) // checking if the number of arguments is not 2 and if the key is valid { printf ( \"Usage: ./caesar key\" ); // if the input is not valid, it will print an error message with the correct way to enter return 1 ; } int key = atoi ( argv [ 1 ]); // converts from ASCII to integer string plaintext = get_string ( \"plaintext: \" ); printf ( \"ciphertext: \" ); for ( int i = 0 , len = strlen ( plaintext ); i < len ; i ++ ) { char c = plaintext [ i ]; if ( isalpha ( c )) { char m = 'A' ; if ( islower ( c )) m = 'a' ; printf ( \"%c\" , ( c - m + key ) % 26 + m ); // inputs the plaintext into Caesar's cipher } else printf ( \"%c\" , c ); // if the character is not alphabetic, it will print it as is } printf ( \" \\n \" ); } bool check_key ( string s ) // this string checks to see if the key is valid { for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) if ( ! isdigit ( s [ i ])) // if its not a digit, return false return false ; return true ; }","title":"Arrays"},{"location":"c-arrays/#arrays","text":"","title":"Arrays"},{"location":"c-arrays/#what-are-arrays","text":"Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you.","title":"What are Arrays?"},{"location":"c-arrays/#array-declarations","text":"type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages.","title":"Array Declarations"},{"location":"c-arrays/#basic-array-program","text":"Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average).","title":"Basic Array Program"},{"location":"c-arrays/#other-array-tips","text":"Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything.","title":"Other Array Tips"},{"location":"c-arrays/#reading-levels-program","text":"According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); }","title":"Reading Levels Program"},{"location":"c-arrays/#caesars-cipher","text":"We will now create a program that will take text and run it through Caesar's encryption method. Supposedly, Caesar (yes, that Caesar) used to \u201cencrypt\u201d (i.e., conceal in a reversible way) confidential messages by shifting each letter therein by some number of places. For instance, he might write A as B, B as C, C as D, \u2026, and, wrapping around alphabetically, Z as A. And so, to say HELLO to someone, Caesar might write IFMMP. Upon receiving such messages from Caesar, recipients would have to \u201cdecrypt\u201d them by shifting letters in the opposite direction by the same number of places. The secrecy of this \u201ccryptosystem\u201d relied on only Caesar and the recipients knowing a secret, the number of places by which Caesar had shifted his letters (e.g., 1). Not particularly secure by modern standards, but, hey, if you\u2019re perhaps the first in the world to do it, pretty secure! Note Unencrypted text is generally called plaintext . Encrypted text is generally called ciphertext . And the secret used is called a key . To be clear, then, here\u2019s how encrypting HELLO with a key of 1 yields IFMMP : plaintext H E L L O + key 1 1 1 1 1 = ciphertext I F M M P More formally, Caesar\u2019s algorithm (i.e., cipher) encrypts messages by \u201crotating\u201d each letter by k positions. More formally, if p is some plaintext (i.e., an unencrypted message), p i is the i th character in p , and k is a secret key (i.e., a non-negative integer), then each letter, c i , in the ciphertext, c , is computed as: c i = (p i + k) % 26 wherein % 26 here means \u201cremainder when dividing by 26.\u201d This formula perhaps makes the cipher seem more complicated than it is, but it\u2019s really just a concise way of expressing the algorithm precisely. Indeed, for the sake of discussion, think of A (or a) as 0, B (or b) as 1, \u2026, H (or h) as 7, I (or i) as 8, \u2026, and Z (or z) as 25. Suppose that Caesar just wants to say Hi to someone confidentially using, this time, a key, k , of 3. And so his plaintext, p , is Hi, in which case his plaintext\u2019s first character, p 0 , is H (aka 7), and his plaintext\u2019s second character, p 1 , is i (aka 8). His ciphertext\u2019s first character, c 0 , is thus K, and his ciphertext\u2019s second character, c 1 , is thus L. Can you see why? Here are a few examples of how the program might work. For example, if the user inputs a key of 1 and a plaintext of HELLO : $ ./caesar 1 plaintext: HELLO ciphertext: IFMMP Here\u2019s how the program might work if the user provides a key of 13 and a plaintext of hello, world : $ ./caesar 13 plaintext: hello, world ciphertext: uryyb, jbeyq Now let's get coding! We need our program to do the following: Get Key (the amount to shift the text by) Get plaintext Encipher Print ciphertext Note We will preserve case for letters (Keep capital letters capital, and lowercase lowercase). We will also wrap the alphabet (If we go beyond the boundaries of the alphabet, it will just start over). Let's walkthrough each piece of the program. Get the Key We will be taking the key as a command line argument : $ ./caesar 3 Remember that in C our main function can take arguments using the following: int main ( int argc , string argv []) { // code here } Getting the Key Ensure single command-line argument (print error message if command-line argument is out of bounds) Make sure argument contains only digit characters Convert argument to an integer We will also need to convert the string from the command line argument into a number using the atoi function, declared in <stdlib.h> . Getting the Plaintext We will simply use the get_string function to get user input for the plaintext. Encipher the Plaintext If it's alphabetic, shift the plaintext character by key, preserving the case. If it's not alphabetic, leave the character as-is. We can use the following functions to help us identify character type: isalpha , isupper , and islower . These functions will return a boolean value ( true or false ). Here is the correct program: #include <stdio.h> #include <cs50.h> #include <stdlib.h> #include <string.h> #include <ctype.h> bool check_key ( string s ); int main ( int argc , string argv []) //argc takes in the number of arguments and argv creates an array for the arguments themselves. { if ( argc != 2 || ! check_key ( argv [ 1 ])) // checking if the number of arguments is not 2 and if the key is valid { printf ( \"Usage: ./caesar key\" ); // if the input is not valid, it will print an error message with the correct way to enter return 1 ; } int key = atoi ( argv [ 1 ]); // converts from ASCII to integer string plaintext = get_string ( \"plaintext: \" ); printf ( \"ciphertext: \" ); for ( int i = 0 , len = strlen ( plaintext ); i < len ; i ++ ) { char c = plaintext [ i ]; if ( isalpha ( c )) { char m = 'A' ; if ( islower ( c )) m = 'a' ; printf ( \"%c\" , ( c - m + key ) % 26 + m ); // inputs the plaintext into Caesar's cipher } else printf ( \"%c\" , c ); // if the character is not alphabetic, it will print it as is } printf ( \" \\n \" ); } bool check_key ( string s ) // this string checks to see if the key is valid { for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) if ( ! isdigit ( s [ i ])) // if its not a digit, return false return false ; return true ; }","title":"Caesar's Cipher"},{"location":"c-cl-arguments/","text":"Command Line Arugments Overview Command Line Arguments So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc - 1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-cl-arguments/#command-line-arugments-overview","text":"","title":"Command Line Arugments Overview"},{"location":"c-cl-arguments/#command-line-arguments","text":"So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc - 1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-data-structures/","text":"Data Structures Pointers In the memory notes, we learned about pointers, malloc , and other useful tools for working with memory. Let's review the following snipped of code: int main ( void ) { int * x ; int * y ; x = malloc ( sizeof ( int )); * x = 42 ; * y = 13 ; } Here, the first two lines of code in our main function are declaring two pointers, x and y . Then, we allocate enough memory for an int with malloc , and stores the address returned by malloc into x . With *x = 42; , we got to the address pointed to by x , and stores the value of 42 into that location. The final line, though, is buggy since we don't know what the value of y is, since we never set a value for it. Instead , we can write: y = x ; * y = 13 ; For a more fun way to understand the above, take a look at the short clip, Pointer Fun with Blinky . Resizing arrays In the arrays notes, we learned about arrays, where we could store the same kind of value in a list side-by-side. But we need to declare the size of arrays when we create them, and when we want to increase the size of the array, the memory surrounding it might be taken up by some other data. One solution might be to allocate more memory in a larger area that's free, and move our array there, where it has more space. This sounds like it could work, but we'll need to copy our array, which becomes an operation with running time of O(n) , since we need to copy each of n elements in an array. We might write a program like the following, to do this in code: copy array code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <stdio.h> #include <stdlib.h> int main ( void ) { // Here, we allocate enough memory to fit three integers, and our variable // list will point to the first integer. int * list = malloc ( 3 * sizeof ( int )); // We should check that we allocated memory correctly, since malloc might // fail to get us enough free memory. if ( list == NULL ) { return 1 ; } // With this syntax, the compiler will do pointer arithmetic for us, and // calculate the byte in memory that list[0], list[1], and list[2] maps to, // since integers are 4 bytes large. list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Now, if we want to resize our array to fit 4 integers, we'll try to allocate // enough memory for them, and temporarily use tmp to point to the first: int * tmp = malloc ( 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, we copy integers from the old array into the new array ... for ( int i = 0 ; i < 3 ; i ++ ) { tmp [ i ] = list [ i ]; } // ... and add the fourth integer: tmp [ 3 ] = 4 ; // We should free the original memory for list, which is why we need a // temporary variable to point to the new array ... free ( list ); // ... and now we can set our list variable to point to the new array that // tmp points to: list = tmp ; // Now, we can print the new array: for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } // And finally, free the memory for the new array. free ( list ); } It turns out that there\u2019s actually a helpful function, realloc , which will reallocate some memory: realloc example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <stdlib.h> int main ( void ) { int * list = malloc ( 3 * sizeof ( int )); if ( list == NULL ) { return 1 ; } list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Here, we give realloc our original array that list points to, and it will // return a new address for a new array, with the old data copied over: int * tmp = realloc ( list , 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, all we need to do is remember the location of the new array: list = tmp ; list [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } free ( list ); } Data Structures Data structures are programming constructs that allow us to store information in different layouts in our computer\u2019s memory. To build a data structure, we\u2019ll need some tools we\u2019ve seen: struct to create custom data types . to access properties in structure * to go to an address in memory pointed to by a pointer Linked Lists With a linked list , we can store a list of values that can easily be grown by storing values in different parts of memory: This is different than an array since our values are no longer next to one another in memory. This uses two chunks of memory, where the second chunk is used to point at the next chunk of memory. By the way, NUL refers to \\0 , a character that ends a string, and NULL refers to an address of all zeros, or a null pointer that we can think of as pointing nowhere. These chunks are linked by the pointers in the second chunk of memory. Unlike with arrays, we no longer randomly access elements in a linked list. For example, we can no longer access the 5 th element of the list by calculating where it is, in constant time. (Since we know arrays store elements back-to-back, we can add 1, or 4, or the size of our element, to calculate addresses.) Instead, we have to follow each element\u2019s pointer, one at a time. And we need to allocate twice as much memory as we needed before for each element. In code, we might create our own struct called node (like a node from a graph in mathematics), and we need to store both an int and a pointer to the next node called next . typedef struct node { int number ; struct node * next ; } node ; // this is the nickname for struct node We start this struct with typedef struct node so that we can refer to a node inside our struct. We can build a linked list in code starting with our struct. First, we'll want to remember an empty list, so we can use the null pointer: node *list = NULL; . To add an element, first we'll need to allocate some memory for a node, and set its values: node * n = malloc ( sizeof ( node )); // We want to make sure malloc succeeded in getting memory for us: if ( n != NULL ) { // This (->) is equivalent to (*n).number, where we first go to the node pointed // to by n, and then set the number property. In C, we can also use this // arrow notation: n -> number = 2 ; // Then we need to store a pointer to the next node in our list, but the // new node won't point to anything (for now): n -> next = NULL ; } Now our list can point to this node: list = n; : To add to our lsit, we'll create a new node the same way, perhaps with the value 4. But now we need to update the pointer in our first node to point to it. since our list pointer points only to the first node (and we can't be sure that the list only has one node), we need to \"follow the breadcrumbs\" and follow each node's next pointer: // Create temporary pointer to what list is pointing to node * tmp = list ; // As long as the node has a next pointer ... while ( tmp -> next != NULL ) { // ... set the temporary to the next node tmp = tmp -> next ; } // Now, tmp points to the last node in our list, and we can update its next // pointer to point to our new node. If we want to insert a node to the front of our linked list, we would need to carefully update our node to point to the one following it, before updating the list. Otherwise, we'll lose the rest of our list: // Here, we're inserting a node into the front of the list, so we want its // next pointer to point to the original list, before pointing the list to // n: n -> next = list ; list = n ; And to insert a node in the middle of our list, we can go through the list, following each element one at a time, comparing its values, and changing the next pointers carefully as well. We can combine all of our snippets of code into a complete program: node example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include <stdio.h> #include <stdlib.h> // Represents a node typedef struct node { int number ; struct node * next ; } node ; int main ( void ) { // List of size 0, initially not pointing to anything node * list = NULL ; // Add number to list node * n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 1 ; n -> next = NULL ; // We create our first node, store the value 1 in it, and leave the next // pointer to point to nothing. Then, our list variable can point to it. list = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 2 ; n -> next = NULL ; // Now, we go our first node that list points to, and sets the next pointer // on it to point to our new node, adding it to the end of the list: list -> next = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 3 ; n -> next = NULL ; // We can follow multiple nodes with this syntax, using the next pointer // over and over, to add our third new node to the end of the list: list -> next -> next = n ; // Normally, though, we would want a loop and a temporary variable to add // a new node to our list. // Print list // Here we can iterate over all the nodes in our list with a temporary // variable. First, we have a temporary pointer, tmp, that points to the // list. Then, our condition for continuing is that tmp is not NULL, and // finally, we update tmp to the next pointer of itself. for ( node * tmp = list ; tmp != NULL ; tmp = tmp -> next ) { // Within the node, we'll just print the number stored: printf ( \"%i \\n \" , tmp -> number ); } // Free list // Since we're freeing each node as we go along, we'll use a while loop // and follow each node's next pointer before freeing it, but we'll see // this in more detail in Problem Set 5. while ( list != NULL ) { node * tmp = list -> next ; free ( list ); list = tmp ; } } More data structures A tree is another data structure where each node points to two other nodes, one to the left (with a smaller value) and one to the right (with a larger value):","title":"Data Structures"},{"location":"c-data-structures/#data-structures","text":"","title":"Data Structures"},{"location":"c-data-structures/#pointers","text":"In the memory notes, we learned about pointers, malloc , and other useful tools for working with memory. Let's review the following snipped of code: int main ( void ) { int * x ; int * y ; x = malloc ( sizeof ( int )); * x = 42 ; * y = 13 ; } Here, the first two lines of code in our main function are declaring two pointers, x and y . Then, we allocate enough memory for an int with malloc , and stores the address returned by malloc into x . With *x = 42; , we got to the address pointed to by x , and stores the value of 42 into that location. The final line, though, is buggy since we don't know what the value of y is, since we never set a value for it. Instead , we can write: y = x ; * y = 13 ; For a more fun way to understand the above, take a look at the short clip, Pointer Fun with Blinky .","title":"Pointers"},{"location":"c-data-structures/#resizing-arrays","text":"In the arrays notes, we learned about arrays, where we could store the same kind of value in a list side-by-side. But we need to declare the size of arrays when we create them, and when we want to increase the size of the array, the memory surrounding it might be taken up by some other data. One solution might be to allocate more memory in a larger area that's free, and move our array there, where it has more space. This sounds like it could work, but we'll need to copy our array, which becomes an operation with running time of O(n) , since we need to copy each of n elements in an array. We might write a program like the following, to do this in code: copy array code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <stdio.h> #include <stdlib.h> int main ( void ) { // Here, we allocate enough memory to fit three integers, and our variable // list will point to the first integer. int * list = malloc ( 3 * sizeof ( int )); // We should check that we allocated memory correctly, since malloc might // fail to get us enough free memory. if ( list == NULL ) { return 1 ; } // With this syntax, the compiler will do pointer arithmetic for us, and // calculate the byte in memory that list[0], list[1], and list[2] maps to, // since integers are 4 bytes large. list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Now, if we want to resize our array to fit 4 integers, we'll try to allocate // enough memory for them, and temporarily use tmp to point to the first: int * tmp = malloc ( 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, we copy integers from the old array into the new array ... for ( int i = 0 ; i < 3 ; i ++ ) { tmp [ i ] = list [ i ]; } // ... and add the fourth integer: tmp [ 3 ] = 4 ; // We should free the original memory for list, which is why we need a // temporary variable to point to the new array ... free ( list ); // ... and now we can set our list variable to point to the new array that // tmp points to: list = tmp ; // Now, we can print the new array: for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } // And finally, free the memory for the new array. free ( list ); } It turns out that there\u2019s actually a helpful function, realloc , which will reallocate some memory: realloc example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <stdlib.h> int main ( void ) { int * list = malloc ( 3 * sizeof ( int )); if ( list == NULL ) { return 1 ; } list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Here, we give realloc our original array that list points to, and it will // return a new address for a new array, with the old data copied over: int * tmp = realloc ( list , 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, all we need to do is remember the location of the new array: list = tmp ; list [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } free ( list ); }","title":"Resizing arrays"},{"location":"c-data-structures/#data-structures_1","text":"Data structures are programming constructs that allow us to store information in different layouts in our computer\u2019s memory. To build a data structure, we\u2019ll need some tools we\u2019ve seen: struct to create custom data types . to access properties in structure * to go to an address in memory pointed to by a pointer","title":"Data Structures"},{"location":"c-data-structures/#linked-lists","text":"With a linked list , we can store a list of values that can easily be grown by storing values in different parts of memory: This is different than an array since our values are no longer next to one another in memory. This uses two chunks of memory, where the second chunk is used to point at the next chunk of memory. By the way, NUL refers to \\0 , a character that ends a string, and NULL refers to an address of all zeros, or a null pointer that we can think of as pointing nowhere. These chunks are linked by the pointers in the second chunk of memory. Unlike with arrays, we no longer randomly access elements in a linked list. For example, we can no longer access the 5 th element of the list by calculating where it is, in constant time. (Since we know arrays store elements back-to-back, we can add 1, or 4, or the size of our element, to calculate addresses.) Instead, we have to follow each element\u2019s pointer, one at a time. And we need to allocate twice as much memory as we needed before for each element. In code, we might create our own struct called node (like a node from a graph in mathematics), and we need to store both an int and a pointer to the next node called next . typedef struct node { int number ; struct node * next ; } node ; // this is the nickname for struct node We start this struct with typedef struct node so that we can refer to a node inside our struct. We can build a linked list in code starting with our struct. First, we'll want to remember an empty list, so we can use the null pointer: node *list = NULL; . To add an element, first we'll need to allocate some memory for a node, and set its values: node * n = malloc ( sizeof ( node )); // We want to make sure malloc succeeded in getting memory for us: if ( n != NULL ) { // This (->) is equivalent to (*n).number, where we first go to the node pointed // to by n, and then set the number property. In C, we can also use this // arrow notation: n -> number = 2 ; // Then we need to store a pointer to the next node in our list, but the // new node won't point to anything (for now): n -> next = NULL ; } Now our list can point to this node: list = n; : To add to our lsit, we'll create a new node the same way, perhaps with the value 4. But now we need to update the pointer in our first node to point to it. since our list pointer points only to the first node (and we can't be sure that the list only has one node), we need to \"follow the breadcrumbs\" and follow each node's next pointer: // Create temporary pointer to what list is pointing to node * tmp = list ; // As long as the node has a next pointer ... while ( tmp -> next != NULL ) { // ... set the temporary to the next node tmp = tmp -> next ; } // Now, tmp points to the last node in our list, and we can update its next // pointer to point to our new node. If we want to insert a node to the front of our linked list, we would need to carefully update our node to point to the one following it, before updating the list. Otherwise, we'll lose the rest of our list: // Here, we're inserting a node into the front of the list, so we want its // next pointer to point to the original list, before pointing the list to // n: n -> next = list ; list = n ; And to insert a node in the middle of our list, we can go through the list, following each element one at a time, comparing its values, and changing the next pointers carefully as well. We can combine all of our snippets of code into a complete program: node example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include <stdio.h> #include <stdlib.h> // Represents a node typedef struct node { int number ; struct node * next ; } node ; int main ( void ) { // List of size 0, initially not pointing to anything node * list = NULL ; // Add number to list node * n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 1 ; n -> next = NULL ; // We create our first node, store the value 1 in it, and leave the next // pointer to point to nothing. Then, our list variable can point to it. list = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 2 ; n -> next = NULL ; // Now, we go our first node that list points to, and sets the next pointer // on it to point to our new node, adding it to the end of the list: list -> next = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 3 ; n -> next = NULL ; // We can follow multiple nodes with this syntax, using the next pointer // over and over, to add our third new node to the end of the list: list -> next -> next = n ; // Normally, though, we would want a loop and a temporary variable to add // a new node to our list. // Print list // Here we can iterate over all the nodes in our list with a temporary // variable. First, we have a temporary pointer, tmp, that points to the // list. Then, our condition for continuing is that tmp is not NULL, and // finally, we update tmp to the next pointer of itself. for ( node * tmp = list ; tmp != NULL ; tmp = tmp -> next ) { // Within the node, we'll just print the number stored: printf ( \"%i \\n \" , tmp -> number ); } // Free list // Since we're freeing each node as we go along, we'll use a while loop // and follow each node's next pointer before freeing it, but we'll see // this in more detail in Problem Set 5. while ( list != NULL ) { node * tmp = list -> next ; free ( list ); list = tmp ; } }","title":"Linked Lists"},{"location":"c-data-structures/#more-data-structures","text":"A tree is another data structure where each node points to two other nodes, one to the left (with a smaller value) and one to the right (with a larger value):","title":"More data structures"},{"location":"c-functions/","text":"Functions What are functions? C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented. Why us functions? Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need! Function Declarations The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number. Function Definitions The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back } Function Calls To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; } Function Miscellany Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type. Practice Problem We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Functions"},{"location":"c-functions/#functions","text":"","title":"Functions"},{"location":"c-functions/#what-are-functions","text":"C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented.","title":"What are functions?"},{"location":"c-functions/#why-us-functions","text":"Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need!","title":"Why us functions?"},{"location":"c-functions/#function-declarations","text":"The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number.","title":"Function Declarations"},{"location":"c-functions/#function-definitions","text":"The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back }","title":"Function Definitions"},{"location":"c-functions/#function-calls","text":"To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; }","title":"Function Calls"},{"location":"c-functions/#function-miscellany","text":"Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type.","title":"Function Miscellany"},{"location":"c-functions/#practice-problem","text":"We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Practice Problem"},{"location":"c-memory-problems/","text":"Memory Problems Filter Implement a program that applies filters to BMPs, per the below: $ ./filter -r image.bmp reflected.bmp Background Perhaps the simplest way to represent an image is with a grid of pixels (i.e., dots), each of which can be of a different color. For black-and-white images, we thus need 1 bit per pixel, as 0 could represent black and 1 could represent white, as in the below. In this sense, then, is an image just a bitmap (i.e., a map of bits). For more colorful images, you simply need more bits per pixel. A file format (like BMP , JPEG , or PNG ) that supports \u201c24-bit color\u201d uses 24 bits per pixel. (BMP actually supports 1-, 4-, 8-, 16-, 24-, and 32-bit color.) A 24-bit BMP uses 8 bits to signify the amount of red in a pixel\u2019s color, 8 bits to signify the amount of green in a pixel\u2019s color, and 8 bits to signify the amount of blue in a pixel\u2019s color. If you\u2019ve ever heard of RGB color, well, there you have it: red, green, blue. If the R, G, and B values of some pixel in a BMP are, say, 0xff , 0x00 , and 0x00 in hexadecimal, that pixel is purely red, as 0xff (otherwise known as 255 in decimal) implies \u201ca lot of red,\u201d while 0x00 and 0x00 imply \u201cno green\u201d and \u201cno blue,\u201d respectively. A Bit(map) More Technical Recall that a file is just a sequence of bits, arranged in some fashion. A 24-bit BMP file, then, is essentially just a sequence of bits, (almost) every 24 of which happen to represent some pixel\u2019s color. But a BMP file also contains some \u201cmetadata,\u201d information like an image\u2019s height and width. That metadata is stored at the beginning of the file in the form of two data structures generally referred to as \u201cheaders,\u201d not to be confused with C\u2019s header files. (Incidentally, these headers have evolved over time. This problem uses the latest version of Microsoft\u2019s BMP format, 4.0, which debuted with Windows 95.) The first of these headers, called BITMAPFILEHEADER , is 14 bytes long. (Recall that 1 byte equals 8 bits.) The second of these headers, called BITMAPINFOHEADER , is 40 bytes long. Immediately following these headers is the actual bitmap: an array of bytes, triples of which represent a pixel\u2019s color. However, BMP stores these triples backwards (i.e., as BGR), with 8 bits for blue, followed by 8 bits for green, followed by 8 bits for red. (Some BMPs also store the entire bitmap backwards, with an image\u2019s top row at the end of the BMP file. But we\u2019ve stored this problem set\u2019s BMPs as described herein, with each bitmap\u2019s top row first and bottom row last.) In other words, were we to convert the 1-bit smiley above to a 24-bit smiley, substituting red for black, a 24-bit BMP would store this bitmap as follows, where 0000ff signifies red and ffffff signifies white; we\u2019ve highlighted in red all instances of 0000ff . Because we\u2019ve presented these bits from left to right, top to bottom, in 8 columns, you can actually see the red smiley if you take a step back. To be clear, recall that a hexadecimal digit represents 4 bits. Accordingly, ffffff in hexadecimal actually signifies 111111111111111111111111 in binary. Notice that you could represent a bitmap as a 2-dimensional array of pixels: where the image is an array of rows, each row is an array of pixels. Indeed, that\u2019s how we\u2019ve chosen to represent bitmap images in this problem. Image Filtering What does it even mean to filter an image? You can think of filtering an image as taking the pixels of some original image, and modifying each pixel in such a way that a particular effect is apparent in the resulting image. Grayscale One common filter is the \u201cgrayscale\u201d filter, where we take an image and want to convert it to black-and-white. How does that work? Recall that if the red, green, and blue values are all set to 0x00 (hexadecimal for 0 ), then the pixel is black. And if all values are set to 0xff (hexadecimal for 255 ), then the pixel is white. So long as the red, green, and blue values are all equal, the result will be varying shades of gray along the black-white spectrum, with higher values meaning lighter shades (closer to white) and lower values meaning darker shades (closer to black). So to convert a pixel to grayscale, we just need to make sure the red, green, and blue values are all the same value. But how do we know what value to make them? Well, it\u2019s probably reasonable to expect that if the original red, green, and blue values were all pretty high, then the new value should also be pretty high. And if the original values were all low, then the new value should also be low. In fact, to ensure each pixel of the new image still has the same general brightness or darkness as the old image, we can take the average of the red, green, and blue values to determine what shade of grey to make the new pixel. If you apply that to each pixel in the image, the result will be an image converted to grayscale. Sepia Most image editing programs support a \u201csepia\u201d filter, which gives images an old-timey feel by making the whole image look a bit reddish-brown. An image can be converted to sepia by taking each pixel, and computing new red, green, and blue values based on the original values of the three. There are a number of algorithms for converting an image to sepia, but for this problem, we\u2019ll ask you to use the following algorithm. For each pixel, the sepia color values should be calculated based on the original color values per the below. sepiaRed = .393 * originalRed + .769 * originalGreen + .189 * originalBlue sepiaGreen = .349 * originalRed + .686 * originalGreen + .168 * originalBlue sepiaBlue = .272 * originalRed + .534 * originalGreen + .131 * originalBlue Of course, the result of each of these formulas may not be an integer, but each value could be rounded to the nearest integer. It\u2019s also possible that the result of the formula is a number greater than 255, the maximum value for an 8-bit color value. In that case, the red, green, and blue values should be capped at 255. As a result, we can guarantee that the resulting red, green, and blue values will be whole numbers between 0 and 255, inclusive. Reflection Some filters might also move pixels around. Reflecting an image, for example, is a filter where the resulting image is what you would get by placing the original image in front of a mirror. So any pixels on the left side of the image should end up on the right, and vice versa. Note that all of the original pixels of the original image will still be present in the reflected image, it\u2019s just that those pixels may have rearranged to be in a different place in the image. Blur There are a number of ways to create the effect of blurring or softening an image. For this problem, we\u2019ll use the \u201cbox blur,\u201d which works by taking each pixel and, for each color value, giving it a new value by averaging the color values of neighboring pixels. Consider the following grid of pixels, where we\u2019ve numbered each pixel. The new value of each pixel would be the average of the values of all of the pixels that are within 1 row and column of the original pixel (forming a 3x3 box). For example, each of the color values for pixel 6 would be obtained by averaging the original color values of pixels 1, 2, 3, 5, 6, 7, 9, 10, and 11 (note that pixel 6 itself is included in the average). Likewise, the color values for pixel 11 would be be obtained by averaging the color values of pixels 6, 7, 8, 10, 11, 12, 14, 15 and 16. For a pixel along the edge or corner, like pixel 15, we would still look for all pixels within 1 row and column: in this case, pixels 10, 11, 12, 14, 15, and 16. Problem Solving Get the files for the filter HERE . Now let's look at the files provided to help break understand what is inside. bmp.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // BMP-related data types based on Microsoft's own #include <stdint.h> /** * Common Data Types * * The data types in this section are essentially aliases for C/C++ * primitive data types. * * Adapted from http://msdn.microsoft.com/en-us/library/cc230309.aspx. * See http://en.wikipedia.org/wiki/Stdint.h for more on stdint.h. */ typedef uint8_t BYTE ; typedef uint32_t DWORD ; typedef int32_t LONG ; typedef uint16_t WORD ; /** * BITMAPFILEHEADER * * The BITMAPFILEHEADER structure contains information about the type, size, * and layout of a file that contains a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183374(VS.85).aspx. */ typedef struct { WORD bfType ; DWORD bfSize ; WORD bfReserved1 ; WORD bfReserved2 ; DWORD bfOffBits ; } __attribute__ (( __packed__ )) BITMAPFILEHEADER ; /** * BITMAPINFOHEADER * * The BITMAPINFOHEADER structure contains information about the * dimensions and color format of a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183376(VS.85).aspx. */ typedef struct { DWORD biSize ; LONG biWidth ; LONG biHeight ; WORD biPlanes ; WORD biBitCount ; DWORD biCompression ; DWORD biSizeImage ; LONG biXPelsPerMeter ; LONG biYPelsPerMeter ; DWORD biClrUsed ; DWORD biClrImportant ; } __attribute__ (( __packed__ )) BITMAPINFOHEADER ; /** * RGBTRIPLE * * This structure describes a color consisting of relative intensities of * red, green, and blue. * * Adapted from http://msdn.microsoft.com/en-us/library/aa922590.aspx. */ typedef struct { BYTE rgbtBlue ; BYTE rgbtGreen ; BYTE rgbtRed ; } __attribute__ (( __packed__ )) RGBTRIPLE ; You\u2019ll see definitions of the headers we\u2019ve mentioned ( BITMAPINFOHEADER and BITMAPFILEHEADER ). In addition, that file defines BYTE , DWORD , LONG , and WORD , data types normally found in the world of Windows programming. Notice how they\u2019re just aliases for primitives with which you are (hopefully) already familiar. It appears that BITMAPFILEHEADER and BITMAPINFOHEADER make use of these types. Perhaps most importantly, this file also defines a struct called RGBTRIPLE that, quite simply, \u201cencapsulates\u201d three bytes: one blue, one green, and one red (the order, recall, in which we expect to find RGB triples actually on disk). Why are these struct s useful? Well, recall that a file is just a sequence of bytes (or, ultimately, bits) on disk. But those bytes are generally ordered in such a way that the first few represent something, the next few represent something else, and so on. \u201cFile formats\u201d exist because the world has standardized what bytes mean what. Now, we could just read a file from disk into RAM as one big array of bytes. And we could just remember that the byte at array[i] represents one thing, while the byte at array[j] represents another. But why not give some of those bytes names so that we can retrieve them from memory more easily? That\u2019s precisely what the structs in bmp.h allow us to do. Rather than think of some file as one long sequence of bytes, we can instead think of it as a sequence of struct s. filter.c filter.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include <getopt.h> #include <stdio.h> #include <stdlib.h> #include \"helpers.h\" int main ( int argc , char * argv []) { // Define allowable filters char * filters = \"bgrs\" ; // Get filter flag and check validity char filter = getopt ( argc , argv , filters ); if ( filter == '?' ) { fprintf ( stderr , \"Invalid filter. \\n \" ); return 1 ; } // Ensure only one filter if ( getopt ( argc , argv , filters ) != - 1 ) { fprintf ( stderr , \"Only one filter allowed. \\n \" ); return 2 ; } // Ensure proper usage if ( argc != optind + 2 ) { fprintf ( stderr , \"Usage: filter [flag] infile outfile \\n \" ); return 3 ; } // Remember filenames char * infile = argv [ optind ]; char * outfile = argv [ optind + 1 ]; // Open input file FILE * inptr = fopen ( infile , \"r\" ); if ( inptr == NULL ) { fprintf ( stderr , \"Could not open %s. \\n \" , infile ); return 4 ; } // Open output file FILE * outptr = fopen ( outfile , \"w\" ); if ( outptr == NULL ) { fclose ( inptr ); fprintf ( stderr , \"Could not create %s. \\n \" , outfile ); return 5 ; } // Read infile's BITMAPFILEHEADER BITMAPFILEHEADER bf ; fread ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , inptr ); // Read infile's BITMAPINFOHEADER BITMAPINFOHEADER bi ; fread ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , inptr ); // Ensure infile is (likely) a 24-bit uncompressed BMP 4.0 if ( bf . bfType != 0x4d42 || bf . bfOffBits != 54 || bi . biSize != 40 || bi . biBitCount != 24 || bi . biCompression != 0 ) { fclose ( outptr ); fclose ( inptr ); fprintf ( stderr , \"Unsupported file format. \\n \" ); return 6 ; } int height = abs ( bi . biHeight ); int width = bi . biWidth ; // Allocate memory for image RGBTRIPLE ( * image )[ width ] = calloc ( height , width * sizeof ( RGBTRIPLE )); if ( image == NULL ) { fprintf ( stderr , \"Not enough memory to store image. \\n \" ); fclose ( outptr ); fclose ( inptr ); return 7 ; } // Determine padding for scanlines int padding = ( 4 - ( width * sizeof ( RGBTRIPLE )) % 4 ) % 4 ; // Iterate over infile's scanlines for ( int i = 0 ; i < height ; i ++ ) { // Read row into pixel array fread ( image [ i ], sizeof ( RGBTRIPLE ), width , inptr ); // Skip over padding fseek ( inptr , padding , SEEK_CUR ); } // Filter image switch ( filter ) { // Blur case 'b' : blur ( height , width , image ); break ; // Grayscale case 'g' : grayscale ( height , width , image ); break ; // Reflection case 'r' : reflect ( height , width , image ); break ; // Sepia case 's' : sepia ( height , width , image ); break ; } // Write outfile's BITMAPFILEHEADER fwrite ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , outptr ); // Write outfile's BITMAPINFOHEADER fwrite ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , outptr ); // Write new pixels to outfile for ( int i = 0 ; i < height ; i ++ ) { // Write row to outfile fwrite ( image [ i ], sizeof ( RGBTRIPLE ), width , outptr ); // Write padding at end of row for ( int k = 0 ; k < padding ; k ++ ) { fputc ( 0x00 , outptr ); } } // Free memory for image free ( image ); // Close infile fclose ( inptr ); // Close outfile fclose ( outptr ); return 0 ; } First, notice the definition of filters on line 11. That string tells the program what the allowable command-line arguments to the program are: b , g , r , and s . Each of them specifies a different filter that we might apply to our images: blur, grayscale, reflection, and sepia. The next several lines open up an image file, make sure it\u2019s indeed a BMP file, and read all of the pixel information into a 2D array called image . Scroll down to the switch statement that begins on line 102. Notice that, depending on what filter we\u2019ve chosen, a different function is called: if the user chooses filter b , the program calls the blur function; if g , then grayscale is called; if r , then reflect is called; and if s , then sepia is called. Notice, too, that each of these functions take as arguments the height of the image, the width of the image, and the 2D array of pixels. The remaining lines of the program take the resulting image and write them out to a new image file. helpers.h helpers.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \"bmp.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]); This file is quite short, and just provides the function prototypes for the functions you saw earlier. Here, take note of the fact that each function takes a 2D array called image as an argument, where image is an array of height many rows, and each row is itself another array of width many GBTRIPLE s. So if image represents the whole picture, then image[0] represents the first row, and image[0][0] represents the pixel in the upper-left corner of the image. helpers.c helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \"helpers.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } Now, open up helpers.c. Here\u2019s where the implementation of the functions declared in helpers.h belong. But note that, right now, the implementations are missing! We will come back to this later. Makefile filter: clang -fsanitize=signed-integer-overflow -fsanitize=undefined -ggdb3 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -o filter filter.c helpers.c Finally, let\u2019s look at Makefile . This file specifies what should happen when we run a terminal command like make filter . Whereas programs you may have written before were confined to just one file, filter seems to use multiple files: filter.c , bmp.h , helpers.h , and helpers.c . So we\u2019ll need to tell make how to compile this file. Try compiling filter for yourself by going to your terminal and running $ make filter Then, you can run the program by running: $ ./filter -g images/yard.bmp out.bmp which takes the image at images/yard.bmp , and generates a new image called out.bmp after running the pixels through the grayscale function. grayscale doesn\u2019t do anything just yet, though, so the output image should look the same as the original yard. Code and Solution Here are our goals for the filter program: The function grayscale should take an image and turn it into a black-and-white version of the same image. The function sepia should take an image and turn it into a sepia version of the same image. The reflect function should take an image and reflect it horizontally. Finally, the blur function should take an image and turn it into a box-blurred version of the same image. Let's look at helpers.c and add some code: helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \"helpers.h\" #include \"math.h\" #include \"cs50.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int average = round (( pixel . rgbtRed + pixel . rgbtBlue + pixel . rgbtGreen ) / 3.0 ); image [ i ][ j ]. rgbtRed = image [ i ][ j ]. rgbtGreen = image [ i ][ j ]. rgbtBlue = average ; } } } // Convert image to sepia using formula given int capacity ( int value ) { return value > 255 ? 255 : value ; } void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int originalRed = pixel . rgbtRed ; int originalBlue = pixel . rgbtBlue ; int originalGreen = pixel . rgbtGreen ; image [ i ][ j ]. rgbtRed = capacity ( round ( 0.393 * originalRed + 0.769 * originalGreen + 0.189 * originalBlue )); image [ i ][ j ]. rgbtGreen = capacity ( round ( 0.349 * originalRed + 0.686 * originalGreen + 0.168 * originalBlue )); image [ i ][ j ]. rgbtBlue = capacity ( round ( 0.272 * originalRed + 0.534 * originalGreen + 0.131 * originalBlue )); } } } // Reflect image horizontally void swap ( RGBTRIPLE * pixel1 , RGBTRIPLE * pixel2 ) { RGBTRIPLE temp = * pixel1 ; * pixel1 = * pixel2 ; * pixel2 = temp ; } void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width / 2 ; j ++ ) { swap ( & image [ i ][ j ], & image [ i ][ width - 1 - i ]); } } } // Blur image bool is_valid ( int i , int j , int height , int width ) { return i >= 0 && i < height && j >= 0 && j < width ; } RGBTRIPLE get_blur ( int i , int j , int height , int width , RGBTRIPLE image [ height ][ width ]) { int redValue , blueValue , greenValue ; redValue = blueValue = greenValue = 0 ; int num_valid_pixels = 0 ; for ( int di = - 1 ; di <= 1 ; di ++ ) // di stand for change in i { for ( int dj = - 1 ; dj <= 1 ; dj ++ ) { int new_i = i + di ; int new_j = j + dj ; if ( is_valid ( new_i , new_j , height , width )) { num_valid_pixels ++ ; redValue += image [ new_i ][ new_j ]. rgbtRed ; blueValue += image [ new_i ][ new_j ]. rgbtBlue ; greenValue += image [ new_i ][ new_j ]. rgbtGreen ; } } } RGBTRIPLE blurred_pix ; blurred_pix . rgbtRed = round (( float ) redValue / num_valid_pixels ); blurred_pix . rgbtGreen = round (( float ) greenValue / num_valid_pixels ); blurred_pix . rgbtBlue = round (( float ) blueValue / num_valid_pixels ); return blurred_pix ; } void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { RGBTRIPLE blur_image [ height ][ width ]; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { blur_image [ i ][ j ] = get_blur ( i , j , height , width , image ); } } for ( int i = 0 ; i < height ; i ++ ) for ( int j = 0 ; j < width ; j ++ ) image [ i ][ j ] = blur_image [ i ][ j ]; } Recover Implement a program that recovers JPEGs from a forensic image, per the below. $ ./recover card.raw Background Sometimes, after taking an image, we may delete them by accident. Thankfully, in the computer world, \u201cdeleted\u201d tends not to mean \u201cdeleted\u201d so much as \u201cforgotten.\u201d Even though the camera insists that the card is now blank, we\u2019re pretty sure that\u2019s not quite true. Even though JPEGs are more complicated than BMPs, JPEGs have \u201csignatures,\u201d patterns of bytes that can distinguish them from other file formats. Specifically, the first three bytes of JPEGs are: 0xff 0xd8 0xff from first byte to third byte, left to right. The fourth byte, meanwhile, is either 0xe0 , 0xe1 , 0xe2 , 0xe3 , 0xe4 , 0xe5 , 0xe6 , 0xe7 , 0xe8 , 0xe9 , 0xea , 0xeb , 0xec , 0xed , 0xee , or 0xef . Put another way, the fourth byte\u2019s first four bits are 1110 . Odds are, if you find this pattern of four bytes on media known to store photos (e.g., my memory card), they demarcate the start of a JPEG. To be fair, you might encounter these patterns on some disk purely by chance, so data recovery isn\u2019t an exact science. Fortunately, digital cameras tend to store photographs contiguously on memory cards, whereby each photo is stored immediately after the previously taken photo. Accordingly, the start of a JPEG usually demarks the end of another. However, digital cameras often initialize cards with a FAT file system whose \u201cblock size\u201d is 512 bytes (B). The implication is that these cameras only write to those cards in units of 512 B. A photo that\u2019s 1 MB (i.e., 1,048,576 B) thus takes up 1048576 \u00f7 512 = 2048 \u201cblocks\u201d on a memory card. But so does a photo that\u2019s, say, one byte smaller (i.e., 1,048,575 B)! The wasted space on disk is called \u201cslack space.\u201d Forensic investigators often look at slack space for remnants of suspicious data. The implication of all these details is that you, the investigator, can probably write a program that iterates over a copy of my memory card, looking for JPEGs\u2019 signatures. Each time you find a signature, you can open a new file for writing and start filling that file with bytes from my memory card, closing that file only once you encounter another signature. Moreover, rather than read my memory card\u2019s bytes one at a time, you can read 512 of them at a time into a buffer for efficiency\u2019s sake. Thanks to FAT, you can trust that JPEGs\u2019 signatures will be \u201cblock-aligned.\u201d That is, you need only look for those signatures in a block\u2019s first four bytes. Realize, of course, that JPEGs can span contiguous blocks. Otherwise, no JPEG could be larger than 512 B. But the last byte of a JPEG might not fall at the very end of a block. Recall the possibility of slack space. But not to worry. Because this memory card was brand-new when I started snapping photos, odds are it\u2019d been \u201czeroed\u201d (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. It\u2019s okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable. Now, I only have one memory card, but there are a lot of you! And so I\u2019ve gone ahead and created a \u201cforensic image\u201d of the card, storing its contents, byte after byte, in a file called card.raw . So that you don\u2019t waste time iterating over millions of 0s unnecessarily, I\u2019ve only imaged the first few megabytes of the memory card. But you should ultimately find that the image contains 50 JPEGs. Problem Solving Get the files for the recovery problem HERE . Let's take a look at the code provided in the .zip: recover.c code 1 2 3 4 5 6 7 #include <stdio.h> #include <stdlib.h> int main ( int argc , char * argv []) { } The above code is basically bare of anything, which means we should break down what we need to do: Tasks Open memory card Look for beginning of a JPEG Open a new JPEG file Write 512 bytes until a new JPEG is found Stop at the end of the file Let's look at some things we can do for each step: Open memory card We can take advantage of the fopen() function to open the memory card: FILE * f = fopen ( filename , \"r\" ); Here inside the fopen(); the filename is the name of the file you are trying to open and the \"r\" means you want to read the files. Look for beginning of a JPEG As mentioned previously, each JPEG file starts with a distinct header, meaning that first byte is always 0xff , the second byte is always 0xd8 , the third byte is always 0xff , and the fourth byte can vary a little bit, but always start with 0xe . Luckily for us, each JPEG is stored back-to-back in this problem file. We can utilize the fread() function to look for JPEGs. fread ( data , size , number , inptr ); The above code can be broken down as: data : pointer to where to store data you're reading. size : size of each element to read. number : number of elements to read. inptr : FILE * to read from. For example, we can check to see if the first byte of an array, for example called buffer , contains 0xff : buffer [ 0 ] == 0xff buffer [ 1 ] == 0xd8 buffer [ 2 ] == 0xff buffer[3] is a little bit more confusing because it can vary. We could use a boolean expression here to check all the different variations to start: buffer [ 3 ] == 0xe0 || buffer [ 3 ] == 0xe1 || buffer [ 3 ] == 0xe2 ... But having to write out all 16 variations could become tedious. For a shortcut, we could use bitwise arithmatic: ( buffer [ 3 ] & 0xf0 ) == 0xe0 This is going to say to look at the first 4 bits of this 8 bit byte, and set the remaining 4 bytes to zero. This clears out the last 4 bits and compares the results. Open a new JPEG file After we find a JPEG, we need to make a new JPEG file. To begin we need to have filenames set as ###.jpg , starting at 000.jpg . This will help us keep track of the number of JPEGs found. We can utilize the sprintf() function here, where instead of printing to the terminal, it prints to a string . For example, we could use the following code: sprintf ( filename , \"%03i.jpg\" , 2 ); %03i.jpg simply means to print an integer with 3 digits. Next, to create the new file, we can use the fopen() function again: FILE * img = fopen ( filename , \"w\" ); Notice the \"w\" , which stands for write. To begin writing the new file, we can use the fwrite function: fwrite ( data , size , number , outptr ); The above code can be broken down as: data : pointer to bytes that will be written to file. size : size of each element to write. number : number of elements to write. outptr : FILE * to write to. Returns number of items of size size were read. Pseudocode Open memory card Repeat until end of card: Read 512 bytes into a buffer If start of new JPEG If first JPEG ... Else ... Else If already found JPEG Solution recover.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <stdio.h> #include <stdlib.h> #include <cs50.h> #include <stdint.h> typedef uint8_t BYTE ; //defining BYTE as a byte (unsigned integer of length = 8 bits) #define BLOCK_SIZE 512 // setting BLOCK_SIZE to 512 bytes #define FILE_NAME_SIZE 8 bool start_jpeg ( BYTE buffer []); int main ( int argc , char * argv []) { if ( argc != 2 ) { printf ( \"Usage: ./recover image \\n \" ); return 1 ; } FILE * infile = fopen ( argv [ 1 ], \"r\" ) if ( infile == NULL ) { printf ( \"File not found \\n \" ); return 1 ; } BYTE buffer [ BLOCK_SIZE ]; int file_index = 0 ; bool first_jpeg = false ; FILE * outfile ; while ( fread ( buffer , BLOCK_SIZE , 1 , infile )) { if ( start_jpeg ( buffer )) { if ( ! first_jpeg ) first_jpeg = true ; else fclose ( outfile ); char filename ( FILE_NAME_SIZE ); sprintf ( filename , \"%03i.jpg\" , file_index ++ ); outfile = fopen ( filename , \"w\" ); if ( outfile == NULL ) return 1 ; fwrite ( buffer , BLOCK_SIZE , 1 , outfile ); } else if ( first_jpeg ) { fwrite ( buffer , BLOCK_SIZE , 1 , outfile ) } } fclose ( outfile ); fclose ( infile ); } bool start_jpeg ( BYTE buffer []) { return buffer [ 0 ] == 0xff && buffer [ 1 ] == 0xd8 && buffer [ 2 ] == 0xff && ( buffer [ 3 ] & 0xf0 ) == 0xe0 ; }","title":"Memory Problems"},{"location":"c-memory-problems/#memory-problems","text":"","title":"Memory Problems"},{"location":"c-memory-problems/#filter","text":"Implement a program that applies filters to BMPs, per the below: $ ./filter -r image.bmp reflected.bmp","title":"Filter"},{"location":"c-memory-problems/#background","text":"Perhaps the simplest way to represent an image is with a grid of pixels (i.e., dots), each of which can be of a different color. For black-and-white images, we thus need 1 bit per pixel, as 0 could represent black and 1 could represent white, as in the below. In this sense, then, is an image just a bitmap (i.e., a map of bits). For more colorful images, you simply need more bits per pixel. A file format (like BMP , JPEG , or PNG ) that supports \u201c24-bit color\u201d uses 24 bits per pixel. (BMP actually supports 1-, 4-, 8-, 16-, 24-, and 32-bit color.) A 24-bit BMP uses 8 bits to signify the amount of red in a pixel\u2019s color, 8 bits to signify the amount of green in a pixel\u2019s color, and 8 bits to signify the amount of blue in a pixel\u2019s color. If you\u2019ve ever heard of RGB color, well, there you have it: red, green, blue. If the R, G, and B values of some pixel in a BMP are, say, 0xff , 0x00 , and 0x00 in hexadecimal, that pixel is purely red, as 0xff (otherwise known as 255 in decimal) implies \u201ca lot of red,\u201d while 0x00 and 0x00 imply \u201cno green\u201d and \u201cno blue,\u201d respectively.","title":"Background"},{"location":"c-memory-problems/#a-bitmap-more-technical","text":"Recall that a file is just a sequence of bits, arranged in some fashion. A 24-bit BMP file, then, is essentially just a sequence of bits, (almost) every 24 of which happen to represent some pixel\u2019s color. But a BMP file also contains some \u201cmetadata,\u201d information like an image\u2019s height and width. That metadata is stored at the beginning of the file in the form of two data structures generally referred to as \u201cheaders,\u201d not to be confused with C\u2019s header files. (Incidentally, these headers have evolved over time. This problem uses the latest version of Microsoft\u2019s BMP format, 4.0, which debuted with Windows 95.) The first of these headers, called BITMAPFILEHEADER , is 14 bytes long. (Recall that 1 byte equals 8 bits.) The second of these headers, called BITMAPINFOHEADER , is 40 bytes long. Immediately following these headers is the actual bitmap: an array of bytes, triples of which represent a pixel\u2019s color. However, BMP stores these triples backwards (i.e., as BGR), with 8 bits for blue, followed by 8 bits for green, followed by 8 bits for red. (Some BMPs also store the entire bitmap backwards, with an image\u2019s top row at the end of the BMP file. But we\u2019ve stored this problem set\u2019s BMPs as described herein, with each bitmap\u2019s top row first and bottom row last.) In other words, were we to convert the 1-bit smiley above to a 24-bit smiley, substituting red for black, a 24-bit BMP would store this bitmap as follows, where 0000ff signifies red and ffffff signifies white; we\u2019ve highlighted in red all instances of 0000ff . Because we\u2019ve presented these bits from left to right, top to bottom, in 8 columns, you can actually see the red smiley if you take a step back. To be clear, recall that a hexadecimal digit represents 4 bits. Accordingly, ffffff in hexadecimal actually signifies 111111111111111111111111 in binary. Notice that you could represent a bitmap as a 2-dimensional array of pixels: where the image is an array of rows, each row is an array of pixels. Indeed, that\u2019s how we\u2019ve chosen to represent bitmap images in this problem.","title":"A Bit(map) More Technical"},{"location":"c-memory-problems/#image-filtering","text":"What does it even mean to filter an image? You can think of filtering an image as taking the pixels of some original image, and modifying each pixel in such a way that a particular effect is apparent in the resulting image. Grayscale One common filter is the \u201cgrayscale\u201d filter, where we take an image and want to convert it to black-and-white. How does that work? Recall that if the red, green, and blue values are all set to 0x00 (hexadecimal for 0 ), then the pixel is black. And if all values are set to 0xff (hexadecimal for 255 ), then the pixel is white. So long as the red, green, and blue values are all equal, the result will be varying shades of gray along the black-white spectrum, with higher values meaning lighter shades (closer to white) and lower values meaning darker shades (closer to black). So to convert a pixel to grayscale, we just need to make sure the red, green, and blue values are all the same value. But how do we know what value to make them? Well, it\u2019s probably reasonable to expect that if the original red, green, and blue values were all pretty high, then the new value should also be pretty high. And if the original values were all low, then the new value should also be low. In fact, to ensure each pixel of the new image still has the same general brightness or darkness as the old image, we can take the average of the red, green, and blue values to determine what shade of grey to make the new pixel. If you apply that to each pixel in the image, the result will be an image converted to grayscale. Sepia Most image editing programs support a \u201csepia\u201d filter, which gives images an old-timey feel by making the whole image look a bit reddish-brown. An image can be converted to sepia by taking each pixel, and computing new red, green, and blue values based on the original values of the three. There are a number of algorithms for converting an image to sepia, but for this problem, we\u2019ll ask you to use the following algorithm. For each pixel, the sepia color values should be calculated based on the original color values per the below. sepiaRed = .393 * originalRed + .769 * originalGreen + .189 * originalBlue sepiaGreen = .349 * originalRed + .686 * originalGreen + .168 * originalBlue sepiaBlue = .272 * originalRed + .534 * originalGreen + .131 * originalBlue Of course, the result of each of these formulas may not be an integer, but each value could be rounded to the nearest integer. It\u2019s also possible that the result of the formula is a number greater than 255, the maximum value for an 8-bit color value. In that case, the red, green, and blue values should be capped at 255. As a result, we can guarantee that the resulting red, green, and blue values will be whole numbers between 0 and 255, inclusive. Reflection Some filters might also move pixels around. Reflecting an image, for example, is a filter where the resulting image is what you would get by placing the original image in front of a mirror. So any pixels on the left side of the image should end up on the right, and vice versa. Note that all of the original pixels of the original image will still be present in the reflected image, it\u2019s just that those pixels may have rearranged to be in a different place in the image. Blur There are a number of ways to create the effect of blurring or softening an image. For this problem, we\u2019ll use the \u201cbox blur,\u201d which works by taking each pixel and, for each color value, giving it a new value by averaging the color values of neighboring pixels. Consider the following grid of pixels, where we\u2019ve numbered each pixel. The new value of each pixel would be the average of the values of all of the pixels that are within 1 row and column of the original pixel (forming a 3x3 box). For example, each of the color values for pixel 6 would be obtained by averaging the original color values of pixels 1, 2, 3, 5, 6, 7, 9, 10, and 11 (note that pixel 6 itself is included in the average). Likewise, the color values for pixel 11 would be be obtained by averaging the color values of pixels 6, 7, 8, 10, 11, 12, 14, 15 and 16. For a pixel along the edge or corner, like pixel 15, we would still look for all pixels within 1 row and column: in this case, pixels 10, 11, 12, 14, 15, and 16.","title":"Image Filtering"},{"location":"c-memory-problems/#problem-solving","text":"Get the files for the filter HERE . Now let's look at the files provided to help break understand what is inside. bmp.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // BMP-related data types based on Microsoft's own #include <stdint.h> /** * Common Data Types * * The data types in this section are essentially aliases for C/C++ * primitive data types. * * Adapted from http://msdn.microsoft.com/en-us/library/cc230309.aspx. * See http://en.wikipedia.org/wiki/Stdint.h for more on stdint.h. */ typedef uint8_t BYTE ; typedef uint32_t DWORD ; typedef int32_t LONG ; typedef uint16_t WORD ; /** * BITMAPFILEHEADER * * The BITMAPFILEHEADER structure contains information about the type, size, * and layout of a file that contains a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183374(VS.85).aspx. */ typedef struct { WORD bfType ; DWORD bfSize ; WORD bfReserved1 ; WORD bfReserved2 ; DWORD bfOffBits ; } __attribute__ (( __packed__ )) BITMAPFILEHEADER ; /** * BITMAPINFOHEADER * * The BITMAPINFOHEADER structure contains information about the * dimensions and color format of a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183376(VS.85).aspx. */ typedef struct { DWORD biSize ; LONG biWidth ; LONG biHeight ; WORD biPlanes ; WORD biBitCount ; DWORD biCompression ; DWORD biSizeImage ; LONG biXPelsPerMeter ; LONG biYPelsPerMeter ; DWORD biClrUsed ; DWORD biClrImportant ; } __attribute__ (( __packed__ )) BITMAPINFOHEADER ; /** * RGBTRIPLE * * This structure describes a color consisting of relative intensities of * red, green, and blue. * * Adapted from http://msdn.microsoft.com/en-us/library/aa922590.aspx. */ typedef struct { BYTE rgbtBlue ; BYTE rgbtGreen ; BYTE rgbtRed ; } __attribute__ (( __packed__ )) RGBTRIPLE ; You\u2019ll see definitions of the headers we\u2019ve mentioned ( BITMAPINFOHEADER and BITMAPFILEHEADER ). In addition, that file defines BYTE , DWORD , LONG , and WORD , data types normally found in the world of Windows programming. Notice how they\u2019re just aliases for primitives with which you are (hopefully) already familiar. It appears that BITMAPFILEHEADER and BITMAPINFOHEADER make use of these types. Perhaps most importantly, this file also defines a struct called RGBTRIPLE that, quite simply, \u201cencapsulates\u201d three bytes: one blue, one green, and one red (the order, recall, in which we expect to find RGB triples actually on disk). Why are these struct s useful? Well, recall that a file is just a sequence of bytes (or, ultimately, bits) on disk. But those bytes are generally ordered in such a way that the first few represent something, the next few represent something else, and so on. \u201cFile formats\u201d exist because the world has standardized what bytes mean what. Now, we could just read a file from disk into RAM as one big array of bytes. And we could just remember that the byte at array[i] represents one thing, while the byte at array[j] represents another. But why not give some of those bytes names so that we can retrieve them from memory more easily? That\u2019s precisely what the structs in bmp.h allow us to do. Rather than think of some file as one long sequence of bytes, we can instead think of it as a sequence of struct s. filter.c filter.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include <getopt.h> #include <stdio.h> #include <stdlib.h> #include \"helpers.h\" int main ( int argc , char * argv []) { // Define allowable filters char * filters = \"bgrs\" ; // Get filter flag and check validity char filter = getopt ( argc , argv , filters ); if ( filter == '?' ) { fprintf ( stderr , \"Invalid filter. \\n \" ); return 1 ; } // Ensure only one filter if ( getopt ( argc , argv , filters ) != - 1 ) { fprintf ( stderr , \"Only one filter allowed. \\n \" ); return 2 ; } // Ensure proper usage if ( argc != optind + 2 ) { fprintf ( stderr , \"Usage: filter [flag] infile outfile \\n \" ); return 3 ; } // Remember filenames char * infile = argv [ optind ]; char * outfile = argv [ optind + 1 ]; // Open input file FILE * inptr = fopen ( infile , \"r\" ); if ( inptr == NULL ) { fprintf ( stderr , \"Could not open %s. \\n \" , infile ); return 4 ; } // Open output file FILE * outptr = fopen ( outfile , \"w\" ); if ( outptr == NULL ) { fclose ( inptr ); fprintf ( stderr , \"Could not create %s. \\n \" , outfile ); return 5 ; } // Read infile's BITMAPFILEHEADER BITMAPFILEHEADER bf ; fread ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , inptr ); // Read infile's BITMAPINFOHEADER BITMAPINFOHEADER bi ; fread ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , inptr ); // Ensure infile is (likely) a 24-bit uncompressed BMP 4.0 if ( bf . bfType != 0x4d42 || bf . bfOffBits != 54 || bi . biSize != 40 || bi . biBitCount != 24 || bi . biCompression != 0 ) { fclose ( outptr ); fclose ( inptr ); fprintf ( stderr , \"Unsupported file format. \\n \" ); return 6 ; } int height = abs ( bi . biHeight ); int width = bi . biWidth ; // Allocate memory for image RGBTRIPLE ( * image )[ width ] = calloc ( height , width * sizeof ( RGBTRIPLE )); if ( image == NULL ) { fprintf ( stderr , \"Not enough memory to store image. \\n \" ); fclose ( outptr ); fclose ( inptr ); return 7 ; } // Determine padding for scanlines int padding = ( 4 - ( width * sizeof ( RGBTRIPLE )) % 4 ) % 4 ; // Iterate over infile's scanlines for ( int i = 0 ; i < height ; i ++ ) { // Read row into pixel array fread ( image [ i ], sizeof ( RGBTRIPLE ), width , inptr ); // Skip over padding fseek ( inptr , padding , SEEK_CUR ); } // Filter image switch ( filter ) { // Blur case 'b' : blur ( height , width , image ); break ; // Grayscale case 'g' : grayscale ( height , width , image ); break ; // Reflection case 'r' : reflect ( height , width , image ); break ; // Sepia case 's' : sepia ( height , width , image ); break ; } // Write outfile's BITMAPFILEHEADER fwrite ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , outptr ); // Write outfile's BITMAPINFOHEADER fwrite ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , outptr ); // Write new pixels to outfile for ( int i = 0 ; i < height ; i ++ ) { // Write row to outfile fwrite ( image [ i ], sizeof ( RGBTRIPLE ), width , outptr ); // Write padding at end of row for ( int k = 0 ; k < padding ; k ++ ) { fputc ( 0x00 , outptr ); } } // Free memory for image free ( image ); // Close infile fclose ( inptr ); // Close outfile fclose ( outptr ); return 0 ; } First, notice the definition of filters on line 11. That string tells the program what the allowable command-line arguments to the program are: b , g , r , and s . Each of them specifies a different filter that we might apply to our images: blur, grayscale, reflection, and sepia. The next several lines open up an image file, make sure it\u2019s indeed a BMP file, and read all of the pixel information into a 2D array called image . Scroll down to the switch statement that begins on line 102. Notice that, depending on what filter we\u2019ve chosen, a different function is called: if the user chooses filter b , the program calls the blur function; if g , then grayscale is called; if r , then reflect is called; and if s , then sepia is called. Notice, too, that each of these functions take as arguments the height of the image, the width of the image, and the 2D array of pixels. The remaining lines of the program take the resulting image and write them out to a new image file. helpers.h helpers.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \"bmp.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]); This file is quite short, and just provides the function prototypes for the functions you saw earlier. Here, take note of the fact that each function takes a 2D array called image as an argument, where image is an array of height many rows, and each row is itself another array of width many GBTRIPLE s. So if image represents the whole picture, then image[0] represents the first row, and image[0][0] represents the pixel in the upper-left corner of the image. helpers.c helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \"helpers.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } Now, open up helpers.c. Here\u2019s where the implementation of the functions declared in helpers.h belong. But note that, right now, the implementations are missing! We will come back to this later. Makefile filter: clang -fsanitize=signed-integer-overflow -fsanitize=undefined -ggdb3 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -o filter filter.c helpers.c Finally, let\u2019s look at Makefile . This file specifies what should happen when we run a terminal command like make filter . Whereas programs you may have written before were confined to just one file, filter seems to use multiple files: filter.c , bmp.h , helpers.h , and helpers.c . So we\u2019ll need to tell make how to compile this file. Try compiling filter for yourself by going to your terminal and running $ make filter Then, you can run the program by running: $ ./filter -g images/yard.bmp out.bmp which takes the image at images/yard.bmp , and generates a new image called out.bmp after running the pixels through the grayscale function. grayscale doesn\u2019t do anything just yet, though, so the output image should look the same as the original yard.","title":"Problem Solving"},{"location":"c-memory-problems/#code-and-solution","text":"Here are our goals for the filter program: The function grayscale should take an image and turn it into a black-and-white version of the same image. The function sepia should take an image and turn it into a sepia version of the same image. The reflect function should take an image and reflect it horizontally. Finally, the blur function should take an image and turn it into a box-blurred version of the same image. Let's look at helpers.c and add some code: helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \"helpers.h\" #include \"math.h\" #include \"cs50.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int average = round (( pixel . rgbtRed + pixel . rgbtBlue + pixel . rgbtGreen ) / 3.0 ); image [ i ][ j ]. rgbtRed = image [ i ][ j ]. rgbtGreen = image [ i ][ j ]. rgbtBlue = average ; } } } // Convert image to sepia using formula given int capacity ( int value ) { return value > 255 ? 255 : value ; } void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int originalRed = pixel . rgbtRed ; int originalBlue = pixel . rgbtBlue ; int originalGreen = pixel . rgbtGreen ; image [ i ][ j ]. rgbtRed = capacity ( round ( 0.393 * originalRed + 0.769 * originalGreen + 0.189 * originalBlue )); image [ i ][ j ]. rgbtGreen = capacity ( round ( 0.349 * originalRed + 0.686 * originalGreen + 0.168 * originalBlue )); image [ i ][ j ]. rgbtBlue = capacity ( round ( 0.272 * originalRed + 0.534 * originalGreen + 0.131 * originalBlue )); } } } // Reflect image horizontally void swap ( RGBTRIPLE * pixel1 , RGBTRIPLE * pixel2 ) { RGBTRIPLE temp = * pixel1 ; * pixel1 = * pixel2 ; * pixel2 = temp ; } void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width / 2 ; j ++ ) { swap ( & image [ i ][ j ], & image [ i ][ width - 1 - i ]); } } } // Blur image bool is_valid ( int i , int j , int height , int width ) { return i >= 0 && i < height && j >= 0 && j < width ; } RGBTRIPLE get_blur ( int i , int j , int height , int width , RGBTRIPLE image [ height ][ width ]) { int redValue , blueValue , greenValue ; redValue = blueValue = greenValue = 0 ; int num_valid_pixels = 0 ; for ( int di = - 1 ; di <= 1 ; di ++ ) // di stand for change in i { for ( int dj = - 1 ; dj <= 1 ; dj ++ ) { int new_i = i + di ; int new_j = j + dj ; if ( is_valid ( new_i , new_j , height , width )) { num_valid_pixels ++ ; redValue += image [ new_i ][ new_j ]. rgbtRed ; blueValue += image [ new_i ][ new_j ]. rgbtBlue ; greenValue += image [ new_i ][ new_j ]. rgbtGreen ; } } } RGBTRIPLE blurred_pix ; blurred_pix . rgbtRed = round (( float ) redValue / num_valid_pixels ); blurred_pix . rgbtGreen = round (( float ) greenValue / num_valid_pixels ); blurred_pix . rgbtBlue = round (( float ) blueValue / num_valid_pixels ); return blurred_pix ; } void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { RGBTRIPLE blur_image [ height ][ width ]; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { blur_image [ i ][ j ] = get_blur ( i , j , height , width , image ); } } for ( int i = 0 ; i < height ; i ++ ) for ( int j = 0 ; j < width ; j ++ ) image [ i ][ j ] = blur_image [ i ][ j ]; }","title":"Code and Solution"},{"location":"c-memory-problems/#recover","text":"Implement a program that recovers JPEGs from a forensic image, per the below. $ ./recover card.raw","title":"Recover"},{"location":"c-memory-problems/#background_1","text":"Sometimes, after taking an image, we may delete them by accident. Thankfully, in the computer world, \u201cdeleted\u201d tends not to mean \u201cdeleted\u201d so much as \u201cforgotten.\u201d Even though the camera insists that the card is now blank, we\u2019re pretty sure that\u2019s not quite true. Even though JPEGs are more complicated than BMPs, JPEGs have \u201csignatures,\u201d patterns of bytes that can distinguish them from other file formats. Specifically, the first three bytes of JPEGs are: 0xff 0xd8 0xff from first byte to third byte, left to right. The fourth byte, meanwhile, is either 0xe0 , 0xe1 , 0xe2 , 0xe3 , 0xe4 , 0xe5 , 0xe6 , 0xe7 , 0xe8 , 0xe9 , 0xea , 0xeb , 0xec , 0xed , 0xee , or 0xef . Put another way, the fourth byte\u2019s first four bits are 1110 . Odds are, if you find this pattern of four bytes on media known to store photos (e.g., my memory card), they demarcate the start of a JPEG. To be fair, you might encounter these patterns on some disk purely by chance, so data recovery isn\u2019t an exact science. Fortunately, digital cameras tend to store photographs contiguously on memory cards, whereby each photo is stored immediately after the previously taken photo. Accordingly, the start of a JPEG usually demarks the end of another. However, digital cameras often initialize cards with a FAT file system whose \u201cblock size\u201d is 512 bytes (B). The implication is that these cameras only write to those cards in units of 512 B. A photo that\u2019s 1 MB (i.e., 1,048,576 B) thus takes up 1048576 \u00f7 512 = 2048 \u201cblocks\u201d on a memory card. But so does a photo that\u2019s, say, one byte smaller (i.e., 1,048,575 B)! The wasted space on disk is called \u201cslack space.\u201d Forensic investigators often look at slack space for remnants of suspicious data. The implication of all these details is that you, the investigator, can probably write a program that iterates over a copy of my memory card, looking for JPEGs\u2019 signatures. Each time you find a signature, you can open a new file for writing and start filling that file with bytes from my memory card, closing that file only once you encounter another signature. Moreover, rather than read my memory card\u2019s bytes one at a time, you can read 512 of them at a time into a buffer for efficiency\u2019s sake. Thanks to FAT, you can trust that JPEGs\u2019 signatures will be \u201cblock-aligned.\u201d That is, you need only look for those signatures in a block\u2019s first four bytes. Realize, of course, that JPEGs can span contiguous blocks. Otherwise, no JPEG could be larger than 512 B. But the last byte of a JPEG might not fall at the very end of a block. Recall the possibility of slack space. But not to worry. Because this memory card was brand-new when I started snapping photos, odds are it\u2019d been \u201czeroed\u201d (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. It\u2019s okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable. Now, I only have one memory card, but there are a lot of you! And so I\u2019ve gone ahead and created a \u201cforensic image\u201d of the card, storing its contents, byte after byte, in a file called card.raw . So that you don\u2019t waste time iterating over millions of 0s unnecessarily, I\u2019ve only imaged the first few megabytes of the memory card. But you should ultimately find that the image contains 50 JPEGs.","title":"Background"},{"location":"c-memory-problems/#problem-solving_1","text":"Get the files for the recovery problem HERE . Let's take a look at the code provided in the .zip: recover.c code 1 2 3 4 5 6 7 #include <stdio.h> #include <stdlib.h> int main ( int argc , char * argv []) { } The above code is basically bare of anything, which means we should break down what we need to do: Tasks Open memory card Look for beginning of a JPEG Open a new JPEG file Write 512 bytes until a new JPEG is found Stop at the end of the file Let's look at some things we can do for each step: Open memory card We can take advantage of the fopen() function to open the memory card: FILE * f = fopen ( filename , \"r\" ); Here inside the fopen(); the filename is the name of the file you are trying to open and the \"r\" means you want to read the files. Look for beginning of a JPEG As mentioned previously, each JPEG file starts with a distinct header, meaning that first byte is always 0xff , the second byte is always 0xd8 , the third byte is always 0xff , and the fourth byte can vary a little bit, but always start with 0xe . Luckily for us, each JPEG is stored back-to-back in this problem file. We can utilize the fread() function to look for JPEGs. fread ( data , size , number , inptr ); The above code can be broken down as: data : pointer to where to store data you're reading. size : size of each element to read. number : number of elements to read. inptr : FILE * to read from. For example, we can check to see if the first byte of an array, for example called buffer , contains 0xff : buffer [ 0 ] == 0xff buffer [ 1 ] == 0xd8 buffer [ 2 ] == 0xff buffer[3] is a little bit more confusing because it can vary. We could use a boolean expression here to check all the different variations to start: buffer [ 3 ] == 0xe0 || buffer [ 3 ] == 0xe1 || buffer [ 3 ] == 0xe2 ... But having to write out all 16 variations could become tedious. For a shortcut, we could use bitwise arithmatic: ( buffer [ 3 ] & 0xf0 ) == 0xe0 This is going to say to look at the first 4 bits of this 8 bit byte, and set the remaining 4 bytes to zero. This clears out the last 4 bits and compares the results. Open a new JPEG file After we find a JPEG, we need to make a new JPEG file. To begin we need to have filenames set as ###.jpg , starting at 000.jpg . This will help us keep track of the number of JPEGs found. We can utilize the sprintf() function here, where instead of printing to the terminal, it prints to a string . For example, we could use the following code: sprintf ( filename , \"%03i.jpg\" , 2 ); %03i.jpg simply means to print an integer with 3 digits. Next, to create the new file, we can use the fopen() function again: FILE * img = fopen ( filename , \"w\" ); Notice the \"w\" , which stands for write. To begin writing the new file, we can use the fwrite function: fwrite ( data , size , number , outptr ); The above code can be broken down as: data : pointer to bytes that will be written to file. size : size of each element to write. number : number of elements to write. outptr : FILE * to write to. Returns number of items of size size were read. Pseudocode Open memory card Repeat until end of card: Read 512 bytes into a buffer If start of new JPEG If first JPEG ... Else ... Else If already found JPEG","title":"Problem Solving"},{"location":"c-memory-problems/#solution","text":"recover.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <stdio.h> #include <stdlib.h> #include <cs50.h> #include <stdint.h> typedef uint8_t BYTE ; //defining BYTE as a byte (unsigned integer of length = 8 bits) #define BLOCK_SIZE 512 // setting BLOCK_SIZE to 512 bytes #define FILE_NAME_SIZE 8 bool start_jpeg ( BYTE buffer []); int main ( int argc , char * argv []) { if ( argc != 2 ) { printf ( \"Usage: ./recover image \\n \" ); return 1 ; } FILE * infile = fopen ( argv [ 1 ], \"r\" ) if ( infile == NULL ) { printf ( \"File not found \\n \" ); return 1 ; } BYTE buffer [ BLOCK_SIZE ]; int file_index = 0 ; bool first_jpeg = false ; FILE * outfile ; while ( fread ( buffer , BLOCK_SIZE , 1 , infile )) { if ( start_jpeg ( buffer )) { if ( ! first_jpeg ) first_jpeg = true ; else fclose ( outfile ); char filename ( FILE_NAME_SIZE ); sprintf ( filename , \"%03i.jpg\" , file_index ++ ); outfile = fopen ( filename , \"w\" ); if ( outfile == NULL ) return 1 ; fwrite ( buffer , BLOCK_SIZE , 1 , outfile ); } else if ( first_jpeg ) { fwrite ( buffer , BLOCK_SIZE , 1 , outfile ) } } fclose ( outfile ); fclose ( infile ); } bool start_jpeg ( BYTE buffer []) { return buffer [ 0 ] == 0xff && buffer [ 1 ] == 0xd8 && buffer [ 2 ] == 0xff && ( buffer [ 3 ] & 0xf0 ) == 0xe0 ; }","title":"Solution"},{"location":"c-memory/","text":"Memory In previous weeks, we have discussed binary. We have also covered how each byte has an address, or identifier, so we can refer to where our variables are actually stored. It turns out, by convention, the addresses for memory use the counting system hexadecimal , where there are 16 digits (0-9 and A-F). In binary ( base-2 ), each digit stood for a power of 2: 128 64 32 16 8 4 2 1 1 1 1 1 1 1 1 1 With 8 bits, we can count up to 255. Hexadecimal ( base-16 ) is a much more concise way to express the data on a computer's system. Hexadecimal is displayed as follows: 0 1 2 3 4 5 6 7 8 9 A B C D E F . Just like binary has place values (1, 2, 4, 8...) and decimal has place values (1, 10, 100, 1000...), hexadecimal does too. Hexadecimal's place values are by the power of 16. For example, if we were to look at the hex number 0x397, it would be as follows: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x 3 9 7 So the above number would be (3 x 256) + (9 x 16) + 7 = 919. Another example that uses alphanumeric hex characters: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x A D C This would look like (10 x 256) + (13 x 16) + 12 = 2780 in decimal form. Here, the F is a value of 15 in decimal, and each place is a power of 16, so the first F is 16^1 * 15 = 240, plus the second F with the value of 16^0 * 15 = 15, for a total of 255. Here is a quick chart to compare decimal, hexadecimal, and binary: The RGB color system also conventionally uses hexadecimal to describe the amount of each color. For example, 000000 in hexadecimal means 0 of each red, green, and blue, for a color of black. And FF0000 would be 255, or the highest possible, amount of red. With different values for each color, we can represent millions of different colors. In writing, we can also indicate a value is in hexadecimal by prefixing it with 0x , as in 0x10 , where the value is equal to 16 in decimal, as opposed to 10. 0x means nothing to a computer, this is simply to help humans see when hexadecimal will be used. Pointers Pointers provide an alternative way to pass data between functions. Up until this point we have passed all data by value, which means we have only passed a copy of that data. If we use pointers instead, we have the power to pass the actual variable itself. That means that if a change is made in one function, it can impact what happens in other functions. Let's create a small program that prints out a value of n : #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , n ); } In our computer's memory, there are now 4 bytes somewhere that have the binary value of 50, labeled n . The bytes for the variable n will start at a unique address and may look something like 0x12345678 . In C, we can actually see the address with the & operator, which means \"get the address of this variable\": #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%p \\n \" , & n ); // notice the %p and & here } When this program was run, I received the result 0x7ffe5878a42c . The address of a variable is called a pointer , which we can think of as a value that \"points\" to a location in the memory. The * operator lets us \"go to\" the location that a pointer is point to. For example, we can print *&n , where we \"go to\" the address of n and print out the value of n , 50 . The * is known as the deference operator . It \"goes to the reference\" and access that data at that location, allowing you to manipulate it at will. #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , *& n ); // notice the *&n here } We also have to use the * operator (in an unfortunately confusing way) to declare a variable that we want to be a pointer: #include <stdio.h> int main ( void ) { int n = 50 ; int * p = & n ; // declaring the pointer variable printf ( \"%p \\n \" , p ); } Here, we use int *p to declare a variable, p , that has the type of * , a pointer, to a value of type int , an integer. Then, we can print its value (something like 0x12345678 ), or print the value at its location with printf(\"%i\\n\", *p); . In our computer\u2019s memory, the variables might look like this (each square representing a byte of memory): We have a pointer, p , with the address of some variable. We can abstract away the actual value of the addresses now, since they\u2019ll be different as we declare variables in our programs, and simply think of p as \u201cpointing at\u201d some value: An easier way to look at this is if we have a mailbox labeled \"123\", with the number \"50\" inside it. The mailbox would be int n , since it stores an integer. We might have another mailbox with the address \u201c456\u201d, inside of which is the value \u201c123\u201d, which is the address of our other mailbox. This would be int *p , since it\u2019s a pointer to an integer. A pointer , then, is a data item whose value is a memory address type describes the data located at that memory address The simplest pointer available to us in C is the NULL pointer. As you might expect, this pointer points to nothing (a fact which can actually come in handy). When you create a pointer and you don't set its value immediately, you should always set the value of the pointer to NULL. string Let's use a variable string s for a name like EMMA for an example. We should be able to access each character in EMMA with s[0] - s[4] : It actually turns out that each character is stored in memory at a byte with some address, and s is actually just a pointer with the address of the first character: Because s is just a pointer to the beginning, only the \\0 indicates the end of the string. In fact, the CS50 Library defines a string with typedef char *string , which just says that we want to name a new type, string , as a char * , or a pointer to a character. #include <stdio.h> int main ( void ) { char * s = \"EMMA\" ; // notice how we are no longer using string, we are using char *s printf ( \"%s \\n \" , s ); } Compare and Copy Let's create a quick program to compare integers: #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two integers int i = get_int ( \"i: \" ); int j = get_int ( \"j: \" ); // Compare integers if ( i == j ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } We can compile and run this, and our program works as we\u2019d expect, with the same values of the two integers giving us \u201cSame\u201d and different values \u201cDifferent\u201d. Now let's try the same thing, but using strings instead of integers: #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two strings string s = get_string ( \"s: \" ); string t = get_string ( \"t: \" ); // Compare strings' addresses if ( s == t ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } If we run the above program we will see that it will give us the result \"Different\" each time, even when the strings are identical. Why does this happen? Simply, this is caused by how C stores strings in memory. When these are compared, C looks at the addresses of the stings, not the user input data. The strings are stored in different places of memory (pointers), which will return different hexadecimal results when compared. Now let's look at how we can copy strings. Let's make a simple program: #include <cs50.h> #include <ctype.h> #include <stdio.h> int main ( void ) { string s = get_string ( \"s: \" ); string t = s ; // copies string s to string t (but only as an address) t [ 0 ] = toupper ( t [ 0 ]); // capitalizes string t // Print string twice printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We get a string s , and copy the value of s into t . Then, we capitalize the first letter in t . But when we run our program, we see that both s and t are now capitalized. Since we set s and t to the same values, they\u2019re actually pointers to the same character, and so we capitalized the same character! To actually make a copy of a string, we have to do a little more work: #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <string.h> // needed for strlen (string length) int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); // malloc is \"memory allocate\" to store the copy for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) // we need n+1 for the null character in a string { t [ i ] = s [ i ]; // copies strings } t [ 0 ] = toupper ( t [ 0 ]); // capitalizes the first character of the string printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We create a new variable, t , of the type char * , with char *t . Now, we want to point it to a new chunk of memory that\u2019s large enough to store the copy of the string. With malloc , we can allocate some number of bytes in memory (that aren\u2019t already used to store other values), and we pass in the number of bytes we\u2019d like. We already know the length of s , so we add 1 to that for the terminating null character. So, our final line of code is char *t = malloc(strlen(s) + 1); . Then, we copy each character, one at a time, and now we can capitalize just the first letter of t . And we use i < n + 1 , since we actually want to go up to n , to ensure we copy the terminating character in the string. We can actually also use the strcpy library function with strcpy(t, s) instead of our loop, to copy the string s into t . To be clear, the concept of a \u201cstring\u201d is from the C language and well-supported; the only training wheels from CS50 are the type string instead of char * , and the get_string function. If we didn\u2019t copy the null terminating character, \\0 , and tried to print out our string t , printf will continue and print out the unknown, or garbage, values that we have in memory, until it happens to reach a \\0 , or crashes entirely, since our program might end up trying to read memory that doesn\u2019t belong to it! valgrind It turns out that, after we\u2019re done with memory that we\u2019ve allocated with malloc , we should call free (as in free(t) ), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again. If we kept running our program and allocating memory with malloc , but never freed the memory after we were done using it, we would have a memory leak , which will slow down our computer and use up more and more memory until our computer runs out. valgrind is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with help50 valgrind ./*program* and see, from the error message, that line 10, we allocated memory that we never freed (or \u201clost\u201d). So at the end, we can add a line free(t) , which won\u2019t change how our program runs, but no errors from valgrind. Let's look at an example program provided from valgrind's official documentation: // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare #include <stdlib.h> void f ( void ) { int * x = malloc ( 10 * sizeof ( int )); x [ 10 ] = 0 ; // this int [10] is not in the correct range (0-9) and will result in a buffer overflow } int main ( void ) { f (); return 0 ; } The function f allocates enough memory for 10 integers, and stores the address in a pointer called x . Then we try to set the 11 th value of x with x[10] to 0 , which goes past the array of memory we\u2019ve allocated for our program. This is called buffer overflow , where we go past the boundaries of our buffer, or array, and into unknown memory. valgrind will also tell us there\u2019s an \u201cInvalid write of size 4\u201d for line 8, where we are indeed trying to change the value of an integer (of size 4 bytes). Swap We have two colored drinks, purple and green, each of which is in a cup. We want to swap the drinks between the two cups, but we can\u2019t do that without a third cup (temporary variable) to pour one of the drink into first. Now, let\u2019s say we wanted to swap the values of two integers. void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } With a third variable to use as temporary storage space, we can do this pretty easily, by putting a into tmp , and then b to a , and finally the original value of a , now in tmp , into b . But, if we tried to use that function in a program, we don\u2019t see any changes: #include <stdio.h> void swap ( int a , int b ); int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( x , y ); printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } This does not work because the swap function successfully swaps int a and int b , but these are simply copies of int x and int y . When x and y are printed, the copies used by the swap funciton do not alter the actual x and y integers in the main function. Memory Layout Within our computer\u2019s memory, the different types of data that need to be stored for our program are organized into different sections: The machine code section is our compiled program\u2019s binary code. When we run our program, that code is loaded into the \u201ctop\u201d of memory. Globals are global variables we declare in our program or other shared variables that our entire program can access. The heap section is an empty area where malloc can get free memory from, for our program to use. The stack section is used by functions in our program as they are called. For example, our main function is at the very bottom of the stack, and has the local variables x and y . The swap function, when it\u2019s called, has its own frame, or slice, of memory that\u2019s on top of main \u2019s, with the local variables a , b , and tmp : Once the function swap returns, the memory it was using is freed for the next function call, and we lose anything we did, other than the return values, and our program goes back to the function that called swap . So by passing in the addresses of x and y from main to swap , we can actually change the values of x and y : By passing in the address of x and y , our swap function from above can actually work: #include <stdio.h> void swap ( int * a , int * b ); // we use * throughout to point to the real integer, not the copy int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( & x , & y ); // address of x and y printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; } The addresses of x and y are passed in from main to swap , and we use the int *a syntax to declare that our swap function takes in pointers. We save the value of x to tmp by following the pointer a , and then take the value of y by following the pointer b , and store that to the location a is pointing to ( x ). Finally, we store the value of tmp to the location pointed to by b ( y ), and we\u2019re done. If we call malloc too many times, we will have a heap overflow , where we end up going past our heap. Or, if we have too many functions being called, we will have a stack overflow , where our stack has too many frames of memory allocated as well. And these two types of overflow are generally known as buffer overflows, after which our program (or entire computer) might crash. get_int We can implement get_int ourselve with a C library function, scanf : #include <stdio.h> int main ( void ) { int x ; printf ( \"x: \" ); scanf ( \"%i\" , & x ); printf ( \"x: %i \\n \" , x ); } scanf takes a format, %i , so the input is \u201cscanned\u201d for that format, and the address in memory where we want that input to go. But scanf doesn\u2019t have much error checking, so we might not get an integer. We can try to get a string the same way: #include <stdio.h> int main ( void ) { char * s = NULL ; printf ( \"s: \" ); scanf ( \"%s\" , s ); printf ( \"s: %s \\n \" , s ); } But we haven\u2019t actually allocated any memory for s ( s is NULL , or not pointing to anything), so we might want to call char s[5] to allocate an array of 5 characters for our string. Then, s will be treated as a pointer in scanf and printf . Now, if the user types in a string of length 4 or less, our program will work safely. But if the user types in a longer string, scanf might be trying to write past the end of our array into unknown memory, causing our program to crash. File Pointers The ability to read data from and write data to files is the primary means of storing persistent data , data that does not disappear when your program stops running. The abstraction of files that C provides is implemented in a data structure known as a FILE . Almost universally when working with files, we will be using pointers to them, FILE* . Some of the most common file input/output (I/O) functions that we will be working with are: fopen() , fclose() , fgetc() , fputc() , fread() , and fwrite() . fopen() opens a file and returns a file pointer to it. It always checks the return value to make sure you don't get back NULL. fclose() closes the file pointed to by the given file pointer. fgetc() reads and returns the next character from the file pointed to. Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fputc() writes or appends the specified character to the pointed-to file. Note: the operation of the file pointer must be \"w\" for write or \"a\" for append, or you will have an error. fread() reads <qty> units of size <size> from the file pointed to and stores them in memory in a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fwrite() writes <qty> units of size <size> to the file pointed to by reading them from a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"w\" for write or \"a\" for append, or you will suffer an error. With the ability to use pointers, we can also open files: #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { // Open file FILE * file = fopen ( \"phonebook.csv\" , \"a\" ); // Get strings from user char * name = get_string ( \"Name: \" ); char * number = get_string ( \"Number: \" ); // Print (write) strings to file fprintf ( file , \"%s,%s \\n \" , name , number ); // Close file fclose ( file ); } fopen is a new function we can use to open a file. It will return a pointer to a new type, FILE , that we can read from and write to. The first argument is the name of the file, and the second argument is the mode we want to open the file in ( r for read, w for write, and a for append, or adding to). After we get some strings, we can use fprintf to print to a file. Finally, we close the file with fclose . Now we can create our own CSV files, files of comma-separated values (like a mini-spreadsheet), programmatically. JPEG We can also write a program that opens a file and tells us if it\u2019s a JPEG (image) file: #include <stdio.h> int main ( int argc , char * argv []) { // Check usage if ( argc != 2 ) { return 1 ; } // Open file FILE * file = fopen ( argv [ 1 ], \"r\" ); if ( ! file ) { return 1 ; } // Read first three bytes unsigned char bytes [ 3 ]; fread ( bytes , 3 , 1 , file ); // Check first three bytes if ( bytes [ 0 ] == 0xff && bytes [ 1 ] == 0xd8 && bytes [ 2 ] == 0xff ) { printf ( \"Maybe \\n \" ); } else { printf ( \"No \\n \" ); } // Close file fclose ( file ); } Now, if we run this program with ./jpeg brian.jpg , our program will try to open the file we specify (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with fread . We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they\u2019re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they\u2019re not the same, we know it\u2019s definitely not a JPEG file. We can use these abilities to read and write files, in particular images, and modify them by changing the bytes in them, in this week\u2019s problem set!","title":"Memory Overview"},{"location":"c-memory/#memory","text":"In previous weeks, we have discussed binary. We have also covered how each byte has an address, or identifier, so we can refer to where our variables are actually stored. It turns out, by convention, the addresses for memory use the counting system hexadecimal , where there are 16 digits (0-9 and A-F). In binary ( base-2 ), each digit stood for a power of 2: 128 64 32 16 8 4 2 1 1 1 1 1 1 1 1 1 With 8 bits, we can count up to 255. Hexadecimal ( base-16 ) is a much more concise way to express the data on a computer's system. Hexadecimal is displayed as follows: 0 1 2 3 4 5 6 7 8 9 A B C D E F . Just like binary has place values (1, 2, 4, 8...) and decimal has place values (1, 10, 100, 1000...), hexadecimal does too. Hexadecimal's place values are by the power of 16. For example, if we were to look at the hex number 0x397, it would be as follows: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x 3 9 7 So the above number would be (3 x 256) + (9 x 16) + 7 = 919. Another example that uses alphanumeric hex characters: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x A D C This would look like (10 x 256) + (13 x 16) + 12 = 2780 in decimal form. Here, the F is a value of 15 in decimal, and each place is a power of 16, so the first F is 16^1 * 15 = 240, plus the second F with the value of 16^0 * 15 = 15, for a total of 255. Here is a quick chart to compare decimal, hexadecimal, and binary: The RGB color system also conventionally uses hexadecimal to describe the amount of each color. For example, 000000 in hexadecimal means 0 of each red, green, and blue, for a color of black. And FF0000 would be 255, or the highest possible, amount of red. With different values for each color, we can represent millions of different colors. In writing, we can also indicate a value is in hexadecimal by prefixing it with 0x , as in 0x10 , where the value is equal to 16 in decimal, as opposed to 10. 0x means nothing to a computer, this is simply to help humans see when hexadecimal will be used.","title":"Memory"},{"location":"c-memory/#pointers","text":"Pointers provide an alternative way to pass data between functions. Up until this point we have passed all data by value, which means we have only passed a copy of that data. If we use pointers instead, we have the power to pass the actual variable itself. That means that if a change is made in one function, it can impact what happens in other functions. Let's create a small program that prints out a value of n : #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , n ); } In our computer's memory, there are now 4 bytes somewhere that have the binary value of 50, labeled n . The bytes for the variable n will start at a unique address and may look something like 0x12345678 . In C, we can actually see the address with the & operator, which means \"get the address of this variable\": #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%p \\n \" , & n ); // notice the %p and & here } When this program was run, I received the result 0x7ffe5878a42c . The address of a variable is called a pointer , which we can think of as a value that \"points\" to a location in the memory. The * operator lets us \"go to\" the location that a pointer is point to. For example, we can print *&n , where we \"go to\" the address of n and print out the value of n , 50 . The * is known as the deference operator . It \"goes to the reference\" and access that data at that location, allowing you to manipulate it at will. #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , *& n ); // notice the *&n here } We also have to use the * operator (in an unfortunately confusing way) to declare a variable that we want to be a pointer: #include <stdio.h> int main ( void ) { int n = 50 ; int * p = & n ; // declaring the pointer variable printf ( \"%p \\n \" , p ); } Here, we use int *p to declare a variable, p , that has the type of * , a pointer, to a value of type int , an integer. Then, we can print its value (something like 0x12345678 ), or print the value at its location with printf(\"%i\\n\", *p); . In our computer\u2019s memory, the variables might look like this (each square representing a byte of memory): We have a pointer, p , with the address of some variable. We can abstract away the actual value of the addresses now, since they\u2019ll be different as we declare variables in our programs, and simply think of p as \u201cpointing at\u201d some value: An easier way to look at this is if we have a mailbox labeled \"123\", with the number \"50\" inside it. The mailbox would be int n , since it stores an integer. We might have another mailbox with the address \u201c456\u201d, inside of which is the value \u201c123\u201d, which is the address of our other mailbox. This would be int *p , since it\u2019s a pointer to an integer. A pointer , then, is a data item whose value is a memory address type describes the data located at that memory address The simplest pointer available to us in C is the NULL pointer. As you might expect, this pointer points to nothing (a fact which can actually come in handy). When you create a pointer and you don't set its value immediately, you should always set the value of the pointer to NULL.","title":"Pointers"},{"location":"c-memory/#string","text":"Let's use a variable string s for a name like EMMA for an example. We should be able to access each character in EMMA with s[0] - s[4] : It actually turns out that each character is stored in memory at a byte with some address, and s is actually just a pointer with the address of the first character: Because s is just a pointer to the beginning, only the \\0 indicates the end of the string. In fact, the CS50 Library defines a string with typedef char *string , which just says that we want to name a new type, string , as a char * , or a pointer to a character. #include <stdio.h> int main ( void ) { char * s = \"EMMA\" ; // notice how we are no longer using string, we are using char *s printf ( \"%s \\n \" , s ); }","title":"string"},{"location":"c-memory/#compare-and-copy","text":"Let's create a quick program to compare integers: #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two integers int i = get_int ( \"i: \" ); int j = get_int ( \"j: \" ); // Compare integers if ( i == j ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } We can compile and run this, and our program works as we\u2019d expect, with the same values of the two integers giving us \u201cSame\u201d and different values \u201cDifferent\u201d. Now let's try the same thing, but using strings instead of integers: #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two strings string s = get_string ( \"s: \" ); string t = get_string ( \"t: \" ); // Compare strings' addresses if ( s == t ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } If we run the above program we will see that it will give us the result \"Different\" each time, even when the strings are identical. Why does this happen? Simply, this is caused by how C stores strings in memory. When these are compared, C looks at the addresses of the stings, not the user input data. The strings are stored in different places of memory (pointers), which will return different hexadecimal results when compared. Now let's look at how we can copy strings. Let's make a simple program: #include <cs50.h> #include <ctype.h> #include <stdio.h> int main ( void ) { string s = get_string ( \"s: \" ); string t = s ; // copies string s to string t (but only as an address) t [ 0 ] = toupper ( t [ 0 ]); // capitalizes string t // Print string twice printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We get a string s , and copy the value of s into t . Then, we capitalize the first letter in t . But when we run our program, we see that both s and t are now capitalized. Since we set s and t to the same values, they\u2019re actually pointers to the same character, and so we capitalized the same character! To actually make a copy of a string, we have to do a little more work: #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <string.h> // needed for strlen (string length) int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); // malloc is \"memory allocate\" to store the copy for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) // we need n+1 for the null character in a string { t [ i ] = s [ i ]; // copies strings } t [ 0 ] = toupper ( t [ 0 ]); // capitalizes the first character of the string printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We create a new variable, t , of the type char * , with char *t . Now, we want to point it to a new chunk of memory that\u2019s large enough to store the copy of the string. With malloc , we can allocate some number of bytes in memory (that aren\u2019t already used to store other values), and we pass in the number of bytes we\u2019d like. We already know the length of s , so we add 1 to that for the terminating null character. So, our final line of code is char *t = malloc(strlen(s) + 1); . Then, we copy each character, one at a time, and now we can capitalize just the first letter of t . And we use i < n + 1 , since we actually want to go up to n , to ensure we copy the terminating character in the string. We can actually also use the strcpy library function with strcpy(t, s) instead of our loop, to copy the string s into t . To be clear, the concept of a \u201cstring\u201d is from the C language and well-supported; the only training wheels from CS50 are the type string instead of char * , and the get_string function. If we didn\u2019t copy the null terminating character, \\0 , and tried to print out our string t , printf will continue and print out the unknown, or garbage, values that we have in memory, until it happens to reach a \\0 , or crashes entirely, since our program might end up trying to read memory that doesn\u2019t belong to it!","title":"Compare and Copy"},{"location":"c-memory/#valgrind","text":"It turns out that, after we\u2019re done with memory that we\u2019ve allocated with malloc , we should call free (as in free(t) ), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again. If we kept running our program and allocating memory with malloc , but never freed the memory after we were done using it, we would have a memory leak , which will slow down our computer and use up more and more memory until our computer runs out. valgrind is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with help50 valgrind ./*program* and see, from the error message, that line 10, we allocated memory that we never freed (or \u201clost\u201d). So at the end, we can add a line free(t) , which won\u2019t change how our program runs, but no errors from valgrind. Let's look at an example program provided from valgrind's official documentation: // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare #include <stdlib.h> void f ( void ) { int * x = malloc ( 10 * sizeof ( int )); x [ 10 ] = 0 ; // this int [10] is not in the correct range (0-9) and will result in a buffer overflow } int main ( void ) { f (); return 0 ; } The function f allocates enough memory for 10 integers, and stores the address in a pointer called x . Then we try to set the 11 th value of x with x[10] to 0 , which goes past the array of memory we\u2019ve allocated for our program. This is called buffer overflow , where we go past the boundaries of our buffer, or array, and into unknown memory. valgrind will also tell us there\u2019s an \u201cInvalid write of size 4\u201d for line 8, where we are indeed trying to change the value of an integer (of size 4 bytes).","title":"valgrind"},{"location":"c-memory/#swap","text":"We have two colored drinks, purple and green, each of which is in a cup. We want to swap the drinks between the two cups, but we can\u2019t do that without a third cup (temporary variable) to pour one of the drink into first. Now, let\u2019s say we wanted to swap the values of two integers. void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } With a third variable to use as temporary storage space, we can do this pretty easily, by putting a into tmp , and then b to a , and finally the original value of a , now in tmp , into b . But, if we tried to use that function in a program, we don\u2019t see any changes: #include <stdio.h> void swap ( int a , int b ); int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( x , y ); printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } This does not work because the swap function successfully swaps int a and int b , but these are simply copies of int x and int y . When x and y are printed, the copies used by the swap funciton do not alter the actual x and y integers in the main function.","title":"Swap"},{"location":"c-memory/#memory-layout","text":"Within our computer\u2019s memory, the different types of data that need to be stored for our program are organized into different sections: The machine code section is our compiled program\u2019s binary code. When we run our program, that code is loaded into the \u201ctop\u201d of memory. Globals are global variables we declare in our program or other shared variables that our entire program can access. The heap section is an empty area where malloc can get free memory from, for our program to use. The stack section is used by functions in our program as they are called. For example, our main function is at the very bottom of the stack, and has the local variables x and y . The swap function, when it\u2019s called, has its own frame, or slice, of memory that\u2019s on top of main \u2019s, with the local variables a , b , and tmp : Once the function swap returns, the memory it was using is freed for the next function call, and we lose anything we did, other than the return values, and our program goes back to the function that called swap . So by passing in the addresses of x and y from main to swap , we can actually change the values of x and y : By passing in the address of x and y , our swap function from above can actually work: #include <stdio.h> void swap ( int * a , int * b ); // we use * throughout to point to the real integer, not the copy int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( & x , & y ); // address of x and y printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; } The addresses of x and y are passed in from main to swap , and we use the int *a syntax to declare that our swap function takes in pointers. We save the value of x to tmp by following the pointer a , and then take the value of y by following the pointer b , and store that to the location a is pointing to ( x ). Finally, we store the value of tmp to the location pointed to by b ( y ), and we\u2019re done. If we call malloc too many times, we will have a heap overflow , where we end up going past our heap. Or, if we have too many functions being called, we will have a stack overflow , where our stack has too many frames of memory allocated as well. And these two types of overflow are generally known as buffer overflows, after which our program (or entire computer) might crash.","title":"Memory Layout"},{"location":"c-memory/#get_int","text":"We can implement get_int ourselve with a C library function, scanf : #include <stdio.h> int main ( void ) { int x ; printf ( \"x: \" ); scanf ( \"%i\" , & x ); printf ( \"x: %i \\n \" , x ); } scanf takes a format, %i , so the input is \u201cscanned\u201d for that format, and the address in memory where we want that input to go. But scanf doesn\u2019t have much error checking, so we might not get an integer. We can try to get a string the same way: #include <stdio.h> int main ( void ) { char * s = NULL ; printf ( \"s: \" ); scanf ( \"%s\" , s ); printf ( \"s: %s \\n \" , s ); } But we haven\u2019t actually allocated any memory for s ( s is NULL , or not pointing to anything), so we might want to call char s[5] to allocate an array of 5 characters for our string. Then, s will be treated as a pointer in scanf and printf . Now, if the user types in a string of length 4 or less, our program will work safely. But if the user types in a longer string, scanf might be trying to write past the end of our array into unknown memory, causing our program to crash.","title":"get_int"},{"location":"c-memory/#file-pointers","text":"The ability to read data from and write data to files is the primary means of storing persistent data , data that does not disappear when your program stops running. The abstraction of files that C provides is implemented in a data structure known as a FILE . Almost universally when working with files, we will be using pointers to them, FILE* . Some of the most common file input/output (I/O) functions that we will be working with are: fopen() , fclose() , fgetc() , fputc() , fread() , and fwrite() . fopen() opens a file and returns a file pointer to it. It always checks the return value to make sure you don't get back NULL. fclose() closes the file pointed to by the given file pointer. fgetc() reads and returns the next character from the file pointed to. Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fputc() writes or appends the specified character to the pointed-to file. Note: the operation of the file pointer must be \"w\" for write or \"a\" for append, or you will have an error. fread() reads <qty> units of size <size> from the file pointed to and stores them in memory in a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fwrite() writes <qty> units of size <size> to the file pointed to by reading them from a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"w\" for write or \"a\" for append, or you will suffer an error. With the ability to use pointers, we can also open files: #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { // Open file FILE * file = fopen ( \"phonebook.csv\" , \"a\" ); // Get strings from user char * name = get_string ( \"Name: \" ); char * number = get_string ( \"Number: \" ); // Print (write) strings to file fprintf ( file , \"%s,%s \\n \" , name , number ); // Close file fclose ( file ); } fopen is a new function we can use to open a file. It will return a pointer to a new type, FILE , that we can read from and write to. The first argument is the name of the file, and the second argument is the mode we want to open the file in ( r for read, w for write, and a for append, or adding to). After we get some strings, we can use fprintf to print to a file. Finally, we close the file with fclose . Now we can create our own CSV files, files of comma-separated values (like a mini-spreadsheet), programmatically.","title":"File Pointers"},{"location":"c-memory/#jpeg","text":"We can also write a program that opens a file and tells us if it\u2019s a JPEG (image) file: #include <stdio.h> int main ( int argc , char * argv []) { // Check usage if ( argc != 2 ) { return 1 ; } // Open file FILE * file = fopen ( argv [ 1 ], \"r\" ); if ( ! file ) { return 1 ; } // Read first three bytes unsigned char bytes [ 3 ]; fread ( bytes , 3 , 1 , file ); // Check first three bytes if ( bytes [ 0 ] == 0xff && bytes [ 1 ] == 0xd8 && bytes [ 2 ] == 0xff ) { printf ( \"Maybe \\n \" ); } else { printf ( \"No \\n \" ); } // Close file fclose ( file ); } Now, if we run this program with ./jpeg brian.jpg , our program will try to open the file we specify (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with fread . We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they\u2019re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they\u2019re not the same, we know it\u2019s definitely not a JPEG file. We can use these abilities to read and write files, in particular images, and modify them by changing the bytes in them, in this week\u2019s problem set!","title":"JPEG"},{"location":"c-variable-scope/","text":"Variables and Scope Variable Scope Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; } Why do local and global distinctions matter? For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Variables and Scope"},{"location":"c-variable-scope/#variables-and-scope","text":"","title":"Variables and Scope"},{"location":"c-variable-scope/#variable-scope","text":"Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; }","title":"Variable Scope"},{"location":"c-variable-scope/#why-do-local-and-global-distinctions-matter","text":"For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Why do local and global distinctions matter?"},{"location":"c/","text":"C Basics Basic Data Types int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\"). Creating a Variable To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ; Using a Variable After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment Operators In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==). Conditional Statements Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); } Loops Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled. First Code #include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename* Hello, *name*! Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); } Mario Problem Set Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n - 1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } } Cash Problem Set When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { loat dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"C Basics"},{"location":"c/#c-basics","text":"","title":"C Basics"},{"location":"c/#basic-data-types","text":"int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\").","title":"Basic Data Types"},{"location":"c/#creating-a-variable","text":"To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ;","title":"Creating a Variable"},{"location":"c/#using-a-variable","text":"After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment","title":"Using a Variable"},{"location":"c/#operators","text":"In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==).","title":"Operators"},{"location":"c/#conditional-statements","text":"Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); }","title":"Conditional Statements"},{"location":"c/#loops","text":"Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled.","title":"Loops"},{"location":"c/#first-code","text":"#include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename*","title":"First Code"},{"location":"c/#hello-name","text":"Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); }","title":"Hello, *name*!"},{"location":"c/#mario-problem-set","text":"Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n - 1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } }","title":"Mario Problem Set"},{"location":"c/#cash-problem-set","text":"When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { loat dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"Cash Problem Set"},{"location":"chrome/","text":"What is Google Chrome? Google Chrome Overview Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"What is Google Chrome?"},{"location":"chrome/#what-is-google-chrome","text":"","title":"What is Google Chrome?"},{"location":"chrome/#google-chrome-overview","text":"Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"Google Chrome Overview"},{"location":"chromeinstall/","text":"How to Install Google Chrome Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"Google Chrome Install"},{"location":"chromeinstall/#how-to-install-google-chrome","text":"Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"How to Install Google Chrome"},{"location":"chromemedia/","text":"Google Chrome Media Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"chromemedia/#google-chrome-media","text":"Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"glossary/","text":"Below is a list of key words and their definitions: Bookmark - A bookmark is a saved shortcut that directs your browser to a specific webpage. It stores the title, URL, and favicon of the corresponding page. Saving bookmarks allows you to easily access your favorite locations on the Web. Browser - Software programs that enable you to view web pages and other documents on the Internet. They \"translate\" HTML-encoded files into the text, images, sounds, and other features you see. Google Chrome is a browser. Cache - In browsers, \"cache\" is used to identify a space where web pages you have visited are stored in your computer. A copy of documents you retrieve is stored in cache. When you use GO, BACK, or any other means to revisit a document, the browser first checks to see if it is in cache and will retrieve it from there because it is much faster than retrieving it from the server. Cookie - An HTTP cookie is a small piece of data sent from a website and stored on the user's computer by the user's web browser while the user is browsing. Cookies were designed to be a reliable mechanism for websites to remember stateful information or to record the user's browsing activity. Extension - Extensions are small software programs that customize the browsing experience. They enable users to tailor Chrome functionality and behavior to individual needs or preferences. They are built on web technologies such as HTML, JavaScript, and CSS. HTML - HTML stands for Hyper Text Markup Language. HTML is the standard markup language for Web pages, which are the building blocks of most web pages. Link - A link (short for hyperlink) is an HTML object that allows you to jump to a new location when you click or tap it. Links are found on almost every webpage and provide a simple means of navigating between pages on the web. Links can be attached to text, images, or other HTML elements. URL - URL stands for Uniform Resource Locator. A URL is nothing more than the address of a given unique resource on the Web (e.g. website, page, or file). In theory, each valid URL points to a unique resource.","title":"Glossary"},{"location":"portfolio/","text":"Nicholas Platt's Portfolio Resume Portfolio Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types. Images Custom Keyboard PCB with Switch Slot Callouts Example 2 Example 3 Example 4 Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Main Portfolio"},{"location":"portfolio/#nicholas-platts-portfolio","text":"","title":"Nicholas Platt's Portfolio"},{"location":"portfolio/#resume","text":"","title":"Resume"},{"location":"portfolio/#portfolio","text":"Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types.","title":"Portfolio"},{"location":"portfolio/#images","text":"Custom Keyboard PCB with Switch Slot Callouts Example 2 Example 3 Example 4","title":"Images"},{"location":"portfolio/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Contact"}]}