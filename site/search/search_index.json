{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Nick's Docs This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here . Portfolio Quick Links: Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018) SoccerFront.io - Web Application Project (2020) Programming Notes C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures Python Python Basics Variables and Simple Data Types Lists Working with Lists If Statements Dictionaries User Input and while Loops Functions Classes Random Programs SQL SQL Basics Joins and Other Query Types SQL Random Problems JavaScript JavaScript Basics Misc. Notes APIs Overview Django Azure C++ Coming Soon! Go Coming Soon! R Coming Soon! Quick Links IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Home"},{"location":"#welcome-to-nicks-docs","text":"This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here .","title":"Welcome to Nick's Docs "},{"location":"#portfolio-quick-links","text":"Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018) SoccerFront.io - Web Application Project (2020)","title":"Portfolio Quick Links:"},{"location":"#programming-notes","text":"C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures Python Python Basics Variables and Simple Data Types Lists Working with Lists If Statements Dictionaries User Input and while Loops Functions Classes Random Programs SQL SQL Basics Joins and Other Query Types SQL Random Problems JavaScript JavaScript Basics Misc. Notes APIs Overview Django Azure C++ Coming Soon! Go Coming Soon! R Coming Soon!","title":"Programming Notes"},{"location":"#quick-links","text":"IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Quick Links"},{"location":"about/","text":"About About Me Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I plan on obtaining a Master's in Software Engineering in the near future. I have basic knowledge in HTML, CSS, JavaScript, Python, SQL, Markdown, and C (hopefully more to come in the near future). Outside of work, I love watching European soccer (Go Bayern!), building keyboards, and spending time with my wife and pup. If you have any questions, please feel free to reach out to me through the contact info below. Random Projects .center{ text-align: center; } Soccerfront.io Soccerfront.io is a soccer live score web application that I built using Nodejs, Expressjs, HTML, CSS, and JavaScript. Soccerfront pulls data from the API-FOOTBALL API and displays the information in a easy to use live score table and league table (standings) view. This is an ongoing project and new features will be added sporadically. Custom Keyboard Builds Below are some keyboards I have built! Custom Keyboards Canoe PC - Gateron Ink Yellow Custom Acrylic - Gateron Ink Blacks TX-87 - C\u00b3Equalz X TKC Banana Splits Satisfaction 75 - Zealios V2 K75 - Gateron Ink Blacks Mysterium - Kailh Purple Pro Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn lightGallery(document.getElementById('lightgallery'));","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#about-me","text":"Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I plan on obtaining a Master's in Software Engineering in the near future. I have basic knowledge in HTML, CSS, JavaScript, Python, SQL, Markdown, and C (hopefully more to come in the near future). Outside of work, I love watching European soccer (Go Bayern!), building keyboards, and spending time with my wife and pup. If you have any questions, please feel free to reach out to me through the contact info below.","title":"About Me"},{"location":"about/#random-projects","text":".center{ text-align: center; }","title":"Random Projects"},{"location":"about/#soccerfrontio","text":"Soccerfront.io is a soccer live score web application that I built using Nodejs, Expressjs, HTML, CSS, and JavaScript. Soccerfront pulls data from the API-FOOTBALL API and displays the information in a easy to use live score table and league table (standings) view. This is an ongoing project and new features will be added sporadically.","title":"Soccerfront.io"},{"location":"about/#custom-keyboard-builds","text":"Below are some keyboards I have built! Custom Keyboards Canoe PC - Gateron Ink Yellow Custom Acrylic - Gateron Ink Blacks TX-87 - C\u00b3Equalz X TKC Banana Splits Satisfaction 75 - Zealios V2 K75 - Gateron Ink Blacks Mysterium - Kailh Purple Pro","title":"Custom Keyboard Builds"},{"location":"about/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn lightGallery(document.getElementById('lightgallery'));","title":"Contact"},{"location":"api/","text":"Introduction to APIs Quick Links API Introduction Docs Working with Web APIs (Online Book) Overview An API (Application Programming Interface) is a way for different machines and software to talk to each other to create ever more complex applications. It is a contract of sorts: it defines how it is expected to be used and what you can expect to receive by using it. When most people hear the acronym API, they most likely are thinking about web-based APIs, which is completely understandable. You must also know about the many APIs that are built into all modern programming languages. For example, let's say you wanted to capitalize a string of text. We could write a long code to translate each individual letter to the uppercase version through low level bitmath OR we could use the uppercase API: Python 'yeet!' . upper () # YEET! JavaScript 'yeet!' . toUpperCase (); // YEET! Java \"yeet!\" . toUpperCase (); // YEET! Basically, programmers use APIs to avoid recreating the wheel. APIs assist us in accomplishing tasks that we need to perform, by abstracting away a ton of work for us. Remote APIs The above examples we gave were local APIs, built into the programming language. Remote APIs can be looked at similarly to your TV's remote. You work with the interface on the remote to make changes to the TV, as if you were using the interface on the device itself. Its not just physical objects that benefit from remote APIs. Sometimes, we don't have space on our local machines for all the data that is available. For example, when we use an app like Shazam to find out what song is playing, the app doesn't store ALL the songs in the world on your phone; it instead uses a remote API to send data to the app serice for indentification. Remote APIs also offer another benefit of computational power. Because an API removes the limitations of your local machine, you can gain access to huge amounts of computational power. A good example of this is the AR feature in the Google Translate app. The app allows you to use the camera on your phone to translate what you are seeing directly to your screen in near real-time. This app requires a ton of computational power and it is getting it elsewhere (through cloud computing). REST ( RE presentational S tate T ransfer) The struggle to achieve the concept of remote APIs was very real. The biggest problem was that there was no standard that everyone loved. Overtime, a clear winner came forward that offered a clean and universally-accepted format, REST. The popularity of REST spread so rapidly that it nearly took over the word API (think how XEROX almost took over the term photocopy). REST is not the end-all, be-all of remote APIs, but it is one of the most common and documented solution. The following notes will cover the REST framework! RESTful When APIs embrace the styles and constraints of REST, they are said to be RESTful. Here are the guiding architectural constraints for an API to be considered RESTful: Client-Server Architecture Statelessness Layered System Cacheability Uniform Design Code on Demand Let's cover these topics by discussing how APIs sit on top of web technology. Much like the web, the client (web browser/program) makes a request to a server. Your program will most likely be using some type of library to create the request to the server. The protocol used for these requests are through HTTP and it is stateless (the server won't remember anything about the particular client (state can be maintained through headers)). This request was almost certainly requesting information about a resource. The \"resource\" is a little absract, it is the R in U R L or U R I. We use the term resource to reference an object, which is also abstract. This is because we can use resources to describe just about anything we build. For example, let's imagine an e-book store website. Each book available for purchase is a resource. If we click into it, we may see a link to the author, which is also a resource. When we click on a resource the browser sends a GET request to the server. The RESTful API follows the same logic; your program will send a GET request to a URI (Uniform Resource Identifier), then the server responds with data. The body of the data returned is typically represented today as JSON (JavaScript Object Notation). JSON provides a great way to structure and nest the data. Here are a few HTTP verbs that are used in REST APIs to clearly state the intention of your request: HTTP Verbs CRUD (Create, Read, Update, Delete) GET Read POST Create PUT Update PATCH Update DELETE Delete Want to add an author? POST to the /authors and send them the data you want to update in the body of your request: POST /au t hors/ { au t hor_Name : \"Dave Eggers\" } Want to remove an author? Send a DELETE to that specific author: DELETE /au t hors/ { HBWSG 123 } This means that you can interact with any application out there that exposes their REST API. Exploring an API Online Let's look at a real API online and see what we can learn. For this, we are going to be looking at Spotify's API . Here we can see all the different features that Spotify allows user's to use in their API. Let's go down to the Search section and read the documentation . We can click on the API beta link at the top and then look for the \"Search for an Item\" link. This documentation explains the \"contract\" of what we need to do in order to use the API. In this documentation we can see which type of headers and query parameters in the request are required or optional for the API to work. You can also see the types of reponses your request can receive. Reading the documentation for APIs is perhaps the most important step in implementing an API in your code. You will see notes from the programmers on how to actually make it work! Let's work with Spotify's Web Console , which allows us to test their APIs and play around with the different features. The Console will show us where it will query: GET https://api.spotify.com/v1/search and how it will query: curl -X \"GET\" \"https://api.spotify.com/v1/search?q=Palace&type=artist&market=US&limit=2\" -H \"Accept: application/json\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer BQBBI2LYRwSAZ__Agy0GV0BU_i3adk4b4Wsv7eQbfsgdOJUn0HJDgCJpF3v6g_oJ6rcZjOeEdVVz4FrIKZWoAixqhEhJYtqByw0jQfC5ZMHq-wqJACdyrQ7sIQlpeZXemL2jGhfa728ckA9\" If we break down the above API GET request, we can see that we are searching for ?q=Palace&type=artist along with some other bits. I have limited the results to 2 ( &limit=2 ) in order to keep the result set small. You can also see the Bearer OAuth token at the end, which I have changed in order for my account to remain anonymous. If we run this in the Console, we will get a result that looks something like the following: { \"artists\" : { \"href\" : \"https://api.spotify.com/v1/search?query=Palace&type=artist&market=US&offset=0&limit=2\" , \"items\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"followers\" : { \"href\" : null , \"total\" : 107224 }, \"genres\" : [ \"english indie rock\" , \"indie soul\" , \"vapor soul\" ], \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/8b76736404ceb4bc72669f44908dea557ab03083\" , \"width\" : 640 }, { \"height\" : 320 , \"url\" : \"https://i.scdn.co/image/0c135b9e55b911a37b7aee00af60630c777d4c04\" , \"width\" : 320 }, { \"height\" : 160 , \"url\" : \"https://i.scdn.co/image/79c30a9ba1518749fb74cc449bcaa060f8aa8151\" , \"width\" : 160 } ], \"name\" : \"Palace\" , \"popularity\" : 59 , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" }, { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/37J1PlAkhRK7yrZUtqaUpQ\" }, \"followers\" : { \"href\" : null , \"total\" : 716429 }, \"genres\" : [ \"electro swing\" , \"nu jazz\" ], \"href\" : \"https://api.spotify.com/v1/artists/37J1PlAkhRK7yrZUtqaUpQ\" , \"id\" : \"37J1PlAkhRK7yrZUtqaUpQ\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/adc8c619e766119fabd784a257d6376a653d41ea\" , \"width\" : 640 }, { \"height\" : 320 , \"url\" : \"https://i.scdn.co/image/65df61829bfdb02f7e068de1b3c28799bdc5ace6\" , \"width\" : 320 }, { \"height\" : 160 , \"url\" : \"https://i.scdn.co/image/e86351da17029aa21616d98104bbc6f3c61109d7\" , \"width\" : 160 } ], \"name\" : \"Caravan Palace\" , \"popularity\" : 67 , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:37J1PlAkhRK7yrZUtqaUpQ\" } ], \"limit\" : 2 , \"next\" : \"https://api.spotify.com/v1/search?query=Palace&type=artist&market=US&offset=2&limit=2\" , \"offset\" : 0 , \"previous\" : null , \"total\" : 448 } } Above you can see the response from the Search API of Spotify. There is some interesting information in here, including the artists unique artist identifier ( 48vDIufGC8ujPuBiTxY8dm for my favorite band Palace), as well as the popularity, folowers, genres, and links to images. Let's take that artist id and plug it into the \"Get an Artist's Top Tracks\" API. JSON Response { \"tracks\" : [ { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 249840 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603029\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/2H30WL3exSctlDC9GyRbD4\" }, \"href\" : \"https://api.spotify.com/v1/tracks/2H30WL3exSctlDC9GyRbD4\" , \"id\" : \"2H30WL3exSctlDC9GyRbD4\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Live Well\" , \"popularity\" : 64 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/516b9622373316d4ebbfd4baab240a8217b01952?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 3 , \"type\" : \"track\" , \"uri\" : \"spotify:track:2H30WL3exSctlDC9GyRbD4\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/2gnr57XaEBXSDlfbkowBP8\" }, \"href\" : \"https://api.spotify.com/v1/albums/2gnr57XaEBXSDlfbkowBP8\" , \"id\" : \"2gnr57XaEBXSDlfbkowBP8\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273287d57f51a9220e1b972d576\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02287d57f51a9220e1b972d576\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851287d57f51a9220e1b972d576\" , \"width\" : 64 } ], \"name\" : \"Life After\" , \"release_date\" : \"2019-07-12\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:2gnr57XaEBXSDlfbkowBP8\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 437577 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71806918\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/3Rl26h1HiMCV0HFHHVb2IM\" }, \"href\" : \"https://api.spotify.com/v1/tracks/3Rl26h1HiMCV0HFHHVb2IM\" , \"id\" : \"3Rl26h1HiMCV0HFHHVb2IM\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Heaven Up There\" , \"popularity\" : 58 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9bfd400bc1701508933e11dd88edbaa3743e726e?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 11 , \"type\" : \"track\" , \"uri\" : \"spotify:track:3Rl26h1HiMCV0HFHHVb2IM\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 233360 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603022\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/2DkZisoN9h1dLa8Sn5sx0n\" }, \"href\" : \"https://api.spotify.com/v1/tracks/2DkZisoN9h1dLa8Sn5sx0n\" , \"id\" : \"2DkZisoN9h1dLa8Sn5sx0n\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Bitter\" , \"popularity\" : 58 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/df18b5b91c3b46589dc1bbca26fbdfd895028995?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 2 , \"type\" : \"track\" , \"uri\" : \"spotify:track:2DkZisoN9h1dLa8Sn5sx0n\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/161a4wcY3Lh9xN8OEF0RMr\" }, \"href\" : \"https://api.spotify.com/v1/albums/161a4wcY3Lh9xN8OEF0RMr\" , \"id\" : \"161a4wcY3Lh9xN8OEF0RMr\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b27390912ce0aad8b575d3cd1b50\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e0290912ce0aad8b575d3cd1b50\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d0000485190912ce0aad8b575d3cd1b50\" , \"width\" : 64 } ], \"name\" : \"Someday, Somewhere\" , \"release_date\" : \"2020-07-17\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:161a4wcY3Lh9xN8OEF0RMr\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 192461 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM72002794\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/75Ibf9kajH52v2uBNc7pkp\" }, \"href\" : \"https://api.spotify.com/v1/tracks/75Ibf9kajH52v2uBNc7pkp\" , \"id\" : \"75Ibf9kajH52v2uBNc7pkp\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Someday, Somewhere\" , \"popularity\" : 55 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9a45e9861c165c1c653f1f54b9049f7033134bd7?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:75Ibf9kajH52v2uBNc7pkp\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/0LyecvMmiD3grsZtkEQQJM\" }, \"href\" : \"https://api.spotify.com/v1/albums/0LyecvMmiD3grsZtkEQQJM\" , \"id\" : \"0LyecvMmiD3grsZtkEQQJM\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273ca84a453df6f486114bcc774\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02ca84a453df6f486114bcc774\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851ca84a453df6f486114bcc774\" , \"width\" : 64 } ], \"name\" : \"Veins\" , \"release_date\" : \"2014-07-15\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:0LyecvMmiD3grsZtkEQQJM\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 269974 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400017\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/1UsXMQwIzCKSk6oIdRE5Jc\" }, \"href\" : \"https://api.spotify.com/v1/tracks/1UsXMQwIzCKSk6oIdRE5Jc\" , \"id\" : \"1UsXMQwIzCKSk6oIdRE5Jc\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Veins\" , \"popularity\" : 52 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/69efa6483c01ab1c3bd323d7a71287aa9b126317?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:1UsXMQwIzCKSk6oIdRE5Jc\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/1SJbZWC9jhrR1m4fDYP1ys\" }, \"href\" : \"https://api.spotify.com/v1/albums/1SJbZWC9jhrR1m4fDYP1ys\" , \"id\" : \"1SJbZWC9jhrR1m4fDYP1ys\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273f490d80a7841c5bd61a4f694\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02f490d80a7841c5bd61a4f694\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851f490d80a7841c5bd61a4f694\" , \"width\" : 64 } ], \"name\" : \"Bitter\" , \"release_date\" : \"2014-08-11\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:1SJbZWC9jhrR1m4fDYP1ys\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 234674 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400014\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/6xxy4SktborcH1wRjISek5\" }, \"href\" : \"https://api.spotify.com/v1/tracks/6xxy4SktborcH1wRjISek5\" , \"id\" : \"6xxy4SktborcH1wRjISek5\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Bitter\" , \"popularity\" : 48 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/36eda2cdf0d31e8b694552159d012fc677296af1?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:6xxy4SktborcH1wRjISek5\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/50lmuZTx1lNcNFjY2cr3HB\" }, \"href\" : \"https://api.spotify.com/v1/albums/50lmuZTx1lNcNFjY2cr3HB\" , \"id\" : \"50lmuZTx1lNcNFjY2cr3HB\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273e84adb5bc350142cb67a5656\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02e84adb5bc350142cb67a5656\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851e84adb5bc350142cb67a5656\" , \"width\" : 64 } ], \"name\" : \"Lost in the Night\" , \"release_date\" : \"2014-10-20\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 5 , \"type\" : \"album\" , \"uri\" : \"spotify:album:50lmuZTx1lNcNFjY2cr3HB\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 242430 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400015\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/6wimdClggXbqamkhOsyRQ9\" }, \"href\" : \"https://api.spotify.com/v1/tracks/6wimdClggXbqamkhOsyRQ9\" , \"id\" : \"6wimdClggXbqamkhOsyRQ9\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"I Want What You Got\" , \"popularity\" : 47 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9c7ba3c471bfaa2fe5ff68ca87402fa8e65ee80f?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 2 , \"type\" : \"track\" , \"uri\" : \"spotify:track:6wimdClggXbqamkhOsyRQ9\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 246893 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71602810\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/23uCHFc7xcQWgXh2oelMOe\" }, \"href\" : \"https://api.spotify.com/v1/tracks/23uCHFc7xcQWgXh2oelMOe\" , \"id\" : \"23uCHFc7xcQWgXh2oelMOe\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Have Faith\" , \"popularity\" : 46 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/634c490bc66b42bc99b7637b0abfb24b47853214?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 7 , \"type\" : \"track\" , \"uri\" : \"spotify:track:23uCHFc7xcQWgXh2oelMOe\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 305040 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603024\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/0s2mDwSz2RvcHE3DYhSkL2\" }, \"href\" : \"https://api.spotify.com/v1/tracks/0s2mDwSz2RvcHE3DYhSkL2\" , \"id\" : \"0s2mDwSz2RvcHE3DYhSkL2\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"So Long Forever\" , \"popularity\" : 45 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/257b17e1ea6c76bce48e02bdf416c8c6600a65e8?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 8 , \"type\" : \"track\" , \"uri\" : \"spotify:track:0s2mDwSz2RvcHE3DYhSkL2\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 198013 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603030\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/3SJI20YW5l5Ri1etVIx1Vo\" }, \"href\" : \"https://api.spotify.com/v1/tracks/3SJI20YW5l5Ri1etVIx1Vo\" , \"id\" : \"3SJI20YW5l5Ri1etVIx1Vo\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Holy Smoke\" , \"popularity\" : 45 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/636cebb17ae17e216bfb39cb276ba29a21003ffb?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 10 , \"type\" : \"track\" , \"uri\" : \"spotify:track:3SJI20YW5l5Ri1etVIx1Vo\" } ] } Here we can see information about their top songs, including name, release date, total tracks, type, direct URI, if it is explicit, the popularity, the track number, and much more. It even includes a link to a preview URL ! This is a great example of a layered system because the results are not rendered on every request! The results can be cached because artist data doesn't update very often. Using an API from the Command Line Let's try making an API request from our own command line, not a website! Let's use a different API this time, one from Twilio . We will be working with the \"Programmable Messaging\" API. Let's click on \"build\" and try sending a message to our phone number from the website. We can do this by adding whatever we want in the \"Body\" section and then clicking on \"Make Request\". You should now receive a text message with whatever you wrote. Let's take this a step further and open a terminal. Let's make a Python program first to interact with this API and send the message: 1 2 3 4 5 6 7 8 9 10 11 12 from twilio.rest import Client account_sid = 'AC504e58232220f1698dbf3c144af87g2z' #these have been changed for security auth_token = '261209ecabd9de3cec413a4b458a423za' client = Client ( account_sid , auth_token ) message = client . messages . create ( from_ = '+12057654321' , to = '+19091234567' ) print ( message . sid ) After running the above Python program, we should get a response like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"sid\" : \"SM55d7040dd06b4c33a19b38863843acea\" , \"date_created\" : \"Wed, 02 Sep 2020 17:41:14 +0000\" , \"date_updated\" : \"Wed, 02 Sep 2020 17:41:14 +0000\" , \"date_sent\" : null , \"account_sid\" : \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"to\" : \"+19091234567\" , \"from\" : \"+12057654321\" , \"messaging_service_sid\" : null , \"body\" : \"Sent from your Twilio trial account - Hello!\" , \"status\" : \"queued\" , \"num_segments\" : \"1\" , \"num_media\" : \"0\" , \"direction\" : \"outbound-api\" , \"api_version\" : \"2010-04-01\" , \"price\" : null , \"price_unit\" : \"USD\" , \"error_code\" : null , \"error_message\" : null , \"uri\" : \"/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages/SM55d7040dd06b4c33a19b38863843acea.json\" , \"subresource_uris\" : { \"media\" : \"/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages/SM55d7040dd06b4c33a19b38863843acea/Media.json\" } } Or an error message telling you what went wrong. We can also do this as a cURL command: curl 'https://api.twilio.com/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages.json' -X POST \\ --data-urlencode 'To=+19091234567' \\ --data-urlencode 'From=+12057654321' \\ --data-urlencode 'Body=Hello!' \\ -u AC504e58232220f1698dbf3c115a8ggt52:[AuthToken] If it worked, you should see the message pop up on a verifed phone! Using Postman to Explore APIs Postman is a feature rich tool that helps users explore new APIs. We can use either the browser application or the desktop application for the following. Let's click on \"Create a New Collection\", which keeps all request that we make grouped together. Let's recreate the calls we made to the Twilio API from above. Let's name the collection \"Twilio\" and click \"Create\". It should now show up in the collections area on the left sidebar. Click on the Twilio collection and then \"Add requests\". We can name the Request \"Message Log\", and add a descriptive description like the following: All messages sent from my account. [Twilio Documentation](https://www.twilio.com/docs/sms/api/message-resource?code-sample=code-read-list-all-messages&code-language=Node.js&code-sdk-version=3.x) It is best practice to reference to the parent documentation whenever using an API for ease of access. Now, let's click on the new GET request we have created to open it in the Launchpad. We can now grab the URL from the Twilio cURL GET request from earlier: https://api.twilio.com/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages.json Before we click \"Send\", we need to make sure we include our auth for Twilio in the \"Authorization\" in Postman. We also need to add some variables in the \"Variables\" tab, specifically TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN . We can now use these variables in the authorization tab with {{TWILIO_ACCOUNT_SID}} in the username field and {{TWILIO_AUTH_TOKEN}} in the password field. Now let's click \"Send\". We should get a response with an array filled out will our previous message body, to/from info, date/time, etc. POST Request on Postman Let's create another request within the Twilio collection titled \"Create a message\". Remember to put a description with a link to the documentation! After creating the request, let's open it and change GET to POST in the dropdown menu. We will need to look through the documentation on how to implement this request and make it follow the API's rules. First, ets fill in the URL: https://api.twilio.com/2010-04-01/Accounts/{{TWILIO_ACCOUNT_SID}}/Messages.json Notice how we used the {{TWILIO_ACCOUNT_SID}} instead of the long id from the last request we made. Now in the Body tab, lets add a to key with a value of the number you want to message. Next, let's create a body key with whatever text you want to be sent. We also need to add a from key with our {{TWILIO_NUMBER}} (we can add this to the credentials tab). Now when we click \"Send\", a message should be sent to the verified number of your choice. Using Helper Libraries in JavaScript In order to avoid writing repitive code, we can use helper libraries or SDKs Software Development Kits). SDKs are unique to each programming language and help make your code more concise and legible. We are going to start out by working with Node . Node.js is an open-source, cross-platform, JavaScript runtime environment that executes JavaScript code outside of a web browser. After installing Node, we can open a command prompt and type in the command node -v to check what version of Node is loaded. If an error occurs, Node is not installed properly on your machine. First, let's create a new directory to work inside with the mkdir scratch command. In that directory let's make a directory called javascript with the mkdir javascript command. Lets open this folder in Visual Studio Code (VS Code) and create a new file called explore.js in the javascript folder. Let's open the terminal in VS Code and install the twilio library with the following command: npm install twilio Now that we have downloaded the file, let's write some code in the explore.js file we made earlier: 1 2 3 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); The two variables we using in the string are are account SID and Auth Token. The problem with this is whenever we upload or share this with anyone, our account credentials are right there to be seen. Later, we will put these into environment variables, but for now, we will stick with this for ease of demonstration. The Twilio JS Client works like most JavaScript libraries. It is asynchronous, and it relies on a concept called promises . The way promises work is that there are set handlers for when a method call completes. To get our message log, we would use the following method (line 5): 1 2 3 4 5 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list (); The client.messages.list() method returns an object called a promise. It is a promise of a future value, which in this case will be our messages. Promises have an important method on them, and it's called then . We can chain on a .then to the end of the method (this method should also be given a function that accepts a value). To pass messages a function, we use something called a fat arrow function (see below). In the .then method, we will put the name of the value ( messages ), because this is what we are expecting to return. Next we are going to put a fat arrow => , followed by the function body. Fat Arrow Functions \" Fat arrow functions \" are a more concise syntax for writing function expressions. They utilize a new token, => , that looks like a fat arrow. Arrow functions are anonymous and change the way this binds in functions. By using arrow functions, we avoid having to type the function keyword, return keyword (it\u2019s implicit in arrow functions), and curly brackets. Let's simply log out the most recent message. To do that we add: 1 2 3 4 5 6 7 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` )); Finally, we will add a console.log to show that this is running asynchronously: 1 2 3 4 5 6 7 8 9 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` )); console . log ( 'Gathering your message log.' ); Now when we run the following command in a terminal: node explore.js We should get the following response: Gathering your message log. The most recent message is: Sent from your Twilio trial account - Hello! If your file errored out, you would see the following response: Gathering your message log. Let's catch any error that may occur and display what the error was: 1 2 3 4 5 6 7 8 9 10 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` ) ). catch ( err => console . error ( err )); console . log ( 'Gathering your message log.' ); Let's remove one character from our account SID from the code and try running to file again. We should see the following response: Gathering your message log. RestException [Error]: The requested resource /2010-04-01/Accounts/AC504e58232220f1698dbf3c1169ef0d8/Messages.json was not found at MessagePage.Page.processResponse (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\base\\Page.js:156:11) at MessagePage.Page (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\base\\Page.js:16:22) at new MessagePage (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\rest\\api\\v2010\\account\\message.js:467:30) at Function.<anonymous> (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\rest\\api\\v2010\\account\\message.js:360:24) at Promise_then_fulfilled (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:766:44) at Promise_done_fulfilled (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:835:31) at Fulfilled_dispatch [as dispatch] (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:1229:9) at Pending_become_eachMessage_task (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:1369:30) at RawTask.call (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\asap\\asap.js:40:19) at flush (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\asap\\raw.js:50:29) { status: 404, code: 20404, moreInfo: 'https://www.twilio.com/docs/errors/20404', details: undefined } Using Helper Libraries in Python In that same scratch directory that we created earlier, let's create a new directory called python. Next, let's create a file called explore.py . Finally, let's install the Twilio helper library by running the following code: pip install twilio Now that the Twilio library is installed we can begin working on the explore.py file. Let's print out the messages we have sent out: 1 2 3 4 5 6 7 8 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) for msg in client . messages . list (): print ( msg . body ) You should get the following result: Sent from your Twilio trial account - Hello! Sent from your Twilio trial account - Test 123! Let's go a little bit deeper and write some code to actually send a message in Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) msg = client . messages . create ( to = \"+19091234567\" , from_ = \"+12057654321\" , body = \"hello from Python!\" ) print ( f \"Created a new message: { msg . sid } .\" ) After running this, our phone should receive a text message and we will get the following return in the terminal: Created a new message: SMb3f7a74a5e754437acf9c7eecfded389. Now let's run the get messages code from earlier to see if it shows up! Sent from your Twilio trial account - Hello from Python! Sent from your Twilio trial account - Hello! Sent from your Twilio trial account - Test 123! Now let's delete ALL messages that we have sent from our Twilio account. This is fairly simple code: 1 2 3 4 5 6 7 8 9 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) for msg in client . messages . list (): print ( f \"Deleting { msg . body } \" ) msg . delete () It will now show all the messages it is deleting: Deleting Sent from your Twilio trial account - Hello from Python! Deleting Sent from your Twilio trial account - Hello! Deleting Sent from your Twilio trial account - Test 123! These helper libraries are able to extract out the HTTP calls we would have had to code out for us! Flask Application Build Let's build a simple Complimenter application! This application will take a name and phone number to compliment and the sender's name and compliment to be sent. To do this, we are going to use Flask. Flask is a web framework that provides an API that let's you extend the framework to create your application. This application is going to be doing server-side rendering, which means that pages will only be created on the server-side and any change/navigation will require a full reload. We are going to be using Glitch to provide a free web server for this project. Let's create an account and click on \"New Project\" \"Clone Git Repo\". We're going to use the following repo . If we click on \"Tools\" \"Log\", we will see all logs of setup and a URL to our local server. If you click on \"Show\" in the top, we can see a preview of our code! We will start with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import os from dotenv import load_dotenv from flask import ( Flask , flash , render_template , redirect , request , url_for , ) from twilio.rest import Client load_dotenv () app = Flask ( __name__ ) app . secret_key = \"ssssh don't tell anyone\" TWILIO_PHONE_NUMBER = os . getenv ( 'TWILIO_PHONE_NUMBER' ) #This pulls our phone number from the .env file from the repo. Make sure to replace the account SID, Auth Token, and Phone number client = Client () def get_sent_messages (): messages = client . messages . list ( from_ = TWILIO_PHONE_NUMBER ) return messages def send_message ( to , body ): client . messages . create ( to = to , from_ = TWILIO_PHONE_NUMBER , body = body ) @app . route ( \"/\" , methods = [ \"GET\" ]) def index (): messages = get_sent_messages () return render_template ( \"index.html\" , messages = messages ) @app . route ( \"/add-compliment\" , methods = [ \"POST\" ]) def add_compliment (): sender = request . values . get ( 'sender' , 'Someone' ) receiver = request . values . get ( 'receiver' , 'Someone' ) compliment = request . values . get ( 'compliment' , 'wonderful' ) to = request . values . get ( 'to' ) body = f ' { sender } says: { receiver } is { compliment } . See more compliments at { request . url_root } ' send_message ( to , body ) flash ( 'Your message was successfully sent' ) return redirect ( url_for ( 'index' )) if __name__ == '__main__' : app . run () We used similar code from above sections to both the get_sent_messages() and send_message functions. Dealing with API Limits API developers need to consider the possiblity of their APIs being hammered by hundreds of thousands or even millions of requests in a short amount of time. The web server may not be able to handle these requests and crash. In order to prevent this, API developers have to code limits or throttle the number of queries possible by each user. For example, Twilio limits the numbers you can text to verified numbers (at least in the Trial version). If we attempt to text a number a message using our Complimentr application that is not verified we will get a long traceback error in the logs. If we look at these logs, we will see that we receive an HTTP 400 error: Unable to create record: The number is unverified... . Being aware of an API's limits can help you better plan your development. JavaScript Single Page Application Now let's try to implement the previous Complimentr application using only JavaScript. For this, we are going to use a full-stack JavaScript application. Full-stack means that the server code and front-end application is written in JS. On the server side, the application uses Node.js and the web framework Express. On the front-end, we will use the client-side framework Vue. Let's use the following repo . The JS version of the Complimentr app is implemented as a Very Simple Single Page Application (SPA). This mean that once the page is loaded, the client will be responsible for rendering parts of the page. We won't need to rely on a full page reload from the server each time something changes. Let's take a look at app.js (the server-side of our application) from the repo. require ( \"dotenv\" ). config (); const express = require ( \"express\" ); const bodyParser = require ( \"body-parser\" ); const app = express (); const port = 3000 ; // This is a single page application and it's all rendered in public/index.html app . use ( express . static ( \"public\" )); // Parse the body of requests automatically app . use ( bodyParser . json ()); app . get ( \"/api/compliments\" , async ( req , res ) => { // TODO: Get a list of messages sent from a specific number const sentMessages = []; // TODO: Gather only the body of those messages for sending to the client const compliments = []; res . json ( compliments ); }); app . post ( \"/api/compliments\" , async ( req , res ) => { const to = req . body . to ; const from = process . env . TWILIO_PHONE_NUMBER ; const body = ` ${ req . body . sender } says: ${ req . body . receiver } is ${ req . body . compliment } . See more compliments at ${ req . headers . referer } ` ; // TODO: Send a message res . json ({ success : false }); }); app . listen ( port , () => console . log ( `Prototype is listening on port ${ port } !` ));","title":"API Overview"},{"location":"api/#introduction-to-apis","text":"","title":"Introduction to APIs"},{"location":"api/#quick-links","text":"API Introduction Docs Working with Web APIs (Online Book)","title":"Quick Links"},{"location":"api/#overview","text":"An API (Application Programming Interface) is a way for different machines and software to talk to each other to create ever more complex applications. It is a contract of sorts: it defines how it is expected to be used and what you can expect to receive by using it. When most people hear the acronym API, they most likely are thinking about web-based APIs, which is completely understandable. You must also know about the many APIs that are built into all modern programming languages. For example, let's say you wanted to capitalize a string of text. We could write a long code to translate each individual letter to the uppercase version through low level bitmath OR we could use the uppercase API: Python 'yeet!' . upper () # YEET! JavaScript 'yeet!' . toUpperCase (); // YEET! Java \"yeet!\" . toUpperCase (); // YEET! Basically, programmers use APIs to avoid recreating the wheel. APIs assist us in accomplishing tasks that we need to perform, by abstracting away a ton of work for us.","title":"Overview"},{"location":"api/#remote-apis","text":"The above examples we gave were local APIs, built into the programming language. Remote APIs can be looked at similarly to your TV's remote. You work with the interface on the remote to make changes to the TV, as if you were using the interface on the device itself. Its not just physical objects that benefit from remote APIs. Sometimes, we don't have space on our local machines for all the data that is available. For example, when we use an app like Shazam to find out what song is playing, the app doesn't store ALL the songs in the world on your phone; it instead uses a remote API to send data to the app serice for indentification. Remote APIs also offer another benefit of computational power. Because an API removes the limitations of your local machine, you can gain access to huge amounts of computational power. A good example of this is the AR feature in the Google Translate app. The app allows you to use the camera on your phone to translate what you are seeing directly to your screen in near real-time. This app requires a ton of computational power and it is getting it elsewhere (through cloud computing).","title":"Remote APIs"},{"location":"api/#rest-representational-state-transfer","text":"The struggle to achieve the concept of remote APIs was very real. The biggest problem was that there was no standard that everyone loved. Overtime, a clear winner came forward that offered a clean and universally-accepted format, REST. The popularity of REST spread so rapidly that it nearly took over the word API (think how XEROX almost took over the term photocopy). REST is not the end-all, be-all of remote APIs, but it is one of the most common and documented solution. The following notes will cover the REST framework! RESTful When APIs embrace the styles and constraints of REST, they are said to be RESTful. Here are the guiding architectural constraints for an API to be considered RESTful: Client-Server Architecture Statelessness Layered System Cacheability Uniform Design Code on Demand Let's cover these topics by discussing how APIs sit on top of web technology. Much like the web, the client (web browser/program) makes a request to a server. Your program will most likely be using some type of library to create the request to the server. The protocol used for these requests are through HTTP and it is stateless (the server won't remember anything about the particular client (state can be maintained through headers)). This request was almost certainly requesting information about a resource. The \"resource\" is a little absract, it is the R in U R L or U R I. We use the term resource to reference an object, which is also abstract. This is because we can use resources to describe just about anything we build. For example, let's imagine an e-book store website. Each book available for purchase is a resource. If we click into it, we may see a link to the author, which is also a resource. When we click on a resource the browser sends a GET request to the server. The RESTful API follows the same logic; your program will send a GET request to a URI (Uniform Resource Identifier), then the server responds with data. The body of the data returned is typically represented today as JSON (JavaScript Object Notation). JSON provides a great way to structure and nest the data. Here are a few HTTP verbs that are used in REST APIs to clearly state the intention of your request: HTTP Verbs CRUD (Create, Read, Update, Delete) GET Read POST Create PUT Update PATCH Update DELETE Delete Want to add an author? POST to the /authors and send them the data you want to update in the body of your request: POST /au t hors/ { au t hor_Name : \"Dave Eggers\" } Want to remove an author? Send a DELETE to that specific author: DELETE /au t hors/ { HBWSG 123 } This means that you can interact with any application out there that exposes their REST API.","title":"REST (REpresentational State Transfer)"},{"location":"api/#exploring-an-api-online","text":"Let's look at a real API online and see what we can learn. For this, we are going to be looking at Spotify's API . Here we can see all the different features that Spotify allows user's to use in their API. Let's go down to the Search section and read the documentation . We can click on the API beta link at the top and then look for the \"Search for an Item\" link. This documentation explains the \"contract\" of what we need to do in order to use the API. In this documentation we can see which type of headers and query parameters in the request are required or optional for the API to work. You can also see the types of reponses your request can receive. Reading the documentation for APIs is perhaps the most important step in implementing an API in your code. You will see notes from the programmers on how to actually make it work! Let's work with Spotify's Web Console , which allows us to test their APIs and play around with the different features. The Console will show us where it will query: GET https://api.spotify.com/v1/search and how it will query: curl -X \"GET\" \"https://api.spotify.com/v1/search?q=Palace&type=artist&market=US&limit=2\" -H \"Accept: application/json\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer BQBBI2LYRwSAZ__Agy0GV0BU_i3adk4b4Wsv7eQbfsgdOJUn0HJDgCJpF3v6g_oJ6rcZjOeEdVVz4FrIKZWoAixqhEhJYtqByw0jQfC5ZMHq-wqJACdyrQ7sIQlpeZXemL2jGhfa728ckA9\" If we break down the above API GET request, we can see that we are searching for ?q=Palace&type=artist along with some other bits. I have limited the results to 2 ( &limit=2 ) in order to keep the result set small. You can also see the Bearer OAuth token at the end, which I have changed in order for my account to remain anonymous. If we run this in the Console, we will get a result that looks something like the following: { \"artists\" : { \"href\" : \"https://api.spotify.com/v1/search?query=Palace&type=artist&market=US&offset=0&limit=2\" , \"items\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"followers\" : { \"href\" : null , \"total\" : 107224 }, \"genres\" : [ \"english indie rock\" , \"indie soul\" , \"vapor soul\" ], \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/8b76736404ceb4bc72669f44908dea557ab03083\" , \"width\" : 640 }, { \"height\" : 320 , \"url\" : \"https://i.scdn.co/image/0c135b9e55b911a37b7aee00af60630c777d4c04\" , \"width\" : 320 }, { \"height\" : 160 , \"url\" : \"https://i.scdn.co/image/79c30a9ba1518749fb74cc449bcaa060f8aa8151\" , \"width\" : 160 } ], \"name\" : \"Palace\" , \"popularity\" : 59 , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" }, { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/37J1PlAkhRK7yrZUtqaUpQ\" }, \"followers\" : { \"href\" : null , \"total\" : 716429 }, \"genres\" : [ \"electro swing\" , \"nu jazz\" ], \"href\" : \"https://api.spotify.com/v1/artists/37J1PlAkhRK7yrZUtqaUpQ\" , \"id\" : \"37J1PlAkhRK7yrZUtqaUpQ\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/adc8c619e766119fabd784a257d6376a653d41ea\" , \"width\" : 640 }, { \"height\" : 320 , \"url\" : \"https://i.scdn.co/image/65df61829bfdb02f7e068de1b3c28799bdc5ace6\" , \"width\" : 320 }, { \"height\" : 160 , \"url\" : \"https://i.scdn.co/image/e86351da17029aa21616d98104bbc6f3c61109d7\" , \"width\" : 160 } ], \"name\" : \"Caravan Palace\" , \"popularity\" : 67 , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:37J1PlAkhRK7yrZUtqaUpQ\" } ], \"limit\" : 2 , \"next\" : \"https://api.spotify.com/v1/search?query=Palace&type=artist&market=US&offset=2&limit=2\" , \"offset\" : 0 , \"previous\" : null , \"total\" : 448 } } Above you can see the response from the Search API of Spotify. There is some interesting information in here, including the artists unique artist identifier ( 48vDIufGC8ujPuBiTxY8dm for my favorite band Palace), as well as the popularity, folowers, genres, and links to images. Let's take that artist id and plug it into the \"Get an Artist's Top Tracks\" API. JSON Response { \"tracks\" : [ { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 249840 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603029\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/2H30WL3exSctlDC9GyRbD4\" }, \"href\" : \"https://api.spotify.com/v1/tracks/2H30WL3exSctlDC9GyRbD4\" , \"id\" : \"2H30WL3exSctlDC9GyRbD4\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Live Well\" , \"popularity\" : 64 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/516b9622373316d4ebbfd4baab240a8217b01952?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 3 , \"type\" : \"track\" , \"uri\" : \"spotify:track:2H30WL3exSctlDC9GyRbD4\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/2gnr57XaEBXSDlfbkowBP8\" }, \"href\" : \"https://api.spotify.com/v1/albums/2gnr57XaEBXSDlfbkowBP8\" , \"id\" : \"2gnr57XaEBXSDlfbkowBP8\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273287d57f51a9220e1b972d576\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02287d57f51a9220e1b972d576\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851287d57f51a9220e1b972d576\" , \"width\" : 64 } ], \"name\" : \"Life After\" , \"release_date\" : \"2019-07-12\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:2gnr57XaEBXSDlfbkowBP8\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 437577 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71806918\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/3Rl26h1HiMCV0HFHHVb2IM\" }, \"href\" : \"https://api.spotify.com/v1/tracks/3Rl26h1HiMCV0HFHHVb2IM\" , \"id\" : \"3Rl26h1HiMCV0HFHHVb2IM\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Heaven Up There\" , \"popularity\" : 58 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9bfd400bc1701508933e11dd88edbaa3743e726e?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 11 , \"type\" : \"track\" , \"uri\" : \"spotify:track:3Rl26h1HiMCV0HFHHVb2IM\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 233360 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603022\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/2DkZisoN9h1dLa8Sn5sx0n\" }, \"href\" : \"https://api.spotify.com/v1/tracks/2DkZisoN9h1dLa8Sn5sx0n\" , \"id\" : \"2DkZisoN9h1dLa8Sn5sx0n\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Bitter\" , \"popularity\" : 58 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/df18b5b91c3b46589dc1bbca26fbdfd895028995?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 2 , \"type\" : \"track\" , \"uri\" : \"spotify:track:2DkZisoN9h1dLa8Sn5sx0n\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/161a4wcY3Lh9xN8OEF0RMr\" }, \"href\" : \"https://api.spotify.com/v1/albums/161a4wcY3Lh9xN8OEF0RMr\" , \"id\" : \"161a4wcY3Lh9xN8OEF0RMr\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b27390912ce0aad8b575d3cd1b50\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e0290912ce0aad8b575d3cd1b50\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d0000485190912ce0aad8b575d3cd1b50\" , \"width\" : 64 } ], \"name\" : \"Someday, Somewhere\" , \"release_date\" : \"2020-07-17\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:161a4wcY3Lh9xN8OEF0RMr\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 192461 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM72002794\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/75Ibf9kajH52v2uBNc7pkp\" }, \"href\" : \"https://api.spotify.com/v1/tracks/75Ibf9kajH52v2uBNc7pkp\" , \"id\" : \"75Ibf9kajH52v2uBNc7pkp\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Someday, Somewhere\" , \"popularity\" : 55 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9a45e9861c165c1c653f1f54b9049f7033134bd7?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:75Ibf9kajH52v2uBNc7pkp\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/0LyecvMmiD3grsZtkEQQJM\" }, \"href\" : \"https://api.spotify.com/v1/albums/0LyecvMmiD3grsZtkEQQJM\" , \"id\" : \"0LyecvMmiD3grsZtkEQQJM\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273ca84a453df6f486114bcc774\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02ca84a453df6f486114bcc774\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851ca84a453df6f486114bcc774\" , \"width\" : 64 } ], \"name\" : \"Veins\" , \"release_date\" : \"2014-07-15\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:0LyecvMmiD3grsZtkEQQJM\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 269974 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400017\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/1UsXMQwIzCKSk6oIdRE5Jc\" }, \"href\" : \"https://api.spotify.com/v1/tracks/1UsXMQwIzCKSk6oIdRE5Jc\" , \"id\" : \"1UsXMQwIzCKSk6oIdRE5Jc\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Veins\" , \"popularity\" : 52 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/69efa6483c01ab1c3bd323d7a71287aa9b126317?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:1UsXMQwIzCKSk6oIdRE5Jc\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/1SJbZWC9jhrR1m4fDYP1ys\" }, \"href\" : \"https://api.spotify.com/v1/albums/1SJbZWC9jhrR1m4fDYP1ys\" , \"id\" : \"1SJbZWC9jhrR1m4fDYP1ys\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273f490d80a7841c5bd61a4f694\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02f490d80a7841c5bd61a4f694\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851f490d80a7841c5bd61a4f694\" , \"width\" : 64 } ], \"name\" : \"Bitter\" , \"release_date\" : \"2014-08-11\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:1SJbZWC9jhrR1m4fDYP1ys\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 234674 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400014\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/6xxy4SktborcH1wRjISek5\" }, \"href\" : \"https://api.spotify.com/v1/tracks/6xxy4SktborcH1wRjISek5\" , \"id\" : \"6xxy4SktborcH1wRjISek5\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Bitter\" , \"popularity\" : 48 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/36eda2cdf0d31e8b694552159d012fc677296af1?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:6xxy4SktborcH1wRjISek5\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/50lmuZTx1lNcNFjY2cr3HB\" }, \"href\" : \"https://api.spotify.com/v1/albums/50lmuZTx1lNcNFjY2cr3HB\" , \"id\" : \"50lmuZTx1lNcNFjY2cr3HB\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273e84adb5bc350142cb67a5656\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02e84adb5bc350142cb67a5656\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851e84adb5bc350142cb67a5656\" , \"width\" : 64 } ], \"name\" : \"Lost in the Night\" , \"release_date\" : \"2014-10-20\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 5 , \"type\" : \"album\" , \"uri\" : \"spotify:album:50lmuZTx1lNcNFjY2cr3HB\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 242430 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400015\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/6wimdClggXbqamkhOsyRQ9\" }, \"href\" : \"https://api.spotify.com/v1/tracks/6wimdClggXbqamkhOsyRQ9\" , \"id\" : \"6wimdClggXbqamkhOsyRQ9\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"I Want What You Got\" , \"popularity\" : 47 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9c7ba3c471bfaa2fe5ff68ca87402fa8e65ee80f?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 2 , \"type\" : \"track\" , \"uri\" : \"spotify:track:6wimdClggXbqamkhOsyRQ9\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 246893 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71602810\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/23uCHFc7xcQWgXh2oelMOe\" }, \"href\" : \"https://api.spotify.com/v1/tracks/23uCHFc7xcQWgXh2oelMOe\" , \"id\" : \"23uCHFc7xcQWgXh2oelMOe\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Have Faith\" , \"popularity\" : 46 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/634c490bc66b42bc99b7637b0abfb24b47853214?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 7 , \"type\" : \"track\" , \"uri\" : \"spotify:track:23uCHFc7xcQWgXh2oelMOe\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 305040 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603024\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/0s2mDwSz2RvcHE3DYhSkL2\" }, \"href\" : \"https://api.spotify.com/v1/tracks/0s2mDwSz2RvcHE3DYhSkL2\" , \"id\" : \"0s2mDwSz2RvcHE3DYhSkL2\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"So Long Forever\" , \"popularity\" : 45 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/257b17e1ea6c76bce48e02bdf416c8c6600a65e8?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 8 , \"type\" : \"track\" , \"uri\" : \"spotify:track:0s2mDwSz2RvcHE3DYhSkL2\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 198013 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603030\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/3SJI20YW5l5Ri1etVIx1Vo\" }, \"href\" : \"https://api.spotify.com/v1/tracks/3SJI20YW5l5Ri1etVIx1Vo\" , \"id\" : \"3SJI20YW5l5Ri1etVIx1Vo\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Holy Smoke\" , \"popularity\" : 45 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/636cebb17ae17e216bfb39cb276ba29a21003ffb?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 10 , \"type\" : \"track\" , \"uri\" : \"spotify:track:3SJI20YW5l5Ri1etVIx1Vo\" } ] } Here we can see information about their top songs, including name, release date, total tracks, type, direct URI, if it is explicit, the popularity, the track number, and much more. It even includes a link to a preview URL ! This is a great example of a layered system because the results are not rendered on every request! The results can be cached because artist data doesn't update very often.","title":"Exploring an API Online"},{"location":"api/#using-an-api-from-the-command-line","text":"Let's try making an API request from our own command line, not a website! Let's use a different API this time, one from Twilio . We will be working with the \"Programmable Messaging\" API. Let's click on \"build\" and try sending a message to our phone number from the website. We can do this by adding whatever we want in the \"Body\" section and then clicking on \"Make Request\". You should now receive a text message with whatever you wrote. Let's take this a step further and open a terminal. Let's make a Python program first to interact with this API and send the message: 1 2 3 4 5 6 7 8 9 10 11 12 from twilio.rest import Client account_sid = 'AC504e58232220f1698dbf3c144af87g2z' #these have been changed for security auth_token = '261209ecabd9de3cec413a4b458a423za' client = Client ( account_sid , auth_token ) message = client . messages . create ( from_ = '+12057654321' , to = '+19091234567' ) print ( message . sid ) After running the above Python program, we should get a response like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"sid\" : \"SM55d7040dd06b4c33a19b38863843acea\" , \"date_created\" : \"Wed, 02 Sep 2020 17:41:14 +0000\" , \"date_updated\" : \"Wed, 02 Sep 2020 17:41:14 +0000\" , \"date_sent\" : null , \"account_sid\" : \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"to\" : \"+19091234567\" , \"from\" : \"+12057654321\" , \"messaging_service_sid\" : null , \"body\" : \"Sent from your Twilio trial account - Hello!\" , \"status\" : \"queued\" , \"num_segments\" : \"1\" , \"num_media\" : \"0\" , \"direction\" : \"outbound-api\" , \"api_version\" : \"2010-04-01\" , \"price\" : null , \"price_unit\" : \"USD\" , \"error_code\" : null , \"error_message\" : null , \"uri\" : \"/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages/SM55d7040dd06b4c33a19b38863843acea.json\" , \"subresource_uris\" : { \"media\" : \"/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages/SM55d7040dd06b4c33a19b38863843acea/Media.json\" } } Or an error message telling you what went wrong. We can also do this as a cURL command: curl 'https://api.twilio.com/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages.json' -X POST \\ --data-urlencode 'To=+19091234567' \\ --data-urlencode 'From=+12057654321' \\ --data-urlencode 'Body=Hello!' \\ -u AC504e58232220f1698dbf3c115a8ggt52:[AuthToken] If it worked, you should see the message pop up on a verifed phone!","title":"Using an API from the Command Line"},{"location":"api/#using-postman-to-explore-apis","text":"Postman is a feature rich tool that helps users explore new APIs. We can use either the browser application or the desktop application for the following. Let's click on \"Create a New Collection\", which keeps all request that we make grouped together. Let's recreate the calls we made to the Twilio API from above. Let's name the collection \"Twilio\" and click \"Create\". It should now show up in the collections area on the left sidebar. Click on the Twilio collection and then \"Add requests\". We can name the Request \"Message Log\", and add a descriptive description like the following: All messages sent from my account. [Twilio Documentation](https://www.twilio.com/docs/sms/api/message-resource?code-sample=code-read-list-all-messages&code-language=Node.js&code-sdk-version=3.x) It is best practice to reference to the parent documentation whenever using an API for ease of access. Now, let's click on the new GET request we have created to open it in the Launchpad. We can now grab the URL from the Twilio cURL GET request from earlier: https://api.twilio.com/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages.json Before we click \"Send\", we need to make sure we include our auth for Twilio in the \"Authorization\" in Postman. We also need to add some variables in the \"Variables\" tab, specifically TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN . We can now use these variables in the authorization tab with {{TWILIO_ACCOUNT_SID}} in the username field and {{TWILIO_AUTH_TOKEN}} in the password field. Now let's click \"Send\". We should get a response with an array filled out will our previous message body, to/from info, date/time, etc.","title":"Using Postman to Explore APIs"},{"location":"api/#post-request-on-postman","text":"Let's create another request within the Twilio collection titled \"Create a message\". Remember to put a description with a link to the documentation! After creating the request, let's open it and change GET to POST in the dropdown menu. We will need to look through the documentation on how to implement this request and make it follow the API's rules. First, ets fill in the URL: https://api.twilio.com/2010-04-01/Accounts/{{TWILIO_ACCOUNT_SID}}/Messages.json Notice how we used the {{TWILIO_ACCOUNT_SID}} instead of the long id from the last request we made. Now in the Body tab, lets add a to key with a value of the number you want to message. Next, let's create a body key with whatever text you want to be sent. We also need to add a from key with our {{TWILIO_NUMBER}} (we can add this to the credentials tab). Now when we click \"Send\", a message should be sent to the verified number of your choice.","title":"POST Request on Postman"},{"location":"api/#using-helper-libraries-in-javascript","text":"In order to avoid writing repitive code, we can use helper libraries or SDKs Software Development Kits). SDKs are unique to each programming language and help make your code more concise and legible. We are going to start out by working with Node . Node.js is an open-source, cross-platform, JavaScript runtime environment that executes JavaScript code outside of a web browser. After installing Node, we can open a command prompt and type in the command node -v to check what version of Node is loaded. If an error occurs, Node is not installed properly on your machine. First, let's create a new directory to work inside with the mkdir scratch command. In that directory let's make a directory called javascript with the mkdir javascript command. Lets open this folder in Visual Studio Code (VS Code) and create a new file called explore.js in the javascript folder. Let's open the terminal in VS Code and install the twilio library with the following command: npm install twilio Now that we have downloaded the file, let's write some code in the explore.js file we made earlier: 1 2 3 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); The two variables we using in the string are are account SID and Auth Token. The problem with this is whenever we upload or share this with anyone, our account credentials are right there to be seen. Later, we will put these into environment variables, but for now, we will stick with this for ease of demonstration. The Twilio JS Client works like most JavaScript libraries. It is asynchronous, and it relies on a concept called promises . The way promises work is that there are set handlers for when a method call completes. To get our message log, we would use the following method (line 5): 1 2 3 4 5 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list (); The client.messages.list() method returns an object called a promise. It is a promise of a future value, which in this case will be our messages. Promises have an important method on them, and it's called then . We can chain on a .then to the end of the method (this method should also be given a function that accepts a value). To pass messages a function, we use something called a fat arrow function (see below). In the .then method, we will put the name of the value ( messages ), because this is what we are expecting to return. Next we are going to put a fat arrow => , followed by the function body. Fat Arrow Functions \" Fat arrow functions \" are a more concise syntax for writing function expressions. They utilize a new token, => , that looks like a fat arrow. Arrow functions are anonymous and change the way this binds in functions. By using arrow functions, we avoid having to type the function keyword, return keyword (it\u2019s implicit in arrow functions), and curly brackets. Let's simply log out the most recent message. To do that we add: 1 2 3 4 5 6 7 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` )); Finally, we will add a console.log to show that this is running asynchronously: 1 2 3 4 5 6 7 8 9 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` )); console . log ( 'Gathering your message log.' ); Now when we run the following command in a terminal: node explore.js We should get the following response: Gathering your message log. The most recent message is: Sent from your Twilio trial account - Hello! If your file errored out, you would see the following response: Gathering your message log. Let's catch any error that may occur and display what the error was: 1 2 3 4 5 6 7 8 9 10 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` ) ). catch ( err => console . error ( err )); console . log ( 'Gathering your message log.' ); Let's remove one character from our account SID from the code and try running to file again. We should see the following response: Gathering your message log. RestException [Error]: The requested resource /2010-04-01/Accounts/AC504e58232220f1698dbf3c1169ef0d8/Messages.json was not found at MessagePage.Page.processResponse (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\base\\Page.js:156:11) at MessagePage.Page (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\base\\Page.js:16:22) at new MessagePage (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\rest\\api\\v2010\\account\\message.js:467:30) at Function.<anonymous> (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\rest\\api\\v2010\\account\\message.js:360:24) at Promise_then_fulfilled (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:766:44) at Promise_done_fulfilled (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:835:31) at Fulfilled_dispatch [as dispatch] (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:1229:9) at Pending_become_eachMessage_task (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:1369:30) at RawTask.call (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\asap\\asap.js:40:19) at flush (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\asap\\raw.js:50:29) { status: 404, code: 20404, moreInfo: 'https://www.twilio.com/docs/errors/20404', details: undefined }","title":"Using Helper Libraries in JavaScript"},{"location":"api/#using-helper-libraries-in-python","text":"In that same scratch directory that we created earlier, let's create a new directory called python. Next, let's create a file called explore.py . Finally, let's install the Twilio helper library by running the following code: pip install twilio Now that the Twilio library is installed we can begin working on the explore.py file. Let's print out the messages we have sent out: 1 2 3 4 5 6 7 8 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) for msg in client . messages . list (): print ( msg . body ) You should get the following result: Sent from your Twilio trial account - Hello! Sent from your Twilio trial account - Test 123! Let's go a little bit deeper and write some code to actually send a message in Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) msg = client . messages . create ( to = \"+19091234567\" , from_ = \"+12057654321\" , body = \"hello from Python!\" ) print ( f \"Created a new message: { msg . sid } .\" ) After running this, our phone should receive a text message and we will get the following return in the terminal: Created a new message: SMb3f7a74a5e754437acf9c7eecfded389. Now let's run the get messages code from earlier to see if it shows up! Sent from your Twilio trial account - Hello from Python! Sent from your Twilio trial account - Hello! Sent from your Twilio trial account - Test 123! Now let's delete ALL messages that we have sent from our Twilio account. This is fairly simple code: 1 2 3 4 5 6 7 8 9 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) for msg in client . messages . list (): print ( f \"Deleting { msg . body } \" ) msg . delete () It will now show all the messages it is deleting: Deleting Sent from your Twilio trial account - Hello from Python! Deleting Sent from your Twilio trial account - Hello! Deleting Sent from your Twilio trial account - Test 123! These helper libraries are able to extract out the HTTP calls we would have had to code out for us!","title":"Using Helper Libraries in Python"},{"location":"api/#flask-application-build","text":"Let's build a simple Complimenter application! This application will take a name and phone number to compliment and the sender's name and compliment to be sent. To do this, we are going to use Flask. Flask is a web framework that provides an API that let's you extend the framework to create your application. This application is going to be doing server-side rendering, which means that pages will only be created on the server-side and any change/navigation will require a full reload. We are going to be using Glitch to provide a free web server for this project. Let's create an account and click on \"New Project\" \"Clone Git Repo\". We're going to use the following repo . If we click on \"Tools\" \"Log\", we will see all logs of setup and a URL to our local server. If you click on \"Show\" in the top, we can see a preview of our code! We will start with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import os from dotenv import load_dotenv from flask import ( Flask , flash , render_template , redirect , request , url_for , ) from twilio.rest import Client load_dotenv () app = Flask ( __name__ ) app . secret_key = \"ssssh don't tell anyone\" TWILIO_PHONE_NUMBER = os . getenv ( 'TWILIO_PHONE_NUMBER' ) #This pulls our phone number from the .env file from the repo. Make sure to replace the account SID, Auth Token, and Phone number client = Client () def get_sent_messages (): messages = client . messages . list ( from_ = TWILIO_PHONE_NUMBER ) return messages def send_message ( to , body ): client . messages . create ( to = to , from_ = TWILIO_PHONE_NUMBER , body = body ) @app . route ( \"/\" , methods = [ \"GET\" ]) def index (): messages = get_sent_messages () return render_template ( \"index.html\" , messages = messages ) @app . route ( \"/add-compliment\" , methods = [ \"POST\" ]) def add_compliment (): sender = request . values . get ( 'sender' , 'Someone' ) receiver = request . values . get ( 'receiver' , 'Someone' ) compliment = request . values . get ( 'compliment' , 'wonderful' ) to = request . values . get ( 'to' ) body = f ' { sender } says: { receiver } is { compliment } . See more compliments at { request . url_root } ' send_message ( to , body ) flash ( 'Your message was successfully sent' ) return redirect ( url_for ( 'index' )) if __name__ == '__main__' : app . run () We used similar code from above sections to both the get_sent_messages() and send_message functions.","title":"Flask Application Build"},{"location":"api/#dealing-with-api-limits","text":"API developers need to consider the possiblity of their APIs being hammered by hundreds of thousands or even millions of requests in a short amount of time. The web server may not be able to handle these requests and crash. In order to prevent this, API developers have to code limits or throttle the number of queries possible by each user. For example, Twilio limits the numbers you can text to verified numbers (at least in the Trial version). If we attempt to text a number a message using our Complimentr application that is not verified we will get a long traceback error in the logs. If we look at these logs, we will see that we receive an HTTP 400 error: Unable to create record: The number is unverified... . Being aware of an API's limits can help you better plan your development.","title":"Dealing with API Limits"},{"location":"api/#javascript-single-page-application","text":"Now let's try to implement the previous Complimentr application using only JavaScript. For this, we are going to use a full-stack JavaScript application. Full-stack means that the server code and front-end application is written in JS. On the server side, the application uses Node.js and the web framework Express. On the front-end, we will use the client-side framework Vue. Let's use the following repo . The JS version of the Complimentr app is implemented as a Very Simple Single Page Application (SPA). This mean that once the page is loaded, the client will be responsible for rendering parts of the page. We won't need to rely on a full page reload from the server each time something changes. Let's take a look at app.js (the server-side of our application) from the repo. require ( \"dotenv\" ). config (); const express = require ( \"express\" ); const bodyParser = require ( \"body-parser\" ); const app = express (); const port = 3000 ; // This is a single page application and it's all rendered in public/index.html app . use ( express . static ( \"public\" )); // Parse the body of requests automatically app . use ( bodyParser . json ()); app . get ( \"/api/compliments\" , async ( req , res ) => { // TODO: Get a list of messages sent from a specific number const sentMessages = []; // TODO: Gather only the body of those messages for sending to the client const compliments = []; res . json ( compliments ); }); app . post ( \"/api/compliments\" , async ( req , res ) => { const to = req . body . to ; const from = process . env . TWILIO_PHONE_NUMBER ; const body = ` ${ req . body . sender } says: ${ req . body . receiver } is ${ req . body . compliment } . See more compliments at ${ req . headers . referer } ` ; // TODO: Send a message res . json ({ success : false }); }); app . listen ( port , () => console . log ( `Prototype is listening on port ${ port } !` ));","title":"JavaScript Single Page Application"},{"location":"azure/","text":"Azure Introduction What is Azure? Azure is Microsoft's cloud computing platform. Azure supports IaaS, PaaS, and SaaS. Services such as VMs, website and database hosting, and AI/Machine Learning. What is cloud computing? Cloud computing is similar to shopping at a store, where you get to pick what products you want. Instead of regular products found in a store, you are able to buy more powerful cloud-based machines (think better CPU, increased storage, more RAM, etc.). Computational power can be added/removed as needed, which saves initial investment cost considerably. Cloud providers also maintain the systems in the background, such as updates, creating backups, and sustain perpetual uptime. Paying for only what you need has many benefits, including: Lower operating costs Run infrastructure more effeciently Scale hardware as needed Simply put, cloud computing allows people to \"rent\" compute power and storage from a providers datacenter, to be used as needed. Main cloud computing benefits : Reliability : Depending on the service agreement with the provider, cloude-based services often provide continuous user experience with no apparent downtime, even when things go wrong. Scalability : Applications in the cloud can be scaled in two different ways: Vertically : Computing capacity increased by adding additional RAM or CPUs. Horizontally : Computing capacity can be increaded by adding instances of a resource, such as additional VMs. Elasticity : Cloud-based applications can be configured to always have the resources needed. Agility : Offers the ability to deploy/reconfigure quickly when requirements change. Geo-distribution : Regional datacenters are usually offered, allowing deployment around the globe, ensuring customers have best performance available. Disaster recover : Backup services, data replication, and geo-distribution means that your data will be safe in the event of a disaster. Cloud Service Models Cloud computing falls into one of the following computing models: Computing Model Description IaaS ( Infrastructure as a Service ) This is the closest computing model to managing physical servers. Operating system and network configuration maintenance is left to the user. One main advantage for IaaS is the rapid deployment of new devices. PaaS ( Platform as a Service ) This computing model is a managed hosting environment. The cloud provider manages the VMs and networking resources, allowing users to deploy applications into the managed hosting environment. SaaS ( Software as a Service ) This computing model is completely managed by the cloud provider, including all aspects of the application environment, VMs, networking resources, data storage, and applications. Only data is needed from the user to run the application. The following image highlights the level of responsibility for the cloud providers and users, based on computing model: What is serverless computing? Overlapping with PaaS, serverless computing allows developers to build applications faster by eliminating the need for them to manage infrastructure. Through serverless computing, the cloud provider automatically provisions, scales, and manages the infrastructure required. Serverless architectures are extremely scalable and event-driven and only use resources when the are requested.","title":"Azure"},{"location":"azure/#azure","text":"","title":"Azure"},{"location":"azure/#introduction","text":"","title":"Introduction"},{"location":"azure/#what-is-azure","text":"Azure is Microsoft's cloud computing platform. Azure supports IaaS, PaaS, and SaaS. Services such as VMs, website and database hosting, and AI/Machine Learning.","title":"What is Azure?"},{"location":"azure/#what-is-cloud-computing","text":"Cloud computing is similar to shopping at a store, where you get to pick what products you want. Instead of regular products found in a store, you are able to buy more powerful cloud-based machines (think better CPU, increased storage, more RAM, etc.). Computational power can be added/removed as needed, which saves initial investment cost considerably. Cloud providers also maintain the systems in the background, such as updates, creating backups, and sustain perpetual uptime. Paying for only what you need has many benefits, including: Lower operating costs Run infrastructure more effeciently Scale hardware as needed Simply put, cloud computing allows people to \"rent\" compute power and storage from a providers datacenter, to be used as needed. Main cloud computing benefits : Reliability : Depending on the service agreement with the provider, cloude-based services often provide continuous user experience with no apparent downtime, even when things go wrong. Scalability : Applications in the cloud can be scaled in two different ways: Vertically : Computing capacity increased by adding additional RAM or CPUs. Horizontally : Computing capacity can be increaded by adding instances of a resource, such as additional VMs. Elasticity : Cloud-based applications can be configured to always have the resources needed. Agility : Offers the ability to deploy/reconfigure quickly when requirements change. Geo-distribution : Regional datacenters are usually offered, allowing deployment around the globe, ensuring customers have best performance available. Disaster recover : Backup services, data replication, and geo-distribution means that your data will be safe in the event of a disaster.","title":"What is cloud computing?"},{"location":"azure/#cloud-service-models","text":"Cloud computing falls into one of the following computing models: Computing Model Description IaaS ( Infrastructure as a Service ) This is the closest computing model to managing physical servers. Operating system and network configuration maintenance is left to the user. One main advantage for IaaS is the rapid deployment of new devices. PaaS ( Platform as a Service ) This computing model is a managed hosting environment. The cloud provider manages the VMs and networking resources, allowing users to deploy applications into the managed hosting environment. SaaS ( Software as a Service ) This computing model is completely managed by the cloud provider, including all aspects of the application environment, VMs, networking resources, data storage, and applications. Only data is needed from the user to run the application. The following image highlights the level of responsibility for the cloud providers and users, based on computing model:","title":"Cloud Service Models"},{"location":"azure/#what-is-serverless-computing","text":"Overlapping with PaaS, serverless computing allows developers to build applications faster by eliminating the need for them to manage infrastructure. Through serverless computing, the cloud provider automatically provisions, scales, and manages the infrastructure required. Serverless architectures are extremely scalable and event-driven and only use resources when the are requested.","title":"What is serverless computing?"},{"location":"c-algorithms-problems/","text":"Algorithm Problems Plurality Problem Now let's take our new knowledge of algorithms and create a program that runs a plurality election that will yield the following output: $ ./plurality Alice Bob Charlie Number of voters: 4 Vote: Alice Vote: Bob Vote: Charlie Vote: Alice Alice Background Elections come in all shapes and sizes. In the UK, the Prime Minister is officially appointed by the monarch, who generally chooses the leader of the political party that wins the most seats in the House of Commons. The United States uses a multi-step Electoral College process where citizens vote on how each state should allocate Electors who then elect the President. Perhaps the simplest way to hold an election, though, is via a method commonly known as the \u201cplurality vote\u201d (also known as \u201cfirst-past-the-post\u201d or \u201cwinner take all\u201d). In the plurality vote, every voter gets to vote for one candidate. At the end of the election, whichever candidate has the greatest number of votes is declared the winner of the election. Getting Started We are going to take the following code and complete the vote and print_winner functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } // Update vote totals given a new vote bool vote ( string name ) { // TODO return false ; } // Print the winner (or winners) of the election void print_winner ( void ) { // TODO return ; } We can make up the following code for the vote and print_winner functions that solves the problem: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } int get_index ( string name ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( name , candidates [ i ]. name ) == 0 ) return i ; } return -1 ; } // Update vote totals given a new vote bool vote ( string name ) { int candidate_index = get_index ( name ); // gets the index for name user inputs if ( candidate_index != -1 ) { candidates [ candidate_index ]. votes ++ ; // increments vote count for each candidate return true ; } return false ; } int get_max ( void ) { int max_votes = candidates [ 0 ]. votes ; for ( int i = 1 ; i < candidate_count ; i ++ ) if ( candidates [ i ]. votes > max_votes ) max_votes = candidates [ i ]. votes ; return max_votes ; } // Print the winner (or winners) of the election void print_winner ( void ) { int max_votes = get_max (); // see who has the most voites for ( int i = 0 ; i < candidate_count ; i ++ ) // prints name of candidate with most votes { if ( candidates [ i ]. votes == max_votes ) printf ( \"%s \\n \" , candidates [ i ]. name ); } } Runoff Now let's take the previous problem and make it a little more intricate. You already know about plurality elections, which follow a very simple algorithm for determining the winner of an election: every voter gets one vote, and the candidate with the most votes wins. But the plurality vote does have some disadvantages. What happens, for instance, in an election with three candidates, and the ballots below are cast? Ballot Ballot Ballot Ballot Ballot Alice Alice Bob Bob Charlie A plurality vote would here declare a tie between Alice and Bob, since each has two votes. But is that the right outcome? There\u2019s another kind of voting system known as a ranked-choice voting system. In a ranked-choice system, voters can vote for more than one candidate. Instead of just voting for their top choice, they can rank the candidates in order of preference. The resulting ballots might therefore look like the below. Ballot Ballot Ballot Ballot Ballot 1.Alice 1.Alice 1.Bob 1.Bob 1.Charlie 2.Bob 2.Charlie 2.Alice 2.Alice 2.Alice 3.Charlie 3.Bob 3.Charlie 3.Charlie 3.Bob Here, each voter, in addition to specifying their first preference candidate, has also indicated their second and third choices. And now, what was previously a tied election could now have a winner. The race was originally tied between Alice and Bob, so Charlie was out of the running. But the voter who chose Charlie preferred Alice over Bob, so Alice could here be declared the winner. One such ranked choice voting system is the instant runoff system. In an instant runoff election, voters can rank as many candidates as they wish. If any candidate has a majority (more than 50%) of the first preference votes, that candidate is declared the winner of the election. Let's look at the following code and see how we can implement this type of voting system. We will need to fill in the correct code for the following functions: vote , tabulate , print_winner , find_min , is_tie , and eliminate . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 #include <cs50.h> #include <stdio.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; int candidate_count ; // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO return ; } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO return 0 ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO return false ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO return ; } Let's take a look at the vote , tabulate , print_winner , find_min , is_tie , and eliminate functions to see what exactly we need to do. vote The function takes arguments voter , rank , and name . If name is a match for the name of a valid candidate, then you should update the global preferences array to indicate that the voter voter has that candidate as their rank preference (where 0 is the first preference, 1 is the second preference, etc.). If the preference is successfully recorded, the function should return true ; the function should return false otherwise (if, for instance, name is not the name of one of the candidates). You may assume that no two candidates will have the same name. tabulate The function should update the number of votes each candidate has at this stage in the runoff. Recall that at each stage in the runoff, every voter effectively votes for their top-preferred candidate who has not already been eliminated. print_winner If any candidate has more than half of the vote, their name should be printed to stdout and the function should return true . If nobody has won the election yet, the function should return false . find_min The function should return the minimum vote total for any candidate who is still in the election. is_tie The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should return true if every candidate remaining in the election has the same number of votes, and should return false otherwise. eliminate The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should eliminate the candidate (or candidates) who have min number of votes. Your program should behave per the example below: ./runoff Alice Bob Charlie Number of voters: 5 Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Charlie Rank 2: Alice Rank 3: Bob Alice The correct code looks as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 #include <cs50.h> #include <stdio.h> #include <string.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; // global variable int candidate_count ; // global variable // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( candidates [ i ]. name , name ) == 0 ) { preferences [ voter ][ rank ] = i ; return true ; } } return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO for ( int i = 0 ; i < voter_count ; i ++ ) { for ( int j = 0 ; j < candidate_count ; j ++ ) // j is rank { int candidate_index = preferences [ i ][ j ]; if ( ! candidates [ candidate_index ]. eliminated ) { candidates [ candidate_index ]. votes ++ ; // update vote count if candidate has not been eliminated break ; } } } } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( candidates [ i ]. votes > ( voter_count / 2 )) // checks to see if one candidate has over half the votes { printf ( \"%s \\n \" , candidates [ i ]. name ); return true ; } } return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO int min = 0 ; // start from zero bool find_first = false ; for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) // see if candidate has been eliminated { if ( ! find_first ) { min = candidates [ i ]. votes ; find_first = true ; } else if ( candidates [ i ]. votes < min ) { min = candidates [ i ]. votes ; } } } return min ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) if ( candidates [ i ]. votes != min ) return false ; } return true ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { if ( candidates [ i ]. votes == min ) candidates [ i ]. eliminated = true ; } } }","title":"Algorithm Problems"},{"location":"c-algorithms-problems/#algorithm-problems","text":"","title":"Algorithm Problems"},{"location":"c-algorithms-problems/#plurality-problem","text":"Now let's take our new knowledge of algorithms and create a program that runs a plurality election that will yield the following output: $ ./plurality Alice Bob Charlie Number of voters: 4 Vote: Alice Vote: Bob Vote: Charlie Vote: Alice Alice Background Elections come in all shapes and sizes. In the UK, the Prime Minister is officially appointed by the monarch, who generally chooses the leader of the political party that wins the most seats in the House of Commons. The United States uses a multi-step Electoral College process where citizens vote on how each state should allocate Electors who then elect the President. Perhaps the simplest way to hold an election, though, is via a method commonly known as the \u201cplurality vote\u201d (also known as \u201cfirst-past-the-post\u201d or \u201cwinner take all\u201d). In the plurality vote, every voter gets to vote for one candidate. At the end of the election, whichever candidate has the greatest number of votes is declared the winner of the election. Getting Started We are going to take the following code and complete the vote and print_winner functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } // Update vote totals given a new vote bool vote ( string name ) { // TODO return false ; } // Print the winner (or winners) of the election void print_winner ( void ) { // TODO return ; } We can make up the following code for the vote and print_winner functions that solves the problem: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } int get_index ( string name ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( name , candidates [ i ]. name ) == 0 ) return i ; } return -1 ; } // Update vote totals given a new vote bool vote ( string name ) { int candidate_index = get_index ( name ); // gets the index for name user inputs if ( candidate_index != -1 ) { candidates [ candidate_index ]. votes ++ ; // increments vote count for each candidate return true ; } return false ; } int get_max ( void ) { int max_votes = candidates [ 0 ]. votes ; for ( int i = 1 ; i < candidate_count ; i ++ ) if ( candidates [ i ]. votes > max_votes ) max_votes = candidates [ i ]. votes ; return max_votes ; } // Print the winner (or winners) of the election void print_winner ( void ) { int max_votes = get_max (); // see who has the most voites for ( int i = 0 ; i < candidate_count ; i ++ ) // prints name of candidate with most votes { if ( candidates [ i ]. votes == max_votes ) printf ( \"%s \\n \" , candidates [ i ]. name ); } }","title":"Plurality Problem"},{"location":"c-algorithms-problems/#runoff","text":"Now let's take the previous problem and make it a little more intricate. You already know about plurality elections, which follow a very simple algorithm for determining the winner of an election: every voter gets one vote, and the candidate with the most votes wins. But the plurality vote does have some disadvantages. What happens, for instance, in an election with three candidates, and the ballots below are cast? Ballot Ballot Ballot Ballot Ballot Alice Alice Bob Bob Charlie A plurality vote would here declare a tie between Alice and Bob, since each has two votes. But is that the right outcome? There\u2019s another kind of voting system known as a ranked-choice voting system. In a ranked-choice system, voters can vote for more than one candidate. Instead of just voting for their top choice, they can rank the candidates in order of preference. The resulting ballots might therefore look like the below. Ballot Ballot Ballot Ballot Ballot 1.Alice 1.Alice 1.Bob 1.Bob 1.Charlie 2.Bob 2.Charlie 2.Alice 2.Alice 2.Alice 3.Charlie 3.Bob 3.Charlie 3.Charlie 3.Bob Here, each voter, in addition to specifying their first preference candidate, has also indicated their second and third choices. And now, what was previously a tied election could now have a winner. The race was originally tied between Alice and Bob, so Charlie was out of the running. But the voter who chose Charlie preferred Alice over Bob, so Alice could here be declared the winner. One such ranked choice voting system is the instant runoff system. In an instant runoff election, voters can rank as many candidates as they wish. If any candidate has a majority (more than 50%) of the first preference votes, that candidate is declared the winner of the election. Let's look at the following code and see how we can implement this type of voting system. We will need to fill in the correct code for the following functions: vote , tabulate , print_winner , find_min , is_tie , and eliminate . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 #include <cs50.h> #include <stdio.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; int candidate_count ; // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO return ; } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO return 0 ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO return false ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO return ; } Let's take a look at the vote , tabulate , print_winner , find_min , is_tie , and eliminate functions to see what exactly we need to do. vote The function takes arguments voter , rank , and name . If name is a match for the name of a valid candidate, then you should update the global preferences array to indicate that the voter voter has that candidate as their rank preference (where 0 is the first preference, 1 is the second preference, etc.). If the preference is successfully recorded, the function should return true ; the function should return false otherwise (if, for instance, name is not the name of one of the candidates). You may assume that no two candidates will have the same name. tabulate The function should update the number of votes each candidate has at this stage in the runoff. Recall that at each stage in the runoff, every voter effectively votes for their top-preferred candidate who has not already been eliminated. print_winner If any candidate has more than half of the vote, their name should be printed to stdout and the function should return true . If nobody has won the election yet, the function should return false . find_min The function should return the minimum vote total for any candidate who is still in the election. is_tie The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should return true if every candidate remaining in the election has the same number of votes, and should return false otherwise. eliminate The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should eliminate the candidate (or candidates) who have min number of votes. Your program should behave per the example below: ./runoff Alice Bob Charlie Number of voters: 5 Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Charlie Rank 2: Alice Rank 3: Bob Alice The correct code looks as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 #include <cs50.h> #include <stdio.h> #include <string.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; // global variable int candidate_count ; // global variable // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( candidates [ i ]. name , name ) == 0 ) { preferences [ voter ][ rank ] = i ; return true ; } } return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO for ( int i = 0 ; i < voter_count ; i ++ ) { for ( int j = 0 ; j < candidate_count ; j ++ ) // j is rank { int candidate_index = preferences [ i ][ j ]; if ( ! candidates [ candidate_index ]. eliminated ) { candidates [ candidate_index ]. votes ++ ; // update vote count if candidate has not been eliminated break ; } } } } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( candidates [ i ]. votes > ( voter_count / 2 )) // checks to see if one candidate has over half the votes { printf ( \"%s \\n \" , candidates [ i ]. name ); return true ; } } return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO int min = 0 ; // start from zero bool find_first = false ; for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) // see if candidate has been eliminated { if ( ! find_first ) { min = candidates [ i ]. votes ; find_first = true ; } else if ( candidates [ i ]. votes < min ) { min = candidates [ i ]. votes ; } } } return min ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) if ( candidates [ i ]. votes != min ) return false ; } return true ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { if ( candidates [ i ]. votes == min ) candidates [ i ]. eliminated = true ; } } }","title":"Runoff"},{"location":"c-algorithms/","text":"Algorithms An algorithm is step-by-step set of instructions for completing a task. Searching In computer science, a search algorithm is any algorithm which solves the search problem, namely, to retrieve information stored within some data structure, or calculates in the search space of a problem domain, either with discrete or continuous values. For now, we are going to go over two different types of searches: Linear Search Binary Search For the following examples, we are going to be using a row of lockers with numbers inside (an array) and we will look through them to find something, while returning a boolean ( true or false ) as a result. A linear search is where we move in a line (usually start to end or end to start). The idea of the algorithm is to iterate across the array from left to right, searching for a specified element. Worst-case scenario : We have to look through the entire array of n elements, either because the target element is the last element of the array or doesn't exist in the array at all. Best-case scenario : The target element is the first element of the array, and so we can stop looking immediately after we start. Now lets look through the lockers to find one with the number 50 inside. Some pseudocode for linear search could be written as: For i from 0 to n\u20131 // from start (0) to end (n-1) If i'th element is 50 Return true // if the i'th element is 50 - return true Return false // if not 50, return false A binary search is where we start in the middle and move left or right, depending on what we're looking for. \"Divide & Conquer\". In order to leverage the power of binary search, our array must be sorted , else we cannot make assumptions about the array's content. Worst-case scenario : We have to divide a list of n elements in half repeatedly to find the target element, either because the target element will be found at the end of the last division or doesn't exist in the array at all. Best-case scenario : The target element is at the midpoint of the full array, and so we can stop looking immediately after we start. Some pseudocode for binary search could be written as: If no items Return false If middle item is 50 Return true Else if 50 < middle item Search left half Else if 50 > middle item Search right half Big O Computer scientists have created a way to describe algorithms (how well it is designed), and it's generally called big O . The more formal way to describe this is with big O notation, which we can think of as \u201con the order of\u201d. For example, if our algorithm is linear search, it will take approximately O( n ) steps, \u201con the order of n \u201d. In fact, even an algorithm that looks at two items at a time and takes n /2 steps has O( n ). This is because, as n gets bigger and bigger, only the largest term, n , matters. There are some common running times (how many seconds does it take, how many steps does it take, etc.): (lower is better) O( n 2 ) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) Computer scientists might also use big \u03a9, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big O is the upper bound of number of steps, or the worst case, and typically what we care about more.) With linear search, for example, the worst case is n steps, but the best case is 1 step since our item might happen to be the first item we check. The best case for binary search, too, is 1 since our item might be in the middle of the array. And we have a similar set of the most common big \u03a9 running times: (lower is better) \u03a9(n2) \u03a9(n log n) \u03a9(n) (counting the number of items) \u03a9(log n) \u03a9(1) (linear search, binary search) Linear Search Now let's create a program to better visualize a lienar search: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cs50.h> #include <stdio.h> int main ( void ) { int numbers [ 6 ] = { 4 , 8 , 15 , 16 , 23 , 42 }; for ( int i = 0 ; i < 6 ; i ++ ) { if ( numbers [ i ] == 50 ) { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Here we initialize an array with some values, and we check the items in the array one at a time, in order. And in each case, depending on whether the value was found or not, we can return an exit code of either 0 (for success) or 1 (for failure). We can do the same for names: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma is the name we're looking for. note the use of strcmp { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can\u2019t compare strings directly, since they\u2019re not a simple data type but rather an array of many characters, and we need to compare them differently. Luckily, the string library has a strcmp function which compares strings for us and returns 0 if they\u2019re the same, so we can use that. Now lets implement a phone book with the same ideas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; string numbers [ 4 ] = { \"617\u2013555\u20130100\" , \"617\u2013555\u20130101\" , \"617\u2013555\u20130102\" , \"617\u2013555\u20130103\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma's phone number is what we're looking for { printf ( \"Found %s \\n \" , numbers [ i ]); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Now, if the name at a certain index in the names array matches who we\u2019re looking for, we\u2019ll return the phone number in the numbers array, at the same index. But that means we need to particularly careful to make sure that each number corresponds to the name at each index, especially if we add or remove names and numbers. Let's improve the above code using our own custom data type! Structs We can make our own custom data types called structs : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include <cs50.h> #include <stdio.h> #include <string.h> typedef struct { string name ; string number ; } person ; // we are encapsulating both the strings name and number inside our struct \"person\" int main ( void ) { person people [ 4 ]; people [ 0 ]. name = \"EMMA\" ; people [ 0 ]. number = \"617\u2013555\u20130100\" ; people [ 1 ]. name = \"RODRIGO\" ; people [ 1 ]. number = \"617\u2013555\u20130101\" ; people [ 2 ]. name = \"BRIAN\" ; people [ 2 ]. number = \"617\u2013555\u20130102\" ; people [ 3 ]. name = \"DAVID\" ; people [ 3 ]. number = \"617\u2013555\u20130103\" ; // Search for EMMA for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( people [ i ]. name , \"EMMA\" ) == 0 ) { printf ( \"Found %s \\n \" , people [ i ]. number ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can think of structs as containers, inside of which are multiple other data types. Here, we create our own type with a struct called person , which will have a string called name and a string called number . Then, we can create an array of these struct types and initialize the values inside each of them, using a new syntax, . , to access the properties of each person . In our loop, we can now be more certain that the number corresponds to the name since they are from the same person element. Sorting The process of Sorting can be explained as a technique of rearranging the elements in any particular order, which can be set ready for further processing by the program logic. In C, there are multiple sorting algorithms available, which can be incorporated inside the code. Bubble Sort In bubble stort, the idea of the algorithm is to move higher valued elements generally towards the right and lower value elements generally towards the left. Let's take 8 random numbers ( 6 , 3 , 8 , 5 , 2 , 7 , 4 , 1 ) and try to sort them in C. First, we can look at the first two numbers and swap them so they are in order: 6 3 8 5 2 7 4 1 3 6 8 5 2 7 4 1 The next pair, 6 and 8 , are in order, so we don\u2019t need to swap them. The next pair, 8 and 5 , need to be swapped: 3 6 8 5 2 7 4 1 3 6 5 8 2 7 4 1 We continue until we reach the end of the list: 3 6 5 8 2 7 4 1 3 6 5 2 8 7 4 1 3 6 5 2 7 8 4 1 3 6 5 2 7 4 8 1 3 6 5 2 7 4 1 8 Our list isn\u2019t sorted yet, but we\u2019re slightly closer to the solution because the biggest value, 8 , has been shifted all the way to the right. We repeat this with another pass through the list, over and over, until it is sorted correctly. The pseudocode for this might look like: Repeat n\u20131 times For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Since we are comparing the i'th and i+1'th element, we only need to go up to n \u2013 2 for i . Then, we swap the two elements if they\u2019re out of order. And we can stop after we\u2019ve made n \u2013 1 passes, since we know the largest n \u20131 elements will have bubbled to the right. We have n \u2013 2 steps for the inner loop, and n \u2013 1 loops, so we get n 2 \u2013 3 n + 2 steps total. But the largest factor, or dominant term, is n 2 , as n gets larger and larger, so we can say that bubble sort is O ( n 2 ). Worst-case scenario : The array is in rever order; we have to \"bubble\" each of the n elements all the way across the array, and since we can only fully bubble one element into position per pass, we must do this n times. Best-case scenario : The array is already perfectly sorted, and we make no swaps on the first pass. We\u2019ve seen running times like the following, and so even though binary search is much faster than linear search, it might not be worth the one\u2013time cost of sorting the list first, unless we do lots of searches over time: O( n 2 ) (bubble sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) And \u03a9 for bubble sort is still n 2 , since we still check each pair of elements for n \u2013 1 passes. Selection Sort In selection sort, the idea of the algorithm is to find the smallest unsorted element and add it to the end of the sorted list. This basically builds a sorted list, one element at a time. We can take another approach with the same set of numbers: 6 3 8 5 2 7 4 1 First, we\u2019ll look at each number, and remember the smallest one we\u2019ve seen. Then, we can swap it with the first number in our list, since we know it\u2019s the smallest: 6 3 8 5 2 7 4 1 1 3 8 5 2 7 4 6 Now we know at least the first element of our list is in the right place, so we can look for the smallest element among the rest, and swap it with the next unsorted element (now the second element): 1 3 8 5 2 7 4 6 1 2 8 5 3 7 4 6 We can repeat this over and over, until we have a sorted list. The pseudocode for this might look like: For i from 0 to n\u20131 Find smallest item between i'th item and last item Swap smallest item with i'th item With big O notation, we still have running time of O ( n 2 ), since we were looking at roughly all n elements to find the smallest, and making n passes to sort all the elements. Worst-case scenario : We have to iterate over each of the n elements of the array (to find the smallest unsorted element) and we must repeat this process n times, since only one element gets sorted on each pass. Best-case scenario : Exactly the same! There's no way to gurantee this array is sorted until we go through this process for all the elements. So it turns out that selection sort is fundamentally about the same as bubble sort in running time: O( n 2 ) (bubble sort, selection sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) The best case, \u03a9, is also n 2 . We can go back to bubble sort and change its algorithm to be something like this, which will allow us to stop early if all the elements are sorted: Repeat until no swaps For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Now, we only need to look at each element once, so the best case is now \u03a9( n ): \u03a9(n 2 ) (selection sort) \u03a9( n log n ) \u03a9( n ) (bubble sort) \u03a9(log n ) \u03a9(1) (linear search, binary search) Insertion Sort In insertion sort, the idea of the algorithm is to build your sorted array in place, shifting elements out of the way if necessary to make room as you go. This is different to bubble sort and selection sort, where we slide actually slide elements out of the way while sorting. In pseudo code: Call the first element of the array \"sorted\". Repeat until all elements are sorted: Look at the next unsorted element. Insert into the \"sorted\" portion by shifting the requisite number of elements. Worst-case scenario : The array is in reverse order; we have to shift each of the n elements n positions each time we make an insertion. Best-case scenario : The array is already perfectly sorted, and we simply keep moving the line between \"unsorted\" and \"sorted\" as we examine each element. Insertion sort can be seen as: O( n 2 ) and \u03a9( n ). We can use a visualization tool, found here , with animations for how the elements move within arrays for both bubble sort and insertion sort. Recursion Recall that in week 0, we had pseudocode for finding a name in a phone book, where we had lines telling us to \u201cgo back\u201d and repeat some steps: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 Open to middle of left half of book 8 **Go back to line 3** 9 Else if Smith is later in book 10 Open to middle of right half of book 11 **Go back to line 3** 12 Else 13 Quit We could instead just repeat our entire algorithm on the half of the book we have left: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 **Search left half of book** 8 Else if Smith is later in book 9 **Search right half of book** 10 Else 11 Quit This seems like a cyclical process that will never end, but we\u2019re actually dividing the problem in half each time, and stopping once there\u2019s no more book left. Recursion occurs when a function or algorithm refers to itself (references its own name in the code), as in the new pseudocode above. Let's try to visualize this with simple code. The factorial function ( n !) is defined over all positive integers. n ! equals all of the positive integers less than or equal to n , multiplied together. Thinking in terms programming, we'll define the mathematical function n ! as fact(n) . fact(1) = 1 fact(2) = 2 * 1 fact(3) = 3 * 2 * 1 fact(4) = 4 * 3 * 2 * 1 ... This can also be seen as: fact(1) = 1 fact(2) = 2 * fact(1) fact(3) = 3 * fact(2) fact(4) = 4 * fact(3) ... This can be seen as fact(n) = n * fact(n-1) . This forms the basis for a recusive definition of the factorial function. Every recursive function has two cases that could apply, given any input: The base case , which when triggered will terminate the recursive process. The recursive case , which is where the recursion will actually occur. We can see this in the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 //recursive version int fact ( int n ) { if ( n == 1 ) // base case { return 1 ; } else // recursive case { return n * fact ( n - 1 ); } } In general, but not always, recursive functions replace loops in non-recursive functions: Below is the iterative version of the same code above (notice how much simpler the recursive version is). 1 2 3 4 5 6 7 8 9 10 11 //iterative version int fact2 ( int n ) { int product = 1 ; while w ( n > 0 ) { product *= n ; n -- ; } return product ; } In week 1, we implemented a \u201cpyramid\u201d of blocks in the following shape : # ## ### #### This was the code we created for that problem set: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // Draw pyramid of height h for ( int i = 1 ; i <= h ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } } Here, we use for loops to print each block in each row. But notice that a pyramid of height 4 is actually a pyramid of height 3, with an extra row of 4 blocks added on. And a pyramid of height 3 is a pyramid of height 2, with an extra row of 3 blocks. A pyramid of height 2 is a pyramid of height 1, with an extra row of 2 blocks. And finally, a pyramid of height 1 is just a pyramid of height 0, or nothing, with another row of a single block added on. With this idea in mind, we can write: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // If nothing to draw if ( h == 0 ) { return ; } // Draw pyramid of height h - 1 draw ( h - 1 ); // Notice how we are referring to itself (draw) within the code // Draw one more row of width h for ( int i = 0 ; i < h ; i ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } Now, our draw function first calls itself recursively , drawing a pyramid of height h - 1 . But even before that, we need to stop if h is 0, since there won\u2019t be anything left to drawn. After, we draw the next row, or a row of width h . Merge Sort In merge sort, the idea of the algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order. We can take the idea of recusion to sorting, with another algorithm called merge sort. The pseudocode might look like: If only one item Return Else Sort left half of items (assuming n > 1) Sort right half of items (assuming n > 1) Merge sorted halves We will use an unsorted list to demonstrate merge sorting: 7 4 5 2 6 3 8 1 First, we'll sort the left half (the first four elements): 7 4 5 2 | 6 3 8 1 - - - - Well, to sort that, we need to sort the left half of the left half first: 7 4 | 5 2 | 6 3 8 1 - - Now, we have just one item, 7 , in the left half, and one item, 4 , in the right half. So we\u2019ll merge that together, by taking the smallest item from each list first: - - | 5 2 | 6 3 8 1 4 7 And now we go back to the right half of the left half, and sort it: - - | - - | 6 3 8 1 4 7 2 5 Now, both halves of the left half are sorted, so we can merge the two of them together. We look at the start of each list, and take 2 since it\u2019s smaller than 4 . Then, we take 4 , since it\u2019s now the smallest item at the front of both lists. Then, we take 5 , and finally, 7 , to get: - - - - | 6 3 8 1 - - - - 2 4 5 7 Next, we do the same thing for the right half of numbers and end up with: - - - - | - - - - - - - - - - - - 2 4 5 7 1 3 6 8 And finally, we can merge both halves of the whole list, following the same steps as before. Notice that we don\u2019t need to check all the elements of each half to find the smallest, since we know that each half is already sorted. Instead, we just take the smallest element of the two at the start of each half. It took a lot of steps, but it actually took fewer steps than the other algorithms we\u2019ve seen so far. We broke our list in half each time, until we were \u201csorting\u201d eight lists with one element each. Since our algorithm divided the problem in half each time, its running time is logarithmic with O(log n). And after we sorted each half (or half of a half), we needed to merge together all the elements, with n steps since we had to look at each element once. Worst-case scenario : We have to split n elements up and then recombine them, effectively doubling the sorted subarrays as we build them. (Combining sorted 1-element arrays into 2-element arrays, combining soorted 2-element arrays into 4-element arrays...) - O ( n log n ). Best-case scenario : The array is already perfectly sorted. But we still have to split and recombine it back together with this algorithm. - \u03a9( n log n ). So our total running time is O ( n log n ): O( n 2 ) (bubble sort, selection sort) O( n log n ) (merge search) O( n ) (linear search) O(log n ) (binary search) O(1) To see this in real time, watch this video to see multiple sorting algorithms running at the same time. Algorithms Summary Algorithm Name Basic Concept O \u03a9 Selection Sort Find the smallest unsorted element in an array and swap it with the first unsorted element of that array. n 2 n 2 Bubble Sort Swap adjacent pairs of elements if they are out of order, effectively \"bubbling\" larger elements to the right and smaller ones to the left. n 2 n Insertion Sort Proceed through the array from left-to-right, shifting elements as necessary to insert each element into its correct place. n 2 n Merge Sort Split the full array into subarrays, then merge those subarrays back together in the correct order. n log n n log n Linear Search Iterate across the array from left-to-right, trying to find the target element. n 1 Binary Search Given a sorted array, divide and conquer by systematically eliminating half of the remaining elements in the search for the target element. log n 1 Algorithm Problems To see the problem sets for the covered algorithms, please click here .","title":"Algorithm Overview"},{"location":"c-algorithms/#algorithms","text":"An algorithm is step-by-step set of instructions for completing a task.","title":"Algorithms"},{"location":"c-algorithms/#searching","text":"In computer science, a search algorithm is any algorithm which solves the search problem, namely, to retrieve information stored within some data structure, or calculates in the search space of a problem domain, either with discrete or continuous values. For now, we are going to go over two different types of searches: Linear Search Binary Search For the following examples, we are going to be using a row of lockers with numbers inside (an array) and we will look through them to find something, while returning a boolean ( true or false ) as a result. A linear search is where we move in a line (usually start to end or end to start). The idea of the algorithm is to iterate across the array from left to right, searching for a specified element. Worst-case scenario : We have to look through the entire array of n elements, either because the target element is the last element of the array or doesn't exist in the array at all. Best-case scenario : The target element is the first element of the array, and so we can stop looking immediately after we start. Now lets look through the lockers to find one with the number 50 inside. Some pseudocode for linear search could be written as: For i from 0 to n\u20131 // from start (0) to end (n-1) If i'th element is 50 Return true // if the i'th element is 50 - return true Return false // if not 50, return false A binary search is where we start in the middle and move left or right, depending on what we're looking for. \"Divide & Conquer\". In order to leverage the power of binary search, our array must be sorted , else we cannot make assumptions about the array's content. Worst-case scenario : We have to divide a list of n elements in half repeatedly to find the target element, either because the target element will be found at the end of the last division or doesn't exist in the array at all. Best-case scenario : The target element is at the midpoint of the full array, and so we can stop looking immediately after we start. Some pseudocode for binary search could be written as: If no items Return false If middle item is 50 Return true Else if 50 < middle item Search left half Else if 50 > middle item Search right half","title":"Searching"},{"location":"c-algorithms/#big-o","text":"Computer scientists have created a way to describe algorithms (how well it is designed), and it's generally called big O . The more formal way to describe this is with big O notation, which we can think of as \u201con the order of\u201d. For example, if our algorithm is linear search, it will take approximately O( n ) steps, \u201con the order of n \u201d. In fact, even an algorithm that looks at two items at a time and takes n /2 steps has O( n ). This is because, as n gets bigger and bigger, only the largest term, n , matters. There are some common running times (how many seconds does it take, how many steps does it take, etc.): (lower is better) O( n 2 ) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) Computer scientists might also use big \u03a9, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big O is the upper bound of number of steps, or the worst case, and typically what we care about more.) With linear search, for example, the worst case is n steps, but the best case is 1 step since our item might happen to be the first item we check. The best case for binary search, too, is 1 since our item might be in the middle of the array. And we have a similar set of the most common big \u03a9 running times: (lower is better) \u03a9(n2) \u03a9(n log n) \u03a9(n) (counting the number of items) \u03a9(log n) \u03a9(1) (linear search, binary search)","title":"Big O"},{"location":"c-algorithms/#linear-search","text":"Now let's create a program to better visualize a lienar search: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cs50.h> #include <stdio.h> int main ( void ) { int numbers [ 6 ] = { 4 , 8 , 15 , 16 , 23 , 42 }; for ( int i = 0 ; i < 6 ; i ++ ) { if ( numbers [ i ] == 50 ) { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Here we initialize an array with some values, and we check the items in the array one at a time, in order. And in each case, depending on whether the value was found or not, we can return an exit code of either 0 (for success) or 1 (for failure). We can do the same for names: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma is the name we're looking for. note the use of strcmp { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can\u2019t compare strings directly, since they\u2019re not a simple data type but rather an array of many characters, and we need to compare them differently. Luckily, the string library has a strcmp function which compares strings for us and returns 0 if they\u2019re the same, so we can use that. Now lets implement a phone book with the same ideas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; string numbers [ 4 ] = { \"617\u2013555\u20130100\" , \"617\u2013555\u20130101\" , \"617\u2013555\u20130102\" , \"617\u2013555\u20130103\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma's phone number is what we're looking for { printf ( \"Found %s \\n \" , numbers [ i ]); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Now, if the name at a certain index in the names array matches who we\u2019re looking for, we\u2019ll return the phone number in the numbers array, at the same index. But that means we need to particularly careful to make sure that each number corresponds to the name at each index, especially if we add or remove names and numbers. Let's improve the above code using our own custom data type!","title":"Linear Search"},{"location":"c-algorithms/#structs","text":"We can make our own custom data types called structs : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include <cs50.h> #include <stdio.h> #include <string.h> typedef struct { string name ; string number ; } person ; // we are encapsulating both the strings name and number inside our struct \"person\" int main ( void ) { person people [ 4 ]; people [ 0 ]. name = \"EMMA\" ; people [ 0 ]. number = \"617\u2013555\u20130100\" ; people [ 1 ]. name = \"RODRIGO\" ; people [ 1 ]. number = \"617\u2013555\u20130101\" ; people [ 2 ]. name = \"BRIAN\" ; people [ 2 ]. number = \"617\u2013555\u20130102\" ; people [ 3 ]. name = \"DAVID\" ; people [ 3 ]. number = \"617\u2013555\u20130103\" ; // Search for EMMA for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( people [ i ]. name , \"EMMA\" ) == 0 ) { printf ( \"Found %s \\n \" , people [ i ]. number ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can think of structs as containers, inside of which are multiple other data types. Here, we create our own type with a struct called person , which will have a string called name and a string called number . Then, we can create an array of these struct types and initialize the values inside each of them, using a new syntax, . , to access the properties of each person . In our loop, we can now be more certain that the number corresponds to the name since they are from the same person element.","title":"Structs"},{"location":"c-algorithms/#sorting","text":"The process of Sorting can be explained as a technique of rearranging the elements in any particular order, which can be set ready for further processing by the program logic. In C, there are multiple sorting algorithms available, which can be incorporated inside the code.","title":"Sorting"},{"location":"c-algorithms/#bubble-sort","text":"In bubble stort, the idea of the algorithm is to move higher valued elements generally towards the right and lower value elements generally towards the left. Let's take 8 random numbers ( 6 , 3 , 8 , 5 , 2 , 7 , 4 , 1 ) and try to sort them in C. First, we can look at the first two numbers and swap them so they are in order: 6 3 8 5 2 7 4 1 3 6 8 5 2 7 4 1 The next pair, 6 and 8 , are in order, so we don\u2019t need to swap them. The next pair, 8 and 5 , need to be swapped: 3 6 8 5 2 7 4 1 3 6 5 8 2 7 4 1 We continue until we reach the end of the list: 3 6 5 8 2 7 4 1 3 6 5 2 8 7 4 1 3 6 5 2 7 8 4 1 3 6 5 2 7 4 8 1 3 6 5 2 7 4 1 8 Our list isn\u2019t sorted yet, but we\u2019re slightly closer to the solution because the biggest value, 8 , has been shifted all the way to the right. We repeat this with another pass through the list, over and over, until it is sorted correctly. The pseudocode for this might look like: Repeat n\u20131 times For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Since we are comparing the i'th and i+1'th element, we only need to go up to n \u2013 2 for i . Then, we swap the two elements if they\u2019re out of order. And we can stop after we\u2019ve made n \u2013 1 passes, since we know the largest n \u20131 elements will have bubbled to the right. We have n \u2013 2 steps for the inner loop, and n \u2013 1 loops, so we get n 2 \u2013 3 n + 2 steps total. But the largest factor, or dominant term, is n 2 , as n gets larger and larger, so we can say that bubble sort is O ( n 2 ). Worst-case scenario : The array is in rever order; we have to \"bubble\" each of the n elements all the way across the array, and since we can only fully bubble one element into position per pass, we must do this n times. Best-case scenario : The array is already perfectly sorted, and we make no swaps on the first pass. We\u2019ve seen running times like the following, and so even though binary search is much faster than linear search, it might not be worth the one\u2013time cost of sorting the list first, unless we do lots of searches over time: O( n 2 ) (bubble sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) And \u03a9 for bubble sort is still n 2 , since we still check each pair of elements for n \u2013 1 passes.","title":"Bubble Sort"},{"location":"c-algorithms/#selection-sort","text":"In selection sort, the idea of the algorithm is to find the smallest unsorted element and add it to the end of the sorted list. This basically builds a sorted list, one element at a time. We can take another approach with the same set of numbers: 6 3 8 5 2 7 4 1 First, we\u2019ll look at each number, and remember the smallest one we\u2019ve seen. Then, we can swap it with the first number in our list, since we know it\u2019s the smallest: 6 3 8 5 2 7 4 1 1 3 8 5 2 7 4 6 Now we know at least the first element of our list is in the right place, so we can look for the smallest element among the rest, and swap it with the next unsorted element (now the second element): 1 3 8 5 2 7 4 6 1 2 8 5 3 7 4 6 We can repeat this over and over, until we have a sorted list. The pseudocode for this might look like: For i from 0 to n\u20131 Find smallest item between i'th item and last item Swap smallest item with i'th item With big O notation, we still have running time of O ( n 2 ), since we were looking at roughly all n elements to find the smallest, and making n passes to sort all the elements. Worst-case scenario : We have to iterate over each of the n elements of the array (to find the smallest unsorted element) and we must repeat this process n times, since only one element gets sorted on each pass. Best-case scenario : Exactly the same! There's no way to gurantee this array is sorted until we go through this process for all the elements. So it turns out that selection sort is fundamentally about the same as bubble sort in running time: O( n 2 ) (bubble sort, selection sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) The best case, \u03a9, is also n 2 . We can go back to bubble sort and change its algorithm to be something like this, which will allow us to stop early if all the elements are sorted: Repeat until no swaps For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Now, we only need to look at each element once, so the best case is now \u03a9( n ): \u03a9(n 2 ) (selection sort) \u03a9( n log n ) \u03a9( n ) (bubble sort) \u03a9(log n ) \u03a9(1) (linear search, binary search)","title":"Selection Sort"},{"location":"c-algorithms/#insertion-sort","text":"In insertion sort, the idea of the algorithm is to build your sorted array in place, shifting elements out of the way if necessary to make room as you go. This is different to bubble sort and selection sort, where we slide actually slide elements out of the way while sorting. In pseudo code: Call the first element of the array \"sorted\". Repeat until all elements are sorted: Look at the next unsorted element. Insert into the \"sorted\" portion by shifting the requisite number of elements. Worst-case scenario : The array is in reverse order; we have to shift each of the n elements n positions each time we make an insertion. Best-case scenario : The array is already perfectly sorted, and we simply keep moving the line between \"unsorted\" and \"sorted\" as we examine each element. Insertion sort can be seen as: O( n 2 ) and \u03a9( n ). We can use a visualization tool, found here , with animations for how the elements move within arrays for both bubble sort and insertion sort.","title":"Insertion Sort"},{"location":"c-algorithms/#recursion","text":"Recall that in week 0, we had pseudocode for finding a name in a phone book, where we had lines telling us to \u201cgo back\u201d and repeat some steps: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 Open to middle of left half of book 8 **Go back to line 3** 9 Else if Smith is later in book 10 Open to middle of right half of book 11 **Go back to line 3** 12 Else 13 Quit We could instead just repeat our entire algorithm on the half of the book we have left: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 **Search left half of book** 8 Else if Smith is later in book 9 **Search right half of book** 10 Else 11 Quit This seems like a cyclical process that will never end, but we\u2019re actually dividing the problem in half each time, and stopping once there\u2019s no more book left. Recursion occurs when a function or algorithm refers to itself (references its own name in the code), as in the new pseudocode above. Let's try to visualize this with simple code. The factorial function ( n !) is defined over all positive integers. n ! equals all of the positive integers less than or equal to n , multiplied together. Thinking in terms programming, we'll define the mathematical function n ! as fact(n) . fact(1) = 1 fact(2) = 2 * 1 fact(3) = 3 * 2 * 1 fact(4) = 4 * 3 * 2 * 1 ... This can also be seen as: fact(1) = 1 fact(2) = 2 * fact(1) fact(3) = 3 * fact(2) fact(4) = 4 * fact(3) ... This can be seen as fact(n) = n * fact(n-1) . This forms the basis for a recusive definition of the factorial function. Every recursive function has two cases that could apply, given any input: The base case , which when triggered will terminate the recursive process. The recursive case , which is where the recursion will actually occur. We can see this in the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 //recursive version int fact ( int n ) { if ( n == 1 ) // base case { return 1 ; } else // recursive case { return n * fact ( n - 1 ); } } In general, but not always, recursive functions replace loops in non-recursive functions: Below is the iterative version of the same code above (notice how much simpler the recursive version is). 1 2 3 4 5 6 7 8 9 10 11 //iterative version int fact2 ( int n ) { int product = 1 ; while w ( n > 0 ) { product *= n ; n -- ; } return product ; } In week 1, we implemented a \u201cpyramid\u201d of blocks in the following shape : # ## ### #### This was the code we created for that problem set: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // Draw pyramid of height h for ( int i = 1 ; i <= h ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } } Here, we use for loops to print each block in each row. But notice that a pyramid of height 4 is actually a pyramid of height 3, with an extra row of 4 blocks added on. And a pyramid of height 3 is a pyramid of height 2, with an extra row of 3 blocks. A pyramid of height 2 is a pyramid of height 1, with an extra row of 2 blocks. And finally, a pyramid of height 1 is just a pyramid of height 0, or nothing, with another row of a single block added on. With this idea in mind, we can write: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // If nothing to draw if ( h == 0 ) { return ; } // Draw pyramid of height h - 1 draw ( h - 1 ); // Notice how we are referring to itself (draw) within the code // Draw one more row of width h for ( int i = 0 ; i < h ; i ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } Now, our draw function first calls itself recursively , drawing a pyramid of height h - 1 . But even before that, we need to stop if h is 0, since there won\u2019t be anything left to drawn. After, we draw the next row, or a row of width h .","title":"Recursion"},{"location":"c-algorithms/#merge-sort","text":"In merge sort, the idea of the algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order. We can take the idea of recusion to sorting, with another algorithm called merge sort. The pseudocode might look like: If only one item Return Else Sort left half of items (assuming n > 1) Sort right half of items (assuming n > 1) Merge sorted halves We will use an unsorted list to demonstrate merge sorting: 7 4 5 2 6 3 8 1 First, we'll sort the left half (the first four elements): 7 4 5 2 | 6 3 8 1 - - - - Well, to sort that, we need to sort the left half of the left half first: 7 4 | 5 2 | 6 3 8 1 - - Now, we have just one item, 7 , in the left half, and one item, 4 , in the right half. So we\u2019ll merge that together, by taking the smallest item from each list first: - - | 5 2 | 6 3 8 1 4 7 And now we go back to the right half of the left half, and sort it: - - | - - | 6 3 8 1 4 7 2 5 Now, both halves of the left half are sorted, so we can merge the two of them together. We look at the start of each list, and take 2 since it\u2019s smaller than 4 . Then, we take 4 , since it\u2019s now the smallest item at the front of both lists. Then, we take 5 , and finally, 7 , to get: - - - - | 6 3 8 1 - - - - 2 4 5 7 Next, we do the same thing for the right half of numbers and end up with: - - - - | - - - - - - - - - - - - 2 4 5 7 1 3 6 8 And finally, we can merge both halves of the whole list, following the same steps as before. Notice that we don\u2019t need to check all the elements of each half to find the smallest, since we know that each half is already sorted. Instead, we just take the smallest element of the two at the start of each half. It took a lot of steps, but it actually took fewer steps than the other algorithms we\u2019ve seen so far. We broke our list in half each time, until we were \u201csorting\u201d eight lists with one element each. Since our algorithm divided the problem in half each time, its running time is logarithmic with O(log n). And after we sorted each half (or half of a half), we needed to merge together all the elements, with n steps since we had to look at each element once. Worst-case scenario : We have to split n elements up and then recombine them, effectively doubling the sorted subarrays as we build them. (Combining sorted 1-element arrays into 2-element arrays, combining soorted 2-element arrays into 4-element arrays...) - O ( n log n ). Best-case scenario : The array is already perfectly sorted. But we still have to split and recombine it back together with this algorithm. - \u03a9( n log n ). So our total running time is O ( n log n ): O( n 2 ) (bubble sort, selection sort) O( n log n ) (merge search) O( n ) (linear search) O(log n ) (binary search) O(1) To see this in real time, watch this video to see multiple sorting algorithms running at the same time.","title":"Merge Sort"},{"location":"c-algorithms/#algorithms-summary","text":"Algorithm Name Basic Concept O \u03a9 Selection Sort Find the smallest unsorted element in an array and swap it with the first unsorted element of that array. n 2 n 2 Bubble Sort Swap adjacent pairs of elements if they are out of order, effectively \"bubbling\" larger elements to the right and smaller ones to the left. n 2 n Insertion Sort Proceed through the array from left-to-right, shifting elements as necessary to insert each element into its correct place. n 2 n Merge Sort Split the full array into subarrays, then merge those subarrays back together in the correct order. n log n n log n Linear Search Iterate across the array from left-to-right, trying to find the target element. n 1 Binary Search Given a sorted array, divide and conquer by systematically eliminating half of the remaining elements in the search for the target element. log n 1","title":"Algorithms Summary"},{"location":"c-algorithms/#algorithm-problems","text":"To see the problem sets for the covered algorithms, please click here .","title":"Algorithm Problems"},{"location":"c-arrays/","text":"Arrays What are Arrays? Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you. Array Declarations \u2003\u2003 type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages. Basic Array Program Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average). Other Array Tips Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything. Reading Levels Program According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); } Caesar's Cipher We will now create a program that will take text and run it through Caesar's encryption method. Supposedly, Caesar (yes, that Caesar) used to \u201cencrypt\u201d (i.e., conceal in a reversible way) confidential messages by shifting each letter therein by some number of places. For instance, he might write A as B, B as C, C as D, \u2026, and, wrapping around alphabetically, Z as A. And so, to say HELLO to someone, Caesar might write IFMMP. Upon receiving such messages from Caesar, recipients would have to \u201cdecrypt\u201d them by shifting letters in the opposite direction by the same number of places. The secrecy of this \u201ccryptosystem\u201d relied on only Caesar and the recipients knowing a secret, the number of places by which Caesar had shifted his letters (e.g., 1). Not particularly secure by modern standards, but, hey, if you\u2019re perhaps the first in the world to do it, pretty secure! Note Unencrypted text is generally called plaintext . Encrypted text is generally called ciphertext . And the secret used is called a key . To be clear, then, here\u2019s how encrypting HELLO with a key of 1 yields IFMMP : plaintext H E L L O + key 1 1 1 1 1 = ciphertext I F M M P More formally, Caesar\u2019s algorithm (i.e., cipher) encrypts messages by \u201crotating\u201d each letter by k positions. More formally, if p is some plaintext (i.e., an unencrypted message), p i is the i th character in p , and k is a secret key (i.e., a non-negative integer), then each letter, c i , in the ciphertext, c , is computed as: c i = (p i + k) % 26 wherein % 26 here means \u201cremainder when dividing by 26.\u201d This formula perhaps makes the cipher seem more complicated than it is, but it\u2019s really just a concise way of expressing the algorithm precisely. Indeed, for the sake of discussion, think of A (or a) as 0, B (or b) as 1, \u2026, H (or h) as 7, I (or i) as 8, \u2026, and Z (or z) as 25. Suppose that Caesar just wants to say Hi to someone confidentially using, this time, a key, k , of 3. And so his plaintext, p , is Hi, in which case his plaintext\u2019s first character, p 0 , is H (aka 7), and his plaintext\u2019s second character, p 1 , is i (aka 8). His ciphertext\u2019s first character, c 0 , is thus K, and his ciphertext\u2019s second character, c 1 , is thus L. Can you see why? Here are a few examples of how the program might work. For example, if the user inputs a key of 1 and a plaintext of HELLO : $ ./caesar 1 plaintext: HELLO ciphertext: IFMMP Here\u2019s how the program might work if the user provides a key of 13 and a plaintext of hello, world : $ ./caesar 13 plaintext: hello, world ciphertext: uryyb, jbeyq Now let's get coding! We need our program to do the following: Get Key (the amount to shift the text by) Get plaintext Encipher Print ciphertext Note We will preserve case for letters (Keep capital letters capital, and lowercase lowercase). We will also wrap the alphabet (If we go beyond the boundaries of the alphabet, it will just start over). Let's walkthrough each piece of the program. Get the Key We will be taking the key as a command line argument : $ ./caesar 3 Remember that in C our main function can take arguments using the following: int main ( int argc , string argv []) { // code here } Getting the Key Ensure single command-line argument (print error message if command-line argument is out of bounds) Make sure argument contains only digit characters Convert argument to an integer We will also need to convert the string from the command line argument into a number using the atoi function, declared in <stdlib.h> . Getting the Plaintext We will simply use the get_string function to get user input for the plaintext. Encipher the Plaintext If it's alphabetic, shift the plaintext character by key, preserving the case. If it's not alphabetic, leave the character as-is. We can use the following functions to help us identify character type: isalpha , isupper , and islower . These functions will return a boolean value ( true or false ). Here is the correct program: #include <stdio.h> #include <cs50.h> #include <stdlib.h> #include <string.h> #include <ctype.h> bool check_key ( string s ); int main ( int argc , string argv []) //argc takes in the number of arguments and argv creates an array for the arguments themselves. { if ( argc != 2 || ! check_key ( argv [ 1 ])) // checking if the number of arguments is not 2 and if the key is valid { printf ( \"Usage: ./caesar key\" ); // if the input is not valid, it will print an error message with the correct way to enter return 1 ; } int key = atoi ( argv [ 1 ]); // converts from ASCII to integer string plaintext = get_string ( \"plaintext: \" ); printf ( \"ciphertext: \" ); for ( int i = 0 , len = strlen ( plaintext ); i < len ; i ++ ) { char c = plaintext [ i ]; if ( isalpha ( c )) { char m = 'A' ; if ( islower ( c )) m = 'a' ; printf ( \"%c\" , ( c - m + key ) % 26 + m ); // inputs the plaintext into Caesar's cipher } else printf ( \"%c\" , c ); // if the character is not alphabetic, it will print it as is } printf ( \" \\n \" ); } bool check_key ( string s ) // this string checks to see if the key is valid { for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) if ( ! isdigit ( s [ i ])) // if its not a digit, return false return false ; return true ; }","title":"Arrays"},{"location":"c-arrays/#arrays","text":"","title":"Arrays"},{"location":"c-arrays/#what-are-arrays","text":"Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you.","title":"What are Arrays?"},{"location":"c-arrays/#array-declarations","text":"type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages.","title":"Array Declarations"},{"location":"c-arrays/#basic-array-program","text":"Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average).","title":"Basic Array Program"},{"location":"c-arrays/#other-array-tips","text":"Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything.","title":"Other Array Tips"},{"location":"c-arrays/#reading-levels-program","text":"According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); }","title":"Reading Levels Program"},{"location":"c-arrays/#caesars-cipher","text":"We will now create a program that will take text and run it through Caesar's encryption method. Supposedly, Caesar (yes, that Caesar) used to \u201cencrypt\u201d (i.e., conceal in a reversible way) confidential messages by shifting each letter therein by some number of places. For instance, he might write A as B, B as C, C as D, \u2026, and, wrapping around alphabetically, Z as A. And so, to say HELLO to someone, Caesar might write IFMMP. Upon receiving such messages from Caesar, recipients would have to \u201cdecrypt\u201d them by shifting letters in the opposite direction by the same number of places. The secrecy of this \u201ccryptosystem\u201d relied on only Caesar and the recipients knowing a secret, the number of places by which Caesar had shifted his letters (e.g., 1). Not particularly secure by modern standards, but, hey, if you\u2019re perhaps the first in the world to do it, pretty secure! Note Unencrypted text is generally called plaintext . Encrypted text is generally called ciphertext . And the secret used is called a key . To be clear, then, here\u2019s how encrypting HELLO with a key of 1 yields IFMMP : plaintext H E L L O + key 1 1 1 1 1 = ciphertext I F M M P More formally, Caesar\u2019s algorithm (i.e., cipher) encrypts messages by \u201crotating\u201d each letter by k positions. More formally, if p is some plaintext (i.e., an unencrypted message), p i is the i th character in p , and k is a secret key (i.e., a non-negative integer), then each letter, c i , in the ciphertext, c , is computed as: c i = (p i + k) % 26 wherein % 26 here means \u201cremainder when dividing by 26.\u201d This formula perhaps makes the cipher seem more complicated than it is, but it\u2019s really just a concise way of expressing the algorithm precisely. Indeed, for the sake of discussion, think of A (or a) as 0, B (or b) as 1, \u2026, H (or h) as 7, I (or i) as 8, \u2026, and Z (or z) as 25. Suppose that Caesar just wants to say Hi to someone confidentially using, this time, a key, k , of 3. And so his plaintext, p , is Hi, in which case his plaintext\u2019s first character, p 0 , is H (aka 7), and his plaintext\u2019s second character, p 1 , is i (aka 8). His ciphertext\u2019s first character, c 0 , is thus K, and his ciphertext\u2019s second character, c 1 , is thus L. Can you see why? Here are a few examples of how the program might work. For example, if the user inputs a key of 1 and a plaintext of HELLO : $ ./caesar 1 plaintext: HELLO ciphertext: IFMMP Here\u2019s how the program might work if the user provides a key of 13 and a plaintext of hello, world : $ ./caesar 13 plaintext: hello, world ciphertext: uryyb, jbeyq Now let's get coding! We need our program to do the following: Get Key (the amount to shift the text by) Get plaintext Encipher Print ciphertext Note We will preserve case for letters (Keep capital letters capital, and lowercase lowercase). We will also wrap the alphabet (If we go beyond the boundaries of the alphabet, it will just start over). Let's walkthrough each piece of the program. Get the Key We will be taking the key as a command line argument : $ ./caesar 3 Remember that in C our main function can take arguments using the following: int main ( int argc , string argv []) { // code here } Getting the Key Ensure single command-line argument (print error message if command-line argument is out of bounds) Make sure argument contains only digit characters Convert argument to an integer We will also need to convert the string from the command line argument into a number using the atoi function, declared in <stdlib.h> . Getting the Plaintext We will simply use the get_string function to get user input for the plaintext. Encipher the Plaintext If it's alphabetic, shift the plaintext character by key, preserving the case. If it's not alphabetic, leave the character as-is. We can use the following functions to help us identify character type: isalpha , isupper , and islower . These functions will return a boolean value ( true or false ). Here is the correct program: #include <stdio.h> #include <cs50.h> #include <stdlib.h> #include <string.h> #include <ctype.h> bool check_key ( string s ); int main ( int argc , string argv []) //argc takes in the number of arguments and argv creates an array for the arguments themselves. { if ( argc != 2 || ! check_key ( argv [ 1 ])) // checking if the number of arguments is not 2 and if the key is valid { printf ( \"Usage: ./caesar key\" ); // if the input is not valid, it will print an error message with the correct way to enter return 1 ; } int key = atoi ( argv [ 1 ]); // converts from ASCII to integer string plaintext = get_string ( \"plaintext: \" ); printf ( \"ciphertext: \" ); for ( int i = 0 , len = strlen ( plaintext ); i < len ; i ++ ) { char c = plaintext [ i ]; if ( isalpha ( c )) { char m = 'A' ; if ( islower ( c )) m = 'a' ; printf ( \"%c\" , ( c - m + key ) % 26 + m ); // inputs the plaintext into Caesar's cipher } else printf ( \"%c\" , c ); // if the character is not alphabetic, it will print it as is } printf ( \" \\n \" ); } bool check_key ( string s ) // this string checks to see if the key is valid { for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) if ( ! isdigit ( s [ i ])) // if its not a digit, return false return false ; return true ; }","title":"Caesar's Cipher"},{"location":"c-cl-arguments/","text":"Command Line Arugments Overview Command Line Arguments So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc -1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-cl-arguments/#command-line-arugments-overview","text":"","title":"Command Line Arugments Overview"},{"location":"c-cl-arguments/#command-line-arguments","text":"So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc -1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-data-structures-problems/","text":"Data Structures Problem Speller We are going to implement a program that spell-checks a file, like below, using a hash table. $ ./speller texts/lalaland.txt MISSPELLED WORDS [...] AHHHHHHHHHHHHHHHHHHHHHHHHHHHT [...] Shangri [...] fianc [...] Sebastian's [...] WORDS MISSPELLED: WORDS IN DICTIONARY: WORDS IN TEXT: TIME IN load: TIME IN check: TIME IN size: TIME IN unload: TIME IN TOTAL: To download the prerequisite files, click here . This should give you the following files: dictionaries/ dictionary.c dictionary.h keys/ Makefile speller.c texts/ Understanding Theoretically, on input of size n , an algorithm with a running time of n is \u201casymptotically equivalent,\u201d in terms of O , to an algorithm with a running time of 2 n . Indeed, when describing the running time of an algorithm, we typically focus on the dominant (i.e., most impactful) term (i.e., n in this case, since n could be much larger than 2). In the real world, though, the fact of the matter is that 2 n feels twice as slow as n . The challenge ahead is to implement the fastest spell checker we can! By \u201cfastest,\u201d though, we\u2019re talking actual \u201cwall-clock,\u201d not asymptotic, time. In speller.c , we\u2019ve put together a program that\u2019s designed to spell-check a file after loading a dictionary of words from disk into memory. That dictionary, meanwhile, is implemented in a file called dictionary.c . (It could just be implemented in speller.c , but as programs get more complex, it\u2019s often convenient to break them into multiple files.) The prototypes for the functions therein, meanwhile, are defined not in dictionary.c itself but in dictionary.h instead. That way, both speller.c and dictionary.c can #include the file. Unfortunately, we didn\u2019t quite get around to implementing the loading part. Or the checking part. Both (and a bit more) we leave to you! But first, a tour. dictionary.h Open up dictionary.h , and you\u2019ll see some new syntax, including a few lines that mention DICTIONARY_H . No need to worry about those, but, if curious, those lines just ensure that, even though dictionary.c and speller.c (which you\u2019ll see in a moment) #include this file, clang will only compile it once. Next notice how we #include a file called stdbool.h . That\u2019s the file in which bool itself is defined. You\u2019ve not needed it before, since the CS50 Library used to #include that for you. Also notice our use of #define , a \u201cpreprocessor directive\u201d that defines a \u201cconstant\u201d called LENGTH that has a value of 45 . It\u2019s a constant in the sense that you can\u2019t (accidentally) change it in your own code. In fact, clang will replace any mentions of LENGTH in your own code with, literally, 45 . In other words, it\u2019s not a variable, just a find-and-replace trick. Finally, notice the prototypes for five functions: check , hash , load , size , and unload . Notice how three of those take a pointer as an argument, per the * : bool check ( const char * word ); unsigned int hash ( const char * word ); bool load ( const char * dictionary ); Recall that char * is what we used to call string . So those three prototypes are essentially just: bool check ( const string word ); unsigned int hash ( const string word ); bool load ( const string dictionary ); And const , meanwhile, just says that those strings, when passed in as arguments, must remain constant; you won\u2019t be able to change them, accidentally or otherwise! dictionary.c Now open up dictionary.c . Notice how, atop the file, we\u2019ve defined a struct called node that represents a node in a hash table. And we\u2019ve declared a global pointer array, table , which will (soon) represent the hash table you will use to keep track of words in the dictionary. The array contains N node pointers, and we\u2019ve set N equal to 1 for now, meaning this hash table has just 1 bucket right now. You\u2019ll likely want to increase the number of buckets, as by changing N , to something larger! Next, notice that we\u2019ve implemented load , hash , check , size , and unload , but only barely, just enough for the code to compile. Your job, ultimately, is to re-implement those functions as cleverly as possible so that this spell checker works as advertised. And fast! speller.c Okay, next open up speller.c and spend some time looking over the code and comments therein. You won\u2019t need to change anything in this file, and you don\u2019t need to understand its entirety, but do try to get a sense of its functionality nonetheless. Notice how, by way of a function called getrusage , we\u2019ll be \u201cbenchmarking\u201d (i.e., timing the execution of) your implementations of check , load , size , and unload . Also notice how we go about passing check , word by word, the contents of some file to be spell-checked. Ultimately, we report each misspelling in that file along with a bunch of statistics. Notice, incidentally, that we have defined the usage of speller to be Usage: speller [dictionary] text where dictionary is assumed to be a file containing a list of lowercase words, one per line, and text is a file to be spell-checked. As the brackets suggest, provision of dictionary is optional; if this argument is omitted, speller will use dictionaries/large by default. In other words, running $ ./speller text will be equivalent to running $ ./speller dictionaries/large text where text is the file you wish to spell-check. Suffice it to say, the former is easier to type! (Of course, speller will not be able to load any dictionaries until you implement load in dictionary.c ! Until then, you\u2019ll see Could not load .) Within the default dictionary, mind you, are 143,091 words, all of which must be loaded into memory! In fact, take a peek at that file to get a sense of its structure and size. Notice that every word in that file appears in lowercase (even, for simplicity, proper nouns and acronyms). From top to bottom, the file is sorted lexicographically, with only one word per line (each of which ends with \\n ). No word is longer than 45 characters, and no word appears more than once. During development, you may find it helpful to provide speller with a dictionary of your own that contains far fewer words, lest you struggle to debug an otherwise enormous structure in memory. In dictionaries/small is one such dictionary. To use it, execute $ ./speller dictionaries/small text where text is the file you wish to spell-check. Don\u2019t move on until you\u2019re sure you understand how speller itself works! Odds are, you didn\u2019t spend enough time looking over speller.c . Go back one square and walk yourself through it again! texts/ So that you can test your implementation of speller , we\u2019ve also provided you with a whole bunch of texts, among them the script from La La Land, the text of the Affordable Care Act, three million bytes from Tolstoy, some excerpts from The Federalist Papers and Shakespeare, the entirety of the King James V Bible and the Koran, and more. So that you know what to expect, open and skim each of those files, all of which are in a directory called texts within your pset5 directory. Now, as you should know from having read over speller.c carefully, the output of speller , if executed with, say, $ ./speller texts/lalaland.txt will eventually resemble the below. For now, try the staff\u2019s solution (using the default dictionary) by executing $ ~cs50/2019/fall/pset5/speller texts/lalaland.txt Below\u2019s some of the output you\u2019ll see. For information\u2019s sake, we\u2019ve excerpted some examples of \u201cmisspellings.\u201d And lest we spoil the fun, we\u2019ve omitted our own statistics for now. MISSPELLED WORDS [...] AHHHHHHHHHHHHHHHHHHHHHHHHHHHT [...] Shangri [...] fianc [...] Sebastian's [...] WORDS MISSPELLED: WORDS IN DICTIONARY: WORDS IN TEXT: TIME IN load: TIME IN check: TIME IN size: TIME IN unload: TIME IN TOTAL: TIME IN load represents the number of seconds that speller spends executing your implementation of load . TIME IN check represents the number of seconds that speller spends, in total, executing your implementation of check . TIME IN size represents the number of seconds that speller spends executing your implementation of size . TIME IN unload represents the number of seconds that speller spends executing your implementation of unload . TIME IN TOTAL is the sum of those four measurements. Note that these times may vary somewhat across executions of speller , depending on what else CS50 IDE is doing, even if you don\u2019t change your code. Incidentally, to be clear, by \u201cmisspelled\u201d we simply mean that some word is not in the dictionary provided. Makefile And, lastly, recall that make automates compilation of your code so that you don\u2019t have to execute clang manually along with a whole bunch of switches. However, as your programs grow in size, make won\u2019t be able to infer from context anymore how to compile your code; you\u2019ll need to start telling make how to compile your program, particularly when they involve multiple source (i.e., .c ) files, as in the case of this problem. And so we\u2019ll utilize a Makefile , a configuration file that tells make exactly what to do. Open up Makefile , and you should see four lines: The first line tells make to execute the subsequent lines whenever you yourself execute make speller (or just make ). The second line tells make how to compile speller.c into machine code (i.e., speller.o ). The third line tells make how to compile dictionary.c into machine code (i.e., dictionary.o ). The fourth line tells make to link speller.o and dictionary.o in a file called speller . Be sure to compile speller by executing make speller (or just make ). Executing make dictionary won\u2019t work! Getting started Alright, the challenge now before you is to implement, in order, load , hash , size , check , and unload as efficiently as possible using a hash table in such a way that TIME IN load , TIME IN check , TIME IN size , and TIME IN unload are all minimized. To be sure, it\u2019s not obvious what it even means to be minimized, inasmuch as these benchmarks will certainly vary as you feed speller different values for dictionary and for text . But therein lies the challenge, if not the fun, of this problem. This problem is your chance to design. Although we invite you to minimize space, your ultimate enemy is time. But before you dive in, some specifications from us. You may not alter speller.c or Makefile . You may alter dictionary.c (and, in fact, must in order to complete the implementations of load , hash , size , check , and unload ), but you may not alter the declarations (i.e., prototypes) of load , hash , size , check , or unload . You may, though, add new functions and (local or global) variables to dictionary.c . You may change the value of N in dictionary.c , so that your hash table can have more buckets. You may alter dictionary.h , but you may not alter the declarations of load , hash , size , check , or unload . Your implementation of check must be case-insensitive. In other words, if foo is in dictionary, then check should return true given any capitalization thereof; none of foo , foO , fOo , fOO , fOO , Foo , FoO , FOo , and FOO should be considered misspelled. Capitalization aside, your implementation of check should only return true for words actually in dictionary . Beware hard-coding common words (e.g., the ), lest we pass your implementation a dictionary without those same words. Moreover, the only possessives allowed are those actually in dictionary . In other words, even if foo is in dictionary , check should return false given foo 's if foo 's is not also in dictionary . You may assume that any dictionary passed to your program will be structured exactly like ours, alphabetically sorted from top to bottom with one word per line, each of which ends with \\n . You may also assume that dictionary will contain at least one word, that no word will be longer than LENGTH (a constant defined in dictionary.h ) characters, that no word will appear more than once, that each word will contain only lowercase alphabetical characters and possibly apostrophes, and that no word will start with an apostrophe. You may assume that check will only be passed words that contain (uppercase or lowercase) alphabetical characters and possibly apostrophes. Your spell checker may only take text and, optionally, dictionary as input. Although you might be inclined (particularly if among those more comfortable) to \u201cpre-process\u201d our default dictionary in order to derive an \u201cideal hash function\u201d for it, you may not save the output of any such pre-processing to disk in order to load it back into memory on subsequent runs of your spell checker in order to gain an advantage. Your spell checker must not leak any memory. Be sure to check for leaks with valgrind . You may search for (good) hash functions online, so long as you cite the origin of any hash function you integrate into your own code. Now let's implement load, hash, size, check, and unload! Solution Speller Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // Implements a dictionary's functionality #include <stdbool.h> #include \"ctype.h\" #include \"stdio.h\" #include \"string.h\" #include \"strings.h\" #include \"stdlib.h\" #include \"cs50.h\" #include \"dictionary.h\" // Represents a node in a hash table typedef struct node { char word [ LENGTH + 1 ]; struct node * next ; } node ; // Number of buckets in hash table const unsigned int N = 25 ; //index for int N for A-Z int total_words = 0 ; //counts the total words from dictionary bool is_loaded = false ; //makes sure that dictionary loads // Hash table node * table [ N ]; // Returns true if word is in dictionary else false bool check ( const char * word ) { int i = hash ( word ); if ( table [ i ] == NULL ) { return false ; } for ( node * cursor = table [ i ]; cursor != NULL ; cursor = cursor -> next ) { if ( strcasecmp ( word , cursor -> word ) == 0 ) //compare strings { return true ; } } return false ; } // Hashes word to a number unsigned int hash ( const char * word ) //create hash code using firt letter { char x ; x = tolower ( word [ 0 ]); int hash = x ; hash = hash - 97 ; return hash ; } // Loads dictionary into memory, returning true if successful else false bool load ( const char * dictionary ) { FILE * d = fopen ( dictionary , \"r\" ); if ( d == NULL ) //check if file opened or not { printf ( \"File not found \\n \" ); return false ; } for ( int k = 0 ; k < N ; k ++ ) { table [ k ] = NULL ; //set all pointers in hash table to NULL } char new_word [ LENGTH + 1 ]; while ( fscanf ( d , \"%s\" , new_word ) != EOF ) { node * new_node = malloc ( sizeof ( node )); if ( new_node == NULL ) { return false ; } int i = hash ( new_word ); strcpy ( new_node -> word , new_word ); if ( table [ i ] == NULL ) { new_node -> next = NULL ; table [ i ] = new_node ; total_words ++ ; } else { new_node -> next = table [ i ]; table [ i ] = new_node ; total_words ++ ; } } fclose ( d ); is_loaded = true ; return true ; } // Returns number of words in dictionary if loaded else 0 if not yet loaded unsigned int size ( void ) { if ( is_loaded == true ) { return total_words ; } else { return 0 ; } } // Unloads dictionary from memory, returning true if successful else false bool unload ( void ) { for ( int i = 0 ; i <= N ; i ++ ) { if ( table [ i ] != NULL ) { node * p = table [ i ]; while ( p != NULL ) { node * q = p ; p = p -> next ; free ( q ); } } } return true ; }","title":"Data Structures Problem"},{"location":"c-data-structures-problems/#data-structures-problem","text":"","title":"Data Structures Problem"},{"location":"c-data-structures-problems/#speller","text":"We are going to implement a program that spell-checks a file, like below, using a hash table. $ ./speller texts/lalaland.txt MISSPELLED WORDS [...] AHHHHHHHHHHHHHHHHHHHHHHHHHHHT [...] Shangri [...] fianc [...] Sebastian's [...] WORDS MISSPELLED: WORDS IN DICTIONARY: WORDS IN TEXT: TIME IN load: TIME IN check: TIME IN size: TIME IN unload: TIME IN TOTAL: To download the prerequisite files, click here . This should give you the following files: dictionaries/ dictionary.c dictionary.h keys/ Makefile speller.c texts/","title":"Speller"},{"location":"c-data-structures-problems/#understanding","text":"Theoretically, on input of size n , an algorithm with a running time of n is \u201casymptotically equivalent,\u201d in terms of O , to an algorithm with a running time of 2 n . Indeed, when describing the running time of an algorithm, we typically focus on the dominant (i.e., most impactful) term (i.e., n in this case, since n could be much larger than 2). In the real world, though, the fact of the matter is that 2 n feels twice as slow as n . The challenge ahead is to implement the fastest spell checker we can! By \u201cfastest,\u201d though, we\u2019re talking actual \u201cwall-clock,\u201d not asymptotic, time. In speller.c , we\u2019ve put together a program that\u2019s designed to spell-check a file after loading a dictionary of words from disk into memory. That dictionary, meanwhile, is implemented in a file called dictionary.c . (It could just be implemented in speller.c , but as programs get more complex, it\u2019s often convenient to break them into multiple files.) The prototypes for the functions therein, meanwhile, are defined not in dictionary.c itself but in dictionary.h instead. That way, both speller.c and dictionary.c can #include the file. Unfortunately, we didn\u2019t quite get around to implementing the loading part. Or the checking part. Both (and a bit more) we leave to you! But first, a tour.","title":"Understanding"},{"location":"c-data-structures-problems/#dictionaryh","text":"Open up dictionary.h , and you\u2019ll see some new syntax, including a few lines that mention DICTIONARY_H . No need to worry about those, but, if curious, those lines just ensure that, even though dictionary.c and speller.c (which you\u2019ll see in a moment) #include this file, clang will only compile it once. Next notice how we #include a file called stdbool.h . That\u2019s the file in which bool itself is defined. You\u2019ve not needed it before, since the CS50 Library used to #include that for you. Also notice our use of #define , a \u201cpreprocessor directive\u201d that defines a \u201cconstant\u201d called LENGTH that has a value of 45 . It\u2019s a constant in the sense that you can\u2019t (accidentally) change it in your own code. In fact, clang will replace any mentions of LENGTH in your own code with, literally, 45 . In other words, it\u2019s not a variable, just a find-and-replace trick. Finally, notice the prototypes for five functions: check , hash , load , size , and unload . Notice how three of those take a pointer as an argument, per the * : bool check ( const char * word ); unsigned int hash ( const char * word ); bool load ( const char * dictionary ); Recall that char * is what we used to call string . So those three prototypes are essentially just: bool check ( const string word ); unsigned int hash ( const string word ); bool load ( const string dictionary ); And const , meanwhile, just says that those strings, when passed in as arguments, must remain constant; you won\u2019t be able to change them, accidentally or otherwise!","title":"dictionary.h"},{"location":"c-data-structures-problems/#dictionaryc","text":"Now open up dictionary.c . Notice how, atop the file, we\u2019ve defined a struct called node that represents a node in a hash table. And we\u2019ve declared a global pointer array, table , which will (soon) represent the hash table you will use to keep track of words in the dictionary. The array contains N node pointers, and we\u2019ve set N equal to 1 for now, meaning this hash table has just 1 bucket right now. You\u2019ll likely want to increase the number of buckets, as by changing N , to something larger! Next, notice that we\u2019ve implemented load , hash , check , size , and unload , but only barely, just enough for the code to compile. Your job, ultimately, is to re-implement those functions as cleverly as possible so that this spell checker works as advertised. And fast!","title":"dictionary.c"},{"location":"c-data-structures-problems/#spellerc","text":"Okay, next open up speller.c and spend some time looking over the code and comments therein. You won\u2019t need to change anything in this file, and you don\u2019t need to understand its entirety, but do try to get a sense of its functionality nonetheless. Notice how, by way of a function called getrusage , we\u2019ll be \u201cbenchmarking\u201d (i.e., timing the execution of) your implementations of check , load , size , and unload . Also notice how we go about passing check , word by word, the contents of some file to be spell-checked. Ultimately, we report each misspelling in that file along with a bunch of statistics. Notice, incidentally, that we have defined the usage of speller to be Usage: speller [dictionary] text where dictionary is assumed to be a file containing a list of lowercase words, one per line, and text is a file to be spell-checked. As the brackets suggest, provision of dictionary is optional; if this argument is omitted, speller will use dictionaries/large by default. In other words, running $ ./speller text will be equivalent to running $ ./speller dictionaries/large text where text is the file you wish to spell-check. Suffice it to say, the former is easier to type! (Of course, speller will not be able to load any dictionaries until you implement load in dictionary.c ! Until then, you\u2019ll see Could not load .) Within the default dictionary, mind you, are 143,091 words, all of which must be loaded into memory! In fact, take a peek at that file to get a sense of its structure and size. Notice that every word in that file appears in lowercase (even, for simplicity, proper nouns and acronyms). From top to bottom, the file is sorted lexicographically, with only one word per line (each of which ends with \\n ). No word is longer than 45 characters, and no word appears more than once. During development, you may find it helpful to provide speller with a dictionary of your own that contains far fewer words, lest you struggle to debug an otherwise enormous structure in memory. In dictionaries/small is one such dictionary. To use it, execute $ ./speller dictionaries/small text where text is the file you wish to spell-check. Don\u2019t move on until you\u2019re sure you understand how speller itself works! Odds are, you didn\u2019t spend enough time looking over speller.c . Go back one square and walk yourself through it again!","title":"speller.c"},{"location":"c-data-structures-problems/#texts","text":"So that you can test your implementation of speller , we\u2019ve also provided you with a whole bunch of texts, among them the script from La La Land, the text of the Affordable Care Act, three million bytes from Tolstoy, some excerpts from The Federalist Papers and Shakespeare, the entirety of the King James V Bible and the Koran, and more. So that you know what to expect, open and skim each of those files, all of which are in a directory called texts within your pset5 directory. Now, as you should know from having read over speller.c carefully, the output of speller , if executed with, say, $ ./speller texts/lalaland.txt will eventually resemble the below. For now, try the staff\u2019s solution (using the default dictionary) by executing $ ~cs50/2019/fall/pset5/speller texts/lalaland.txt Below\u2019s some of the output you\u2019ll see. For information\u2019s sake, we\u2019ve excerpted some examples of \u201cmisspellings.\u201d And lest we spoil the fun, we\u2019ve omitted our own statistics for now. MISSPELLED WORDS [...] AHHHHHHHHHHHHHHHHHHHHHHHHHHHT [...] Shangri [...] fianc [...] Sebastian's [...] WORDS MISSPELLED: WORDS IN DICTIONARY: WORDS IN TEXT: TIME IN load: TIME IN check: TIME IN size: TIME IN unload: TIME IN TOTAL: TIME IN load represents the number of seconds that speller spends executing your implementation of load . TIME IN check represents the number of seconds that speller spends, in total, executing your implementation of check . TIME IN size represents the number of seconds that speller spends executing your implementation of size . TIME IN unload represents the number of seconds that speller spends executing your implementation of unload . TIME IN TOTAL is the sum of those four measurements. Note that these times may vary somewhat across executions of speller , depending on what else CS50 IDE is doing, even if you don\u2019t change your code. Incidentally, to be clear, by \u201cmisspelled\u201d we simply mean that some word is not in the dictionary provided.","title":"texts/"},{"location":"c-data-structures-problems/#makefile","text":"And, lastly, recall that make automates compilation of your code so that you don\u2019t have to execute clang manually along with a whole bunch of switches. However, as your programs grow in size, make won\u2019t be able to infer from context anymore how to compile your code; you\u2019ll need to start telling make how to compile your program, particularly when they involve multiple source (i.e., .c ) files, as in the case of this problem. And so we\u2019ll utilize a Makefile , a configuration file that tells make exactly what to do. Open up Makefile , and you should see four lines: The first line tells make to execute the subsequent lines whenever you yourself execute make speller (or just make ). The second line tells make how to compile speller.c into machine code (i.e., speller.o ). The third line tells make how to compile dictionary.c into machine code (i.e., dictionary.o ). The fourth line tells make to link speller.o and dictionary.o in a file called speller . Be sure to compile speller by executing make speller (or just make ). Executing make dictionary won\u2019t work!","title":"Makefile"},{"location":"c-data-structures-problems/#getting-started","text":"Alright, the challenge now before you is to implement, in order, load , hash , size , check , and unload as efficiently as possible using a hash table in such a way that TIME IN load , TIME IN check , TIME IN size , and TIME IN unload are all minimized. To be sure, it\u2019s not obvious what it even means to be minimized, inasmuch as these benchmarks will certainly vary as you feed speller different values for dictionary and for text . But therein lies the challenge, if not the fun, of this problem. This problem is your chance to design. Although we invite you to minimize space, your ultimate enemy is time. But before you dive in, some specifications from us. You may not alter speller.c or Makefile . You may alter dictionary.c (and, in fact, must in order to complete the implementations of load , hash , size , check , and unload ), but you may not alter the declarations (i.e., prototypes) of load , hash , size , check , or unload . You may, though, add new functions and (local or global) variables to dictionary.c . You may change the value of N in dictionary.c , so that your hash table can have more buckets. You may alter dictionary.h , but you may not alter the declarations of load , hash , size , check , or unload . Your implementation of check must be case-insensitive. In other words, if foo is in dictionary, then check should return true given any capitalization thereof; none of foo , foO , fOo , fOO , fOO , Foo , FoO , FOo , and FOO should be considered misspelled. Capitalization aside, your implementation of check should only return true for words actually in dictionary . Beware hard-coding common words (e.g., the ), lest we pass your implementation a dictionary without those same words. Moreover, the only possessives allowed are those actually in dictionary . In other words, even if foo is in dictionary , check should return false given foo 's if foo 's is not also in dictionary . You may assume that any dictionary passed to your program will be structured exactly like ours, alphabetically sorted from top to bottom with one word per line, each of which ends with \\n . You may also assume that dictionary will contain at least one word, that no word will be longer than LENGTH (a constant defined in dictionary.h ) characters, that no word will appear more than once, that each word will contain only lowercase alphabetical characters and possibly apostrophes, and that no word will start with an apostrophe. You may assume that check will only be passed words that contain (uppercase or lowercase) alphabetical characters and possibly apostrophes. Your spell checker may only take text and, optionally, dictionary as input. Although you might be inclined (particularly if among those more comfortable) to \u201cpre-process\u201d our default dictionary in order to derive an \u201cideal hash function\u201d for it, you may not save the output of any such pre-processing to disk in order to load it back into memory on subsequent runs of your spell checker in order to gain an advantage. Your spell checker must not leak any memory. Be sure to check for leaks with valgrind . You may search for (good) hash functions online, so long as you cite the origin of any hash function you integrate into your own code. Now let's implement load, hash, size, check, and unload!","title":"Getting started"},{"location":"c-data-structures-problems/#solution","text":"Speller Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // Implements a dictionary's functionality #include <stdbool.h> #include \"ctype.h\" #include \"stdio.h\" #include \"string.h\" #include \"strings.h\" #include \"stdlib.h\" #include \"cs50.h\" #include \"dictionary.h\" // Represents a node in a hash table typedef struct node { char word [ LENGTH + 1 ]; struct node * next ; } node ; // Number of buckets in hash table const unsigned int N = 25 ; //index for int N for A-Z int total_words = 0 ; //counts the total words from dictionary bool is_loaded = false ; //makes sure that dictionary loads // Hash table node * table [ N ]; // Returns true if word is in dictionary else false bool check ( const char * word ) { int i = hash ( word ); if ( table [ i ] == NULL ) { return false ; } for ( node * cursor = table [ i ]; cursor != NULL ; cursor = cursor -> next ) { if ( strcasecmp ( word , cursor -> word ) == 0 ) //compare strings { return true ; } } return false ; } // Hashes word to a number unsigned int hash ( const char * word ) //create hash code using firt letter { char x ; x = tolower ( word [ 0 ]); int hash = x ; hash = hash - 97 ; return hash ; } // Loads dictionary into memory, returning true if successful else false bool load ( const char * dictionary ) { FILE * d = fopen ( dictionary , \"r\" ); if ( d == NULL ) //check if file opened or not { printf ( \"File not found \\n \" ); return false ; } for ( int k = 0 ; k < N ; k ++ ) { table [ k ] = NULL ; //set all pointers in hash table to NULL } char new_word [ LENGTH + 1 ]; while ( fscanf ( d , \"%s\" , new_word ) != EOF ) { node * new_node = malloc ( sizeof ( node )); if ( new_node == NULL ) { return false ; } int i = hash ( new_word ); strcpy ( new_node -> word , new_word ); if ( table [ i ] == NULL ) { new_node -> next = NULL ; table [ i ] = new_node ; total_words ++ ; } else { new_node -> next = table [ i ]; table [ i ] = new_node ; total_words ++ ; } } fclose ( d ); is_loaded = true ; return true ; } // Returns number of words in dictionary if loaded else 0 if not yet loaded unsigned int size ( void ) { if ( is_loaded == true ) { return total_words ; } else { return 0 ; } } // Unloads dictionary from memory, returning true if successful else false bool unload ( void ) { for ( int i = 0 ; i <= N ; i ++ ) { if ( table [ i ] != NULL ) { node * p = table [ i ]; while ( p != NULL ) { node * q = p ; p = p -> next ; free ( q ); } } } return true ; }","title":"Solution"},{"location":"c-data-structures/","text":"Data Structures Data Structures Summary By this point we've now examined four different ways to store sets of data: Arrays Linked lists Hash tables Tries There are even some variations on these (trees and heaps, quite similar to tries, stacks and queues quite similar to arrays or linked lists, etc.) but this will generally cover most of what we're looking at in C. Arrays Insertion is bad - lots of shifting to fit an element in the middle. Deletion is bad - lots of shifting after removing an element. Lookup is great - random access, constant time. Relatively easy to sort. Relatively small size-wise. Stuck with a fixed size, no flexibility. Linked lists Insertion is easy - just tack onto the front. Deletion is easy - once you find the element. Lookup is bad - have to rely on linear search. Relatively difficult to sort - unless you're willing to compromise on super-fast insertion and instead sort as you construct. Relatively small size-wise (not as small as arrays). Hash tables Insertion is a two-step process - hash, then add. Deletion is easy - once you find the element. Lookup is on average better than with linked lists because you have the benefit of real-world constant factor. Not an ideal data structure if sorting is the goal - just use an array. Can run the gamut on size. Tries Insertion is complex - a lot of dynamic memory allocation, but gets easier as you go. Deletion is easy - just free a node. Lookup is fast - not quite as fast as an array, but almost. Already sorted - sorts as you build in almost all situations. Rapidly becomes huge, even with very little data present, not great if space is at a premium. Pointers In the memory notes, we learned about pointers, malloc , and other useful tools for working with memory. Let's review the following snipped of code: 1 2 3 4 5 6 7 8 9 10 int main ( void ) { int * x ; int * y ; x = malloc ( sizeof ( int )); * x = 42 ; * y = 13 ; } Here, the first two lines of code in our main function are declaring two pointers, x and y . Then, we allocate enough memory for an int with malloc , and stores the address returned by malloc into x . With *x = 42; , we got to the address pointed to by x , and stores the value of 42 into that location. The final line, though, is buggy since we don't know what the value of y is, since we never set a value for it. Instead , we can write: y = x ; * y = 13 ; For a more fun way to understand the above, take a look at the short clip, Pointer Fun with Blinky . Resizing arrays In the arrays notes, we learned about arrays, where we could store the same kind of value in a list side-by-side. But we need to declare the size of arrays when we create them, and when we want to increase the size of the array, the memory surrounding it might be taken up by some other data. One solution might be to allocate more memory in a larger area that's free, and move our array there, where it has more space. This sounds like it could work, but we'll need to copy our array, which becomes an operation with running time of O(n) , since we need to copy each of n elements in an array. We might write a program like the following, to do this in code: copy array code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <stdio.h> #include <stdlib.h> int main ( void ) { // Here, we allocate enough memory to fit three integers, and our variable // list will point to the first integer. int * list = malloc ( 3 * sizeof ( int )); // We should check that we allocated memory correctly, since malloc might // fail to get us enough free memory. if ( list == NULL ) { return 1 ; } // With this syntax, the compiler will do pointer arithmetic for us, and // calculate the byte in memory that list[0], list[1], and list[2] maps to, // since integers are 4 bytes large. list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Now, if we want to resize our array to fit 4 integers, we'll try to allocate // enough memory for them, and temporarily use tmp to point to the first: int * tmp = malloc ( 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, we copy integers from the old array into the new array ... for ( int i = 0 ; i < 3 ; i ++ ) { tmp [ i ] = list [ i ]; } // ... and add the fourth integer: tmp [ 3 ] = 4 ; // We should free the original memory for list, which is why we need a // temporary variable to point to the new array ... free ( list ); // ... and now we can set our list variable to point to the new array that // tmp points to: list = tmp ; // Now, we can print the new array: for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } // And finally, free the memory for the new array. free ( list ); } It turns out that there\u2019s actually a helpful function, realloc , which will reallocate some memory: realloc example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <stdlib.h> int main ( void ) { int * list = malloc ( 3 * sizeof ( int )); if ( list == NULL ) { return 1 ; } list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Here, we give realloc our original array that list points to, and it will // return a new address for a new array, with the old data copied over: int * tmp = realloc ( list , 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, all we need to do is remember the location of the new array: list = tmp ; list [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } free ( list ); } Data Structures Data structures are programming constructs that allow us to store information in different layouts in our computer\u2019s memory. To build a data structure, we\u2019ll need some tools we\u2019ve seen: struct to create custom data types . to access properties in structure * to go to an address in memory pointed to by a pointer Linked Lists So far, we've only had one kind of data structure for representing collections of like values - struct - which give us \"containers\" for holding variables of different types, typically. Arrays are great for element lookup, but unless we want to insert at the very end of an array, inserting elements is quite costly. Arrays also suffer from great inflexibility - what happens if we need a larger array than we thought? Through clever use of pointers, dynamic memory allocation and struct s, we can put the pieces together to develop a new kind of data structure that gives us the ability to grow and shrink a collection of like values to fit our needs. We call this combination of elements, when used in this way, a linked list . A linked list node is a special kind of struct with two members: Data of some type ( int , char , float ...) A pointer to another node of the same type In this way, a set of nodes together can be thought of as forming a chain of elements that we can follow from beginning to end. With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory: This is different than an array since our values are no longer next to one another in memory. This uses two chunks of memory, where the second chunk is used to point at the next chunk of memory. By the way, NUL refers to \\0 , a character that ends a string, and NULL refers to an address of all zeros, or a null pointer that we can think of as pointing nowhere. These chunks are linked by the pointers in the second chunk of memory. In order to work with linked lists effectively, there are a number of operations that we need to understand: Create a linked list when it doesn't already exist . Search through a linked list to find an element . Insert a new node into the linked list . Delete a single element from a linked list . Delete an entire linked list . Create a linked list sllnode * create ( VALUE val ); // ssl stands for \"single-linked list\" in the following code Steps involved: Dynamically allocate space for a new sllnode . Check to make sure we didn't run out of memory. Initialize the node's val field. Initialize the node's next field. Return a pointer to the newly created sllnode . Search through a linked list to find an element bool find ( sllnode * head , VALUE val ); Steps involved: Create a traversal pointer pointing to the list's head. If the current node's val field is what we're looking for, report success. If not, set the traversal point to the next pointer in the list and go back to step 2 (above). If you've reached the end of the list, report failure. Insert a new node into the linked list sllnode * insert ( sllnode * head , VALUE val ); Steps involved: Dynamically allocate space for a new sllnode . Check to make sure we didn't run out of memory. Populate and insert the node at the beginning of the linked list. Return a pointer to the new head of the linked list. Delete a single element from a linked list Deleting a single element from a singley-linked list can be a little tricky because it can cause different problems. There are solutions for this in doubley-linked lists. Delete an entire linked list void destroy ( sllnode * head ); Steps involved: If you've reached a null pointer, stop. Delete the rest of the list. Free the current node. Additional linked list notes Unlike with arrays, we no longer randomly access elements in a linked list. For example, we can no longer access the 5 th element of the list by calculating where it is, in constant time. (Since we know arrays store elements back-to-back, we can add 1, or 4, or the size of our element, to calculate addresses.) Instead, we have to follow each element\u2019s pointer, one at a time. And we need to allocate twice as much memory as we needed before for each element. In code, we might create our own struct called node (like a node from a graph in mathematics), and we need to store both an int and a pointer to the next node called next . 1 2 3 4 5 6 typedef struct node { int number ; struct node * next ; } node ; // this is the nickname for struct node We start this struct with typedef struct node so that we can refer to a node inside our struct. We can build a linked list in code starting with our struct. First, we'll want to remember an empty list, so we can use the null pointer: node *list = NULL; . To add an element, first we'll need to allocate some memory for a node, and set its values: 1 2 3 4 5 6 7 8 9 10 11 12 node * n = malloc ( sizeof ( node )); // We want to make sure malloc succeeded in getting memory for us: if ( n != NULL ) { // This (->) is equivalent to (*n).number, where we first go to the node pointed // to by n, and then set the number property. In C, we can also use this // arrow notation: n -> number = 2 ; // Then we need to store a pointer to the next node in our list, but the // new node won't point to anything (for now): n -> next = NULL ; } Now our list can point to this node: list = n; : To add to our lsit, we'll create a new node the same way, perhaps with the value 4. But now we need to update the pointer in our first node to point to it. since our list pointer points only to the first node (and we can't be sure that the list only has one node), we need to \"follow the breadcrumbs\" and follow each node's next pointer: 1 2 3 4 5 6 7 8 9 10 // Create temporary pointer to what list is pointing to node * tmp = list ; // As long as the node has a next pointer ... while ( tmp -> next != NULL ) { // ... set the temporary to the next node tmp = tmp -> next ; } // Now, tmp points to the last node in our list, and we can update its next // pointer to point to our new node. If we want to insert a node to the front of our linked list, we would need to carefully update our node to point to the one following it, before updating the list. Otherwise, we'll lose the rest of our list: 1 2 3 4 5 // Here, we're inserting a node into the front of the list, so we want its // next pointer to point to the original list, before pointing the list to // n: n -> next = list ; list = n ; And to insert a node in the middle of our list, we can go through the list, following each element one at a time, comparing its values, and changing the next pointers carefully as well. We can combine all of our snippets of code into a complete program: node example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include <stdio.h> #include <stdlib.h> // Represents a node typedef struct node { int number ; struct node * next ; } node ; int main ( void ) { // List of size 0, initially not pointing to anything node * list = NULL ; // Add number to list node * n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 1 ; n -> next = NULL ; // We create our first node, store the value 1 in it, and leave the next // pointer to point to nothing. Then, our list variable can point to it. list = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 2 ; n -> next = NULL ; // Now, we go our first node that list points to, and sets the next pointer // on it to point to our new node, adding it to the end of the list: list -> next = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 3 ; n -> next = NULL ; // We can follow multiple nodes with this syntax, using the next pointer // over and over, to add our third new node to the end of the list: list -> next -> next = n ; // Normally, though, we would want a loop and a temporary variable to add // a new node to our list. // Print list // Here we can iterate over all the nodes in our list with a temporary // variable. First, we have a temporary pointer, tmp, that points to the // list. Then, our condition for continuing is that tmp is not NULL, and // finally, we update tmp to the next pointer of itself. for ( node * tmp = list ; tmp != NULL ; tmp = tmp -> next ) { // Within the node, we'll just print the number stored: printf ( \"%i \\n \" , tmp -> number ); } // Free list // Since we're freeing each node as we go along, we'll use a while loop // and follow each node's next pointer before freeing it, but we'll see // this in more detail in Problem Set 5. while ( list != NULL ) { node * tmp = list -> next ; free ( list ); list = tmp ; } } Hash Table Hash tables combine the random access ability of an array with the dynamism of a linked list. This means (assuming we define our hash table well): Insetion can start to tend toward \u0398(1) Deletion can start to tend toward \u0398(1) Lookup can start to tend toward \u0398(1) \u0398 above stands for the average case. We're gaining the advantages of both types of data structure (arrays & linked lists), while mitigating the disadvantages. To get this performance upgrade, we create a new structure whereby when we insert data into the structure, the data itself gives us a clue about where we will find the data, should we need to look it up later. A hash table amounts to a combination of two things: First, a hash function , which returns a nonnegative integer value called a hash code . Second, an array capable of storing data of the type we wish to place into the data structure. The idea is that we run our data through the hash function, and then store the data in the element of the array represented by the returned hash code. We can implement this in a hash table with an array of 26 pointers, each of which points to a linked list for a letter of the alphabet: Since we have random access with arrays, we can add elements quickly, and also index quickly into a bucket. A bucket might have might have multiple matching values, so we'll use a linked list to store all of them horizontally. (We call this a collision, when two values match in the same way.) This is called a hash table because we use a hash function, which takes some input and maps it to a bucket it should go in. In our example, the hash function is just at the first letter of the name, so it might return 0 for \"Albus\" and 25 for \"Zacharias\". But in the worst case, all the names might start with the same letter, so we might end up with the equivalent of a single linked list again. We might look at the first two letters, and allocate enough buckets for 26x26 possible hashed values, or even the first three letters, and now we\u2019ll need 26x26x26 buckets. But we could still have a worst case where all our values start with the same three characters, so the running time for search is O ( n ). In practice, though, we can get closer to O (1) if we have about as many buckets as possible values, especially if we have an ideal hash function, where we can sort our inputs into unique buckets. Tries We can use another data structure called a trie (prounounced like \"try\", and is short for \"retrieval\"): Tries combine structures and poiinters together to store data in an interesting way. The data to be searched for in the trie is now a roadmap. If you can follow the map from beginning to end, the data exists in the trie, if you can't, it does not exist in the trie. Unlike with a hash table, there are no collisions, and no two pieces of data (unless they are identical) have the same path. Imagine we want to store a dictionary of words efficiently, and be able to access each one in constant time. A trie is like a tree, but each node is an array. Each array will have each letter, A-Z, stored. For each word, the first letter will point to an array, where the next valid letter will point to another array, and so on, until we reach something indicating the end of a valid word. If our word isn\u2019t in the trie, then one of the arrays won\u2019t have a pointer or terminating character for our word. Now, even if our data structure has lots of words, the lookup time will be just the length of the word we\u2019re looking for, and this might be a fixed maximum so we have O (1) for searching and insertion. The cost for this, though, is 26 times as much memory as we need for each character. More data structures A tree is another data structure where each node points to two other nodes, one to the left (with a smaller value) and one to the right (with a larger value): Notice that there are now two dimensions to this data structure, where some nodes are on different \"levels\" than others. We can imagine implementing this with a more complex version of a node in a linked list, where each node has not one but two pointers, one to the value in the \"middle of the left half\" and one to the value in the \"middle of the right half\". Note: all elements to the left of the node are smaller and all elements to the right are greater. This is called a binary search tree because each node has at most two children, or nodes it is pointing to, and a search tree because it's sorted in a way that allows us to search correctly. And like a linked list, we'll want to keep a pointer to just the beginning of the list, but in this case we want to point to the root, or top center node of the tree (the 4 in the image above). Now, we can easily do binary search, and since each node is pointing to another, we can also insert nodes into the tree without moving all of them around as we would have to do with an array. Recursively searching this tree would look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 typedef struct node { int number ; struct node * left ; struct node * right ; } node ; // Here, *tree is a pointer to the root of our tree. bool search ( node * tree ) { // We need a base case, if the current tree (or part of the tree) is NULL, // to return false: if ( tree == NULL ) { return false ; } // Now, depending on if the number in the current node is bigger or smaller, // we can just look at the left or right side of the tree: else if ( 50 < tree -> number ) { return search ( tree -> left ); } else if ( 50 > tree -> number ) { return search ( tree -> right ); } // Otherwise, the number must be equal to what we're looking for: else { return true ; } } The running time of searching a tree is O (log n ) and inserting nodes while keeping the tree balances is also O (log n ). By spending a bit more memory and time to maintain the tree, we've now gained faster searching compared to a plain linked list. There are even higher-level constructs, abstract data structures , where we use our building blocks of arrays, linked lists, hash tables, and tries to implement a solution to some problem. For example, one abstract data structure is a queue , where we want to be able to add values and remove values in a first-in-first-out (FIFO) way. To add a value we might enqueue it, and to remove a value we would dequeue it. And we can implement this with an array that we resize as we add items, or a linked list where we append values to the end. An \u201copposite\u201d data structure would be a stack , where items most recently added (pushed) are removed (popped) first, in a last-in-first-out (LIFO) way. Our email inbox is a stack, where our most recent emails are at the top. Another example is a dictionary , where we can map keys to values, or strings to values, and we can implement one with a hash table where a word comes with some other information (like its definition or meaning).","title":"Data Structures Overview"},{"location":"c-data-structures/#data-structures","text":"","title":"Data Structures"},{"location":"c-data-structures/#data-structures-summary","text":"By this point we've now examined four different ways to store sets of data: Arrays Linked lists Hash tables Tries There are even some variations on these (trees and heaps, quite similar to tries, stacks and queues quite similar to arrays or linked lists, etc.) but this will generally cover most of what we're looking at in C.","title":"Data Structures Summary"},{"location":"c-data-structures/#arrays","text":"Insertion is bad - lots of shifting to fit an element in the middle. Deletion is bad - lots of shifting after removing an element. Lookup is great - random access, constant time. Relatively easy to sort. Relatively small size-wise. Stuck with a fixed size, no flexibility.","title":"Arrays"},{"location":"c-data-structures/#linked-lists","text":"Insertion is easy - just tack onto the front. Deletion is easy - once you find the element. Lookup is bad - have to rely on linear search. Relatively difficult to sort - unless you're willing to compromise on super-fast insertion and instead sort as you construct. Relatively small size-wise (not as small as arrays).","title":"Linked lists"},{"location":"c-data-structures/#hash-tables","text":"Insertion is a two-step process - hash, then add. Deletion is easy - once you find the element. Lookup is on average better than with linked lists because you have the benefit of real-world constant factor. Not an ideal data structure if sorting is the goal - just use an array. Can run the gamut on size.","title":"Hash tables"},{"location":"c-data-structures/#tries","text":"Insertion is complex - a lot of dynamic memory allocation, but gets easier as you go. Deletion is easy - just free a node. Lookup is fast - not quite as fast as an array, but almost. Already sorted - sorts as you build in almost all situations. Rapidly becomes huge, even with very little data present, not great if space is at a premium.","title":"Tries"},{"location":"c-data-structures/#pointers","text":"In the memory notes, we learned about pointers, malloc , and other useful tools for working with memory. Let's review the following snipped of code: 1 2 3 4 5 6 7 8 9 10 int main ( void ) { int * x ; int * y ; x = malloc ( sizeof ( int )); * x = 42 ; * y = 13 ; } Here, the first two lines of code in our main function are declaring two pointers, x and y . Then, we allocate enough memory for an int with malloc , and stores the address returned by malloc into x . With *x = 42; , we got to the address pointed to by x , and stores the value of 42 into that location. The final line, though, is buggy since we don't know what the value of y is, since we never set a value for it. Instead , we can write: y = x ; * y = 13 ; For a more fun way to understand the above, take a look at the short clip, Pointer Fun with Blinky .","title":"Pointers"},{"location":"c-data-structures/#resizing-arrays","text":"In the arrays notes, we learned about arrays, where we could store the same kind of value in a list side-by-side. But we need to declare the size of arrays when we create them, and when we want to increase the size of the array, the memory surrounding it might be taken up by some other data. One solution might be to allocate more memory in a larger area that's free, and move our array there, where it has more space. This sounds like it could work, but we'll need to copy our array, which becomes an operation with running time of O(n) , since we need to copy each of n elements in an array. We might write a program like the following, to do this in code: copy array code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <stdio.h> #include <stdlib.h> int main ( void ) { // Here, we allocate enough memory to fit three integers, and our variable // list will point to the first integer. int * list = malloc ( 3 * sizeof ( int )); // We should check that we allocated memory correctly, since malloc might // fail to get us enough free memory. if ( list == NULL ) { return 1 ; } // With this syntax, the compiler will do pointer arithmetic for us, and // calculate the byte in memory that list[0], list[1], and list[2] maps to, // since integers are 4 bytes large. list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Now, if we want to resize our array to fit 4 integers, we'll try to allocate // enough memory for them, and temporarily use tmp to point to the first: int * tmp = malloc ( 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, we copy integers from the old array into the new array ... for ( int i = 0 ; i < 3 ; i ++ ) { tmp [ i ] = list [ i ]; } // ... and add the fourth integer: tmp [ 3 ] = 4 ; // We should free the original memory for list, which is why we need a // temporary variable to point to the new array ... free ( list ); // ... and now we can set our list variable to point to the new array that // tmp points to: list = tmp ; // Now, we can print the new array: for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } // And finally, free the memory for the new array. free ( list ); } It turns out that there\u2019s actually a helpful function, realloc , which will reallocate some memory: realloc example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <stdlib.h> int main ( void ) { int * list = malloc ( 3 * sizeof ( int )); if ( list == NULL ) { return 1 ; } list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Here, we give realloc our original array that list points to, and it will // return a new address for a new array, with the old data copied over: int * tmp = realloc ( list , 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, all we need to do is remember the location of the new array: list = tmp ; list [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } free ( list ); }","title":"Resizing arrays"},{"location":"c-data-structures/#data-structures_1","text":"Data structures are programming constructs that allow us to store information in different layouts in our computer\u2019s memory. To build a data structure, we\u2019ll need some tools we\u2019ve seen: struct to create custom data types . to access properties in structure * to go to an address in memory pointed to by a pointer","title":"Data Structures"},{"location":"c-data-structures/#linked-lists_1","text":"So far, we've only had one kind of data structure for representing collections of like values - struct - which give us \"containers\" for holding variables of different types, typically. Arrays are great for element lookup, but unless we want to insert at the very end of an array, inserting elements is quite costly. Arrays also suffer from great inflexibility - what happens if we need a larger array than we thought? Through clever use of pointers, dynamic memory allocation and struct s, we can put the pieces together to develop a new kind of data structure that gives us the ability to grow and shrink a collection of like values to fit our needs. We call this combination of elements, when used in this way, a linked list . A linked list node is a special kind of struct with two members: Data of some type ( int , char , float ...) A pointer to another node of the same type In this way, a set of nodes together can be thought of as forming a chain of elements that we can follow from beginning to end. With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory: This is different than an array since our values are no longer next to one another in memory. This uses two chunks of memory, where the second chunk is used to point at the next chunk of memory. By the way, NUL refers to \\0 , a character that ends a string, and NULL refers to an address of all zeros, or a null pointer that we can think of as pointing nowhere. These chunks are linked by the pointers in the second chunk of memory. In order to work with linked lists effectively, there are a number of operations that we need to understand: Create a linked list when it doesn't already exist . Search through a linked list to find an element . Insert a new node into the linked list . Delete a single element from a linked list . Delete an entire linked list .","title":"Linked Lists"},{"location":"c-data-structures/#create-a-linked-list","text":"sllnode * create ( VALUE val ); // ssl stands for \"single-linked list\" in the following code Steps involved: Dynamically allocate space for a new sllnode . Check to make sure we didn't run out of memory. Initialize the node's val field. Initialize the node's next field. Return a pointer to the newly created sllnode .","title":"Create a linked list"},{"location":"c-data-structures/#search-through-a-linked-list-to-find-an-element","text":"bool find ( sllnode * head , VALUE val ); Steps involved: Create a traversal pointer pointing to the list's head. If the current node's val field is what we're looking for, report success. If not, set the traversal point to the next pointer in the list and go back to step 2 (above). If you've reached the end of the list, report failure.","title":"Search through a linked list to find an element"},{"location":"c-data-structures/#insert-a-new-node-into-the-linked-list","text":"sllnode * insert ( sllnode * head , VALUE val ); Steps involved: Dynamically allocate space for a new sllnode . Check to make sure we didn't run out of memory. Populate and insert the node at the beginning of the linked list. Return a pointer to the new head of the linked list.","title":"Insert a new node into the linked list"},{"location":"c-data-structures/#delete-a-single-element-from-a-linked-list","text":"Deleting a single element from a singley-linked list can be a little tricky because it can cause different problems. There are solutions for this in doubley-linked lists.","title":"Delete a single element from a linked list"},{"location":"c-data-structures/#delete-an-entire-linked-list","text":"void destroy ( sllnode * head ); Steps involved: If you've reached a null pointer, stop. Delete the rest of the list. Free the current node.","title":"Delete an entire linked list"},{"location":"c-data-structures/#additional-linked-list-notes","text":"Unlike with arrays, we no longer randomly access elements in a linked list. For example, we can no longer access the 5 th element of the list by calculating where it is, in constant time. (Since we know arrays store elements back-to-back, we can add 1, or 4, or the size of our element, to calculate addresses.) Instead, we have to follow each element\u2019s pointer, one at a time. And we need to allocate twice as much memory as we needed before for each element. In code, we might create our own struct called node (like a node from a graph in mathematics), and we need to store both an int and a pointer to the next node called next . 1 2 3 4 5 6 typedef struct node { int number ; struct node * next ; } node ; // this is the nickname for struct node We start this struct with typedef struct node so that we can refer to a node inside our struct. We can build a linked list in code starting with our struct. First, we'll want to remember an empty list, so we can use the null pointer: node *list = NULL; . To add an element, first we'll need to allocate some memory for a node, and set its values: 1 2 3 4 5 6 7 8 9 10 11 12 node * n = malloc ( sizeof ( node )); // We want to make sure malloc succeeded in getting memory for us: if ( n != NULL ) { // This (->) is equivalent to (*n).number, where we first go to the node pointed // to by n, and then set the number property. In C, we can also use this // arrow notation: n -> number = 2 ; // Then we need to store a pointer to the next node in our list, but the // new node won't point to anything (for now): n -> next = NULL ; } Now our list can point to this node: list = n; : To add to our lsit, we'll create a new node the same way, perhaps with the value 4. But now we need to update the pointer in our first node to point to it. since our list pointer points only to the first node (and we can't be sure that the list only has one node), we need to \"follow the breadcrumbs\" and follow each node's next pointer: 1 2 3 4 5 6 7 8 9 10 // Create temporary pointer to what list is pointing to node * tmp = list ; // As long as the node has a next pointer ... while ( tmp -> next != NULL ) { // ... set the temporary to the next node tmp = tmp -> next ; } // Now, tmp points to the last node in our list, and we can update its next // pointer to point to our new node. If we want to insert a node to the front of our linked list, we would need to carefully update our node to point to the one following it, before updating the list. Otherwise, we'll lose the rest of our list: 1 2 3 4 5 // Here, we're inserting a node into the front of the list, so we want its // next pointer to point to the original list, before pointing the list to // n: n -> next = list ; list = n ; And to insert a node in the middle of our list, we can go through the list, following each element one at a time, comparing its values, and changing the next pointers carefully as well. We can combine all of our snippets of code into a complete program: node example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include <stdio.h> #include <stdlib.h> // Represents a node typedef struct node { int number ; struct node * next ; } node ; int main ( void ) { // List of size 0, initially not pointing to anything node * list = NULL ; // Add number to list node * n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 1 ; n -> next = NULL ; // We create our first node, store the value 1 in it, and leave the next // pointer to point to nothing. Then, our list variable can point to it. list = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 2 ; n -> next = NULL ; // Now, we go our first node that list points to, and sets the next pointer // on it to point to our new node, adding it to the end of the list: list -> next = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 3 ; n -> next = NULL ; // We can follow multiple nodes with this syntax, using the next pointer // over and over, to add our third new node to the end of the list: list -> next -> next = n ; // Normally, though, we would want a loop and a temporary variable to add // a new node to our list. // Print list // Here we can iterate over all the nodes in our list with a temporary // variable. First, we have a temporary pointer, tmp, that points to the // list. Then, our condition for continuing is that tmp is not NULL, and // finally, we update tmp to the next pointer of itself. for ( node * tmp = list ; tmp != NULL ; tmp = tmp -> next ) { // Within the node, we'll just print the number stored: printf ( \"%i \\n \" , tmp -> number ); } // Free list // Since we're freeing each node as we go along, we'll use a while loop // and follow each node's next pointer before freeing it, but we'll see // this in more detail in Problem Set 5. while ( list != NULL ) { node * tmp = list -> next ; free ( list ); list = tmp ; } }","title":"Additional linked list notes"},{"location":"c-data-structures/#hash-table","text":"Hash tables combine the random access ability of an array with the dynamism of a linked list. This means (assuming we define our hash table well): Insetion can start to tend toward \u0398(1) Deletion can start to tend toward \u0398(1) Lookup can start to tend toward \u0398(1) \u0398 above stands for the average case. We're gaining the advantages of both types of data structure (arrays & linked lists), while mitigating the disadvantages. To get this performance upgrade, we create a new structure whereby when we insert data into the structure, the data itself gives us a clue about where we will find the data, should we need to look it up later. A hash table amounts to a combination of two things: First, a hash function , which returns a nonnegative integer value called a hash code . Second, an array capable of storing data of the type we wish to place into the data structure. The idea is that we run our data through the hash function, and then store the data in the element of the array represented by the returned hash code. We can implement this in a hash table with an array of 26 pointers, each of which points to a linked list for a letter of the alphabet: Since we have random access with arrays, we can add elements quickly, and also index quickly into a bucket. A bucket might have might have multiple matching values, so we'll use a linked list to store all of them horizontally. (We call this a collision, when two values match in the same way.) This is called a hash table because we use a hash function, which takes some input and maps it to a bucket it should go in. In our example, the hash function is just at the first letter of the name, so it might return 0 for \"Albus\" and 25 for \"Zacharias\". But in the worst case, all the names might start with the same letter, so we might end up with the equivalent of a single linked list again. We might look at the first two letters, and allocate enough buckets for 26x26 possible hashed values, or even the first three letters, and now we\u2019ll need 26x26x26 buckets. But we could still have a worst case where all our values start with the same three characters, so the running time for search is O ( n ). In practice, though, we can get closer to O (1) if we have about as many buckets as possible values, especially if we have an ideal hash function, where we can sort our inputs into unique buckets.","title":"Hash Table"},{"location":"c-data-structures/#tries_1","text":"We can use another data structure called a trie (prounounced like \"try\", and is short for \"retrieval\"): Tries combine structures and poiinters together to store data in an interesting way. The data to be searched for in the trie is now a roadmap. If you can follow the map from beginning to end, the data exists in the trie, if you can't, it does not exist in the trie. Unlike with a hash table, there are no collisions, and no two pieces of data (unless they are identical) have the same path. Imagine we want to store a dictionary of words efficiently, and be able to access each one in constant time. A trie is like a tree, but each node is an array. Each array will have each letter, A-Z, stored. For each word, the first letter will point to an array, where the next valid letter will point to another array, and so on, until we reach something indicating the end of a valid word. If our word isn\u2019t in the trie, then one of the arrays won\u2019t have a pointer or terminating character for our word. Now, even if our data structure has lots of words, the lookup time will be just the length of the word we\u2019re looking for, and this might be a fixed maximum so we have O (1) for searching and insertion. The cost for this, though, is 26 times as much memory as we need for each character.","title":"Tries"},{"location":"c-data-structures/#more-data-structures","text":"A tree is another data structure where each node points to two other nodes, one to the left (with a smaller value) and one to the right (with a larger value): Notice that there are now two dimensions to this data structure, where some nodes are on different \"levels\" than others. We can imagine implementing this with a more complex version of a node in a linked list, where each node has not one but two pointers, one to the value in the \"middle of the left half\" and one to the value in the \"middle of the right half\". Note: all elements to the left of the node are smaller and all elements to the right are greater. This is called a binary search tree because each node has at most two children, or nodes it is pointing to, and a search tree because it's sorted in a way that allows us to search correctly. And like a linked list, we'll want to keep a pointer to just the beginning of the list, but in this case we want to point to the root, or top center node of the tree (the 4 in the image above). Now, we can easily do binary search, and since each node is pointing to another, we can also insert nodes into the tree without moving all of them around as we would have to do with an array. Recursively searching this tree would look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 typedef struct node { int number ; struct node * left ; struct node * right ; } node ; // Here, *tree is a pointer to the root of our tree. bool search ( node * tree ) { // We need a base case, if the current tree (or part of the tree) is NULL, // to return false: if ( tree == NULL ) { return false ; } // Now, depending on if the number in the current node is bigger or smaller, // we can just look at the left or right side of the tree: else if ( 50 < tree -> number ) { return search ( tree -> left ); } else if ( 50 > tree -> number ) { return search ( tree -> right ); } // Otherwise, the number must be equal to what we're looking for: else { return true ; } } The running time of searching a tree is O (log n ) and inserting nodes while keeping the tree balances is also O (log n ). By spending a bit more memory and time to maintain the tree, we've now gained faster searching compared to a plain linked list. There are even higher-level constructs, abstract data structures , where we use our building blocks of arrays, linked lists, hash tables, and tries to implement a solution to some problem. For example, one abstract data structure is a queue , where we want to be able to add values and remove values in a first-in-first-out (FIFO) way. To add a value we might enqueue it, and to remove a value we would dequeue it. And we can implement this with an array that we resize as we add items, or a linked list where we append values to the end. An \u201copposite\u201d data structure would be a stack , where items most recently added (pushed) are removed (popped) first, in a last-in-first-out (LIFO) way. Our email inbox is a stack, where our most recent emails are at the top. Another example is a dictionary , where we can map keys to values, or strings to values, and we can implement one with a hash table where a word comes with some other information (like its definition or meaning).","title":"More data structures"},{"location":"c-functions/","text":"Functions What are functions? C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented. Why us functions? Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need! Function Declarations The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number. Function Definitions The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back } Function Calls To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; } Function Miscellany Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type. Practice Problem We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Functions"},{"location":"c-functions/#functions","text":"","title":"Functions"},{"location":"c-functions/#what-are-functions","text":"C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented.","title":"What are functions?"},{"location":"c-functions/#why-us-functions","text":"Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need!","title":"Why us functions?"},{"location":"c-functions/#function-declarations","text":"The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number.","title":"Function Declarations"},{"location":"c-functions/#function-definitions","text":"The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back }","title":"Function Definitions"},{"location":"c-functions/#function-calls","text":"To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; }","title":"Function Calls"},{"location":"c-functions/#function-miscellany","text":"Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type.","title":"Function Miscellany"},{"location":"c-functions/#practice-problem","text":"We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Practice Problem"},{"location":"c-memory-problems/","text":"Memory Problems Filter Implement a program that applies filters to BMPs, per the below: $ ./filter -r image.bmp reflected.bmp Background Perhaps the simplest way to represent an image is with a grid of pixels (i.e., dots), each of which can be of a different color. For black-and-white images, we thus need 1 bit per pixel, as 0 could represent black and 1 could represent white, as in the below. In this sense, then, is an image just a bitmap (i.e., a map of bits). For more colorful images, you simply need more bits per pixel. A file format (like BMP , JPEG , or PNG ) that supports \u201c24-bit color\u201d uses 24 bits per pixel. (BMP actually supports 1-, 4-, 8-, 16-, 24-, and 32-bit color.) A 24-bit BMP uses 8 bits to signify the amount of red in a pixel\u2019s color, 8 bits to signify the amount of green in a pixel\u2019s color, and 8 bits to signify the amount of blue in a pixel\u2019s color. If you\u2019ve ever heard of RGB color, well, there you have it: red, green, blue. If the R, G, and B values of some pixel in a BMP are, say, 0xff , 0x00 , and 0x00 in hexadecimal, that pixel is purely red, as 0xff (otherwise known as 255 in decimal) implies \u201ca lot of red,\u201d while 0x00 and 0x00 imply \u201cno green\u201d and \u201cno blue,\u201d respectively. A Bit(map) More Technical Recall that a file is just a sequence of bits, arranged in some fashion. A 24-bit BMP file, then, is essentially just a sequence of bits, (almost) every 24 of which happen to represent some pixel\u2019s color. But a BMP file also contains some \u201cmetadata,\u201d information like an image\u2019s height and width. That metadata is stored at the beginning of the file in the form of two data structures generally referred to as \u201cheaders,\u201d not to be confused with C\u2019s header files. (Incidentally, these headers have evolved over time. This problem uses the latest version of Microsoft\u2019s BMP format, 4.0, which debuted with Windows 95.) The first of these headers, called BITMAPFILEHEADER , is 14 bytes long. (Recall that 1 byte equals 8 bits.) The second of these headers, called BITMAPINFOHEADER , is 40 bytes long. Immediately following these headers is the actual bitmap: an array of bytes, triples of which represent a pixel\u2019s color. However, BMP stores these triples backwards (i.e., as BGR), with 8 bits for blue, followed by 8 bits for green, followed by 8 bits for red. (Some BMPs also store the entire bitmap backwards, with an image\u2019s top row at the end of the BMP file. But we\u2019ve stored this problem set\u2019s BMPs as described herein, with each bitmap\u2019s top row first and bottom row last.) In other words, were we to convert the 1-bit smiley above to a 24-bit smiley, substituting red for black, a 24-bit BMP would store this bitmap as follows, where 0000ff signifies red and ffffff signifies white; we\u2019ve highlighted in red all instances of 0000ff . Because we\u2019ve presented these bits from left to right, top to bottom, in 8 columns, you can actually see the red smiley if you take a step back. To be clear, recall that a hexadecimal digit represents 4 bits. Accordingly, ffffff in hexadecimal actually signifies 111111111111111111111111 in binary. Notice that you could represent a bitmap as a 2-dimensional array of pixels: where the image is an array of rows, each row is an array of pixels. Indeed, that\u2019s how we\u2019ve chosen to represent bitmap images in this problem. Image Filtering What does it even mean to filter an image? You can think of filtering an image as taking the pixels of some original image, and modifying each pixel in such a way that a particular effect is apparent in the resulting image. Grayscale One common filter is the \u201cgrayscale\u201d filter, where we take an image and want to convert it to black-and-white. How does that work? Recall that if the red, green, and blue values are all set to 0x00 (hexadecimal for 0 ), then the pixel is black. And if all values are set to 0xff (hexadecimal for 255 ), then the pixel is white. So long as the red, green, and blue values are all equal, the result will be varying shades of gray along the black-white spectrum, with higher values meaning lighter shades (closer to white) and lower values meaning darker shades (closer to black). So to convert a pixel to grayscale, we just need to make sure the red, green, and blue values are all the same value. But how do we know what value to make them? Well, it\u2019s probably reasonable to expect that if the original red, green, and blue values were all pretty high, then the new value should also be pretty high. And if the original values were all low, then the new value should also be low. In fact, to ensure each pixel of the new image still has the same general brightness or darkness as the old image, we can take the average of the red, green, and blue values to determine what shade of grey to make the new pixel. If you apply that to each pixel in the image, the result will be an image converted to grayscale. Sepia Most image editing programs support a \u201csepia\u201d filter, which gives images an old-timey feel by making the whole image look a bit reddish-brown. An image can be converted to sepia by taking each pixel, and computing new red, green, and blue values based on the original values of the three. There are a number of algorithms for converting an image to sepia, but for this problem, we\u2019ll ask you to use the following algorithm. For each pixel, the sepia color values should be calculated based on the original color values per the below. sepiaRed = .393 * originalRed + .769 * originalGreen + .189 * originalBlue sepiaGreen = .349 * originalRed + .686 * originalGreen + .168 * originalBlue sepiaBlue = .272 * originalRed + .534 * originalGreen + .131 * originalBlue Of course, the result of each of these formulas may not be an integer, but each value could be rounded to the nearest integer. It\u2019s also possible that the result of the formula is a number greater than 255, the maximum value for an 8-bit color value. In that case, the red, green, and blue values should be capped at 255. As a result, we can guarantee that the resulting red, green, and blue values will be whole numbers between 0 and 255, inclusive. Reflection Some filters might also move pixels around. Reflecting an image, for example, is a filter where the resulting image is what you would get by placing the original image in front of a mirror. So any pixels on the left side of the image should end up on the right, and vice versa. Note that all of the original pixels of the original image will still be present in the reflected image, it\u2019s just that those pixels may have rearranged to be in a different place in the image. Blur There are a number of ways to create the effect of blurring or softening an image. For this problem, we\u2019ll use the \u201cbox blur,\u201d which works by taking each pixel and, for each color value, giving it a new value by averaging the color values of neighboring pixels. Consider the following grid of pixels, where we\u2019ve numbered each pixel. The new value of each pixel would be the average of the values of all of the pixels that are within 1 row and column of the original pixel (forming a 3x3 box). For example, each of the color values for pixel 6 would be obtained by averaging the original color values of pixels 1, 2, 3, 5, 6, 7, 9, 10, and 11 (note that pixel 6 itself is included in the average). Likewise, the color values for pixel 11 would be be obtained by averaging the color values of pixels 6, 7, 8, 10, 11, 12, 14, 15 and 16. For a pixel along the edge or corner, like pixel 15, we would still look for all pixels within 1 row and column: in this case, pixels 10, 11, 12, 14, 15, and 16. Problem Solving Get the files for the filter HERE . Now let's look at the files provided to help break understand what is inside. bmp.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // BMP-related data types based on Microsoft's own #include <stdint.h> /** * Common Data Types * * The data types in this section are essentially aliases for C/C++ * primitive data types. * * Adapted from http://msdn.microsoft.com/en-us/library/cc230309.aspx. * See http://en.wikipedia.org/wiki/Stdint.h for more on stdint.h. */ typedef uint8_t BYTE ; typedef uint32_t DWORD ; typedef int32_t LONG ; typedef uint16_t WORD ; /** * BITMAPFILEHEADER * * The BITMAPFILEHEADER structure contains information about the type, size, * and layout of a file that contains a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183374(VS.85).aspx. */ typedef struct { WORD bfType ; DWORD bfSize ; WORD bfReserved1 ; WORD bfReserved2 ; DWORD bfOffBits ; } __attribute__ (( __packed__ )) BITMAPFILEHEADER ; /** * BITMAPINFOHEADER * * The BITMAPINFOHEADER structure contains information about the * dimensions and color format of a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183376(VS.85).aspx. */ typedef struct { DWORD biSize ; LONG biWidth ; LONG biHeight ; WORD biPlanes ; WORD biBitCount ; DWORD biCompression ; DWORD biSizeImage ; LONG biXPelsPerMeter ; LONG biYPelsPerMeter ; DWORD biClrUsed ; DWORD biClrImportant ; } __attribute__ (( __packed__ )) BITMAPINFOHEADER ; /** * RGBTRIPLE * * This structure describes a color consisting of relative intensities of * red, green, and blue. * * Adapted from http://msdn.microsoft.com/en-us/library/aa922590.aspx. */ typedef struct { BYTE rgbtBlue ; BYTE rgbtGreen ; BYTE rgbtRed ; } __attribute__ (( __packed__ )) RGBTRIPLE ; You\u2019ll see definitions of the headers we\u2019ve mentioned ( BITMAPINFOHEADER and BITMAPFILEHEADER ). In addition, that file defines BYTE , DWORD , LONG , and WORD , data types normally found in the world of Windows programming. Notice how they\u2019re just aliases for primitives with which you are (hopefully) already familiar. It appears that BITMAPFILEHEADER and BITMAPINFOHEADER make use of these types. Perhaps most importantly, this file also defines a struct called RGBTRIPLE that, quite simply, \u201cencapsulates\u201d three bytes: one blue, one green, and one red (the order, recall, in which we expect to find RGB triples actually on disk). Why are these struct s useful? Well, recall that a file is just a sequence of bytes (or, ultimately, bits) on disk. But those bytes are generally ordered in such a way that the first few represent something, the next few represent something else, and so on. \u201cFile formats\u201d exist because the world has standardized what bytes mean what. Now, we could just read a file from disk into RAM as one big array of bytes. And we could just remember that the byte at array[i] represents one thing, while the byte at array[j] represents another. But why not give some of those bytes names so that we can retrieve them from memory more easily? That\u2019s precisely what the structs in bmp.h allow us to do. Rather than think of some file as one long sequence of bytes, we can instead think of it as a sequence of struct s. filter.c filter.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include <getopt.h> #include <stdio.h> #include <stdlib.h> #include \"helpers.h\" int main ( int argc , char * argv []) { // Define allowable filters char * filters = \"bgrs\" ; // Get filter flag and check validity char filter = getopt ( argc , argv , filters ); if ( filter == '?' ) { fprintf ( stderr , \"Invalid filter. \\n \" ); return 1 ; } // Ensure only one filter if ( getopt ( argc , argv , filters ) != -1 ) { fprintf ( stderr , \"Only one filter allowed. \\n \" ); return 2 ; } // Ensure proper usage if ( argc != optind + 2 ) { fprintf ( stderr , \"Usage: filter [flag] infile outfile \\n \" ); return 3 ; } // Remember filenames char * infile = argv [ optind ]; char * outfile = argv [ optind + 1 ]; // Open input file FILE * inptr = fopen ( infile , \"r\" ); if ( inptr == NULL ) { fprintf ( stderr , \"Could not open %s. \\n \" , infile ); return 4 ; } // Open output file FILE * outptr = fopen ( outfile , \"w\" ); if ( outptr == NULL ) { fclose ( inptr ); fprintf ( stderr , \"Could not create %s. \\n \" , outfile ); return 5 ; } // Read infile's BITMAPFILEHEADER BITMAPFILEHEADER bf ; fread ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , inptr ); // Read infile's BITMAPINFOHEADER BITMAPINFOHEADER bi ; fread ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , inptr ); // Ensure infile is (likely) a 24-bit uncompressed BMP 4.0 if ( bf . bfType != 0x4d42 || bf . bfOffBits != 54 || bi . biSize != 40 || bi . biBitCount != 24 || bi . biCompression != 0 ) { fclose ( outptr ); fclose ( inptr ); fprintf ( stderr , \"Unsupported file format. \\n \" ); return 6 ; } int height = abs ( bi . biHeight ); int width = bi . biWidth ; // Allocate memory for image RGBTRIPLE ( * image )[ width ] = calloc ( height , width * sizeof ( RGBTRIPLE )); if ( image == NULL ) { fprintf ( stderr , \"Not enough memory to store image. \\n \" ); fclose ( outptr ); fclose ( inptr ); return 7 ; } // Determine padding for scanlines int padding = ( 4 - ( width * sizeof ( RGBTRIPLE )) % 4 ) % 4 ; // Iterate over infile's scanlines for ( int i = 0 ; i < height ; i ++ ) { // Read row into pixel array fread ( image [ i ], sizeof ( RGBTRIPLE ), width , inptr ); // Skip over padding fseek ( inptr , padding , SEEK_CUR ); } // Filter image switch ( filter ) { // Blur case 'b' : blur ( height , width , image ); break ; // Grayscale case 'g' : grayscale ( height , width , image ); break ; // Reflection case 'r' : reflect ( height , width , image ); break ; // Sepia case 's' : sepia ( height , width , image ); break ; } // Write outfile's BITMAPFILEHEADER fwrite ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , outptr ); // Write outfile's BITMAPINFOHEADER fwrite ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , outptr ); // Write new pixels to outfile for ( int i = 0 ; i < height ; i ++ ) { // Write row to outfile fwrite ( image [ i ], sizeof ( RGBTRIPLE ), width , outptr ); // Write padding at end of row for ( int k = 0 ; k < padding ; k ++ ) { fputc ( 0x00 , outptr ); } } // Free memory for image free ( image ); // Close infile fclose ( inptr ); // Close outfile fclose ( outptr ); return 0 ; } First, notice the definition of filters on line 11. That string tells the program what the allowable command-line arguments to the program are: b , g , r , and s . Each of them specifies a different filter that we might apply to our images: blur, grayscale, reflection, and sepia. The next several lines open up an image file, make sure it\u2019s indeed a BMP file, and read all of the pixel information into a 2D array called image . Scroll down to the switch statement that begins on line 102. Notice that, depending on what filter we\u2019ve chosen, a different function is called: if the user chooses filter b , the program calls the blur function; if g , then grayscale is called; if r , then reflect is called; and if s , then sepia is called. Notice, too, that each of these functions take as arguments the height of the image, the width of the image, and the 2D array of pixels. The remaining lines of the program take the resulting image and write them out to a new image file. helpers.h helpers.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \"bmp.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]); This file is quite short, and just provides the function prototypes for the functions you saw earlier. Here, take note of the fact that each function takes a 2D array called image as an argument, where image is an array of height many rows, and each row is itself another array of width many GBTRIPLE s. So if image represents the whole picture, then image[0] represents the first row, and image[0][0] represents the pixel in the upper-left corner of the image. helpers.c helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \"helpers.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } Now, open up helpers.c. Here\u2019s where the implementation of the functions declared in helpers.h belong. But note that, right now, the implementations are missing! We will come back to this later. Makefile filter: clang -fsanitize=signed-integer-overflow -fsanitize=undefined -ggdb3 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -o filter filter.c helpers.c Finally, let\u2019s look at Makefile . This file specifies what should happen when we run a terminal command like make filter . Whereas programs you may have written before were confined to just one file, filter seems to use multiple files: filter.c , bmp.h , helpers.h , and helpers.c . So we\u2019ll need to tell make how to compile this file. Try compiling filter for yourself by going to your terminal and running $ make filter Then, you can run the program by running: $ ./filter -g images/yard.bmp out.bmp which takes the image at images/yard.bmp , and generates a new image called out.bmp after running the pixels through the grayscale function. grayscale doesn\u2019t do anything just yet, though, so the output image should look the same as the original yard. Code and Solution Here are our goals for the filter program: The function grayscale should take an image and turn it into a black-and-white version of the same image. The function sepia should take an image and turn it into a sepia version of the same image. The reflect function should take an image and reflect it horizontally. Finally, the blur function should take an image and turn it into a box-blurred version of the same image. Let's look at helpers.c and add some code: helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \"helpers.h\" #include \"math.h\" #include \"cs50.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int average = round (( pixel . rgbtRed + pixel . rgbtBlue + pixel . rgbtGreen ) / 3.0 ); image [ i ][ j ]. rgbtRed = image [ i ][ j ]. rgbtGreen = image [ i ][ j ]. rgbtBlue = average ; } } } // Convert image to sepia using formula given int capacity ( int value ) { return value > 255 ? 255 : value ; } void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int originalRed = pixel . rgbtRed ; int originalBlue = pixel . rgbtBlue ; int originalGreen = pixel . rgbtGreen ; image [ i ][ j ]. rgbtRed = capacity ( round ( 0.393 * originalRed + 0.769 * originalGreen + 0.189 * originalBlue )); image [ i ][ j ]. rgbtGreen = capacity ( round ( 0.349 * originalRed + 0.686 * originalGreen + 0.168 * originalBlue )); image [ i ][ j ]. rgbtBlue = capacity ( round ( 0.272 * originalRed + 0.534 * originalGreen + 0.131 * originalBlue )); } } } // Reflect image horizontally void swap ( RGBTRIPLE * pixel1 , RGBTRIPLE * pixel2 ) { RGBTRIPLE temp = * pixel1 ; * pixel1 = * pixel2 ; * pixel2 = temp ; } void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width / 2 ; j ++ ) { swap ( & image [ i ][ j ], & image [ i ][ width - 1 - i ]); } } } // Blur image bool is_valid ( int i , int j , int height , int width ) { return i >= 0 && i < height && j >= 0 && j < width ; } RGBTRIPLE get_blur ( int i , int j , int height , int width , RGBTRIPLE image [ height ][ width ]) { int redValue , blueValue , greenValue ; redValue = blueValue = greenValue = 0 ; int num_valid_pixels = 0 ; for ( int di = -1 ; di <= 1 ; di ++ ) // di stand for change in i { for ( int dj = -1 ; dj <= 1 ; dj ++ ) { int new_i = i + di ; int new_j = j + dj ; if ( is_valid ( new_i , new_j , height , width )) { num_valid_pixels ++ ; redValue += image [ new_i ][ new_j ]. rgbtRed ; blueValue += image [ new_i ][ new_j ]. rgbtBlue ; greenValue += image [ new_i ][ new_j ]. rgbtGreen ; } } } RGBTRIPLE blurred_pix ; blurred_pix . rgbtRed = round (( float ) redValue / num_valid_pixels ); blurred_pix . rgbtGreen = round (( float ) greenValue / num_valid_pixels ); blurred_pix . rgbtBlue = round (( float ) blueValue / num_valid_pixels ); return blurred_pix ; } void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { RGBTRIPLE blur_image [ height ][ width ]; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { blur_image [ i ][ j ] = get_blur ( i , j , height , width , image ); } } for ( int i = 0 ; i < height ; i ++ ) for ( int j = 0 ; j < width ; j ++ ) image [ i ][ j ] = blur_image [ i ][ j ]; } Recover Implement a program that recovers JPEGs from a forensic image, per the below. $ ./recover card.raw Background Sometimes, after taking an image, we may delete them by accident. Thankfully, in the computer world, \u201cdeleted\u201d tends not to mean \u201cdeleted\u201d so much as \u201cforgotten.\u201d Even though the camera insists that the card is now blank, we\u2019re pretty sure that\u2019s not quite true. Even though JPEGs are more complicated than BMPs, JPEGs have \u201csignatures,\u201d patterns of bytes that can distinguish them from other file formats. Specifically, the first three bytes of JPEGs are: 0xff 0xd8 0xff from first byte to third byte, left to right. The fourth byte, meanwhile, is either 0xe0 , 0xe1 , 0xe2 , 0xe3 , 0xe4 , 0xe5 , 0xe6 , 0xe7 , 0xe8 , 0xe9 , 0xea , 0xeb , 0xec , 0xed , 0xee , or 0xef . Put another way, the fourth byte\u2019s first four bits are 1110 . Odds are, if you find this pattern of four bytes on media known to store photos (e.g., my memory card), they demarcate the start of a JPEG. To be fair, you might encounter these patterns on some disk purely by chance, so data recovery isn\u2019t an exact science. Fortunately, digital cameras tend to store photographs contiguously on memory cards, whereby each photo is stored immediately after the previously taken photo. Accordingly, the start of a JPEG usually demarks the end of another. However, digital cameras often initialize cards with a FAT file system whose \u201cblock size\u201d is 512 bytes (B). The implication is that these cameras only write to those cards in units of 512 B. A photo that\u2019s 1 MB (i.e., 1,048,576 B) thus takes up 1048576 \u00f7 512 = 2048 \u201cblocks\u201d on a memory card. But so does a photo that\u2019s, say, one byte smaller (i.e., 1,048,575 B)! The wasted space on disk is called \u201cslack space.\u201d Forensic investigators often look at slack space for remnants of suspicious data. The implication of all these details is that you, the investigator, can probably write a program that iterates over a copy of my memory card, looking for JPEGs\u2019 signatures. Each time you find a signature, you can open a new file for writing and start filling that file with bytes from my memory card, closing that file only once you encounter another signature. Moreover, rather than read my memory card\u2019s bytes one at a time, you can read 512 of them at a time into a buffer for efficiency\u2019s sake. Thanks to FAT, you can trust that JPEGs\u2019 signatures will be \u201cblock-aligned.\u201d That is, you need only look for those signatures in a block\u2019s first four bytes. Realize, of course, that JPEGs can span contiguous blocks. Otherwise, no JPEG could be larger than 512 B. But the last byte of a JPEG might not fall at the very end of a block. Recall the possibility of slack space. But not to worry. Because this memory card was brand-new when I started snapping photos, odds are it\u2019d been \u201czeroed\u201d (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. It\u2019s okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable. Now, I only have one memory card, but there are a lot of you! And so I\u2019ve gone ahead and created a \u201cforensic image\u201d of the card, storing its contents, byte after byte, in a file called card.raw . So that you don\u2019t waste time iterating over millions of 0s unnecessarily, I\u2019ve only imaged the first few megabytes of the memory card. But you should ultimately find that the image contains 50 JPEGs. Problem Solving Get the files for the recovery problem HERE . Let's take a look at the code provided in the .zip: recover.c code 1 2 3 4 5 6 7 #include <stdio.h> #include <stdlib.h> int main ( int argc , char * argv []) { } The above code is basically bare of anything, which means we should break down what we need to do: Tasks Open memory card Look for beginning of a JPEG Open a new JPEG file Write 512 bytes until a new JPEG is found Stop at the end of the file Let's look at some things we can do for each step: Open memory card We can take advantage of the fopen() function to open the memory card: FILE * f = fopen ( filename , \"r\" ); Here inside the fopen(); the filename is the name of the file you are trying to open and the \"r\" means you want to read the files. Look for beginning of a JPEG As mentioned previously, each JPEG file starts with a distinct header, meaning that first byte is always 0xff , the second byte is always 0xd8 , the third byte is always 0xff , and the fourth byte can vary a little bit, but always start with 0xe . Luckily for us, each JPEG is stored back-to-back in this problem file. We can utilize the fread() function to look for JPEGs. fread ( data , size , number , inptr ); The above code can be broken down as: data : pointer to where to store data you're reading. size : size of each element to read. number : number of elements to read. inptr : FILE * to read from. For example, we can check to see if the first byte of an array, for example called buffer , contains 0xff : buffer [ 0 ] == 0xff buffer [ 1 ] == 0xd8 buffer [ 2 ] == 0xff buffer[3] is a little bit more confusing because it can vary. We could use a boolean expression here to check all the different variations to start: buffer [ 3 ] == 0xe0 || buffer [ 3 ] == 0xe1 || buffer [ 3 ] == 0xe2 ... But having to write out all 16 variations could become tedious. For a shortcut, we could use bitwise arithmatic: ( buffer [ 3 ] & 0xf0 ) == 0xe0 This is going to say to look at the first 4 bits of this 8 bit byte, and set the remaining 4 bytes to zero. This clears out the last 4 bits and compares the results. Open a new JPEG file After we find a JPEG, we need to make a new JPEG file. To begin we need to have filenames set as ###.jpg , starting at 000.jpg . This will help us keep track of the number of JPEGs found. We can utilize the sprintf() function here, where instead of printing to the terminal, it prints to a string . For example, we could use the following code: sprintf ( filename , \"%03i.jpg\" , 2 ); %03i.jpg simply means to print an integer with 3 digits. Next, to create the new file, we can use the fopen() function again: FILE * img = fopen ( filename , \"w\" ); Notice the \"w\" , which stands for write. To begin writing the new file, we can use the fwrite function: fwrite ( data , size , number , outptr ); The above code can be broken down as: data : pointer to bytes that will be written to file. size : size of each element to write. number : number of elements to write. outptr : FILE * to write to. Returns number of items of size size were read. Pseudocode Open memory card Repeat until end of card: Read 512 bytes into a buffer If start of new JPEG If first JPEG ... Else ... Else If already found JPEG Solution recover.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <stdio.h> #include <stdlib.h> #include <cs50.h> #include <stdint.h> typedef uint8_t BYTE ; //defining BYTE as a byte (unsigned integer of length = 8 bits) #define BLOCK_SIZE 512 // setting BLOCK_SIZE to 512 bytes #define FILE_NAME_SIZE 8 bool start_jpeg ( BYTE buffer []); int main ( int argc , char * argv []) { if ( argc != 2 ) { printf ( \"Usage: ./recover image \\n \" ); return 1 ; } FILE * infile = fopen ( argv [ 1 ], \"r\" ) if ( infile == NULL ) { printf ( \"File not found \\n \" ); return 1 ; } BYTE buffer [ BLOCK_SIZE ]; int file_index = 0 ; bool first_jpeg = false ; FILE * outfile ; while ( fread ( buffer , BLOCK_SIZE , 1 , infile )) { if ( start_jpeg ( buffer )) { if ( ! first_jpeg ) first_jpeg = true ; else fclose ( outfile ); char filename ( FILE_NAME_SIZE ); sprintf ( filename , \"%03i.jpg\" , file_index ++ ); outfile = fopen ( filename , \"w\" ); if ( outfile == NULL ) return 1 ; fwrite ( buffer , BLOCK_SIZE , 1 , outfile ); } else if ( first_jpeg ) { fwrite ( buffer , BLOCK_SIZE , 1 , outfile ) } } fclose ( outfile ); fclose ( infile ); } bool start_jpeg ( BYTE buffer []) { return buffer [ 0 ] == 0xff && buffer [ 1 ] == 0xd8 && buffer [ 2 ] == 0xff && ( buffer [ 3 ] & 0xf0 ) == 0xe0 ; }","title":"Memory Problems"},{"location":"c-memory-problems/#memory-problems","text":"","title":"Memory Problems"},{"location":"c-memory-problems/#filter","text":"Implement a program that applies filters to BMPs, per the below: $ ./filter -r image.bmp reflected.bmp","title":"Filter"},{"location":"c-memory-problems/#background","text":"Perhaps the simplest way to represent an image is with a grid of pixels (i.e., dots), each of which can be of a different color. For black-and-white images, we thus need 1 bit per pixel, as 0 could represent black and 1 could represent white, as in the below. In this sense, then, is an image just a bitmap (i.e., a map of bits). For more colorful images, you simply need more bits per pixel. A file format (like BMP , JPEG , or PNG ) that supports \u201c24-bit color\u201d uses 24 bits per pixel. (BMP actually supports 1-, 4-, 8-, 16-, 24-, and 32-bit color.) A 24-bit BMP uses 8 bits to signify the amount of red in a pixel\u2019s color, 8 bits to signify the amount of green in a pixel\u2019s color, and 8 bits to signify the amount of blue in a pixel\u2019s color. If you\u2019ve ever heard of RGB color, well, there you have it: red, green, blue. If the R, G, and B values of some pixel in a BMP are, say, 0xff , 0x00 , and 0x00 in hexadecimal, that pixel is purely red, as 0xff (otherwise known as 255 in decimal) implies \u201ca lot of red,\u201d while 0x00 and 0x00 imply \u201cno green\u201d and \u201cno blue,\u201d respectively.","title":"Background"},{"location":"c-memory-problems/#a-bitmap-more-technical","text":"Recall that a file is just a sequence of bits, arranged in some fashion. A 24-bit BMP file, then, is essentially just a sequence of bits, (almost) every 24 of which happen to represent some pixel\u2019s color. But a BMP file also contains some \u201cmetadata,\u201d information like an image\u2019s height and width. That metadata is stored at the beginning of the file in the form of two data structures generally referred to as \u201cheaders,\u201d not to be confused with C\u2019s header files. (Incidentally, these headers have evolved over time. This problem uses the latest version of Microsoft\u2019s BMP format, 4.0, which debuted with Windows 95.) The first of these headers, called BITMAPFILEHEADER , is 14 bytes long. (Recall that 1 byte equals 8 bits.) The second of these headers, called BITMAPINFOHEADER , is 40 bytes long. Immediately following these headers is the actual bitmap: an array of bytes, triples of which represent a pixel\u2019s color. However, BMP stores these triples backwards (i.e., as BGR), with 8 bits for blue, followed by 8 bits for green, followed by 8 bits for red. (Some BMPs also store the entire bitmap backwards, with an image\u2019s top row at the end of the BMP file. But we\u2019ve stored this problem set\u2019s BMPs as described herein, with each bitmap\u2019s top row first and bottom row last.) In other words, were we to convert the 1-bit smiley above to a 24-bit smiley, substituting red for black, a 24-bit BMP would store this bitmap as follows, where 0000ff signifies red and ffffff signifies white; we\u2019ve highlighted in red all instances of 0000ff . Because we\u2019ve presented these bits from left to right, top to bottom, in 8 columns, you can actually see the red smiley if you take a step back. To be clear, recall that a hexadecimal digit represents 4 bits. Accordingly, ffffff in hexadecimal actually signifies 111111111111111111111111 in binary. Notice that you could represent a bitmap as a 2-dimensional array of pixels: where the image is an array of rows, each row is an array of pixels. Indeed, that\u2019s how we\u2019ve chosen to represent bitmap images in this problem.","title":"A Bit(map) More Technical"},{"location":"c-memory-problems/#image-filtering","text":"What does it even mean to filter an image? You can think of filtering an image as taking the pixels of some original image, and modifying each pixel in such a way that a particular effect is apparent in the resulting image. Grayscale One common filter is the \u201cgrayscale\u201d filter, where we take an image and want to convert it to black-and-white. How does that work? Recall that if the red, green, and blue values are all set to 0x00 (hexadecimal for 0 ), then the pixel is black. And if all values are set to 0xff (hexadecimal for 255 ), then the pixel is white. So long as the red, green, and blue values are all equal, the result will be varying shades of gray along the black-white spectrum, with higher values meaning lighter shades (closer to white) and lower values meaning darker shades (closer to black). So to convert a pixel to grayscale, we just need to make sure the red, green, and blue values are all the same value. But how do we know what value to make them? Well, it\u2019s probably reasonable to expect that if the original red, green, and blue values were all pretty high, then the new value should also be pretty high. And if the original values were all low, then the new value should also be low. In fact, to ensure each pixel of the new image still has the same general brightness or darkness as the old image, we can take the average of the red, green, and blue values to determine what shade of grey to make the new pixel. If you apply that to each pixel in the image, the result will be an image converted to grayscale. Sepia Most image editing programs support a \u201csepia\u201d filter, which gives images an old-timey feel by making the whole image look a bit reddish-brown. An image can be converted to sepia by taking each pixel, and computing new red, green, and blue values based on the original values of the three. There are a number of algorithms for converting an image to sepia, but for this problem, we\u2019ll ask you to use the following algorithm. For each pixel, the sepia color values should be calculated based on the original color values per the below. sepiaRed = .393 * originalRed + .769 * originalGreen + .189 * originalBlue sepiaGreen = .349 * originalRed + .686 * originalGreen + .168 * originalBlue sepiaBlue = .272 * originalRed + .534 * originalGreen + .131 * originalBlue Of course, the result of each of these formulas may not be an integer, but each value could be rounded to the nearest integer. It\u2019s also possible that the result of the formula is a number greater than 255, the maximum value for an 8-bit color value. In that case, the red, green, and blue values should be capped at 255. As a result, we can guarantee that the resulting red, green, and blue values will be whole numbers between 0 and 255, inclusive. Reflection Some filters might also move pixels around. Reflecting an image, for example, is a filter where the resulting image is what you would get by placing the original image in front of a mirror. So any pixels on the left side of the image should end up on the right, and vice versa. Note that all of the original pixels of the original image will still be present in the reflected image, it\u2019s just that those pixels may have rearranged to be in a different place in the image. Blur There are a number of ways to create the effect of blurring or softening an image. For this problem, we\u2019ll use the \u201cbox blur,\u201d which works by taking each pixel and, for each color value, giving it a new value by averaging the color values of neighboring pixels. Consider the following grid of pixels, where we\u2019ve numbered each pixel. The new value of each pixel would be the average of the values of all of the pixels that are within 1 row and column of the original pixel (forming a 3x3 box). For example, each of the color values for pixel 6 would be obtained by averaging the original color values of pixels 1, 2, 3, 5, 6, 7, 9, 10, and 11 (note that pixel 6 itself is included in the average). Likewise, the color values for pixel 11 would be be obtained by averaging the color values of pixels 6, 7, 8, 10, 11, 12, 14, 15 and 16. For a pixel along the edge or corner, like pixel 15, we would still look for all pixels within 1 row and column: in this case, pixels 10, 11, 12, 14, 15, and 16.","title":"Image Filtering"},{"location":"c-memory-problems/#problem-solving","text":"Get the files for the filter HERE . Now let's look at the files provided to help break understand what is inside. bmp.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // BMP-related data types based on Microsoft's own #include <stdint.h> /** * Common Data Types * * The data types in this section are essentially aliases for C/C++ * primitive data types. * * Adapted from http://msdn.microsoft.com/en-us/library/cc230309.aspx. * See http://en.wikipedia.org/wiki/Stdint.h for more on stdint.h. */ typedef uint8_t BYTE ; typedef uint32_t DWORD ; typedef int32_t LONG ; typedef uint16_t WORD ; /** * BITMAPFILEHEADER * * The BITMAPFILEHEADER structure contains information about the type, size, * and layout of a file that contains a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183374(VS.85).aspx. */ typedef struct { WORD bfType ; DWORD bfSize ; WORD bfReserved1 ; WORD bfReserved2 ; DWORD bfOffBits ; } __attribute__ (( __packed__ )) BITMAPFILEHEADER ; /** * BITMAPINFOHEADER * * The BITMAPINFOHEADER structure contains information about the * dimensions and color format of a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183376(VS.85).aspx. */ typedef struct { DWORD biSize ; LONG biWidth ; LONG biHeight ; WORD biPlanes ; WORD biBitCount ; DWORD biCompression ; DWORD biSizeImage ; LONG biXPelsPerMeter ; LONG biYPelsPerMeter ; DWORD biClrUsed ; DWORD biClrImportant ; } __attribute__ (( __packed__ )) BITMAPINFOHEADER ; /** * RGBTRIPLE * * This structure describes a color consisting of relative intensities of * red, green, and blue. * * Adapted from http://msdn.microsoft.com/en-us/library/aa922590.aspx. */ typedef struct { BYTE rgbtBlue ; BYTE rgbtGreen ; BYTE rgbtRed ; } __attribute__ (( __packed__ )) RGBTRIPLE ; You\u2019ll see definitions of the headers we\u2019ve mentioned ( BITMAPINFOHEADER and BITMAPFILEHEADER ). In addition, that file defines BYTE , DWORD , LONG , and WORD , data types normally found in the world of Windows programming. Notice how they\u2019re just aliases for primitives with which you are (hopefully) already familiar. It appears that BITMAPFILEHEADER and BITMAPINFOHEADER make use of these types. Perhaps most importantly, this file also defines a struct called RGBTRIPLE that, quite simply, \u201cencapsulates\u201d three bytes: one blue, one green, and one red (the order, recall, in which we expect to find RGB triples actually on disk). Why are these struct s useful? Well, recall that a file is just a sequence of bytes (or, ultimately, bits) on disk. But those bytes are generally ordered in such a way that the first few represent something, the next few represent something else, and so on. \u201cFile formats\u201d exist because the world has standardized what bytes mean what. Now, we could just read a file from disk into RAM as one big array of bytes. And we could just remember that the byte at array[i] represents one thing, while the byte at array[j] represents another. But why not give some of those bytes names so that we can retrieve them from memory more easily? That\u2019s precisely what the structs in bmp.h allow us to do. Rather than think of some file as one long sequence of bytes, we can instead think of it as a sequence of struct s. filter.c filter.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include <getopt.h> #include <stdio.h> #include <stdlib.h> #include \"helpers.h\" int main ( int argc , char * argv []) { // Define allowable filters char * filters = \"bgrs\" ; // Get filter flag and check validity char filter = getopt ( argc , argv , filters ); if ( filter == '?' ) { fprintf ( stderr , \"Invalid filter. \\n \" ); return 1 ; } // Ensure only one filter if ( getopt ( argc , argv , filters ) != -1 ) { fprintf ( stderr , \"Only one filter allowed. \\n \" ); return 2 ; } // Ensure proper usage if ( argc != optind + 2 ) { fprintf ( stderr , \"Usage: filter [flag] infile outfile \\n \" ); return 3 ; } // Remember filenames char * infile = argv [ optind ]; char * outfile = argv [ optind + 1 ]; // Open input file FILE * inptr = fopen ( infile , \"r\" ); if ( inptr == NULL ) { fprintf ( stderr , \"Could not open %s. \\n \" , infile ); return 4 ; } // Open output file FILE * outptr = fopen ( outfile , \"w\" ); if ( outptr == NULL ) { fclose ( inptr ); fprintf ( stderr , \"Could not create %s. \\n \" , outfile ); return 5 ; } // Read infile's BITMAPFILEHEADER BITMAPFILEHEADER bf ; fread ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , inptr ); // Read infile's BITMAPINFOHEADER BITMAPINFOHEADER bi ; fread ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , inptr ); // Ensure infile is (likely) a 24-bit uncompressed BMP 4.0 if ( bf . bfType != 0x4d42 || bf . bfOffBits != 54 || bi . biSize != 40 || bi . biBitCount != 24 || bi . biCompression != 0 ) { fclose ( outptr ); fclose ( inptr ); fprintf ( stderr , \"Unsupported file format. \\n \" ); return 6 ; } int height = abs ( bi . biHeight ); int width = bi . biWidth ; // Allocate memory for image RGBTRIPLE ( * image )[ width ] = calloc ( height , width * sizeof ( RGBTRIPLE )); if ( image == NULL ) { fprintf ( stderr , \"Not enough memory to store image. \\n \" ); fclose ( outptr ); fclose ( inptr ); return 7 ; } // Determine padding for scanlines int padding = ( 4 - ( width * sizeof ( RGBTRIPLE )) % 4 ) % 4 ; // Iterate over infile's scanlines for ( int i = 0 ; i < height ; i ++ ) { // Read row into pixel array fread ( image [ i ], sizeof ( RGBTRIPLE ), width , inptr ); // Skip over padding fseek ( inptr , padding , SEEK_CUR ); } // Filter image switch ( filter ) { // Blur case 'b' : blur ( height , width , image ); break ; // Grayscale case 'g' : grayscale ( height , width , image ); break ; // Reflection case 'r' : reflect ( height , width , image ); break ; // Sepia case 's' : sepia ( height , width , image ); break ; } // Write outfile's BITMAPFILEHEADER fwrite ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , outptr ); // Write outfile's BITMAPINFOHEADER fwrite ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , outptr ); // Write new pixels to outfile for ( int i = 0 ; i < height ; i ++ ) { // Write row to outfile fwrite ( image [ i ], sizeof ( RGBTRIPLE ), width , outptr ); // Write padding at end of row for ( int k = 0 ; k < padding ; k ++ ) { fputc ( 0x00 , outptr ); } } // Free memory for image free ( image ); // Close infile fclose ( inptr ); // Close outfile fclose ( outptr ); return 0 ; } First, notice the definition of filters on line 11. That string tells the program what the allowable command-line arguments to the program are: b , g , r , and s . Each of them specifies a different filter that we might apply to our images: blur, grayscale, reflection, and sepia. The next several lines open up an image file, make sure it\u2019s indeed a BMP file, and read all of the pixel information into a 2D array called image . Scroll down to the switch statement that begins on line 102. Notice that, depending on what filter we\u2019ve chosen, a different function is called: if the user chooses filter b , the program calls the blur function; if g , then grayscale is called; if r , then reflect is called; and if s , then sepia is called. Notice, too, that each of these functions take as arguments the height of the image, the width of the image, and the 2D array of pixels. The remaining lines of the program take the resulting image and write them out to a new image file. helpers.h helpers.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \"bmp.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]); This file is quite short, and just provides the function prototypes for the functions you saw earlier. Here, take note of the fact that each function takes a 2D array called image as an argument, where image is an array of height many rows, and each row is itself another array of width many GBTRIPLE s. So if image represents the whole picture, then image[0] represents the first row, and image[0][0] represents the pixel in the upper-left corner of the image. helpers.c helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \"helpers.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } Now, open up helpers.c. Here\u2019s where the implementation of the functions declared in helpers.h belong. But note that, right now, the implementations are missing! We will come back to this later. Makefile filter: clang -fsanitize=signed-integer-overflow -fsanitize=undefined -ggdb3 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -o filter filter.c helpers.c Finally, let\u2019s look at Makefile . This file specifies what should happen when we run a terminal command like make filter . Whereas programs you may have written before were confined to just one file, filter seems to use multiple files: filter.c , bmp.h , helpers.h , and helpers.c . So we\u2019ll need to tell make how to compile this file. Try compiling filter for yourself by going to your terminal and running $ make filter Then, you can run the program by running: $ ./filter -g images/yard.bmp out.bmp which takes the image at images/yard.bmp , and generates a new image called out.bmp after running the pixels through the grayscale function. grayscale doesn\u2019t do anything just yet, though, so the output image should look the same as the original yard.","title":"Problem Solving"},{"location":"c-memory-problems/#code-and-solution","text":"Here are our goals for the filter program: The function grayscale should take an image and turn it into a black-and-white version of the same image. The function sepia should take an image and turn it into a sepia version of the same image. The reflect function should take an image and reflect it horizontally. Finally, the blur function should take an image and turn it into a box-blurred version of the same image. Let's look at helpers.c and add some code: helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \"helpers.h\" #include \"math.h\" #include \"cs50.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int average = round (( pixel . rgbtRed + pixel . rgbtBlue + pixel . rgbtGreen ) / 3.0 ); image [ i ][ j ]. rgbtRed = image [ i ][ j ]. rgbtGreen = image [ i ][ j ]. rgbtBlue = average ; } } } // Convert image to sepia using formula given int capacity ( int value ) { return value > 255 ? 255 : value ; } void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int originalRed = pixel . rgbtRed ; int originalBlue = pixel . rgbtBlue ; int originalGreen = pixel . rgbtGreen ; image [ i ][ j ]. rgbtRed = capacity ( round ( 0.393 * originalRed + 0.769 * originalGreen + 0.189 * originalBlue )); image [ i ][ j ]. rgbtGreen = capacity ( round ( 0.349 * originalRed + 0.686 * originalGreen + 0.168 * originalBlue )); image [ i ][ j ]. rgbtBlue = capacity ( round ( 0.272 * originalRed + 0.534 * originalGreen + 0.131 * originalBlue )); } } } // Reflect image horizontally void swap ( RGBTRIPLE * pixel1 , RGBTRIPLE * pixel2 ) { RGBTRIPLE temp = * pixel1 ; * pixel1 = * pixel2 ; * pixel2 = temp ; } void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width / 2 ; j ++ ) { swap ( & image [ i ][ j ], & image [ i ][ width - 1 - i ]); } } } // Blur image bool is_valid ( int i , int j , int height , int width ) { return i >= 0 && i < height && j >= 0 && j < width ; } RGBTRIPLE get_blur ( int i , int j , int height , int width , RGBTRIPLE image [ height ][ width ]) { int redValue , blueValue , greenValue ; redValue = blueValue = greenValue = 0 ; int num_valid_pixels = 0 ; for ( int di = -1 ; di <= 1 ; di ++ ) // di stand for change in i { for ( int dj = -1 ; dj <= 1 ; dj ++ ) { int new_i = i + di ; int new_j = j + dj ; if ( is_valid ( new_i , new_j , height , width )) { num_valid_pixels ++ ; redValue += image [ new_i ][ new_j ]. rgbtRed ; blueValue += image [ new_i ][ new_j ]. rgbtBlue ; greenValue += image [ new_i ][ new_j ]. rgbtGreen ; } } } RGBTRIPLE blurred_pix ; blurred_pix . rgbtRed = round (( float ) redValue / num_valid_pixels ); blurred_pix . rgbtGreen = round (( float ) greenValue / num_valid_pixels ); blurred_pix . rgbtBlue = round (( float ) blueValue / num_valid_pixels ); return blurred_pix ; } void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { RGBTRIPLE blur_image [ height ][ width ]; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { blur_image [ i ][ j ] = get_blur ( i , j , height , width , image ); } } for ( int i = 0 ; i < height ; i ++ ) for ( int j = 0 ; j < width ; j ++ ) image [ i ][ j ] = blur_image [ i ][ j ]; }","title":"Code and Solution"},{"location":"c-memory-problems/#recover","text":"Implement a program that recovers JPEGs from a forensic image, per the below. $ ./recover card.raw","title":"Recover"},{"location":"c-memory-problems/#background_1","text":"Sometimes, after taking an image, we may delete them by accident. Thankfully, in the computer world, \u201cdeleted\u201d tends not to mean \u201cdeleted\u201d so much as \u201cforgotten.\u201d Even though the camera insists that the card is now blank, we\u2019re pretty sure that\u2019s not quite true. Even though JPEGs are more complicated than BMPs, JPEGs have \u201csignatures,\u201d patterns of bytes that can distinguish them from other file formats. Specifically, the first three bytes of JPEGs are: 0xff 0xd8 0xff from first byte to third byte, left to right. The fourth byte, meanwhile, is either 0xe0 , 0xe1 , 0xe2 , 0xe3 , 0xe4 , 0xe5 , 0xe6 , 0xe7 , 0xe8 , 0xe9 , 0xea , 0xeb , 0xec , 0xed , 0xee , or 0xef . Put another way, the fourth byte\u2019s first four bits are 1110 . Odds are, if you find this pattern of four bytes on media known to store photos (e.g., my memory card), they demarcate the start of a JPEG. To be fair, you might encounter these patterns on some disk purely by chance, so data recovery isn\u2019t an exact science. Fortunately, digital cameras tend to store photographs contiguously on memory cards, whereby each photo is stored immediately after the previously taken photo. Accordingly, the start of a JPEG usually demarks the end of another. However, digital cameras often initialize cards with a FAT file system whose \u201cblock size\u201d is 512 bytes (B). The implication is that these cameras only write to those cards in units of 512 B. A photo that\u2019s 1 MB (i.e., 1,048,576 B) thus takes up 1048576 \u00f7 512 = 2048 \u201cblocks\u201d on a memory card. But so does a photo that\u2019s, say, one byte smaller (i.e., 1,048,575 B)! The wasted space on disk is called \u201cslack space.\u201d Forensic investigators often look at slack space for remnants of suspicious data. The implication of all these details is that you, the investigator, can probably write a program that iterates over a copy of my memory card, looking for JPEGs\u2019 signatures. Each time you find a signature, you can open a new file for writing and start filling that file with bytes from my memory card, closing that file only once you encounter another signature. Moreover, rather than read my memory card\u2019s bytes one at a time, you can read 512 of them at a time into a buffer for efficiency\u2019s sake. Thanks to FAT, you can trust that JPEGs\u2019 signatures will be \u201cblock-aligned.\u201d That is, you need only look for those signatures in a block\u2019s first four bytes. Realize, of course, that JPEGs can span contiguous blocks. Otherwise, no JPEG could be larger than 512 B. But the last byte of a JPEG might not fall at the very end of a block. Recall the possibility of slack space. But not to worry. Because this memory card was brand-new when I started snapping photos, odds are it\u2019d been \u201czeroed\u201d (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. It\u2019s okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable. Now, I only have one memory card, but there are a lot of you! And so I\u2019ve gone ahead and created a \u201cforensic image\u201d of the card, storing its contents, byte after byte, in a file called card.raw . So that you don\u2019t waste time iterating over millions of 0s unnecessarily, I\u2019ve only imaged the first few megabytes of the memory card. But you should ultimately find that the image contains 50 JPEGs.","title":"Background"},{"location":"c-memory-problems/#problem-solving_1","text":"Get the files for the recovery problem HERE . Let's take a look at the code provided in the .zip: recover.c code 1 2 3 4 5 6 7 #include <stdio.h> #include <stdlib.h> int main ( int argc , char * argv []) { } The above code is basically bare of anything, which means we should break down what we need to do: Tasks Open memory card Look for beginning of a JPEG Open a new JPEG file Write 512 bytes until a new JPEG is found Stop at the end of the file Let's look at some things we can do for each step: Open memory card We can take advantage of the fopen() function to open the memory card: FILE * f = fopen ( filename , \"r\" ); Here inside the fopen(); the filename is the name of the file you are trying to open and the \"r\" means you want to read the files. Look for beginning of a JPEG As mentioned previously, each JPEG file starts with a distinct header, meaning that first byte is always 0xff , the second byte is always 0xd8 , the third byte is always 0xff , and the fourth byte can vary a little bit, but always start with 0xe . Luckily for us, each JPEG is stored back-to-back in this problem file. We can utilize the fread() function to look for JPEGs. fread ( data , size , number , inptr ); The above code can be broken down as: data : pointer to where to store data you're reading. size : size of each element to read. number : number of elements to read. inptr : FILE * to read from. For example, we can check to see if the first byte of an array, for example called buffer , contains 0xff : buffer [ 0 ] == 0xff buffer [ 1 ] == 0xd8 buffer [ 2 ] == 0xff buffer[3] is a little bit more confusing because it can vary. We could use a boolean expression here to check all the different variations to start: buffer [ 3 ] == 0xe0 || buffer [ 3 ] == 0xe1 || buffer [ 3 ] == 0xe2 ... But having to write out all 16 variations could become tedious. For a shortcut, we could use bitwise arithmatic: ( buffer [ 3 ] & 0xf0 ) == 0xe0 This is going to say to look at the first 4 bits of this 8 bit byte, and set the remaining 4 bytes to zero. This clears out the last 4 bits and compares the results. Open a new JPEG file After we find a JPEG, we need to make a new JPEG file. To begin we need to have filenames set as ###.jpg , starting at 000.jpg . This will help us keep track of the number of JPEGs found. We can utilize the sprintf() function here, where instead of printing to the terminal, it prints to a string . For example, we could use the following code: sprintf ( filename , \"%03i.jpg\" , 2 ); %03i.jpg simply means to print an integer with 3 digits. Next, to create the new file, we can use the fopen() function again: FILE * img = fopen ( filename , \"w\" ); Notice the \"w\" , which stands for write. To begin writing the new file, we can use the fwrite function: fwrite ( data , size , number , outptr ); The above code can be broken down as: data : pointer to bytes that will be written to file. size : size of each element to write. number : number of elements to write. outptr : FILE * to write to. Returns number of items of size size were read. Pseudocode Open memory card Repeat until end of card: Read 512 bytes into a buffer If start of new JPEG If first JPEG ... Else ... Else If already found JPEG","title":"Problem Solving"},{"location":"c-memory-problems/#solution","text":"recover.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <stdio.h> #include <stdlib.h> #include <cs50.h> #include <stdint.h> typedef uint8_t BYTE ; //defining BYTE as a byte (unsigned integer of length = 8 bits) #define BLOCK_SIZE 512 // setting BLOCK_SIZE to 512 bytes #define FILE_NAME_SIZE 8 bool start_jpeg ( BYTE buffer []); int main ( int argc , char * argv []) { if ( argc != 2 ) { printf ( \"Usage: ./recover image \\n \" ); return 1 ; } FILE * infile = fopen ( argv [ 1 ], \"r\" ) if ( infile == NULL ) { printf ( \"File not found \\n \" ); return 1 ; } BYTE buffer [ BLOCK_SIZE ]; int file_index = 0 ; bool first_jpeg = false ; FILE * outfile ; while ( fread ( buffer , BLOCK_SIZE , 1 , infile )) { if ( start_jpeg ( buffer )) { if ( ! first_jpeg ) first_jpeg = true ; else fclose ( outfile ); char filename ( FILE_NAME_SIZE ); sprintf ( filename , \"%03i.jpg\" , file_index ++ ); outfile = fopen ( filename , \"w\" ); if ( outfile == NULL ) return 1 ; fwrite ( buffer , BLOCK_SIZE , 1 , outfile ); } else if ( first_jpeg ) { fwrite ( buffer , BLOCK_SIZE , 1 , outfile ) } } fclose ( outfile ); fclose ( infile ); } bool start_jpeg ( BYTE buffer []) { return buffer [ 0 ] == 0xff && buffer [ 1 ] == 0xd8 && buffer [ 2 ] == 0xff && ( buffer [ 3 ] & 0xf0 ) == 0xe0 ; }","title":"Solution"},{"location":"c-memory/","text":"Memory In previous weeks, we have discussed binary. We have also covered how each byte has an address, or identifier, so we can refer to where our variables are actually stored. It turns out, by convention, the addresses for memory use the counting system hexadecimal , where there are 16 digits (0-9 and A-F). In binary ( base-2 ), each digit stood for a power of 2: 128 64 32 16 8 4 2 1 1 1 1 1 1 1 1 1 With 8 bits, we can count up to 255. Hexadecimal ( base-16 ) is a much more concise way to express the data on a computer's system. Hexadecimal is displayed as follows: 0 1 2 3 4 5 6 7 8 9 A B C D E F . Just like binary has place values (1, 2, 4, 8...) and decimal has place values (1, 10, 100, 1000...), hexadecimal does too. Hexadecimal's place values are by the power of 16. For example, if we were to look at the hex number 0x397, it would be as follows: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x 3 9 7 So the above number would be (3 x 256) + (9 x 16) + 7 = 919. Another example that uses alphanumeric hex characters: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x A D C This would look like (10 x 256) + (13 x 16) + 12 = 2780 in decimal form. Here, the F is a value of 15 in decimal, and each place is a power of 16, so the first F is 16^1 * 15 = 240, plus the second F with the value of 16^0 * 15 = 15, for a total of 255. Here is a quick chart to compare decimal, hexadecimal, and binary: The RGB color system also conventionally uses hexadecimal to describe the amount of each color. For example, 000000 in hexadecimal means 0 of each red, green, and blue, for a color of black. And FF0000 would be 255, or the highest possible, amount of red. With different values for each color, we can represent millions of different colors. In writing, we can also indicate a value is in hexadecimal by prefixing it with 0x , as in 0x10 , where the value is equal to 16 in decimal, as opposed to 10. 0x means nothing to a computer, this is simply to help humans see when hexadecimal will be used. Pointers Pointers provide an alternative way to pass data between functions. Up until this point we have passed all data by value, which means we have only passed a copy of that data. If we use pointers instead, we have the power to pass the actual variable itself. That means that if a change is made in one function, it can impact what happens in other functions. Let's create a small program that prints out a value of n : 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , n ); } In our computer's memory, there are now 4 bytes somewhere that have the binary value of 50, labeled n . The bytes for the variable n will start at a unique address and may look something like 0x12345678 . In C, we can actually see the address with the & operator, which means \"get the address of this variable\": 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%p \\n \" , & n ); // notice the %p and & here } When this program was run, I received the result 0x7ffe5878a42c . The address of a variable is called a pointer , which we can think of as a value that \"points\" to a location in the memory. The * operator lets us \"go to\" the location that a pointer is point to. For example, we can print *&n , where we \"go to\" the address of n and print out the value of n , 50 . The * is known as the deference operator . It \"goes to the reference\" and access that data at that location, allowing you to manipulate it at will. 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , *& n ); // notice the *&n here } We also have to use the * operator (in an unfortunately confusing way) to declare a variable that we want to be a pointer: 1 2 3 4 5 6 7 8 #include <stdio.h> int main ( void ) { int n = 50 ; int * p = & n ; // declaring the pointer variable printf ( \"%p \\n \" , p ); } Here, we use int *p to declare a variable, p , that has the type of * , a pointer, to a value of type int , an integer. Then, we can print its value (something like 0x12345678 ), or print the value at its location with printf(\"%i\\n\", *p); . In our computer\u2019s memory, the variables might look like this (each square representing a byte of memory): We have a pointer, p , with the address of some variable. We can abstract away the actual value of the addresses now, since they\u2019ll be different as we declare variables in our programs, and simply think of p as \u201cpointing at\u201d some value: An easier way to look at this is if we have a mailbox labeled \"123\", with the number \"50\" inside it. The mailbox would be int n , since it stores an integer. We might have another mailbox with the address \u201c456\u201d, inside of which is the value \u201c123\u201d, which is the address of our other mailbox. This would be int *p , since it\u2019s a pointer to an integer. A pointer , then, is a data item whose value is a memory address type describes the data located at that memory address The simplest pointer available to us in C is the NULL pointer. As you might expect, this pointer points to nothing (a fact which can actually come in handy). When you create a pointer and you don't set its value immediately, you should always set the value of the pointer to NULL. string Let's use a variable string s for a name like EMMA for an example. We should be able to access each character in EMMA with s[0] - s[4] : It actually turns out that each character is stored in memory at a byte with some address, and s is actually just a pointer with the address of the first character: Because s is just a pointer to the beginning, only the \\0 indicates the end of the string. In fact, the CS50 Library defines a string with typedef char *string , which just says that we want to name a new type, string , as a char * , or a pointer to a character. 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { char * s = \"EMMA\" ; // notice how we are no longer using string, we are using char *s printf ( \"%s \\n \" , s ); } Compare and Copy Let's create a quick program to compare integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two integers int i = get_int ( \"i: \" ); int j = get_int ( \"j: \" ); // Compare integers if ( i == j ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } We can compile and run this, and our program works as we\u2019d expect, with the same values of the two integers giving us \u201cSame\u201d and different values \u201cDifferent\u201d. Now let's try the same thing, but using strings instead of integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two strings string s = get_string ( \"s: \" ); string t = get_string ( \"t: \" ); // Compare strings' addresses if ( s == t ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } If we run the above program we will see that it will give us the result \"Different\" each time, even when the strings are identical. Why does this happen? Simply, this is caused by how C stores strings in memory. When these are compared, C looks at the addresses of the stings, not the user input data. The strings are stored in different places of memory (pointers), which will return different hexadecimal results when compared. Now let's look at how we can copy strings. Let's make a simple program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cs50.h> #include <ctype.h> #include <stdio.h> int main ( void ) { string s = get_string ( \"s: \" ); string t = s ; // copies string s to string t (but only as an address) t [ 0 ] = toupper ( t [ 0 ]); // capitalizes string t // Print string twice printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We get a string s , and copy the value of s into t . Then, we capitalize the first letter in t . But when we run our program, we see that both s and t are now capitalized. Since we set s and t to the same values, they\u2019re actually pointers to the same character, and so we capitalized the same character! To actually make a copy of a string, we have to do a little more work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <string.h> // needed for strlen (string length) int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); // malloc is \"memory allocate\" to store the copy for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) // we need n+1 for the null character in a string { t [ i ] = s [ i ]; // copies strings } t [ 0 ] = toupper ( t [ 0 ]); // capitalizes the first character of the string printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We create a new variable, t , of the type char * , with char *t . Now, we want to point it to a new chunk of memory that\u2019s large enough to store the copy of the string. With malloc , we can allocate some number of bytes in memory (that aren\u2019t already used to store other values), and we pass in the number of bytes we\u2019d like. We already know the length of s , so we add 1 to that for the terminating null character. So, our final line of code is char *t = malloc(strlen(s) + 1); . Then, we copy each character, one at a time, and now we can capitalize just the first letter of t . And we use i < n + 1 , since we actually want to go up to n , to ensure we copy the terminating character in the string. We can actually also use the strcpy library function with strcpy(t, s) instead of our loop, to copy the string s into t . To be clear, the concept of a \u201cstring\u201d is from the C language and well-supported; the only training wheels from CS50 are the type string instead of char * , and the get_string function. If we didn\u2019t copy the null terminating character, \\0 , and tried to print out our string t , printf will continue and print out the unknown, or garbage, values that we have in memory, until it happens to reach a \\0 , or crashes entirely, since our program might end up trying to read memory that doesn\u2019t belong to it! valgrind It turns out that, after we\u2019re done with memory that we\u2019ve allocated with malloc , we should call free (as in free(t) ), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again. If we kept running our program and allocating memory with malloc , but never freed the memory after we were done using it, we would have a memory leak , which will slow down our computer and use up more and more memory until our computer runs out. valgrind is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with help50 valgrind ./*program* and see, from the error message, that line 10, we allocated memory that we never freed (or \u201clost\u201d). So at the end, we can add a line free(t) , which won\u2019t change how our program runs, but no errors from valgrind. Let's look at an example program provided from valgrind's official documentation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare #include <stdlib.h> void f ( void ) { int * x = malloc ( 10 * sizeof ( int )); x [ 10 ] = 0 ; // this int [10] is not in the correct range (0-9) and will result in a buffer overflow } int main ( void ) { f (); return 0 ; } The function f allocates enough memory for 10 integers, and stores the address in a pointer called x . Then we try to set the 11 th value of x with x[10] to 0 , which goes past the array of memory we\u2019ve allocated for our program. This is called buffer overflow , where we go past the boundaries of our buffer, or array, and into unknown memory. valgrind will also tell us there\u2019s an \u201cInvalid write of size 4\u201d for line 8, where we are indeed trying to change the value of an integer (of size 4 bytes). Swap We have two colored drinks, purple and green, each of which is in a cup. We want to swap the drinks between the two cups, but we can\u2019t do that without a third cup (temporary variable) to pour one of the drink into first. Now, let\u2019s say we wanted to swap the values of two integers. 1 2 3 4 5 6 void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } With a third variable to use as temporary storage space, we can do this pretty easily, by putting a into tmp , and then b to a , and finally the original value of a , now in tmp , into b . But, if we tried to use that function in a program, we don\u2019t see any changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> void swap ( int a , int b ); int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( x , y ); printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } This does not work because the swap function successfully swaps int a and int b , but these are simply copies of int x and int y . When x and y are printed, the copies used by the swap funciton do not alter the actual x and y integers in the main function. Memory Layout Within our computer\u2019s memory, the different types of data that need to be stored for our program are organized into different sections: The machine code section is our compiled program\u2019s binary code. When we run our program, that code is loaded into the \u201ctop\u201d of memory. Globals are global variables we declare in our program or other shared variables that our entire program can access. The heap section is an empty area where malloc can get free memory from, for our program to use. The stack section is used by functions in our program as they are called. For example, our main function is at the very bottom of the stack, and has the local variables x and y . The swap function, when it\u2019s called, has its own frame, or slice, of memory that\u2019s on top of main \u2019s, with the local variables a , b , and tmp : Once the function swap returns, the memory it was using is freed for the next function call, and we lose anything we did, other than the return values, and our program goes back to the function that called swap . So by passing in the addresses of x and y from main to swap , we can actually change the values of x and y : By passing in the address of x and y , our swap function from above can actually work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> void swap ( int * a , int * b ); // we use * throughout to point to the real integer, not the copy int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( & x , & y ); // address of x and y printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; } The addresses of x and y are passed in from main to swap , and we use the int *a syntax to declare that our swap function takes in pointers. We save the value of x to tmp by following the pointer a , and then take the value of y by following the pointer b , and store that to the location a is pointing to ( x ). Finally, we store the value of tmp to the location pointed to by b ( y ), and we\u2019re done. If we call malloc too many times, we will have a heap overflow , where we end up going past our heap. Or, if we have too many functions being called, we will have a stack overflow , where our stack has too many frames of memory allocated as well. And these two types of overflow are generally known as buffer overflows, after which our program (or entire computer) might crash. get_int We can implement get_int ourselve with a C library function, scanf : 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { int x ; printf ( \"x: \" ); scanf ( \"%i\" , & x ); printf ( \"x: %i \\n \" , x ); } scanf takes a format, %i , so the input is \u201cscanned\u201d for that format, and the address in memory where we want that input to go. But scanf doesn\u2019t have much error checking, so we might not get an integer. We can try to get a string the same way: 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { char * s = NULL ; printf ( \"s: \" ); scanf ( \"%s\" , s ); printf ( \"s: %s \\n \" , s ); } But we haven\u2019t actually allocated any memory for s ( s is NULL , or not pointing to anything), so we might want to call char s[5] to allocate an array of 5 characters for our string. Then, s will be treated as a pointer in scanf and printf . Now, if the user types in a string of length 4 or less, our program will work safely. But if the user types in a longer string, scanf might be trying to write past the end of our array into unknown memory, causing our program to crash. File Pointers The ability to read data from and write data to files is the primary means of storing persistent data , data that does not disappear when your program stops running. The abstraction of files that C provides is implemented in a data structure known as a FILE . Almost universally when working with files, we will be using pointers to them, FILE* . Some of the most common file input/output (I/O) functions that we will be working with are: fopen() , fclose() , fgetc() , fputc() , fread() , and fwrite() . fopen() opens a file and returns a file pointer to it. It always checks the return value to make sure you don't get back NULL. fclose() closes the file pointed to by the given file pointer. fgetc() reads and returns the next character from the file pointed to. Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fputc() writes or appends the specified character to the pointed-to file. Note: the operation of the file pointer must be \"w\" for write or \"a\" for append, or you will have an error. fread() reads <qty> units of size <size> from the file pointed to and stores them in memory in a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fwrite() writes <qty> units of size <size> to the file pointed to by reading them from a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"w\" for write or \"a\" for append, or you will suffer an error. With the ability to use pointers, we can also open files: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { // Open file FILE * file = fopen ( \"phonebook.csv\" , \"a\" ); // Get strings from user char * name = get_string ( \"Name: \" ); char * number = get_string ( \"Number: \" ); // Print (write) strings to file fprintf ( file , \"%s,%s \\n \" , name , number ); // Close file fclose ( file ); } fopen is a new function we can use to open a file. It will return a pointer to a new type, FILE , that we can read from and write to. The first argument is the name of the file, and the second argument is the mode we want to open the file in ( r for read, w for write, and a for append, or adding to). After we get some strings, we can use fprintf to print to a file. Finally, we close the file with fclose . Now we can create our own CSV files, files of comma-separated values (like a mini-spreadsheet), programmatically. JPEG We can also write a program that opens a file and tells us if it\u2019s a JPEG (image) file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> int main ( int argc , char * argv []) { // Check usage if ( argc != 2 ) { return 1 ; } // Open file FILE * file = fopen ( argv [ 1 ], \"r\" ); if ( ! file ) { return 1 ; } // Read first three bytes unsigned char bytes [ 3 ]; fread ( bytes , 3 , 1 , file ); // Check first three bytes if ( bytes [ 0 ] == 0xff && bytes [ 1 ] == 0xd8 && bytes [ 2 ] == 0xff ) { printf ( \"Maybe \\n \" ); } else { printf ( \"No \\n \" ); } // Close file fclose ( file ); } Now, if we run this program with ./jpeg brian.jpg , our program will try to open the file we specify (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with fread . We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they\u2019re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they\u2019re not the same, we know it\u2019s definitely not a JPEG file. We can use these abilities to read and write files, in particular images, and modify them by changing the bytes in them, in this week\u2019s problem set!","title":"Memory Overview"},{"location":"c-memory/#memory","text":"In previous weeks, we have discussed binary. We have also covered how each byte has an address, or identifier, so we can refer to where our variables are actually stored. It turns out, by convention, the addresses for memory use the counting system hexadecimal , where there are 16 digits (0-9 and A-F). In binary ( base-2 ), each digit stood for a power of 2: 128 64 32 16 8 4 2 1 1 1 1 1 1 1 1 1 With 8 bits, we can count up to 255. Hexadecimal ( base-16 ) is a much more concise way to express the data on a computer's system. Hexadecimal is displayed as follows: 0 1 2 3 4 5 6 7 8 9 A B C D E F . Just like binary has place values (1, 2, 4, 8...) and decimal has place values (1, 10, 100, 1000...), hexadecimal does too. Hexadecimal's place values are by the power of 16. For example, if we were to look at the hex number 0x397, it would be as follows: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x 3 9 7 So the above number would be (3 x 256) + (9 x 16) + 7 = 919. Another example that uses alphanumeric hex characters: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x A D C This would look like (10 x 256) + (13 x 16) + 12 = 2780 in decimal form. Here, the F is a value of 15 in decimal, and each place is a power of 16, so the first F is 16^1 * 15 = 240, plus the second F with the value of 16^0 * 15 = 15, for a total of 255. Here is a quick chart to compare decimal, hexadecimal, and binary: The RGB color system also conventionally uses hexadecimal to describe the amount of each color. For example, 000000 in hexadecimal means 0 of each red, green, and blue, for a color of black. And FF0000 would be 255, or the highest possible, amount of red. With different values for each color, we can represent millions of different colors. In writing, we can also indicate a value is in hexadecimal by prefixing it with 0x , as in 0x10 , where the value is equal to 16 in decimal, as opposed to 10. 0x means nothing to a computer, this is simply to help humans see when hexadecimal will be used.","title":"Memory"},{"location":"c-memory/#pointers","text":"Pointers provide an alternative way to pass data between functions. Up until this point we have passed all data by value, which means we have only passed a copy of that data. If we use pointers instead, we have the power to pass the actual variable itself. That means that if a change is made in one function, it can impact what happens in other functions. Let's create a small program that prints out a value of n : 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , n ); } In our computer's memory, there are now 4 bytes somewhere that have the binary value of 50, labeled n . The bytes for the variable n will start at a unique address and may look something like 0x12345678 . In C, we can actually see the address with the & operator, which means \"get the address of this variable\": 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%p \\n \" , & n ); // notice the %p and & here } When this program was run, I received the result 0x7ffe5878a42c . The address of a variable is called a pointer , which we can think of as a value that \"points\" to a location in the memory. The * operator lets us \"go to\" the location that a pointer is point to. For example, we can print *&n , where we \"go to\" the address of n and print out the value of n , 50 . The * is known as the deference operator . It \"goes to the reference\" and access that data at that location, allowing you to manipulate it at will. 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , *& n ); // notice the *&n here } We also have to use the * operator (in an unfortunately confusing way) to declare a variable that we want to be a pointer: 1 2 3 4 5 6 7 8 #include <stdio.h> int main ( void ) { int n = 50 ; int * p = & n ; // declaring the pointer variable printf ( \"%p \\n \" , p ); } Here, we use int *p to declare a variable, p , that has the type of * , a pointer, to a value of type int , an integer. Then, we can print its value (something like 0x12345678 ), or print the value at its location with printf(\"%i\\n\", *p); . In our computer\u2019s memory, the variables might look like this (each square representing a byte of memory): We have a pointer, p , with the address of some variable. We can abstract away the actual value of the addresses now, since they\u2019ll be different as we declare variables in our programs, and simply think of p as \u201cpointing at\u201d some value: An easier way to look at this is if we have a mailbox labeled \"123\", with the number \"50\" inside it. The mailbox would be int n , since it stores an integer. We might have another mailbox with the address \u201c456\u201d, inside of which is the value \u201c123\u201d, which is the address of our other mailbox. This would be int *p , since it\u2019s a pointer to an integer. A pointer , then, is a data item whose value is a memory address type describes the data located at that memory address The simplest pointer available to us in C is the NULL pointer. As you might expect, this pointer points to nothing (a fact which can actually come in handy). When you create a pointer and you don't set its value immediately, you should always set the value of the pointer to NULL.","title":"Pointers"},{"location":"c-memory/#string","text":"Let's use a variable string s for a name like EMMA for an example. We should be able to access each character in EMMA with s[0] - s[4] : It actually turns out that each character is stored in memory at a byte with some address, and s is actually just a pointer with the address of the first character: Because s is just a pointer to the beginning, only the \\0 indicates the end of the string. In fact, the CS50 Library defines a string with typedef char *string , which just says that we want to name a new type, string , as a char * , or a pointer to a character. 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { char * s = \"EMMA\" ; // notice how we are no longer using string, we are using char *s printf ( \"%s \\n \" , s ); }","title":"string"},{"location":"c-memory/#compare-and-copy","text":"Let's create a quick program to compare integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two integers int i = get_int ( \"i: \" ); int j = get_int ( \"j: \" ); // Compare integers if ( i == j ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } We can compile and run this, and our program works as we\u2019d expect, with the same values of the two integers giving us \u201cSame\u201d and different values \u201cDifferent\u201d. Now let's try the same thing, but using strings instead of integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two strings string s = get_string ( \"s: \" ); string t = get_string ( \"t: \" ); // Compare strings' addresses if ( s == t ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } If we run the above program we will see that it will give us the result \"Different\" each time, even when the strings are identical. Why does this happen? Simply, this is caused by how C stores strings in memory. When these are compared, C looks at the addresses of the stings, not the user input data. The strings are stored in different places of memory (pointers), which will return different hexadecimal results when compared. Now let's look at how we can copy strings. Let's make a simple program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cs50.h> #include <ctype.h> #include <stdio.h> int main ( void ) { string s = get_string ( \"s: \" ); string t = s ; // copies string s to string t (but only as an address) t [ 0 ] = toupper ( t [ 0 ]); // capitalizes string t // Print string twice printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We get a string s , and copy the value of s into t . Then, we capitalize the first letter in t . But when we run our program, we see that both s and t are now capitalized. Since we set s and t to the same values, they\u2019re actually pointers to the same character, and so we capitalized the same character! To actually make a copy of a string, we have to do a little more work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <string.h> // needed for strlen (string length) int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); // malloc is \"memory allocate\" to store the copy for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) // we need n+1 for the null character in a string { t [ i ] = s [ i ]; // copies strings } t [ 0 ] = toupper ( t [ 0 ]); // capitalizes the first character of the string printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We create a new variable, t , of the type char * , with char *t . Now, we want to point it to a new chunk of memory that\u2019s large enough to store the copy of the string. With malloc , we can allocate some number of bytes in memory (that aren\u2019t already used to store other values), and we pass in the number of bytes we\u2019d like. We already know the length of s , so we add 1 to that for the terminating null character. So, our final line of code is char *t = malloc(strlen(s) + 1); . Then, we copy each character, one at a time, and now we can capitalize just the first letter of t . And we use i < n + 1 , since we actually want to go up to n , to ensure we copy the terminating character in the string. We can actually also use the strcpy library function with strcpy(t, s) instead of our loop, to copy the string s into t . To be clear, the concept of a \u201cstring\u201d is from the C language and well-supported; the only training wheels from CS50 are the type string instead of char * , and the get_string function. If we didn\u2019t copy the null terminating character, \\0 , and tried to print out our string t , printf will continue and print out the unknown, or garbage, values that we have in memory, until it happens to reach a \\0 , or crashes entirely, since our program might end up trying to read memory that doesn\u2019t belong to it!","title":"Compare and Copy"},{"location":"c-memory/#valgrind","text":"It turns out that, after we\u2019re done with memory that we\u2019ve allocated with malloc , we should call free (as in free(t) ), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again. If we kept running our program and allocating memory with malloc , but never freed the memory after we were done using it, we would have a memory leak , which will slow down our computer and use up more and more memory until our computer runs out. valgrind is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with help50 valgrind ./*program* and see, from the error message, that line 10, we allocated memory that we never freed (or \u201clost\u201d). So at the end, we can add a line free(t) , which won\u2019t change how our program runs, but no errors from valgrind. Let's look at an example program provided from valgrind's official documentation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare #include <stdlib.h> void f ( void ) { int * x = malloc ( 10 * sizeof ( int )); x [ 10 ] = 0 ; // this int [10] is not in the correct range (0-9) and will result in a buffer overflow } int main ( void ) { f (); return 0 ; } The function f allocates enough memory for 10 integers, and stores the address in a pointer called x . Then we try to set the 11 th value of x with x[10] to 0 , which goes past the array of memory we\u2019ve allocated for our program. This is called buffer overflow , where we go past the boundaries of our buffer, or array, and into unknown memory. valgrind will also tell us there\u2019s an \u201cInvalid write of size 4\u201d for line 8, where we are indeed trying to change the value of an integer (of size 4 bytes).","title":"valgrind"},{"location":"c-memory/#swap","text":"We have two colored drinks, purple and green, each of which is in a cup. We want to swap the drinks between the two cups, but we can\u2019t do that without a third cup (temporary variable) to pour one of the drink into first. Now, let\u2019s say we wanted to swap the values of two integers. 1 2 3 4 5 6 void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } With a third variable to use as temporary storage space, we can do this pretty easily, by putting a into tmp , and then b to a , and finally the original value of a , now in tmp , into b . But, if we tried to use that function in a program, we don\u2019t see any changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> void swap ( int a , int b ); int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( x , y ); printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } This does not work because the swap function successfully swaps int a and int b , but these are simply copies of int x and int y . When x and y are printed, the copies used by the swap funciton do not alter the actual x and y integers in the main function.","title":"Swap"},{"location":"c-memory/#memory-layout","text":"Within our computer\u2019s memory, the different types of data that need to be stored for our program are organized into different sections: The machine code section is our compiled program\u2019s binary code. When we run our program, that code is loaded into the \u201ctop\u201d of memory. Globals are global variables we declare in our program or other shared variables that our entire program can access. The heap section is an empty area where malloc can get free memory from, for our program to use. The stack section is used by functions in our program as they are called. For example, our main function is at the very bottom of the stack, and has the local variables x and y . The swap function, when it\u2019s called, has its own frame, or slice, of memory that\u2019s on top of main \u2019s, with the local variables a , b , and tmp : Once the function swap returns, the memory it was using is freed for the next function call, and we lose anything we did, other than the return values, and our program goes back to the function that called swap . So by passing in the addresses of x and y from main to swap , we can actually change the values of x and y : By passing in the address of x and y , our swap function from above can actually work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> void swap ( int * a , int * b ); // we use * throughout to point to the real integer, not the copy int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( & x , & y ); // address of x and y printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; } The addresses of x and y are passed in from main to swap , and we use the int *a syntax to declare that our swap function takes in pointers. We save the value of x to tmp by following the pointer a , and then take the value of y by following the pointer b , and store that to the location a is pointing to ( x ). Finally, we store the value of tmp to the location pointed to by b ( y ), and we\u2019re done. If we call malloc too many times, we will have a heap overflow , where we end up going past our heap. Or, if we have too many functions being called, we will have a stack overflow , where our stack has too many frames of memory allocated as well. And these two types of overflow are generally known as buffer overflows, after which our program (or entire computer) might crash.","title":"Memory Layout"},{"location":"c-memory/#get_int","text":"We can implement get_int ourselve with a C library function, scanf : 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { int x ; printf ( \"x: \" ); scanf ( \"%i\" , & x ); printf ( \"x: %i \\n \" , x ); } scanf takes a format, %i , so the input is \u201cscanned\u201d for that format, and the address in memory where we want that input to go. But scanf doesn\u2019t have much error checking, so we might not get an integer. We can try to get a string the same way: 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { char * s = NULL ; printf ( \"s: \" ); scanf ( \"%s\" , s ); printf ( \"s: %s \\n \" , s ); } But we haven\u2019t actually allocated any memory for s ( s is NULL , or not pointing to anything), so we might want to call char s[5] to allocate an array of 5 characters for our string. Then, s will be treated as a pointer in scanf and printf . Now, if the user types in a string of length 4 or less, our program will work safely. But if the user types in a longer string, scanf might be trying to write past the end of our array into unknown memory, causing our program to crash.","title":"get_int"},{"location":"c-memory/#file-pointers","text":"The ability to read data from and write data to files is the primary means of storing persistent data , data that does not disappear when your program stops running. The abstraction of files that C provides is implemented in a data structure known as a FILE . Almost universally when working with files, we will be using pointers to them, FILE* . Some of the most common file input/output (I/O) functions that we will be working with are: fopen() , fclose() , fgetc() , fputc() , fread() , and fwrite() . fopen() opens a file and returns a file pointer to it. It always checks the return value to make sure you don't get back NULL. fclose() closes the file pointed to by the given file pointer. fgetc() reads and returns the next character from the file pointed to. Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fputc() writes or appends the specified character to the pointed-to file. Note: the operation of the file pointer must be \"w\" for write or \"a\" for append, or you will have an error. fread() reads <qty> units of size <size> from the file pointed to and stores them in memory in a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fwrite() writes <qty> units of size <size> to the file pointed to by reading them from a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"w\" for write or \"a\" for append, or you will suffer an error. With the ability to use pointers, we can also open files: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { // Open file FILE * file = fopen ( \"phonebook.csv\" , \"a\" ); // Get strings from user char * name = get_string ( \"Name: \" ); char * number = get_string ( \"Number: \" ); // Print (write) strings to file fprintf ( file , \"%s,%s \\n \" , name , number ); // Close file fclose ( file ); } fopen is a new function we can use to open a file. It will return a pointer to a new type, FILE , that we can read from and write to. The first argument is the name of the file, and the second argument is the mode we want to open the file in ( r for read, w for write, and a for append, or adding to). After we get some strings, we can use fprintf to print to a file. Finally, we close the file with fclose . Now we can create our own CSV files, files of comma-separated values (like a mini-spreadsheet), programmatically.","title":"File Pointers"},{"location":"c-memory/#jpeg","text":"We can also write a program that opens a file and tells us if it\u2019s a JPEG (image) file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> int main ( int argc , char * argv []) { // Check usage if ( argc != 2 ) { return 1 ; } // Open file FILE * file = fopen ( argv [ 1 ], \"r\" ); if ( ! file ) { return 1 ; } // Read first three bytes unsigned char bytes [ 3 ]; fread ( bytes , 3 , 1 , file ); // Check first three bytes if ( bytes [ 0 ] == 0xff && bytes [ 1 ] == 0xd8 && bytes [ 2 ] == 0xff ) { printf ( \"Maybe \\n \" ); } else { printf ( \"No \\n \" ); } // Close file fclose ( file ); } Now, if we run this program with ./jpeg brian.jpg , our program will try to open the file we specify (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with fread . We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they\u2019re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they\u2019re not the same, we know it\u2019s definitely not a JPEG file. We can use these abilities to read and write files, in particular images, and modify them by changing the bytes in them, in this week\u2019s problem set!","title":"JPEG"},{"location":"c-variable-scope/","text":"Variables and Scope Variable Scope Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; } Why do local and global distinctions matter? For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Variables and Scope"},{"location":"c-variable-scope/#variables-and-scope","text":"","title":"Variables and Scope"},{"location":"c-variable-scope/#variable-scope","text":"Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; }","title":"Variable Scope"},{"location":"c-variable-scope/#why-do-local-and-global-distinctions-matter","text":"For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Why do local and global distinctions matter?"},{"location":"c/","text":"C Basics Basic Data Types int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\"). Creating a Variable To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ; Using a Variable After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment Operators In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==). Conditional Statements Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); } Loops Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled. First Code #include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename* Hello, *name*! Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); } Mario Problem Set Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n -1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } } Cash Problem Set When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { float dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"C Basics"},{"location":"c/#c-basics","text":"","title":"C Basics"},{"location":"c/#basic-data-types","text":"int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\").","title":"Basic Data Types"},{"location":"c/#creating-a-variable","text":"To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ;","title":"Creating a Variable"},{"location":"c/#using-a-variable","text":"After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment","title":"Using a Variable"},{"location":"c/#operators","text":"In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==).","title":"Operators"},{"location":"c/#conditional-statements","text":"Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); }","title":"Conditional Statements"},{"location":"c/#loops","text":"Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled.","title":"Loops"},{"location":"c/#first-code","text":"#include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename*","title":"First Code"},{"location":"c/#hello-name","text":"Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); }","title":"Hello, *name*!"},{"location":"c/#mario-problem-set","text":"Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n -1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } }","title":"Mario Problem Set"},{"location":"c/#cash-problem-set","text":"When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { float dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"Cash Problem Set"},{"location":"chrome/","text":"What is Google Chrome? Google Chrome Overview Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"What is Google Chrome?"},{"location":"chrome/#what-is-google-chrome","text":"","title":"What is Google Chrome?"},{"location":"chrome/#google-chrome-overview","text":"Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"Google Chrome Overview"},{"location":"chromeinstall/","text":"How to Install Google Chrome Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"Google Chrome Install"},{"location":"chromeinstall/#how-to-install-google-chrome","text":"Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"How to Install Google Chrome"},{"location":"chromemedia/","text":"Google Chrome Media Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"chromemedia/#google-chrome-media","text":"Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"django/","text":"Django Basics Quick Links Django 3: By Example (PDF) Django 3 Documentation Django Web Framework - Full Course Introduction Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. A web framework is a set of components that helps you to develop websites faster and easier. Django's primary goal is to ease the creation of complex, database-driven websites. The framework emphasizes reusability and \"pluggability\" of components, less code, low coupling, rapid development, and the principle of don't repeat yourself.","title":"Django"},{"location":"django/#django-basics","text":"","title":"Django Basics"},{"location":"django/#quick-links","text":"Django 3: By Example (PDF) Django 3 Documentation Django Web Framework - Full Course","title":"Quick Links"},{"location":"django/#introduction","text":"Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. A web framework is a set of components that helps you to develop websites faster and easier. Django's primary goal is to ease the creation of complex, database-driven websites. The framework emphasizes reusability and \"pluggability\" of components, less code, low coupling, rapid development, and the principle of don't repeat yourself.","title":"Introduction"},{"location":"glossary/","text":"Below is a list of key words and their definitions: Bookmark - A bookmark is a saved shortcut that directs your browser to a specific webpage. It stores the title, URL, and favicon of the corresponding page. Saving bookmarks allows you to easily access your favorite locations on the Web. Browser - Software programs that enable you to view web pages and other documents on the Internet. They \"translate\" HTML-encoded files into the text, images, sounds, and other features you see. Google Chrome is a browser. Cache - In browsers, \"cache\" is used to identify a space where web pages you have visited are stored in your computer. A copy of documents you retrieve is stored in cache. When you use GO, BACK, or any other means to revisit a document, the browser first checks to see if it is in cache and will retrieve it from there because it is much faster than retrieving it from the server. Cookie - An HTTP cookie is a small piece of data sent from a website and stored on the user's computer by the user's web browser while the user is browsing. Cookies were designed to be a reliable mechanism for websites to remember stateful information or to record the user's browsing activity. Extension - Extensions are small software programs that customize the browsing experience. They enable users to tailor Chrome functionality and behavior to individual needs or preferences. They are built on web technologies such as HTML, JavaScript, and CSS. HTML - HTML stands for Hyper Text Markup Language. HTML is the standard markup language for Web pages, which are the building blocks of most web pages. Link - A link (short for hyperlink) is an HTML object that allows you to jump to a new location when you click or tap it. Links are found on almost every webpage and provide a simple means of navigating between pages on the web. Links can be attached to text, images, or other HTML elements. URL - URL stands for Uniform Resource Locator. A URL is nothing more than the address of a given unique resource on the Web (e.g. website, page, or file). In theory, each valid URL points to a unique resource.","title":"Glossary"},{"location":"js-data-types/","text":"Variables and Simple Data Types Variables Variables are a JavaScript developer's bread and butter. They make it really easy to write complex programs with lots and lots of instructions, and keep everything organized and straight. Often times when you're writing a program in JavaScript, there will be several pieces of data that you need to keep track of. Think for example of Facebook. Facebook keeps track of tons of information and displays it on their websites and apps. Things like names, birthdays, status', etc. In order for us to write more complex programs like these, that do more than print text out onto the screen, we'll need to learn how to manage all of the information in our programs and use variables. Variables are essentially containers which allow a program to store different pieces of information inside of them. Once the information is stored inside the variable, that information can then be accessed throughout the program simply by referring to the variable's name. Using variables is a great way to keep track of and organize your data. When creating variables, make sure to use descriptive names! For example, if we were creating a variable to hold someones age, using var age is much better than var a . This can save time trying to figure out what each variable is defining! Let's make some variables in JS: var phrase = \"To be or not to be\" ; document . write ( phrase ); var is a special word in JS, which tells JS that a variable is being created. Now we can call the variable within the document . write (); command instead of having to type out the string. This can be very powerful and save programmers a ton of time! We can also change the variable after defining it originally: var phrase = \"To be or not to be\" ; document . write ( phrase ); phrase = \"Apple\" document . write ( phrase ); Now it should print out To be or not to be and apple . We are not limited to only storing strings of text within a variable. We can also store numbers (whole numbers or decimals), boolean variables, undefined, and Null: var name = \"Nick\" var age = 25 ; var gpa = 3.8 ; var isMale = true ; var flaws = null ; var description = undefined ; document . write ( ` ${ name } is ${ age } years old.` ); if ( isMale = true ){ document . write ( `He has a ${ gpa } GPA.` ); } else { document . write ( `She has a ${ gpa } GPA.` ); } The above code should have the following output: Nick is 25 years old.He has a 3.8 GPA. null and undefined are different because when you use null , you are saying that there is no value, but undefined says that there is no value yet . You will probably not use null or undefined much as a developer, but they are still good to know/understand. Remember to use descriptive variable names ! Think of a variable as a moving box. When you fill up the box it is common to write on the outside of the box what it contains. Use similar logic when it comes to naming variables. Strings","title":"Variables and Simple Data Types"},{"location":"js-data-types/#variables-and-simple-data-types","text":"","title":"Variables and Simple Data Types"},{"location":"js-data-types/#variables","text":"Variables are a JavaScript developer's bread and butter. They make it really easy to write complex programs with lots and lots of instructions, and keep everything organized and straight. Often times when you're writing a program in JavaScript, there will be several pieces of data that you need to keep track of. Think for example of Facebook. Facebook keeps track of tons of information and displays it on their websites and apps. Things like names, birthdays, status', etc. In order for us to write more complex programs like these, that do more than print text out onto the screen, we'll need to learn how to manage all of the information in our programs and use variables. Variables are essentially containers which allow a program to store different pieces of information inside of them. Once the information is stored inside the variable, that information can then be accessed throughout the program simply by referring to the variable's name. Using variables is a great way to keep track of and organize your data. When creating variables, make sure to use descriptive names! For example, if we were creating a variable to hold someones age, using var age is much better than var a . This can save time trying to figure out what each variable is defining! Let's make some variables in JS: var phrase = \"To be or not to be\" ; document . write ( phrase ); var is a special word in JS, which tells JS that a variable is being created. Now we can call the variable within the document . write (); command instead of having to type out the string. This can be very powerful and save programmers a ton of time! We can also change the variable after defining it originally: var phrase = \"To be or not to be\" ; document . write ( phrase ); phrase = \"Apple\" document . write ( phrase ); Now it should print out To be or not to be and apple . We are not limited to only storing strings of text within a variable. We can also store numbers (whole numbers or decimals), boolean variables, undefined, and Null: var name = \"Nick\" var age = 25 ; var gpa = 3.8 ; var isMale = true ; var flaws = null ; var description = undefined ; document . write ( ` ${ name } is ${ age } years old.` ); if ( isMale = true ){ document . write ( `He has a ${ gpa } GPA.` ); } else { document . write ( `She has a ${ gpa } GPA.` ); } The above code should have the following output: Nick is 25 years old.He has a 3.8 GPA. null and undefined are different because when you use null , you are saying that there is no value, but undefined says that there is no value yet . You will probably not use null or undefined much as a developer, but they are still good to know/understand. Remember to use descriptive variable names ! Think of a variable as a moving box. When you fill up the box it is common to write on the outside of the box what it contains. Use similar logic when it comes to naming variables.","title":"Variables"},{"location":"js-data-types/#strings","text":"","title":"Strings"},{"location":"js/","text":"JavaScript Basics Quick Links You Don't Know JS Yet: Get Started (Online Book) Eloquent JavaScript (Online Book) JavaScript: Notes for Professionals (PDF) Interactive JS CheatSheet JavaScript and JQuery - Interactive Front-End Web Development (PDF) Introduction JavaScript, often abbreviated as JS, is a scripting or programming language that allows you to implement complex features on web pages - every time a web page does mroe than just sit there and display static information for you to look at - displaying timely content updates, interactive maps, animated 2D/3D graphics, etc. - you can bet that JavaScript is probably involved. Most modern webpages are a mix of HTML, CSS, and JavaScript. Setup and Hello World! Whenever we are writing JS, we can either write the code directly inside the HTML file or we can create a separate JS file that we link into the HTML. To start, we are going to be writing the JS directly inside the HTML file. We are going to use a basic HTML file titled index.html . We will work directly inside a < script > tag and open the .html file inside a browser. Saving the file and refreshing the browser should show any updates that have been made. Below is the index.html file we will be working with: 1 2 3 4 5 6 7 8 9 < html > < head > < meta charset = \"UTF-8\" > < title > JavaScript Testing </ title > </ head > < body > <!-- JavaScript Code goes here inside a <script> tag --> </ body > </ html > Now that we have the basic HTML file ready to go, let's insert the following JS: 1 2 3 4 5 6 < script type = \"text/javascript\" > // This alert ( \"Hello World!\" ); // This writes text to the screen document . write ( \"Hello World!\" ); </ script > The above document . write ( \"\" ) command is the most basic way to write something to the screen. The alert ( \"\" ) command will display text in a dialog box that pops up on the screen. Linking a seperate JS file into HTML can be helpful for organization and is a simple process. Create another file in the same directory as the index.html file and name it something like script.js . You can name it whatever you want, it just needs to end with the file type .js . To link the .js file into the HTML file, we will add the following code into the < head > tag: 1 2 3 4 5 6 7 8 9 10 < html > < head > < meta charset = \"UTF-8\" > < title > JavaScript Testing </ title > < script src = \"script.js\" ></ script > </ head > < body > </ body > </ html > Functionally, including the JS as a file or directly inside the HTML file are functionally the same. Writing HTML in JavaScript Let's start with a blank HTML file, like the one from above, that links to an outside JS file. In that JS file, let's add the following: 1 2 document . write ( \"<h2 style='color:blue;'>JavaScript Rules!</h2>\" ); document . write ( \"<hr/>\" ); The document command refers to the HTML document that the entire file is linked to. The write () command let's us write whatever we want to the HTML document. We can write plain text or actual HTML tags (like the example above). Moving the < script > tag within the HTML file will determine where that JS will write the HTML.","title":"JavaScript Basics"},{"location":"js/#javascript-basics","text":"","title":"JavaScript Basics"},{"location":"js/#quick-links","text":"You Don't Know JS Yet: Get Started (Online Book) Eloquent JavaScript (Online Book) JavaScript: Notes for Professionals (PDF) Interactive JS CheatSheet JavaScript and JQuery - Interactive Front-End Web Development (PDF)","title":"Quick Links"},{"location":"js/#introduction","text":"JavaScript, often abbreviated as JS, is a scripting or programming language that allows you to implement complex features on web pages - every time a web page does mroe than just sit there and display static information for you to look at - displaying timely content updates, interactive maps, animated 2D/3D graphics, etc. - you can bet that JavaScript is probably involved. Most modern webpages are a mix of HTML, CSS, and JavaScript.","title":"Introduction"},{"location":"js/#setup-and-hello-world","text":"Whenever we are writing JS, we can either write the code directly inside the HTML file or we can create a separate JS file that we link into the HTML. To start, we are going to be writing the JS directly inside the HTML file. We are going to use a basic HTML file titled index.html . We will work directly inside a < script > tag and open the .html file inside a browser. Saving the file and refreshing the browser should show any updates that have been made. Below is the index.html file we will be working with: 1 2 3 4 5 6 7 8 9 < html > < head > < meta charset = \"UTF-8\" > < title > JavaScript Testing </ title > </ head > < body > <!-- JavaScript Code goes here inside a <script> tag --> </ body > </ html > Now that we have the basic HTML file ready to go, let's insert the following JS: 1 2 3 4 5 6 < script type = \"text/javascript\" > // This alert ( \"Hello World!\" ); // This writes text to the screen document . write ( \"Hello World!\" ); </ script > The above document . write ( \"\" ) command is the most basic way to write something to the screen. The alert ( \"\" ) command will display text in a dialog box that pops up on the screen. Linking a seperate JS file into HTML can be helpful for organization and is a simple process. Create another file in the same directory as the index.html file and name it something like script.js . You can name it whatever you want, it just needs to end with the file type .js . To link the .js file into the HTML file, we will add the following code into the < head > tag: 1 2 3 4 5 6 7 8 9 10 < html > < head > < meta charset = \"UTF-8\" > < title > JavaScript Testing </ title > < script src = \"script.js\" ></ script > </ head > < body > </ body > </ html > Functionally, including the JS as a file or directly inside the HTML file are functionally the same.","title":"Setup and Hello World!"},{"location":"js/#writing-html-in-javascript","text":"Let's start with a blank HTML file, like the one from above, that links to an outside JS file. In that JS file, let's add the following: 1 2 document . write ( \"<h2 style='color:blue;'>JavaScript Rules!</h2>\" ); document . write ( \"<hr/>\" ); The document command refers to the HTML document that the entire file is linked to. The write () command let's us write whatever we want to the HTML document. We can write plain text or actual HTML tags (like the example above). Moving the < script > tag within the HTML file will determine where that JS will write the HTML.","title":"Writing HTML in JavaScript"},{"location":"notes/","text":"Programming Notes Notes by Language C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures Python Python Basics Variables and Simple Data Types Lists Working with Lists If Statements Dictionaries User Input and while Loops Functions Classes Random Programs SQL SQL Basics Joins and Other Query Types SQL Random Problems JavaScript JavaScript Basics Variables and Simple Data Types Random Notes APIs Django Azure","title":"Notes Overview"},{"location":"notes/#programming-notes","text":"","title":"Programming Notes"},{"location":"notes/#notes-by-language","text":"C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures Python Python Basics Variables and Simple Data Types Lists Working with Lists If Statements Dictionaries User Input and while Loops Functions Classes Random Programs SQL SQL Basics Joins and Other Query Types SQL Random Problems JavaScript JavaScript Basics Variables and Simple Data Types","title":"Notes by Language"},{"location":"notes/#random-notes","text":"APIs Django Azure","title":"Random Notes"},{"location":"portfolio/","text":"Nicholas Platt's Portfolio Resume Portfolio Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types. SoccerFront (2020) is a soccer live score web application that I built using Nodejs, Expressjs, HTML, CSS, and JavaScript. Soccerfront pulls data from the API-FOOTBALL API and displays the information in a easy to use live score table and league table (standings) view. Currently, over 20 leagues/cups are supported! This is an ongoing project and new features will be added sporadically. Images Custom Keyboard PCB with Switch Slot Callouts Table Example Instruction Example About Me Click Here Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Main Portfolio"},{"location":"portfolio/#nicholas-platts-portfolio","text":"","title":"Nicholas Platt's Portfolio"},{"location":"portfolio/#resume","text":"","title":"Resume"},{"location":"portfolio/#portfolio","text":"Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types. SoccerFront (2020) is a soccer live score web application that I built using Nodejs, Expressjs, HTML, CSS, and JavaScript. Soccerfront pulls data from the API-FOOTBALL API and displays the information in a easy to use live score table and league table (standings) view. Currently, over 20 leagues/cups are supported! This is an ongoing project and new features will be added sporadically.","title":"Portfolio"},{"location":"portfolio/#images","text":"Custom Keyboard PCB with Switch Slot Callouts Table Example Instruction Example","title":"Images"},{"location":"portfolio/#about-me","text":"Click Here","title":"About Me"},{"location":"portfolio/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Contact"},{"location":"py-classes/","text":"Classes Object-oriented programming (OOP) is one of the most effective approaches to writing software. In OOP you write classes that represent real-world things and situations, and you create objects based on these classes. When you write a class, you define the general behavior that a whole category of objects can have. When you create individual objects from the class, each object is automatically equipped with the genearl behavior; you can then give each object whatever unique traits you desire. You'll be amazed how well real-world situations can be modeled with object-oriented programming. Making an object from a class is called instantiation , and you work with instances of a class. On this page, we'll write classes and create instances of those classes. We will specify the kind of information that will be stored in instances, and we'll define actions that can be taken with these instances. We'll also write classes that extend the functionality of existing classes, so similar classes can share code efficiently. We'll store our classes in modules and import classes written by other programmers into our program files. Understanding object-oriented programming will help us see the world as a programmer does. It'll help us really know our code, not just what's happening line by line, but also the bigger picture behind it. Knowing the logic behind classes will train us to think logically so we can write programs that effectively address almost any problem we encounter. Creating and Using a Class You can model almost anything using classes. Let's start by writing a simple class, Dog , that represents a dog - not one dog in particular, but any dog. What do we know about pet dogs? Well, they all have a name and age. We also know that most dogs sit and roll over. Those two pieces of information (name and age) and those two behaviors (sit and roll over) will go in our Dog class because they're common to most dogs. This class will tell Python how to make an object representing a dog. After our class is written, we'll use it to make individual instances, each of which represent one specific dog. Creating the Dog Class Each instance created from the Dog class will store a name and an age , and we'll give each dog the ability to sit () and roll_over () : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) There's a lot to notice here, but don't worry. You'll see this structure throughout this page and have lot's of time to get used to it. On line 1, we define a classed called Dog . By convention, capitalized names refer to classes in Python. There are no parenthesis in the class deinition because we're creating this class from scratch. On line 2, we write a docstring describing what this class does. The __init__() Method A function that's part of a class is a method . Everything you learned about functions applies to methods as well; the only practical difference for now is the way we'll call methods. The __init__ () method on line 4 is a special method that Python runs automatically whenever we create a new instance based on the Dog class. This method has two leading underscores and two trailing underscores, a convention that helps prevent Python's default method names from conflicting with your method names. Make sure to use two underscores on each side of __init__ () . If you use just one on each side, the method won't be called automatically when you use your class, which can result in errors that are difficult to identify. We define the __init__() method to have three parameters: self , name , and age . The self parameter is required in the method definition, and it must come first before the other parameters. It must be included in the definition because when Python cals this method later (to create an instance of Dog ), the method call will automatically pass the self argument. Every method call associated with an instance automatically passes self , which is a reference to the instance itself; it gives the individual instance access to the attributes and methods in the class. When we make an instance of Dog , Python will call the __init__() method from the Dog class. We'll pass Dog() a name and an age as arguments; self is passed automatically, so we don't need to pass it. Whenever we want to make an instance from the Dog class, we'll provide values for only the last two parameters, name and age . The two variables defined on line 6/7 each have the prefix self . Any varibale prefixed with self is available to every method in the class, and we'll also be able to access these variables through any instance created from the class. The line self . name = name takes the value associated with the parameter name and assigns it to the variable name , which is then attached to the instance being created. The same process happens with self . age = age . Variables that are accessible through instances like this are called attributes . The Dog class has two other methods defined: sit() and roll_over() (line 9 & 13). Because these methods don't need additional information to run, we just define them to have one parameter, self . The instances we create later will have access to these methods. In other words, they'll be able to sit and roll over. For now, sit() and roll_over() don't do much. They simply print a message saying the dog is sitting or rolling over. But the concept can be extended to realistic situations: if this class were part of an actual computer game, these messages would contain code to make an animated dog sit and roll over. If this class was written to control a robot, these methods would direct movements that cause a robotic doc to sit and roll over. Making an Instance from a Class Think of a class as a set of instructions for how to make an instance. The class Dog is a set of instructions that tells Python how to make individual instances representing specific dogs. Let's make an instance representing a specific dog: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) print ( f \"My dog's name is { my_dog . name } .\" ) print ( f \"My dog is { my_dog . age } years old.\" ) The Dog class we're using here is the same from the previous example. On line 17 we tell Python to create a dog whose name is 'Willie' and whose age is 6 . When Python reads this line, it calls the __init__() method in Dog with the arguments 'Willie' and 6 . The __init__() method creates an instance representing this particular dog and sets the name and age attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable my_dog . The naming convention is helpful here: we can usually assume that a capitalized name like Dog refers to a class, and a lowercase name like my_dog refers to a single instance created from a class. Accessing Attributes To acces the attributes of an instance, you use dot notation. On line 19, we access the value of my_dog 's name by writing: my_dog . name Dot notaion is used often in Python. This syntax demonstrates how Python finds an attribute's value. Here Python looks at the instance my_dog and then finds the attribute name associated with my_dog . This is the same attribute referred to as self . name in the class Dog . On line 20 we use the same approach to work with the attribute age . The output is a summary of what we know about my_dog : My dog's name is Willie. My dog is 6 years old. Calling Methods After we create an instance from the class Dog , we can use dot notation to call any method defined in Dog . Let's make our dog sit and roll over: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) my_dog . sit () my_dog . roll_over () To call a method, give the name of the instance (in this case, my_dog ) and the method you want to call, separated by a dot. When Python reads my_dog . sit () , it looks for the method sit() in the class Dog and runs that code. Python interprets the line my_dog . roll_over () in the same way. Now Willie does what we tell him to: Willie is now sitting. Willie rolled over! This syntax is quite useful. When attributes and methods have been given appropriately descriptive names like name , age , sit() , and roll_over() , we can easily infer what a block of code, even one we've never seen before, is supposed to do. Creating Multiple Instances You can create as many instances from a class as you need. Let's create a second dog called your_dog : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) your_dog = Dog ( 'Lucy' , 3 ) print ( f \"My dog's name is { my_dog . name } .\" ) print ( f \"My dog is { my_dog . age } years old.\" ) my_dog . sit () print ( f \" \\n Your dog's name is { your_dog . name } .\" ) print ( f \"Your dog is { your_dog . age } years old.\" ) your_dog . sit () In this example we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own set of attributes, capable of the same set of actions: My dog's name is Willie. My dog is 6 years old. Willie is now sitting. Your dog's name is Lucy. Your dog is 3 years old. Lucy is now sitting. Even if We used the same name and age for the second dog, Python would still create a separate instance from the Dog class. You can make as many instances from one class as you need, as long as you give each instance a unique variable name or it occupies a unique spot in a list or dictionary. Working with Classes and Instances You can use classes to represent many real-word situations. Once you write a class, you'll spend most of your time working with instances created from that class. One of the first tasks you'll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways. The Car Class Let's write a new class representing a car. Our class will store information about the kind of car we're working with, and it will have a method that summarizes this information: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Intiialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) On line 4 in the Car class, we define the __init__() method with the self parameter first, just like we did before with our Dog class. We also give in three other parameters: make , model , and year . The __init__() method takes in these parameters and assigns them to the attributes that will be associated with instances made from this class. When we make a new Car instance, we'll need to specify a make, model, and year for our instance. On line 10 we define a method called get_descriptive_name () that puts a car's year , make , and model into one string neatly describing the car. This will spare us from having to print each attribute's value individually. To work with the attribute values in this method, we use self . make , self . model and self . year . On line 15 we make an instance from the Car class and assign it to the variable my_new_car . Then we call get_descriptive_name() to show what kind of car we have: 2020 Audi A4 To make the class more interesting, let's add an attribute that changes over time. We'll add an attribute that stores the car's overall mileage. Setting a Default Value for an Attribute When an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the __init__() method, where they are assigned a default value. Let's add an attribute called odometer_reading that always starts with a value of 0 . We'll also add a method read_odometer() that helps us read each car's odometer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Intiialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): \"\"\"Print a statement showing the car's mileage.\"\"\" print ( f \"This car has { self . odometer_reading } miles on it.\" ) my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . read_odometer () This time when Python calls the __init__() method to create a new instance, it stores the make, model, and year values as attributes like it did in the previous example. Then Python creates a new attribute called odometer_reading and sets its initial value to 0 (line 9). We also have a new method called read_odometer() on line 16 that makes it easy to read a car's mileage. Our car starts with a mileage of 0: 2020 Audi A4 This car has 0 miles on it. Not many cars are sold with exactly 0 miles on the odometer, so we need a way to change the value of this attribute. Modifying Attribute Values You can change an attribute's value in three ways: Change the value directly through an instance Set the value through a method Increment the value through a method Modifying an Attribute's Value Directly The simplest way to modify the value of an attribute is to access the attribute directly through an instance. Here we set the odometer reading to 23 directly: 1 2 3 4 5 6 7 8 class Car : -- snip -- my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . odometer_reading = 23 my_new_car . read_odometer () On line 7 we use dot notation to access the car's odometer_reading attribute and set its value directly. This line tells Python to take the instance my_new_car , find the attribute odomerter_reading associated with it, and set the value of that attribute to 23: 2020 Audi A4 This car has 23 miles on it. Sometimes you'll want to access attributes directly like this, but other times you'll want to write a method that updates the value for you. Modifying an Attribute's Value Through a Method It can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally. Here's an example showing a method called update_odometer() : 1 2 3 4 5 6 7 8 9 10 11 12 class Car : -- snip -- def update_odometer ( self , milage ): \"\"\"Set the odometer reading to a given value.\"\"\" self . odometer_reading = milage my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . update_odometer ( 23 ) my_new_car . read_odometer () The only modification to Car is the addition of update_odometer() on line 4. This method takes in a mileage value and assigns it to self . odometer_reading . On line 11 we call update_odometer() and give it 23 as an argument (corresponding to the mileage parameter in the method definition). It sets the odometer reading to 23 , and read_odometer() prints the reading: 2020 Audi A4 This car has 23 miles on it. We can extend the method update_odometer() to do additional work every time the odometer reading is modified. Let's add a little logic to make sure no one tries to roll back the odometer reading: 1 2 3 4 5 6 7 8 9 10 11 12 class Car : -- snip -- def update_odometer ( self , mileage ): \"\"\" Set the odometer reading to a given value. Reject the change if it atempts to roll the odometer back. \"\"\" if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) Now update_odometer() checks that the new reading makes sense before modifying the attribute. If the new mileage, mileage , is greater than or equal to the existing mileage, self . odometer_reading , you can update the odometer reading to the new mileage (line 9). If the new mileage is less than the existing mileage, you'll get a warning that you can't roll back an odometer (line 12). Incrementing an Attribute's Value Through a Method Sometimes you'll want to increment an attribute's value by a certain amount rather than set an entirely new value. Say we buy a used car and put 100 miles on it between the time we buy it and the time we register it. Here's a method that allows us to pass this incremental amount and add that value to the odometer reading: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Car : -- snip -- def update_odometer ( self , mileage ): -- snip -- def increment_odometer ( self , miles ): \"\"\"Add the given amount to the odometer reading.\"\"\" self . odometer_reading += miles my_used_car = Car ( 'subaru' , 'outback' , 2016 ) print ( my_used_car . get_descriptive_name ()) my_used_car . update_odometer ( 23_500 ) my_used_car . read_odometer () my_used_car . update_odometer ( 100 ) my_used_car . read_odometer () This new method increment_odometer() at line 7 takes in a number of miles and adds this value to self . odometer_reading . On line 11 we create a used car, my_used_car . We set its odomoer to 23,500 by calling update_odometer() and passing it 23_500 on line 14. On line 16 we call increment_odometer() and pass it 100 to add the 100 miles that we drove between buying the car and registering it: 2015 Subaru Outback This car has 23500 miles on it. This car has 23600 miles on it. You can easily modify this method to reject negative increments so no one uses this function to roll back an odometer. Inheritance You don't always have to start from scratch when writing a class. If the class you're writing is a specialized version of another class you wrote, you can use inheritance . When one class inherits from another, it takes on the attributes and methods of the first class. The original class is called the parent class , and the new class is the child class . The child class can inherit any or all of the attributes and methods of its parent class, but it's also free to define new attributes and methods of its own. The __init__() Method for a Child Class When you're writing a new class based on an existing class, you'll often want to call the __init__() method from the parent class. This will initialize any attributes that were defined in the parent __init__() method and make them available in the child class. As an example, let's model an electric car. An electric car is just a specific kind of car, so we can base our new ElectricCar class on the Car class we wrote earlier. Then we'll only have to write code for the attributes and behavior specific to electric cars. Let's start by making a simple version of the ElectricCar class, which does everythin the Car class does: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): print ( f \"This car has { self . odometer_reading } miles on it.\" ) def update_odometer ( self , mileage ): if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) def increment_odometer ( self , miles ): self . odometer_reading += miles class ElectricCar ( Car ): \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Initialize attributes of the parent class.\"\"\" super () . __init__ ( make , model , year ) my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) On line 1 we start with Car . When you create a child class, the parent class must be part of the current file and must appear before the child class in the file. On line 25 we define the child class, ElectricCar . The name of the parent class must be included in the parentheses in the defintion of a child class. The __init__() method on line 28 takes in the information required to make a Car instance. The super() function on line 30 is a special function that allows you to call a method from the parent class. This line tells Python to call the __init__() method from Car , which gives and ElectricCar instance all the attributes fefined in that method. The name super comes from a convention of calling the parent class a superclass and the child class a subclass . We test whether inheritence is working properly by trying to create an electric car with the same kind of information we'd provide when making a regular car. On line 32 we make an instance of the ElectricCar class and assign it to my_tesla . This line calls the __init__() method defined in ElectricCar , which in turn tells Python to call the __init__() method defined in the parent class Car . We provide the arguments 'tesla' , 'model s' , and 2019 . Aside from __init__() , there are no attributes or methods yet that are particular to an electric car. At this point we're just making sure the car has the appropriate Car behaviors: 2019 Tesla Model S The ElectricCar instance works just like an instance of Car , so now we can begin defining attributes and methods specific to electric cars. Defining Attributes and Methods for the Child Class Once you have a child class that inherits from a parent class, you can add any new attributes and methods necessary to differentiate the child class from the parent class. Let's add an attribute that's specific to electric cars (a battery, for example) and a method to report on this attribute. We'll store the battery size and write a method that print a description of the battery: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Car : --- snip --- class ElectricCar ( Car ): \"\"\"Represents aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery_size = 75 def describe_battery ( self ): \"\"\"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . describe_battery () On line 13 we add a new attribute self . battery_size and set its initial value to 75 . This attribute will be associated with all instances created from the ElectricCar class but won't be associated with any instances of Car . We also add a method called describe_battery() that prints information about the battery on line 15. When we call this method, we get a description that is clearly specific to an electric car: 2019 Tesla Model S This car has a 75-kWh battery. There's no limit to how much you can specialize the ElectricCar class. You can add as many attributes and methods as you need to model an electric car to whatever degree of accuracy you need. An attribute or method that could belong to any car, rather than one that's specific to an electric car, should be added to the Car class instead of the ElectricCar class. Then anyone who uses the Car class will have that functionality available as well, and the ElectricCar class wil only contain code for the information and behavior specific to electric vehicles. Overriding Methods from the Parent Class You can override any method from the parent class that doesn't fit what you're trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class. Say the class Car had a method called fill_gas_tank () . This method is meaningless for an all-electric vehicle, so you might want to override this method. Here is one way to do that: 1 2 3 4 5 6 class ElectricCar ( Car ): -- snip -- def fill_gas_tank ( self ): \"\"\"Electric cars don't have gas tanks.\"\"\" print ( \"This car doesn't need a gas tank!\" ) Now if someone tries to call fill_gas_tank() with an electric car, Python will ignore the method fill_gas_tank() in Car and run this code instead. When you use inheritence, you can make your child classes retain what you need and override anything you don't need from the parent class. Instances as Attributes When modeling something from the real world in code, you may find that you're adding more and more detail to a class. You'll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together. For example, if we continue adding detail to the ElectricCar class, we might notice that we're adding many attributes and methods specific to the car's battery. When we see this happening, we can stop and move those attributes and methods to a separate class called Battery . Then we can use a Battery instance as an attribute in the ElectricCar class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Car : -- snip -- class Battery : \"\"\"A simple attempt to model a battery for an electric car.\"\"\" def __init__ ( self , battery_size = 75 ): \"\"\"Initialize the battery's attributes.\"\"\" self . battery_size = battery_size def describe_battery ( self ): \"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) class ElectricCar ( Car ): \"represents aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery = Battery () my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . battery . describe_battery () On line 4 we define a new class called class Battery that doesn't inherit from any other class. The __init__ () method on line 7 has one parameter battery_size , in addition to self . This is an optional parameter that sets the battery's size to 75 if no value is provided. The method describe_battery () has been moved to this class as well (line 11). In the ElectricCar class, we now add an attribute called self . battery (line 24). This line tells Python to create a new instance of Battery (with a default size of 75 because we're not specifying a value) and assign that instance to the attribute self.battery . This will happen every time the __init__ () method is called; and ElectricCar instance will now have a Battery instance created automatically. We create an electric car and assign it to the variable my_tesla . When we want to describe the battery, we need to work through the car's battery attribute: 1 my_tesla . batter . describe_battery () This line tells Python to look at the instance of my_tesla , find its battery attribute, and call the method describe_battery() that's associated with the Battery instance stored in the attribute. The output is identical to what we saw previously: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Car : -- snip -- class Battery : -- snip -- def get_range ( self ): \"\"\"Print a statement about the range this battery provides.\"\"\" if self . battery_size == 75 : range = 260 elif self . battery_size == 100 : range = 315 class ElectricCar ( Car ): -- snip -- my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . battery . describe_battery () my_tesla . battery . get_range () The new method get_range() on line 7, performs some simple analysis. If the battery's capacity is 75 kWh, get_range() sets the range to 260 miles, and if the capacity is 100 kWh, it sets the range to 315 miles. It then reports this value. When we want to use this method, we again have to call it through the car's battery attribute on line 21. The output tells us the range of the car based on its battery size: 2019 Tesla Model S This car has a 75-kWh battery. This car can go about 260 mile son a full charge. Modeling Real-World Objects","title":"Classes"},{"location":"py-classes/#classes","text":"Object-oriented programming (OOP) is one of the most effective approaches to writing software. In OOP you write classes that represent real-world things and situations, and you create objects based on these classes. When you write a class, you define the general behavior that a whole category of objects can have. When you create individual objects from the class, each object is automatically equipped with the genearl behavior; you can then give each object whatever unique traits you desire. You'll be amazed how well real-world situations can be modeled with object-oriented programming. Making an object from a class is called instantiation , and you work with instances of a class. On this page, we'll write classes and create instances of those classes. We will specify the kind of information that will be stored in instances, and we'll define actions that can be taken with these instances. We'll also write classes that extend the functionality of existing classes, so similar classes can share code efficiently. We'll store our classes in modules and import classes written by other programmers into our program files. Understanding object-oriented programming will help us see the world as a programmer does. It'll help us really know our code, not just what's happening line by line, but also the bigger picture behind it. Knowing the logic behind classes will train us to think logically so we can write programs that effectively address almost any problem we encounter.","title":"Classes"},{"location":"py-classes/#creating-and-using-a-class","text":"You can model almost anything using classes. Let's start by writing a simple class, Dog , that represents a dog - not one dog in particular, but any dog. What do we know about pet dogs? Well, they all have a name and age. We also know that most dogs sit and roll over. Those two pieces of information (name and age) and those two behaviors (sit and roll over) will go in our Dog class because they're common to most dogs. This class will tell Python how to make an object representing a dog. After our class is written, we'll use it to make individual instances, each of which represent one specific dog.","title":"Creating and Using a Class"},{"location":"py-classes/#creating-the-dog-class","text":"Each instance created from the Dog class will store a name and an age , and we'll give each dog the ability to sit () and roll_over () : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) There's a lot to notice here, but don't worry. You'll see this structure throughout this page and have lot's of time to get used to it. On line 1, we define a classed called Dog . By convention, capitalized names refer to classes in Python. There are no parenthesis in the class deinition because we're creating this class from scratch. On line 2, we write a docstring describing what this class does.","title":"Creating the Dog Class"},{"location":"py-classes/#the-__init__-method","text":"A function that's part of a class is a method . Everything you learned about functions applies to methods as well; the only practical difference for now is the way we'll call methods. The __init__ () method on line 4 is a special method that Python runs automatically whenever we create a new instance based on the Dog class. This method has two leading underscores and two trailing underscores, a convention that helps prevent Python's default method names from conflicting with your method names. Make sure to use two underscores on each side of __init__ () . If you use just one on each side, the method won't be called automatically when you use your class, which can result in errors that are difficult to identify. We define the __init__() method to have three parameters: self , name , and age . The self parameter is required in the method definition, and it must come first before the other parameters. It must be included in the definition because when Python cals this method later (to create an instance of Dog ), the method call will automatically pass the self argument. Every method call associated with an instance automatically passes self , which is a reference to the instance itself; it gives the individual instance access to the attributes and methods in the class. When we make an instance of Dog , Python will call the __init__() method from the Dog class. We'll pass Dog() a name and an age as arguments; self is passed automatically, so we don't need to pass it. Whenever we want to make an instance from the Dog class, we'll provide values for only the last two parameters, name and age . The two variables defined on line 6/7 each have the prefix self . Any varibale prefixed with self is available to every method in the class, and we'll also be able to access these variables through any instance created from the class. The line self . name = name takes the value associated with the parameter name and assigns it to the variable name , which is then attached to the instance being created. The same process happens with self . age = age . Variables that are accessible through instances like this are called attributes . The Dog class has two other methods defined: sit() and roll_over() (line 9 & 13). Because these methods don't need additional information to run, we just define them to have one parameter, self . The instances we create later will have access to these methods. In other words, they'll be able to sit and roll over. For now, sit() and roll_over() don't do much. They simply print a message saying the dog is sitting or rolling over. But the concept can be extended to realistic situations: if this class were part of an actual computer game, these messages would contain code to make an animated dog sit and roll over. If this class was written to control a robot, these methods would direct movements that cause a robotic doc to sit and roll over.","title":"The __init__() Method"},{"location":"py-classes/#making-an-instance-from-a-class","text":"Think of a class as a set of instructions for how to make an instance. The class Dog is a set of instructions that tells Python how to make individual instances representing specific dogs. Let's make an instance representing a specific dog: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) print ( f \"My dog's name is { my_dog . name } .\" ) print ( f \"My dog is { my_dog . age } years old.\" ) The Dog class we're using here is the same from the previous example. On line 17 we tell Python to create a dog whose name is 'Willie' and whose age is 6 . When Python reads this line, it calls the __init__() method in Dog with the arguments 'Willie' and 6 . The __init__() method creates an instance representing this particular dog and sets the name and age attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable my_dog . The naming convention is helpful here: we can usually assume that a capitalized name like Dog refers to a class, and a lowercase name like my_dog refers to a single instance created from a class.","title":"Making an Instance from a Class"},{"location":"py-classes/#accessing-attributes","text":"To acces the attributes of an instance, you use dot notation. On line 19, we access the value of my_dog 's name by writing: my_dog . name Dot notaion is used often in Python. This syntax demonstrates how Python finds an attribute's value. Here Python looks at the instance my_dog and then finds the attribute name associated with my_dog . This is the same attribute referred to as self . name in the class Dog . On line 20 we use the same approach to work with the attribute age . The output is a summary of what we know about my_dog : My dog's name is Willie. My dog is 6 years old.","title":"Accessing Attributes"},{"location":"py-classes/#calling-methods","text":"After we create an instance from the class Dog , we can use dot notation to call any method defined in Dog . Let's make our dog sit and roll over: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) my_dog . sit () my_dog . roll_over () To call a method, give the name of the instance (in this case, my_dog ) and the method you want to call, separated by a dot. When Python reads my_dog . sit () , it looks for the method sit() in the class Dog and runs that code. Python interprets the line my_dog . roll_over () in the same way. Now Willie does what we tell him to: Willie is now sitting. Willie rolled over! This syntax is quite useful. When attributes and methods have been given appropriately descriptive names like name , age , sit() , and roll_over() , we can easily infer what a block of code, even one we've never seen before, is supposed to do.","title":"Calling Methods"},{"location":"py-classes/#creating-multiple-instances","text":"You can create as many instances from a class as you need. Let's create a second dog called your_dog : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) your_dog = Dog ( 'Lucy' , 3 ) print ( f \"My dog's name is { my_dog . name } .\" ) print ( f \"My dog is { my_dog . age } years old.\" ) my_dog . sit () print ( f \" \\n Your dog's name is { your_dog . name } .\" ) print ( f \"Your dog is { your_dog . age } years old.\" ) your_dog . sit () In this example we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own set of attributes, capable of the same set of actions: My dog's name is Willie. My dog is 6 years old. Willie is now sitting. Your dog's name is Lucy. Your dog is 3 years old. Lucy is now sitting. Even if We used the same name and age for the second dog, Python would still create a separate instance from the Dog class. You can make as many instances from one class as you need, as long as you give each instance a unique variable name or it occupies a unique spot in a list or dictionary.","title":"Creating Multiple Instances"},{"location":"py-classes/#working-with-classes-and-instances","text":"You can use classes to represent many real-word situations. Once you write a class, you'll spend most of your time working with instances created from that class. One of the first tasks you'll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways.","title":"Working with Classes and Instances"},{"location":"py-classes/#the-car-class","text":"Let's write a new class representing a car. Our class will store information about the kind of car we're working with, and it will have a method that summarizes this information: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Intiialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) On line 4 in the Car class, we define the __init__() method with the self parameter first, just like we did before with our Dog class. We also give in three other parameters: make , model , and year . The __init__() method takes in these parameters and assigns them to the attributes that will be associated with instances made from this class. When we make a new Car instance, we'll need to specify a make, model, and year for our instance. On line 10 we define a method called get_descriptive_name () that puts a car's year , make , and model into one string neatly describing the car. This will spare us from having to print each attribute's value individually. To work with the attribute values in this method, we use self . make , self . model and self . year . On line 15 we make an instance from the Car class and assign it to the variable my_new_car . Then we call get_descriptive_name() to show what kind of car we have: 2020 Audi A4 To make the class more interesting, let's add an attribute that changes over time. We'll add an attribute that stores the car's overall mileage.","title":"The Car Class"},{"location":"py-classes/#setting-a-default-value-for-an-attribute","text":"When an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the __init__() method, where they are assigned a default value. Let's add an attribute called odometer_reading that always starts with a value of 0 . We'll also add a method read_odometer() that helps us read each car's odometer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Intiialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): \"\"\"Print a statement showing the car's mileage.\"\"\" print ( f \"This car has { self . odometer_reading } miles on it.\" ) my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . read_odometer () This time when Python calls the __init__() method to create a new instance, it stores the make, model, and year values as attributes like it did in the previous example. Then Python creates a new attribute called odometer_reading and sets its initial value to 0 (line 9). We also have a new method called read_odometer() on line 16 that makes it easy to read a car's mileage. Our car starts with a mileage of 0: 2020 Audi A4 This car has 0 miles on it. Not many cars are sold with exactly 0 miles on the odometer, so we need a way to change the value of this attribute.","title":"Setting a Default Value for an Attribute"},{"location":"py-classes/#modifying-attribute-values","text":"You can change an attribute's value in three ways: Change the value directly through an instance Set the value through a method Increment the value through a method","title":"Modifying Attribute Values"},{"location":"py-classes/#modifying-an-attributes-value-directly","text":"The simplest way to modify the value of an attribute is to access the attribute directly through an instance. Here we set the odometer reading to 23 directly: 1 2 3 4 5 6 7 8 class Car : -- snip -- my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . odometer_reading = 23 my_new_car . read_odometer () On line 7 we use dot notation to access the car's odometer_reading attribute and set its value directly. This line tells Python to take the instance my_new_car , find the attribute odomerter_reading associated with it, and set the value of that attribute to 23: 2020 Audi A4 This car has 23 miles on it. Sometimes you'll want to access attributes directly like this, but other times you'll want to write a method that updates the value for you.","title":"Modifying an Attribute's Value Directly"},{"location":"py-classes/#modifying-an-attributes-value-through-a-method","text":"It can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally. Here's an example showing a method called update_odometer() : 1 2 3 4 5 6 7 8 9 10 11 12 class Car : -- snip -- def update_odometer ( self , milage ): \"\"\"Set the odometer reading to a given value.\"\"\" self . odometer_reading = milage my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . update_odometer ( 23 ) my_new_car . read_odometer () The only modification to Car is the addition of update_odometer() on line 4. This method takes in a mileage value and assigns it to self . odometer_reading . On line 11 we call update_odometer() and give it 23 as an argument (corresponding to the mileage parameter in the method definition). It sets the odometer reading to 23 , and read_odometer() prints the reading: 2020 Audi A4 This car has 23 miles on it. We can extend the method update_odometer() to do additional work every time the odometer reading is modified. Let's add a little logic to make sure no one tries to roll back the odometer reading: 1 2 3 4 5 6 7 8 9 10 11 12 class Car : -- snip -- def update_odometer ( self , mileage ): \"\"\" Set the odometer reading to a given value. Reject the change if it atempts to roll the odometer back. \"\"\" if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) Now update_odometer() checks that the new reading makes sense before modifying the attribute. If the new mileage, mileage , is greater than or equal to the existing mileage, self . odometer_reading , you can update the odometer reading to the new mileage (line 9). If the new mileage is less than the existing mileage, you'll get a warning that you can't roll back an odometer (line 12).","title":"Modifying an Attribute's Value Through a Method"},{"location":"py-classes/#incrementing-an-attributes-value-through-a-method","text":"Sometimes you'll want to increment an attribute's value by a certain amount rather than set an entirely new value. Say we buy a used car and put 100 miles on it between the time we buy it and the time we register it. Here's a method that allows us to pass this incremental amount and add that value to the odometer reading: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Car : -- snip -- def update_odometer ( self , mileage ): -- snip -- def increment_odometer ( self , miles ): \"\"\"Add the given amount to the odometer reading.\"\"\" self . odometer_reading += miles my_used_car = Car ( 'subaru' , 'outback' , 2016 ) print ( my_used_car . get_descriptive_name ()) my_used_car . update_odometer ( 23_500 ) my_used_car . read_odometer () my_used_car . update_odometer ( 100 ) my_used_car . read_odometer () This new method increment_odometer() at line 7 takes in a number of miles and adds this value to self . odometer_reading . On line 11 we create a used car, my_used_car . We set its odomoer to 23,500 by calling update_odometer() and passing it 23_500 on line 14. On line 16 we call increment_odometer() and pass it 100 to add the 100 miles that we drove between buying the car and registering it: 2015 Subaru Outback This car has 23500 miles on it. This car has 23600 miles on it. You can easily modify this method to reject negative increments so no one uses this function to roll back an odometer.","title":"Incrementing an Attribute's Value Through a Method"},{"location":"py-classes/#inheritance","text":"You don't always have to start from scratch when writing a class. If the class you're writing is a specialized version of another class you wrote, you can use inheritance . When one class inherits from another, it takes on the attributes and methods of the first class. The original class is called the parent class , and the new class is the child class . The child class can inherit any or all of the attributes and methods of its parent class, but it's also free to define new attributes and methods of its own.","title":"Inheritance"},{"location":"py-classes/#the-__init__-method-for-a-child-class","text":"When you're writing a new class based on an existing class, you'll often want to call the __init__() method from the parent class. This will initialize any attributes that were defined in the parent __init__() method and make them available in the child class. As an example, let's model an electric car. An electric car is just a specific kind of car, so we can base our new ElectricCar class on the Car class we wrote earlier. Then we'll only have to write code for the attributes and behavior specific to electric cars. Let's start by making a simple version of the ElectricCar class, which does everythin the Car class does: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): print ( f \"This car has { self . odometer_reading } miles on it.\" ) def update_odometer ( self , mileage ): if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) def increment_odometer ( self , miles ): self . odometer_reading += miles class ElectricCar ( Car ): \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Initialize attributes of the parent class.\"\"\" super () . __init__ ( make , model , year ) my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) On line 1 we start with Car . When you create a child class, the parent class must be part of the current file and must appear before the child class in the file. On line 25 we define the child class, ElectricCar . The name of the parent class must be included in the parentheses in the defintion of a child class. The __init__() method on line 28 takes in the information required to make a Car instance. The super() function on line 30 is a special function that allows you to call a method from the parent class. This line tells Python to call the __init__() method from Car , which gives and ElectricCar instance all the attributes fefined in that method. The name super comes from a convention of calling the parent class a superclass and the child class a subclass . We test whether inheritence is working properly by trying to create an electric car with the same kind of information we'd provide when making a regular car. On line 32 we make an instance of the ElectricCar class and assign it to my_tesla . This line calls the __init__() method defined in ElectricCar , which in turn tells Python to call the __init__() method defined in the parent class Car . We provide the arguments 'tesla' , 'model s' , and 2019 . Aside from __init__() , there are no attributes or methods yet that are particular to an electric car. At this point we're just making sure the car has the appropriate Car behaviors: 2019 Tesla Model S The ElectricCar instance works just like an instance of Car , so now we can begin defining attributes and methods specific to electric cars.","title":"The __init__() Method for a Child Class"},{"location":"py-classes/#defining-attributes-and-methods-for-the-child-class","text":"Once you have a child class that inherits from a parent class, you can add any new attributes and methods necessary to differentiate the child class from the parent class. Let's add an attribute that's specific to electric cars (a battery, for example) and a method to report on this attribute. We'll store the battery size and write a method that print a description of the battery: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Car : --- snip --- class ElectricCar ( Car ): \"\"\"Represents aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery_size = 75 def describe_battery ( self ): \"\"\"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . describe_battery () On line 13 we add a new attribute self . battery_size and set its initial value to 75 . This attribute will be associated with all instances created from the ElectricCar class but won't be associated with any instances of Car . We also add a method called describe_battery() that prints information about the battery on line 15. When we call this method, we get a description that is clearly specific to an electric car: 2019 Tesla Model S This car has a 75-kWh battery. There's no limit to how much you can specialize the ElectricCar class. You can add as many attributes and methods as you need to model an electric car to whatever degree of accuracy you need. An attribute or method that could belong to any car, rather than one that's specific to an electric car, should be added to the Car class instead of the ElectricCar class. Then anyone who uses the Car class will have that functionality available as well, and the ElectricCar class wil only contain code for the information and behavior specific to electric vehicles.","title":"Defining Attributes and Methods for the Child Class"},{"location":"py-classes/#overriding-methods-from-the-parent-class","text":"You can override any method from the parent class that doesn't fit what you're trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class. Say the class Car had a method called fill_gas_tank () . This method is meaningless for an all-electric vehicle, so you might want to override this method. Here is one way to do that: 1 2 3 4 5 6 class ElectricCar ( Car ): -- snip -- def fill_gas_tank ( self ): \"\"\"Electric cars don't have gas tanks.\"\"\" print ( \"This car doesn't need a gas tank!\" ) Now if someone tries to call fill_gas_tank() with an electric car, Python will ignore the method fill_gas_tank() in Car and run this code instead. When you use inheritence, you can make your child classes retain what you need and override anything you don't need from the parent class.","title":"Overriding Methods from the Parent Class"},{"location":"py-classes/#instances-as-attributes","text":"When modeling something from the real world in code, you may find that you're adding more and more detail to a class. You'll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together. For example, if we continue adding detail to the ElectricCar class, we might notice that we're adding many attributes and methods specific to the car's battery. When we see this happening, we can stop and move those attributes and methods to a separate class called Battery . Then we can use a Battery instance as an attribute in the ElectricCar class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Car : -- snip -- class Battery : \"\"\"A simple attempt to model a battery for an electric car.\"\"\" def __init__ ( self , battery_size = 75 ): \"\"\"Initialize the battery's attributes.\"\"\" self . battery_size = battery_size def describe_battery ( self ): \"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) class ElectricCar ( Car ): \"represents aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery = Battery () my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . battery . describe_battery () On line 4 we define a new class called class Battery that doesn't inherit from any other class. The __init__ () method on line 7 has one parameter battery_size , in addition to self . This is an optional parameter that sets the battery's size to 75 if no value is provided. The method describe_battery () has been moved to this class as well (line 11). In the ElectricCar class, we now add an attribute called self . battery (line 24). This line tells Python to create a new instance of Battery (with a default size of 75 because we're not specifying a value) and assign that instance to the attribute self.battery . This will happen every time the __init__ () method is called; and ElectricCar instance will now have a Battery instance created automatically. We create an electric car and assign it to the variable my_tesla . When we want to describe the battery, we need to work through the car's battery attribute: 1 my_tesla . batter . describe_battery () This line tells Python to look at the instance of my_tesla , find its battery attribute, and call the method describe_battery() that's associated with the Battery instance stored in the attribute. The output is identical to what we saw previously: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Car : -- snip -- class Battery : -- snip -- def get_range ( self ): \"\"\"Print a statement about the range this battery provides.\"\"\" if self . battery_size == 75 : range = 260 elif self . battery_size == 100 : range = 315 class ElectricCar ( Car ): -- snip -- my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . battery . describe_battery () my_tesla . battery . get_range () The new method get_range() on line 7, performs some simple analysis. If the battery's capacity is 75 kWh, get_range() sets the range to 260 miles, and if the capacity is 100 kWh, it sets the range to 315 miles. It then reports this value. When we want to use this method, we again have to call it through the car's battery attribute on line 21. The output tells us the range of the car based on its battery size: 2019 Tesla Model S This car has a 75-kWh battery. This car can go about 260 mile son a full charge.","title":"Instances as Attributes"},{"location":"py-classes/#modeling-real-world-objects","text":"","title":"Modeling Real-World Objects"},{"location":"py-data-types/","text":"Variables and Simple Data Types Variables Let's go back to the first program and use a variable. To do this, we simply add a new line at the beginning of the file and modify the second line: 1 2 message = \"Hello Python World!\" print ( message ) We have now created a variable named message . Every variable is connected to a value , which is the information associated with that variable. In this case the value is the Hello Python World! text. Adding a variable makes a little more work for the Python interpreter. When it processes the first line, it associates the variable message with the Hello Python World! text. When it reaches the second line, it prints the value associated with message to the screen. Naming and Using Variables When you're using variables in Python, you need to adhere to a few rules and guidelines. breaking some of these rules will cause errors; other guidelines just help you write code that's easier to read and understand. Be sure to keep the following variable rules in mind: Variable names can contain only letters, numbers and underscores. They can start with a letter or underscore, but not with a number. Spaces are not allowed in variable names, underscores should be used instead. Avoid using Python keywords and function names as variable names that serve a particular programmatic purpose. This could cause many different problems. Variable names should be short but descripitve. For example, name is better than n . Be careful when using the lowercase l and the uppercase letter O because they could be confused with the numbers 1 and 0 . Strings Because most programs define and gather some sort of data, and then do something useful with it, it helps to classify different types of data. The first data type we'll look at is the string . Strings are quite simple at first glance, but you can use them in many different ways. A string is a series of characters. Anything inside quotes is considered a string in Python, and you can use single or double quotes around your strings like this: 1 2 \"This is a string\" 'This is also a string' This flexibility allows you to use quotes and apostrophes within your strings: 1 'I told my friend, \"Python is my favorite language!\"' Changing Case in a String with Methods One of the simplest tasks you can do with strings is change the case of the words in a string: 1 2 name = \"ada lovelace\" print ( name . title ()) In the above example, the variable name refers to the lowercase string ada lovelace / The method title () appears after the variable in the print () call. A method is an action that Python can perform on a piece of data. The dot (.) after name in name . title () tells Python to make the title() method act on the variable name . The title () method changes each word to title case, where each word begins with a capital letter. This is useful because you'll often want to think of a name as a piece of information. For example, you might want to program the input values of Ada . ADA , and ada as the same name, and display them all as Ada . Several other useful methods are available for dealing with case as well. For example, you can change a string to all uppercase or all lowercase letters like this: 1 2 3 name = \"Ada Lovelace\" print ( name . upper ()) print ( name . lower ()) This will display the following: ADA LOVELACE ada lovelace Using Variables in Strings In some situations, you may want to use a variable's name inside a string. For example, you might want two variables to represent a first name and a last name respectively, and then want to combine those values to display someone's full name: 1 2 3 4 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" print ( full_name ) To insert a variable's value into a string, place the letter f immediately before the opening quoatation mark. Put braces around the name or names of any variable you want to use inside the string. Python will replace each variable with its value when the string is displayed. These strings are called f-strings . The f is for format , because Python formats the string by replaceing the name of any variable in braces with its value. You can do a lot with f-strings. For example, you can use f-strings to compose complete messages using the information associated with a variable: 1 2 3 4 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" print ( f \"Hello, { full_name . title () } !\" ) The above code would display the following: Hello, Ada Lovelace! We can actually make this even simpler, by assigning the entire message to a variable: 1 2 3 4 5 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" message = f \"Hello, { full_name . title () } !\" print ( message ) The final print() call is much simpler in this case. f-string compatibility f-strings were first introduced in Python 3.6. If you are using Python 3.5 or earlier, you must use the format () method rather than the above f syntax. To use format () , list the variables you want to use in the string inside the parentheses following format. Each variable is referred to by a set of braces; the braces will be filled by the values listed in parentheses in the order provided: 1 full_name = \" {} {} \" . format ( first_name , last_name ) Adding Whitespace to Strings with Tabs or Newlines In programming, whitespace refers to any nonprinting character, such as spaces, tabs, and end-of-line symbols. You can use whitespace to organize your output so it's easier for users to read. To add a tab to your text, use the character combination \\t . To add a newline in a string, use the character combination \\n . You can also combine tabs and newlines in a single string. The string \\n\\t tells Python to move to a new line and start the next line with a tab. Stripping Whitespace Extra whitespace can be confusing in your programs. To programmers, 'python' and 'python ' look pretty much the same, but to a program, they are two different strings. Puthon detects the extra space in 'python ' and considers it significant unless you tell it otherwise. It is important to think about whitespace, because often you'll want to compare two strings to determine whether they are the same. For example, one important instance might involve checking people's usernames when they login to a website. Extra whitespace can be confusing in much simpler situations as well. Fortunately, Python makes it simple to eliminate extraneous whitespace from data that people enter. Python can look for extra whitespace on the right and left sides of a string. To ensure that no whitespace exists at the right end of a string, use the rstrip () method. 1 2 3 4 5 6 7 favorite_language = 'python ' favorite_language >>> 'python ' favorite_language . rstrip () >>> 'python' Running the above code with the rstrip () method does not permanently remove the whitespace at the end of the string. If the code was run again without the rstrip () , the extra whitespace would appear again. Avoiding Syntax Errors with Strings One kind of error that you mught see with some regularity is a syntax error. A syntax error occurs when Python doesn't recognize a section of your program as valid Python code. For example, if you use an apostrophe within single quotes, you will produce an error. This happens because Python interprets everything between the first single quote and the apostrophe as a string. Luckily, Python will let you know where the error is located and will try it's best to say what the problem is. Sometimes, the error is straight forward, but sometimes, it will require additional research to find a solution. Numbers Numbers are used quite often in programming to keep score in games, represent data in visualizations, store information in web applications, and so on. Python treats numbers in several different ways. Let's first take a look at how Python manages integers, because they are the simplest to work with: You can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) integers in Python. 1 2 3 4 5 6 7 8 9 10 11 >>> 2 + 3 5 >>> 3 - 2 1 >>> 2 * 3 6 >>> 3 / 2 1.5 In a terminal session, Python simply returns the result of the operation. Python uses two multiplication symbols to represent exponents: 1 2 3 4 5 6 7 8 >>> 3 ** 2 9 >>> 3 ** 3 27 >>> 10 ** 6 1000000 Python supports the order of operations too, so you can use multiple operations in one expression. You can also use parentheses to modify the order of operations so Python can evaluate your expression in the order you specify. For example: 1 2 3 4 5 >>> 2 + 3 * 4 14 >>> ( 2 + 3 ) * 4 20 Floats Python calls any number with a decimal point a float . This term is used in most programming languages (like in C ), and it refers to the fact that a decimal point can appear at any position in a number. Every programming language must be carefully designed to properly manage decimal numbers so numbers behave appropriately no matter where the decimal point appears. For the most part, you cnas use decimals without worrying how they behave. Simply enter the numbers you want to use, and Python will most likely do what you expect: 1 2 3 4 5 >>> 0.1 + 0.1 0.2 >>> 0.2 * 0.2 0.4 But beware, sometimes you will get an arbitrary number of decimals in your answer: 1 2 3 4 5 >>> 0.2 + 0.1 0.3000000000000004 >>> 0.3 * 0.1 0.3000000000000004 This happens in all languages and is of little concern. Python tries to find a way to represent the result as precisely as possible, which is sometimes difficult given how computers have to represent numbers internally. Integers and Floats When you divide any two numbers, even if they are integers that result in a whole number, you'll always get a float: 1 2 >>> 4 / 2 2.0 If you mix an integer and a float in any operation, you'll get a float as well. Python defaults to a float in any operation that uses a float, even if the output is a whole number. Underscores in Numbers When you're writing long numbers, you can group digits using underscores to make large numbers more readable in code: 1 universe_age = 14_000_000_000 When you print a number that was defined with underscores, Python only prints the digits. Even if the numbers are not grouped in threes, Python will still ignore the underscores. This feature works for both integers and floats, but only in Python 3.6 and later. Multiple Assignment You can assign values to more than one variable using just a single line. This can help shorten your programs and make them easier to read; you'll use this technique most often when initializing a set of number. For example, here is how you can initialize the variables x , y , and z to zero: 1 x , y , z = 0 , 0 , 0 You need to separate the variable names with commas, and do the same with the values, and Python will assign each value to its respectively positioned variable. As long as the number of values matches the number of variables, Python will match them up correctly. Constants A constant is like a variable whose value stays the same throughout the life of a program. Python doesn't have built-in constant types, but Python programmers use all capital letters to indicate a variable should be treated as a constant and never be changed: 1 MAX_CONNECTIONS = 5000 Comments Comments are an extremely useful feature in most programming languages. Adding a hash mark (#) indicates a comment. Anything following a hash mark in your code is ignored by the Python interpreter until a new line of code is detected. Comments should be written throughout your program to help whoever is reading it understand what does what.","title":"Variables and Simple Data Types"},{"location":"py-data-types/#variables-and-simple-data-types","text":"","title":"Variables and Simple Data Types"},{"location":"py-data-types/#variables","text":"Let's go back to the first program and use a variable. To do this, we simply add a new line at the beginning of the file and modify the second line: 1 2 message = \"Hello Python World!\" print ( message ) We have now created a variable named message . Every variable is connected to a value , which is the information associated with that variable. In this case the value is the Hello Python World! text. Adding a variable makes a little more work for the Python interpreter. When it processes the first line, it associates the variable message with the Hello Python World! text. When it reaches the second line, it prints the value associated with message to the screen.","title":"Variables"},{"location":"py-data-types/#naming-and-using-variables","text":"When you're using variables in Python, you need to adhere to a few rules and guidelines. breaking some of these rules will cause errors; other guidelines just help you write code that's easier to read and understand. Be sure to keep the following variable rules in mind: Variable names can contain only letters, numbers and underscores. They can start with a letter or underscore, but not with a number. Spaces are not allowed in variable names, underscores should be used instead. Avoid using Python keywords and function names as variable names that serve a particular programmatic purpose. This could cause many different problems. Variable names should be short but descripitve. For example, name is better than n . Be careful when using the lowercase l and the uppercase letter O because they could be confused with the numbers 1 and 0 .","title":"Naming and Using Variables"},{"location":"py-data-types/#strings","text":"Because most programs define and gather some sort of data, and then do something useful with it, it helps to classify different types of data. The first data type we'll look at is the string . Strings are quite simple at first glance, but you can use them in many different ways. A string is a series of characters. Anything inside quotes is considered a string in Python, and you can use single or double quotes around your strings like this: 1 2 \"This is a string\" 'This is also a string' This flexibility allows you to use quotes and apostrophes within your strings: 1 'I told my friend, \"Python is my favorite language!\"'","title":"Strings"},{"location":"py-data-types/#changing-case-in-a-string-with-methods","text":"One of the simplest tasks you can do with strings is change the case of the words in a string: 1 2 name = \"ada lovelace\" print ( name . title ()) In the above example, the variable name refers to the lowercase string ada lovelace / The method title () appears after the variable in the print () call. A method is an action that Python can perform on a piece of data. The dot (.) after name in name . title () tells Python to make the title() method act on the variable name . The title () method changes each word to title case, where each word begins with a capital letter. This is useful because you'll often want to think of a name as a piece of information. For example, you might want to program the input values of Ada . ADA , and ada as the same name, and display them all as Ada . Several other useful methods are available for dealing with case as well. For example, you can change a string to all uppercase or all lowercase letters like this: 1 2 3 name = \"Ada Lovelace\" print ( name . upper ()) print ( name . lower ()) This will display the following: ADA LOVELACE ada lovelace","title":"Changing Case in a String with Methods"},{"location":"py-data-types/#using-variables-in-strings","text":"In some situations, you may want to use a variable's name inside a string. For example, you might want two variables to represent a first name and a last name respectively, and then want to combine those values to display someone's full name: 1 2 3 4 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" print ( full_name ) To insert a variable's value into a string, place the letter f immediately before the opening quoatation mark. Put braces around the name or names of any variable you want to use inside the string. Python will replace each variable with its value when the string is displayed. These strings are called f-strings . The f is for format , because Python formats the string by replaceing the name of any variable in braces with its value. You can do a lot with f-strings. For example, you can use f-strings to compose complete messages using the information associated with a variable: 1 2 3 4 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" print ( f \"Hello, { full_name . title () } !\" ) The above code would display the following: Hello, Ada Lovelace! We can actually make this even simpler, by assigning the entire message to a variable: 1 2 3 4 5 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" message = f \"Hello, { full_name . title () } !\" print ( message ) The final print() call is much simpler in this case. f-string compatibility f-strings were first introduced in Python 3.6. If you are using Python 3.5 or earlier, you must use the format () method rather than the above f syntax. To use format () , list the variables you want to use in the string inside the parentheses following format. Each variable is referred to by a set of braces; the braces will be filled by the values listed in parentheses in the order provided: 1 full_name = \" {} {} \" . format ( first_name , last_name )","title":"Using Variables in Strings"},{"location":"py-data-types/#adding-whitespace-to-strings-with-tabs-or-newlines","text":"In programming, whitespace refers to any nonprinting character, such as spaces, tabs, and end-of-line symbols. You can use whitespace to organize your output so it's easier for users to read. To add a tab to your text, use the character combination \\t . To add a newline in a string, use the character combination \\n . You can also combine tabs and newlines in a single string. The string \\n\\t tells Python to move to a new line and start the next line with a tab.","title":"Adding Whitespace to Strings with Tabs or Newlines"},{"location":"py-data-types/#stripping-whitespace","text":"Extra whitespace can be confusing in your programs. To programmers, 'python' and 'python ' look pretty much the same, but to a program, they are two different strings. Puthon detects the extra space in 'python ' and considers it significant unless you tell it otherwise. It is important to think about whitespace, because often you'll want to compare two strings to determine whether they are the same. For example, one important instance might involve checking people's usernames when they login to a website. Extra whitespace can be confusing in much simpler situations as well. Fortunately, Python makes it simple to eliminate extraneous whitespace from data that people enter. Python can look for extra whitespace on the right and left sides of a string. To ensure that no whitespace exists at the right end of a string, use the rstrip () method. 1 2 3 4 5 6 7 favorite_language = 'python ' favorite_language >>> 'python ' favorite_language . rstrip () >>> 'python' Running the above code with the rstrip () method does not permanently remove the whitespace at the end of the string. If the code was run again without the rstrip () , the extra whitespace would appear again.","title":"Stripping Whitespace"},{"location":"py-data-types/#avoiding-syntax-errors-with-strings","text":"One kind of error that you mught see with some regularity is a syntax error. A syntax error occurs when Python doesn't recognize a section of your program as valid Python code. For example, if you use an apostrophe within single quotes, you will produce an error. This happens because Python interprets everything between the first single quote and the apostrophe as a string. Luckily, Python will let you know where the error is located and will try it's best to say what the problem is. Sometimes, the error is straight forward, but sometimes, it will require additional research to find a solution.","title":"Avoiding Syntax Errors with Strings"},{"location":"py-data-types/#numbers","text":"Numbers are used quite often in programming to keep score in games, represent data in visualizations, store information in web applications, and so on. Python treats numbers in several different ways. Let's first take a look at how Python manages integers, because they are the simplest to work with: You can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) integers in Python. 1 2 3 4 5 6 7 8 9 10 11 >>> 2 + 3 5 >>> 3 - 2 1 >>> 2 * 3 6 >>> 3 / 2 1.5 In a terminal session, Python simply returns the result of the operation. Python uses two multiplication symbols to represent exponents: 1 2 3 4 5 6 7 8 >>> 3 ** 2 9 >>> 3 ** 3 27 >>> 10 ** 6 1000000 Python supports the order of operations too, so you can use multiple operations in one expression. You can also use parentheses to modify the order of operations so Python can evaluate your expression in the order you specify. For example: 1 2 3 4 5 >>> 2 + 3 * 4 14 >>> ( 2 + 3 ) * 4 20","title":"Numbers"},{"location":"py-data-types/#floats","text":"Python calls any number with a decimal point a float . This term is used in most programming languages (like in C ), and it refers to the fact that a decimal point can appear at any position in a number. Every programming language must be carefully designed to properly manage decimal numbers so numbers behave appropriately no matter where the decimal point appears. For the most part, you cnas use decimals without worrying how they behave. Simply enter the numbers you want to use, and Python will most likely do what you expect: 1 2 3 4 5 >>> 0.1 + 0.1 0.2 >>> 0.2 * 0.2 0.4 But beware, sometimes you will get an arbitrary number of decimals in your answer: 1 2 3 4 5 >>> 0.2 + 0.1 0.3000000000000004 >>> 0.3 * 0.1 0.3000000000000004 This happens in all languages and is of little concern. Python tries to find a way to represent the result as precisely as possible, which is sometimes difficult given how computers have to represent numbers internally.","title":"Floats"},{"location":"py-data-types/#integers-and-floats","text":"When you divide any two numbers, even if they are integers that result in a whole number, you'll always get a float: 1 2 >>> 4 / 2 2.0 If you mix an integer and a float in any operation, you'll get a float as well. Python defaults to a float in any operation that uses a float, even if the output is a whole number.","title":"Integers and Floats"},{"location":"py-data-types/#underscores-in-numbers","text":"When you're writing long numbers, you can group digits using underscores to make large numbers more readable in code: 1 universe_age = 14_000_000_000 When you print a number that was defined with underscores, Python only prints the digits. Even if the numbers are not grouped in threes, Python will still ignore the underscores. This feature works for both integers and floats, but only in Python 3.6 and later.","title":"Underscores in Numbers"},{"location":"py-data-types/#multiple-assignment","text":"You can assign values to more than one variable using just a single line. This can help shorten your programs and make them easier to read; you'll use this technique most often when initializing a set of number. For example, here is how you can initialize the variables x , y , and z to zero: 1 x , y , z = 0 , 0 , 0 You need to separate the variable names with commas, and do the same with the values, and Python will assign each value to its respectively positioned variable. As long as the number of values matches the number of variables, Python will match them up correctly.","title":"Multiple Assignment"},{"location":"py-data-types/#constants","text":"A constant is like a variable whose value stays the same throughout the life of a program. Python doesn't have built-in constant types, but Python programmers use all capital letters to indicate a variable should be treated as a constant and never be changed: 1 MAX_CONNECTIONS = 5000","title":"Constants"},{"location":"py-data-types/#comments","text":"Comments are an extremely useful feature in most programming languages. Adding a hash mark (#) indicates a comment. Anything following a hash mark in your code is ignored by the Python interpreter until a new line of code is detected. Comments should be written throughout your program to help whoever is reading it understand what does what.","title":"Comments"},{"location":"py-dictionaries/","text":"Dictionaries Understanding dictionaries allows you to model a variety of real-world objects more accurately. For example, we could create a dictionary representing a person and then store as much information as we want about that person. You can store their name, location, age, profession, and any other aspect of a person you can describe. We can store any two kinds of information that can be matched up, such as a list of words and their meanings, a list of people's names and their favorite numbers, a list of mountains and their elevations, etc. A Simple Dictionary Consider a game featuring aliens that can have different colors and point values. This simple dictionary stores information about a particular alien: 1 2 3 4 alien_0 = { 'color' : 'green' , 'points' : 5 } print ( alien_0 [ 'color' ]) print ( alien_0 [ 'points' ]) The dictionary alien_0 stores the alien's color and point value. The last two lines access and display that information, as shown here: green 5 As with most new programming concepts, using dictionaries takes practice. Once you've worked with dictionaries for a bit, you'll soon see how effectively they can model real-world situations. Working with Dictionaries A dictionary in Python is a collection of key-value pairs . Each key is connected to a value, and you can use a key to access the value associated with that key. A key's value can be a number, a string, a list, or even another dictionary. In fact, you can use any object that you can create in Python as a value in a dictionary. In Python, a dictionary is wrapped in braces, { }, with a series of key-value pairs inside the braces, as shown in the earlier example: alien_0 = { 'color' : 'green' , 'points' : 5 } A key-value pair is a set of values associated with each other. When you provide a key, Python returns the value associated with that key. Every key is connected to its value by a colon, and individual key-value pairs are separated by commas. You can store as many key-value pairs as you want in a dictionary. The simplest dictionary has exactly one key-value pair, as shown in this modified version of the alien_0 dictionary: alien_0 = { 'color' : 'green' } This dictionary stores one piece of information about alien_0 , namely the alien's color. The string 'color' is a key in this dictionary, and its associated value is 'green' . Accessing Values in a Dictionary To get the value associated with a key, give the name of the dictionary and then place the key inside a set of square brackets, as shown here: 1 2 alien_0 = { 'color' : 'green' } print ( alien_0 [ 'color' ]) This returns the value associated with the key 'color' from the dictionary alien_0 : green You can have an ulimited number of key-value pairs in a dictionary. For example, here's the original alien_0 dictionary with two key-value pairs: alien_0 = { 'color' : 'green' , 'points' : 5 } Now you can access either the color or the point value of alien_0 . If a player shoots down this alien, you can look up how many points they should earn using code like this: 1 2 3 4 alien_0 = { 'color' : 'green' , 'points' : 5 } new_points = alien_0 [ 'points' ] print ( f \"You just earned { new_points } points!\" ) Once the dictionary has been defined, the code on line 3 pulls the value associated with the key 'points' from the dictionary. This value is then assigned to the variable 'new_points' . The code on line 4 then prints a statement about how many points the player just earned. Adding New Key-Value Pairs Dictionaries are dynamic structures, and you can add new key-value pairs to a dictionary at any time. For example, to add a new key-value pair, you would give the name of the dictionary followed by the new key in square brackets along with the new value. Let's add two new pieces to the alien_0 dictionary: the alien's x- and y- coordinates, which will help us display the alien in a particular position on the screen. Let's place the alien on the left edge of the screen, 25 pixels down from the top. Because screen coordinates usually start at the upper-left corner of the screen, we'll place the alien on the left edge of the screen by setting the x-coordinate to 0 and 25 pixels from the top by setting the y-coordinate to positive 25: 1 2 3 4 5 6 alien_0 = { 'color' : 'green' , 'points' : '5' } print ( alien_0 ) alien_0 [ 'x_position' ] = 0 alien_0 [ 'y_position' ] = 25 print ( alien_0 ) We start by defining the same dictionary that we have been working with. We then print this dictionary, displaying a snapshot of its information. On line 4, we add a new key-value pair to the dictionary: key 'x_position' and a value of 0 . We do the same for key 'y_position' on the next line. Finally, when we print the modified dictionary, we see the two additional key-value pairs: {'color': 'green', 'points': '5'} {'color': 'green', 'points': '5', 'x_position': 0, 'y_position': 25} The final version of the dictionary contains four key-value pairs. Starting with an Empty Dictionary It's sometimes convenient, or even necessary, to start with an empty dictionary and then add each new item to it. To start filling an empty dictionary, define a dictionary with an empty set of braces and then add each key-value pair on its own line. For example, here's how to build the alien_0 dictionary using this approach: 1 2 3 4 5 6 alien_0 = {} alien_0 [ 'color' ] = 'green' alien_0 [ 'points' ] = '5' print ( alien_0 ) Here we define an empty alien_0 dictionary, and then add color and point values to it. The result is the dictionary we have been usinging in previous examples: {'color': 'green', 'points': '5'} Typically, you'll use empty dictionaries when storing user-supplied data in a dictionary or when you write code that generates a large number of key-value pairs automatically. Modifying Values ina Dictionary To modify a value in a dictionary, give the name of the dictionary with the key in square brackets and then the new value you want associated with that key. For example, consider an alien that changes from green to yellow as a game progresses: 1 2 3 4 5 alien_0 = { 'color' : 'green' } print ( f \"The alien is { alien_0 [ 'color' ] } .\" ) alien_0 [ 'color' ] = 'yellow' print ( f \"The alien is now { alien_0 [ 'color' ] } .\" ) We first define a dictionary for alien_0 that contains only the aliens color; then we change the value associated with the key 'color' to 'yellow' . The output shows that the alien has indeed changed from green to yellow: The alien is green. The alien is now yellow. For a more interesting example, let's track the position of an alien that can move at different speeds. We'll sotre a value representing the alien's current speed and then use it to determine how far to the right the alien should move: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 alien_0 = { 'x_position' : 0 , 'y_position' : 25 , 'speed' : 'medium' } print ( f \"Original position: { alien_0 [ 'x_position' ] } \" ) # Move the alien to the right. # Determine how far to move the alien based on its current speed. if alien_0 [ 'speed' ] == 'slow' : x_increment = 1 elif alien_0 [ 'speed' ] == 'medium' : x_increment = 2 else : # This must be a fast alien. x_increment = 3 # The new position is the old position plus the increment. alien_0 [ 'x_position' ] = alien_0 [ 'x_position' ] + x_increment print ( f \"New position: { alien_0 [ 'x_position' ] } \" ) We start by defining an alien with an initial x and y position, and a speed of 'medium' . We also print the original value of x_position to see how far the alien moves to the right. On line 5, an if - elif - else chain determins how far the alien should move to the right and assigns this value to the variable x_increment . If the alien's speed is 'slow' , it moves one unit, if it is 'medium' , it moves two, and if it is 'fast' , it moves three. Once the increment has been calculated, it is added to the value of x_position on line 13 and the result is stored in the dictionary's x_position . Because this is a medium-speed alien, its position shifts two units to the right: Original position: 0 New position: 2 This technique is pretty cool: by changing one value in the alien's dictionary, you can change the overall behavior of the alien. For example, to turn this medium-speed alien into a fast alien, you would add the line: alien_0 [ 'speed' ] = 'fast' The if-elif-else block would then assign a larger value to x_increment the next time the code runs. Removing Key-Value Pairs When you no longer need a piece of information that is stored ina dictionary, you can you the del statement to completely remove a key-value pair. All del needs is the name of the dictionary and the key that you want to remove. For example, let's remove the key 'points' from the alien_0 dictionary along with its value: 1 2 3 4 5 alien_0 = { 'color' : 'green' , 'points' : 5 } print ( alien_0 ) del alien_0 [ 'points' ] print ( alien_0 ) The code on line 4 tells Python to delete the key 'points' from the dictionary alien_0 and to remove the value associated with that key as well. The output shows that the key 'points' and its value of 5 are deleted from the dictionary, and the rest is unaffected: {'color': 'green', 'points': 5} {'color': 'green'} A Dictionary of Similar Objects The previous example involved storing different kinds of information about one object, an alien in a game. You can also use a dictionary to store one kind of information about many objects. For example, a dictionary of a group of people's favorite programming language. A dictionary for this could look like: 1 2 3 4 5 6 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } As you can see, we've broken a larger dictionary into several lines (mainly for better readability). Each key is the name of a person and each value is their favorite language. When you know you'll need more than one line to define a dictionary, press ENTER after the opening brace. Then indent the next line one tab, and write your first key-value pair, followed by a comma. Once you have finished defining the dictionary, add a closing brace on a new line after the last key-value pair and indent it one level so it aligns with the keys in the dictionary. It's good practice to include a comma after the last key-value pair, just in case you want to add more in the future. To use this dictionary, given the name of a person, you can easily look up their favorite language: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } language = favorite_languages [ 'sarah' ] . title () print ( f \"Sarah's favorite langugage is { language } .\" ) To see which language Sarah chose, we ask for the value at: favorite_languages [ 'sarah' ] We use this syntax to pull Sarah's favorite language from the dictionary (line 8) and assign it to the variable language . Creating a new variable here makes for a much cleaner print () call. The output shows Sarah's favorite Language: Sarah's favorite langugage is C. Using get () to Access Values Using keys in square brackets to retrieve the value you're interested in from a dictionary might cause one potential problem: if the key you ask for doesn't exist, you'll get an error. Let's see what happens when you ask for the point value of an alien that doesn't have a point value set: 1 2 alien_0 = { 'color' : 'green' , 'speed' : 'slow' } print ( alien_0 [ 'points' ]) This results in a traceback, showing a KeyError: KeyError Traceback (most recent call last) <ipython-input-9-3914d637e9f3> in <module> 1 alien_0 = {'color': 'green', 'speed': 'slow'} ----> 2 print(alien_0['points']) KeyError: 'points' For dictionaries, we can use the get () method to set a default value that will be returned if the requested key doesn't exist. The get () method requires a key as a first argument. As a second optional argument, you can pass the value to be returned if the key doesn't exist: 1 2 3 4 alien_0 = { 'color' : 'green' , 'speed' : 'slow' } point_value = alien_0 . get ( 'points' , 'No point value assigned.' ) print ( point_value ) If the key 'points' exists in the dictionary, you'll get corresponding value. If it doesn't, you get the default value. In this case, points doesn't exist, and we get a clean message instead of an error: No point value assigned. If there's a chance the key you're asking for might not exist, consider using the get () method instead of the square bracket notation. Looping Through a Dictionary A single Python dictionary can contain just a few key-value pairs or millions of pairs. Because a dictionary can contain large amounts of data, Python lets you loop through a dictionary. Dictionaries can be used to store information in a variety of ways; therefore, several different ways exist to loop through them. You can loop through all of a dictionary's key-value pairs, through its keys, or its values. Looping Through All Key-Value Pairs Before we explore the different approaches to looping, let's consider a new dictionary designed to store information about a user on website. The following dictionary would store one person's username, first name, and last name: 1 2 3 4 5 user_0 = { 'username' : 'efermi' 'first' : 'enrico' 'last' : 'fermi' } You can access any single piece of information about user_0 based on what you've already learned in this chapter. But what if you wanted to see everything stored in this user's dictionary? To do so, you could loop through the dictionary using a for loop. 1 2 3 4 5 6 7 8 9 user_0 = { 'username' : 'efermi' , 'first' : 'enrico' , 'last' : 'fermi' , } for key , value in user_0 . items (): print ( f \" \\n Key: { key } \" ) print ( f \"Value: { value } \" ) As shown on line 7, to write a for loop for a dictionary, you create names for the two variables that will hold the key and value in each key-value pair. You can choose any names you want for these two variables. This code would work just as well if you had used abbreviated for the variable names, like this: for k , v in user_0 . items () The second half of the for statement on line 7 includes the name of the dictionary followed by the method items() , which returns a list of key-value pairs. The for loop then assigns each of these pairs to the two vairbales provided. In the preceding example, we use the variables to print each key (line 8), followed by the associated value (line 9). The \"\\n\" in the first print () call ensures that a blank line is inserted bfore each key-value pair in the output: Key: username Value: efermi Key: first Value: enrico Key: last Value: fermi Looping through all key-value pairs works particularly well for dictionaries like the favorite_languages example from above , which stores the same kind of information for many different keys. If you loop through the favorite_languages dictionary, you get the name of each person in the dictionary and their favorite programming language. Because the keys always refer to a person's name and the value is always language, we'll use the variables name and language in the loop, instead of key and value . This will make it easier to follow what's happening inside the loop: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name , language in favorite_languages . items (): print ( f \" { name . title () } 's favorite language is { language . title () } !\" ) The code on line 8 tells Python to loop through each key-value pair in the dictionary. As it works through each pair the key is assigned to the variable name , and the value is assigned to the variable language . These descriptive names make it much easier to see what the print () call on line 9 is doing. Now, in just a few lines of code, we can display all the information from the poll: Jen's favorite language is Python! Sarah's favorite language is C! Edward's favorite language is Ruby! Phil's favorite language is Python! This type of looping would work just as well if our dictionary stored the results from polling a thousand or even a million people. Looping Through All The Keys in a Dictionary The keys() method is useful when you don't need to work with all of the values in a dictionary. Let's loop through the favorite_languages dictionary and print the names of everyone who answered: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name in favorite_languages . keys (): print ( name . title ()) The code on line 8 tells Python to pull all the keys from the dictionary favorite_languages and assign them one at a time to the variable name . The output shows the names of everyone who answered: Jen Sarah Edward Phil Looping through the keys is actually the default behavior when looping through a dictionary, so this code would have exactly the same output if you wrote: for name in favorite_languages : rather than: for name in favorite_languages . keys (): You can choose to use the keys() method explicitly if it makes your code easier to read, or you can omit it if you wish. You can access the value associated with any key you care about inside the loop by using the current key. Let's print a message to a couple of friends about the languages they chose. We'll loop through the names in the dictionary as we did previously, but when the name matches on of our friends, we'll display a message about their favorite language: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } friends = [ 'phil' , 'sarah' ] for name in favorite_languages . keys (): print ( f \"Hi, { name . title () } .\" ) if name in friends : language = favorite_languages [ name ] . title () print ( f \" \\t { name . title () } , I see you love { language } !\" ) On line 8 we make a list of friends that we want to print a message to. Inside the loop, we print each person's name. Then on line 12 we check whether the name we're working with is in the list friends . If it is, we determine the person's favorite language using the name of the dictionary and the current value of name as the key (line 13). We then print a special greeting, including a reference to their language of choice. Everyone's name is printed, but our friends receive a special message: Hi, Jen. Hi, Sarah. Sarah, I see you love C! Hi, Edward. Hi, Phil. Phil, I see you love Python! You can also use the keys() method to find out if a particular person was polled. This time, let's find out if Erin took the poll: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } if 'erin' not in favorite_languages . keys (): print ( \"Erin, please take our poll!\" ) The keys() method isn't just for looping: it actually returns a list of all the keys, and the code on line 8 simply checks if 'erin' is in the list. Because she is not, a message is printed inviting her to take the poll. Looping Through a Dictionary's Keys in a Particular Order Starting in Python 3.7, looping through a dictionary returns the items in the same order they were inserted. Sometimes, though, you'll want to loop through a dictionary in a different order. One way to do this is to sort the keys as they're retunred in the for loop. You can use the sorted () function to get a copy of the keys in order: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name in sorted ( favorite_languages . keys ()): print ( f \" { name . title () } , thank you for taking the poll.\" ) This for statement is like other for statements except that we've wrapped the sorted () function around the dictionary . keys () method. This tells Python to list all keys in the dictionary and sort that list before looping through it. The output shows everyone who took the poll, with the names displayed in order: Edward, thank you for taking the poll. Jen, thank you for taking the poll. Phil, thank you for taking the poll. Sarah, thank you for taking the poll. Looping Through All Values in a Dictionary If you are primarily interested in the values that a dictionary contains, you can use the values () method to return a list of values without any keys. For example, say we simply want a list of all languages chosen in our programming language poll without the name of the person who chose each language: 1 2 3 4 5 6 7 8 9 10 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } print ( \"The following languages have been mentioned:\" ) for language in favorite_languages . values (): print ( language . title ()) The for statement here pulls each value from the dictionary and assigns it to the variable language . When these values are printed, we get a list of all chosen languages: The following languages have been mentioned: Python C Ruby Python This approach pulls all the values from the dictionary without checking for repeats. That might work fine with a small number of values, but in a poll with a large number of respondents, this would result in a very repetitive list. To see each language chosen without repitionm we can use a set. A set is a collection in which each item must be unique. We can use the following for loop in place of the one used above: for language in set ( favorite_languages . values ()): When you wrap set () around a list that contains duplicate items, Python identifies the unique items in the list and build a set from those items. The result is a nonrepetitive list of languages that have been menetioned: The following languages have been mentioned: C Ruby Python Nesting Sometimes you'll want to store multiple dictionaries in a list, or a list of items as a value in a dictionary. This is called nesting . You can nest dictionaries inside a list, a list of items inside a dictionary, or even a dictionary inside another dictionary. Nesting is a powerful feature, as the following examples will demonstrate. A List of Dictionaries The alien_0 dictionary contains a variety of information about one alien, but it has no room to store information about a second alien, much less a full screen of aliens. How can you managae a fleet of aliens? One way is to make a list of aliens in which each alien is a dictionary of information about that alien. For example, the following code builds a list of three aliens: 1 2 3 4 5 6 7 8 alien_0 = { 'color' : 'green' , 'points' : 5 } alien_1 = { 'color' : 'yellow' , 'points' : 10 } alien_2 = { 'color' : 'red' , 'points' : 15 } aliens = [ alien_0 , alien_1 , alien_2 ] for alien in aliens : print ( alien ) We first create three dictionaries, each representing a different alien. On line 5 we store each of these dictionaries in a list called aliens . Finally, we loop through the list and print out each alien: {'color': 'green', 'points': 5} {'color': 'yellow', 'points': 10} {'color': 'red', 'points': 15} A more realistic example would involve more than three alies with code that automatically generates each alien. In the following example we use range () to create a fleet of 30 aliens: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Make an empty list for storing aliens aliens = [] # Make 30 green aliens. for alien_number in range ( 30 ): new_alien = { 'color' : 'green' , 'points' : 5 , 'speed' : 'slow' } aliens . append ( new_alien ) # Show the first 5 aliens. for alien in aliens [: 5 ]: print ( alien ) print ( \"...\" ) # Show how many aliens have been created. print ( f \"Total number of aliens: { len ( aliens ) } \" ) This example befins with an empty list to hold all of the aliens that will created. At line 5 range () returns a series of numbers, which just tells Python how many times we want the loop to repeat. Each time the loop runs we create a new alien (line 6) and then append each new alien to the list aliens (line 7). On line 10 we us a slice to print the first five aliens, and then on line 15 we print the length of the list to prove we've actually generated the full fleet of 30 aliens: {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} ... Total number of aliens: 30 These aliens all have the same characteristics, but Python considers each one a separate object, which allows us to modify each alien individually. How might you work with a group of aliens like this? Imagine that one aspect of a game has some aliens changing color and moving faster as the game progress. When it's time to change colors, we can use a for loop and an if statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Make an empty list for storing aliens aliens = [] # Make 30 green aliens. for alien_number in range ( 30 ): new_alien = { 'color' : 'green' , 'points' : 5 , 'speed' : 'slow' } aliens . append ( new_alien ) for alien in aliens [: 3 ]: if alien [ 'color' ] == 'green' : alien [ 'color' ] = 'yellow' alien [ 'speed' ] = 'medium' alien [ 'points' ] = '10' # Show the first 5 aliens. for alien in aliens [: 5 ]: print ( alien ) print ( \"...\" ) Because we want to modify the first three aliens, we loop through a slice that includes only the first three aliens. All of the aliens are green now but that won't always be the case, so we write an if statement to make sure we're only modifying green aliens. If the alien is green, we change the color to 'yellow' , the speed to 'medium' , and the point value to 10 , as shown in the following output: {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} ... You could expand this loop by adding an elif block that turns yellow aliens into red, fast-moving ones worth 15 points each. Without showing the entire program again, that loop would look like this: 1 2 3 4 5 6 7 8 9 for alien in aliens [: 3 ]: if alien [ 'color' ] == 'green' : alien [ 'color' ] = 'yellow' alien [ 'speed' ] = 'medium' alien [ 'points' ] = '10' elif alien [ 'color' ] == 'yellow' : alien [ 'color' ] = 'red' alien [ 'speed' ] = 'fast' alien [ 'points' ] = 15 It's common to store a number of dictionaries in a list when each dictionary contains many kinds of information about one subject. For example, you might create a dictionary for each user on a website and store the individual dictionaries in a list called users . All of the dictionaries in the list should have an identical structure so you can loop through the list and work with each dictionary object in the same way. A List in a Dictionary Rather than putting a dictionary inside a list, it's sometimes useful to put a list inside a dictionary. For example, consider how you might describe a pizza that someone is ordering. If you were to use only a list, all you could really store is a list of the pizza's toppings. With a dictionary, a list of toppings can be just one aspect of the pizza you're describing. In the following example, two kinds of information are stored for each pizza: a type of crust and a list of toppings. The list of toppings is a value associated with the key 'toppings' . To use the items in the list, we give the name of the dictionary and the key 'toppings' , as we would any value in the dictionary. Instead of returning a single value, we get a list of toppings: 1 2 3 4 5 6 7 8 9 10 11 12 # Store information about a pizza being ordered. pizza = { 'crust' : 'thick' , 'toppings' : [ 'mushrooms' , 'extra cheese' ], } # Summarize the order. print ( f \"You ordered a { pizza [ 'crust' ] } -crust pizza \" \"with the following toppings:\" ) for topping in pizza [ 'toppings' ]: print ( \" \\t \" + topping ) We begin on line 2 with a dictionary that holds information about a pizza that has been ordered. One key in the dictionary is 'crust' , and the associated value is the string 'thick' . The next key, 'toppings' , has a list as its value that stores all the requested toppings. On line 8 we summarize the order before building the pizza. When you need to break up a long ling in a print () call, choose an appropriate point at which to break the line being printed and quotation mark. Indent the next line, add an opening quotation mark, and continue the string. Python will automatically combine all of the strings it finds inside the parentheses. To print the toppings, we write a for loop on line 10. To access the list of toppings, we use the key 'toppings' , and Python grabs the list of toppings from the dictionary. The following output summarizes the pizza that we plan to build: You ordered a thick-crust pizza with the following toppings: mushrooms extra cheese You can nest a list inside a dictionary any time you want more than one value to be associated with a single key in a dictionary. In the earlier example of favorite programming languages, if we were to store each person's responses in a list, people could choose more than one favorite language. When we loop through the dictionary, the value associated with each person would be a list of languages rather than a single language. Inside the dictionary's for loop, we use another for loop to run through the list of languages associated with each person: 1 2 3 4 5 6 7 8 9 10 11 favorite_languages = { 'jen' : [ 'python' , 'ruby' ], 'sarah' : [ 'c' ], 'edward' : [ 'ruby' , 'go' ], 'phil' : [ 'python' , 'haskell' ], } for name , languages in favorite_languages . items (): print ( f \" \\n { name . title () } 's favorite languages are:\" ) for language in languages : print ( f \" \\t { language . title () } \" ) As you can see on line 1, the value associated with each name is now a list. Notice that some people have one favorite language and others have multiple favorites. When we loop through the dictionary on line 8, we use the variable name languages to hold each value from the dictionary, because we know that each value will be a list. Inside the main dictionary loop, we use another for loop (line 10) to run through each persons list of favorite languages. Now each person can list as many favorite languages as they like: Jen's favorite languages are: Python Ruby Sarah's favorite languages are: C Edward's favorite languages are: Ruby Go Phil's favorite languages are: Python Haskell To refine this program even further, you can ad an if statement at the beginning of the dictionary's for loop to see whether each person has more than one favorite language by examining the value of len ( languages ) . If a person has more than one favoriem the output would stay the same. If the person has only one favorite language, you could change the wording to reflect that. For example, you could say \"Sarah's favorite language is C.\" A Dictionary in a Dictionary You can nest a dictionary inside another dictionary, b ut your code can get complicated quickly when you do. For example, if you have several users for a website, each with a unique username, you can use the usernames as the keys in a dictionary. You can then store information about each user by using a dictionary as the value associated with their username. In the following listing, we store three pieces of information about each user: their first name, last name, and location. We'll access this information by looping through the usernames and the dictionary of information associated with each username: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 users = { 'aeinstein' : { 'first' : 'albert' , 'last' : 'einstein' , 'location' : 'princeton' , }, 'mcurie' : { 'first' : 'marie' , 'last' : 'curie' , 'location' : 'paris' , }, } for username , user_info in users . items (): print ( f \" \\n Username: { username } \" ) full_name = f \" { user_info [ 'first' ] } { user_info [ 'last' ] } \" location = user_info [ 'location' ] print ( f \" \\t Full name: { full_name . title () } \" ) print ( f \" \\t Location: { location . title () } \" ) We first define a dictionary called users with two keys: one each for the usernames 'aeinstein' and 'mcurie' . The value associated with each key is a dictionary that includes each user's first name, last name, and location. On line 14 we loop through the users dictionary. Python assigns each key to the variable username , and the dictionary associated with each username is assigned to the variable user_info . Once inside the main dictionary loop, we print the user-name at line 15. On line 16 we start accessing the inner dictionary. The variable user_info , which contains the dictionary of user information, has three keys: 'first' , 'last' , and 'location' . We use each key to generate a neatly formated full name and location for each person, and then print a summary of what we know about each user: Username: aeinstein Full name: Albert Einstein Location: Princeton Username: mcurie Full name: Marie Curie Location: Paris Notice that the structure of each user's dictionary is identical. Although not required by Python, this structure makes nested dictionaries easier to work with. If each user's dictionary had different keys, the code inside the for loop would be more complicated.","title":"Dictionaries"},{"location":"py-dictionaries/#dictionaries","text":"Understanding dictionaries allows you to model a variety of real-world objects more accurately. For example, we could create a dictionary representing a person and then store as much information as we want about that person. You can store their name, location, age, profession, and any other aspect of a person you can describe. We can store any two kinds of information that can be matched up, such as a list of words and their meanings, a list of people's names and their favorite numbers, a list of mountains and their elevations, etc.","title":"Dictionaries"},{"location":"py-dictionaries/#a-simple-dictionary","text":"Consider a game featuring aliens that can have different colors and point values. This simple dictionary stores information about a particular alien: 1 2 3 4 alien_0 = { 'color' : 'green' , 'points' : 5 } print ( alien_0 [ 'color' ]) print ( alien_0 [ 'points' ]) The dictionary alien_0 stores the alien's color and point value. The last two lines access and display that information, as shown here: green 5 As with most new programming concepts, using dictionaries takes practice. Once you've worked with dictionaries for a bit, you'll soon see how effectively they can model real-world situations.","title":"A Simple Dictionary"},{"location":"py-dictionaries/#working-with-dictionaries","text":"A dictionary in Python is a collection of key-value pairs . Each key is connected to a value, and you can use a key to access the value associated with that key. A key's value can be a number, a string, a list, or even another dictionary. In fact, you can use any object that you can create in Python as a value in a dictionary. In Python, a dictionary is wrapped in braces, { }, with a series of key-value pairs inside the braces, as shown in the earlier example: alien_0 = { 'color' : 'green' , 'points' : 5 } A key-value pair is a set of values associated with each other. When you provide a key, Python returns the value associated with that key. Every key is connected to its value by a colon, and individual key-value pairs are separated by commas. You can store as many key-value pairs as you want in a dictionary. The simplest dictionary has exactly one key-value pair, as shown in this modified version of the alien_0 dictionary: alien_0 = { 'color' : 'green' } This dictionary stores one piece of information about alien_0 , namely the alien's color. The string 'color' is a key in this dictionary, and its associated value is 'green' .","title":"Working with Dictionaries"},{"location":"py-dictionaries/#accessing-values-in-a-dictionary","text":"To get the value associated with a key, give the name of the dictionary and then place the key inside a set of square brackets, as shown here: 1 2 alien_0 = { 'color' : 'green' } print ( alien_0 [ 'color' ]) This returns the value associated with the key 'color' from the dictionary alien_0 : green You can have an ulimited number of key-value pairs in a dictionary. For example, here's the original alien_0 dictionary with two key-value pairs: alien_0 = { 'color' : 'green' , 'points' : 5 } Now you can access either the color or the point value of alien_0 . If a player shoots down this alien, you can look up how many points they should earn using code like this: 1 2 3 4 alien_0 = { 'color' : 'green' , 'points' : 5 } new_points = alien_0 [ 'points' ] print ( f \"You just earned { new_points } points!\" ) Once the dictionary has been defined, the code on line 3 pulls the value associated with the key 'points' from the dictionary. This value is then assigned to the variable 'new_points' . The code on line 4 then prints a statement about how many points the player just earned.","title":"Accessing Values in a Dictionary"},{"location":"py-dictionaries/#adding-new-key-value-pairs","text":"Dictionaries are dynamic structures, and you can add new key-value pairs to a dictionary at any time. For example, to add a new key-value pair, you would give the name of the dictionary followed by the new key in square brackets along with the new value. Let's add two new pieces to the alien_0 dictionary: the alien's x- and y- coordinates, which will help us display the alien in a particular position on the screen. Let's place the alien on the left edge of the screen, 25 pixels down from the top. Because screen coordinates usually start at the upper-left corner of the screen, we'll place the alien on the left edge of the screen by setting the x-coordinate to 0 and 25 pixels from the top by setting the y-coordinate to positive 25: 1 2 3 4 5 6 alien_0 = { 'color' : 'green' , 'points' : '5' } print ( alien_0 ) alien_0 [ 'x_position' ] = 0 alien_0 [ 'y_position' ] = 25 print ( alien_0 ) We start by defining the same dictionary that we have been working with. We then print this dictionary, displaying a snapshot of its information. On line 4, we add a new key-value pair to the dictionary: key 'x_position' and a value of 0 . We do the same for key 'y_position' on the next line. Finally, when we print the modified dictionary, we see the two additional key-value pairs: {'color': 'green', 'points': '5'} {'color': 'green', 'points': '5', 'x_position': 0, 'y_position': 25} The final version of the dictionary contains four key-value pairs.","title":"Adding New Key-Value Pairs"},{"location":"py-dictionaries/#starting-with-an-empty-dictionary","text":"It's sometimes convenient, or even necessary, to start with an empty dictionary and then add each new item to it. To start filling an empty dictionary, define a dictionary with an empty set of braces and then add each key-value pair on its own line. For example, here's how to build the alien_0 dictionary using this approach: 1 2 3 4 5 6 alien_0 = {} alien_0 [ 'color' ] = 'green' alien_0 [ 'points' ] = '5' print ( alien_0 ) Here we define an empty alien_0 dictionary, and then add color and point values to it. The result is the dictionary we have been usinging in previous examples: {'color': 'green', 'points': '5'} Typically, you'll use empty dictionaries when storing user-supplied data in a dictionary or when you write code that generates a large number of key-value pairs automatically.","title":"Starting with an Empty Dictionary"},{"location":"py-dictionaries/#modifying-values-ina-dictionary","text":"To modify a value in a dictionary, give the name of the dictionary with the key in square brackets and then the new value you want associated with that key. For example, consider an alien that changes from green to yellow as a game progresses: 1 2 3 4 5 alien_0 = { 'color' : 'green' } print ( f \"The alien is { alien_0 [ 'color' ] } .\" ) alien_0 [ 'color' ] = 'yellow' print ( f \"The alien is now { alien_0 [ 'color' ] } .\" ) We first define a dictionary for alien_0 that contains only the aliens color; then we change the value associated with the key 'color' to 'yellow' . The output shows that the alien has indeed changed from green to yellow: The alien is green. The alien is now yellow. For a more interesting example, let's track the position of an alien that can move at different speeds. We'll sotre a value representing the alien's current speed and then use it to determine how far to the right the alien should move: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 alien_0 = { 'x_position' : 0 , 'y_position' : 25 , 'speed' : 'medium' } print ( f \"Original position: { alien_0 [ 'x_position' ] } \" ) # Move the alien to the right. # Determine how far to move the alien based on its current speed. if alien_0 [ 'speed' ] == 'slow' : x_increment = 1 elif alien_0 [ 'speed' ] == 'medium' : x_increment = 2 else : # This must be a fast alien. x_increment = 3 # The new position is the old position plus the increment. alien_0 [ 'x_position' ] = alien_0 [ 'x_position' ] + x_increment print ( f \"New position: { alien_0 [ 'x_position' ] } \" ) We start by defining an alien with an initial x and y position, and a speed of 'medium' . We also print the original value of x_position to see how far the alien moves to the right. On line 5, an if - elif - else chain determins how far the alien should move to the right and assigns this value to the variable x_increment . If the alien's speed is 'slow' , it moves one unit, if it is 'medium' , it moves two, and if it is 'fast' , it moves three. Once the increment has been calculated, it is added to the value of x_position on line 13 and the result is stored in the dictionary's x_position . Because this is a medium-speed alien, its position shifts two units to the right: Original position: 0 New position: 2 This technique is pretty cool: by changing one value in the alien's dictionary, you can change the overall behavior of the alien. For example, to turn this medium-speed alien into a fast alien, you would add the line: alien_0 [ 'speed' ] = 'fast' The if-elif-else block would then assign a larger value to x_increment the next time the code runs.","title":"Modifying Values ina  Dictionary"},{"location":"py-dictionaries/#removing-key-value-pairs","text":"When you no longer need a piece of information that is stored ina dictionary, you can you the del statement to completely remove a key-value pair. All del needs is the name of the dictionary and the key that you want to remove. For example, let's remove the key 'points' from the alien_0 dictionary along with its value: 1 2 3 4 5 alien_0 = { 'color' : 'green' , 'points' : 5 } print ( alien_0 ) del alien_0 [ 'points' ] print ( alien_0 ) The code on line 4 tells Python to delete the key 'points' from the dictionary alien_0 and to remove the value associated with that key as well. The output shows that the key 'points' and its value of 5 are deleted from the dictionary, and the rest is unaffected: {'color': 'green', 'points': 5} {'color': 'green'}","title":"Removing Key-Value Pairs"},{"location":"py-dictionaries/#a-dictionary-of-similar-objects","text":"The previous example involved storing different kinds of information about one object, an alien in a game. You can also use a dictionary to store one kind of information about many objects. For example, a dictionary of a group of people's favorite programming language. A dictionary for this could look like: 1 2 3 4 5 6 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } As you can see, we've broken a larger dictionary into several lines (mainly for better readability). Each key is the name of a person and each value is their favorite language. When you know you'll need more than one line to define a dictionary, press ENTER after the opening brace. Then indent the next line one tab, and write your first key-value pair, followed by a comma. Once you have finished defining the dictionary, add a closing brace on a new line after the last key-value pair and indent it one level so it aligns with the keys in the dictionary. It's good practice to include a comma after the last key-value pair, just in case you want to add more in the future. To use this dictionary, given the name of a person, you can easily look up their favorite language: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } language = favorite_languages [ 'sarah' ] . title () print ( f \"Sarah's favorite langugage is { language } .\" ) To see which language Sarah chose, we ask for the value at: favorite_languages [ 'sarah' ] We use this syntax to pull Sarah's favorite language from the dictionary (line 8) and assign it to the variable language . Creating a new variable here makes for a much cleaner print () call. The output shows Sarah's favorite Language: Sarah's favorite langugage is C.","title":"A Dictionary of Similar Objects"},{"location":"py-dictionaries/#using-get-to-access-values","text":"Using keys in square brackets to retrieve the value you're interested in from a dictionary might cause one potential problem: if the key you ask for doesn't exist, you'll get an error. Let's see what happens when you ask for the point value of an alien that doesn't have a point value set: 1 2 alien_0 = { 'color' : 'green' , 'speed' : 'slow' } print ( alien_0 [ 'points' ]) This results in a traceback, showing a KeyError: KeyError Traceback (most recent call last) <ipython-input-9-3914d637e9f3> in <module> 1 alien_0 = {'color': 'green', 'speed': 'slow'} ----> 2 print(alien_0['points']) KeyError: 'points' For dictionaries, we can use the get () method to set a default value that will be returned if the requested key doesn't exist. The get () method requires a key as a first argument. As a second optional argument, you can pass the value to be returned if the key doesn't exist: 1 2 3 4 alien_0 = { 'color' : 'green' , 'speed' : 'slow' } point_value = alien_0 . get ( 'points' , 'No point value assigned.' ) print ( point_value ) If the key 'points' exists in the dictionary, you'll get corresponding value. If it doesn't, you get the default value. In this case, points doesn't exist, and we get a clean message instead of an error: No point value assigned. If there's a chance the key you're asking for might not exist, consider using the get () method instead of the square bracket notation.","title":"Using get() to Access Values"},{"location":"py-dictionaries/#looping-through-a-dictionary","text":"A single Python dictionary can contain just a few key-value pairs or millions of pairs. Because a dictionary can contain large amounts of data, Python lets you loop through a dictionary. Dictionaries can be used to store information in a variety of ways; therefore, several different ways exist to loop through them. You can loop through all of a dictionary's key-value pairs, through its keys, or its values.","title":"Looping Through a Dictionary"},{"location":"py-dictionaries/#looping-through-all-key-value-pairs","text":"Before we explore the different approaches to looping, let's consider a new dictionary designed to store information about a user on website. The following dictionary would store one person's username, first name, and last name: 1 2 3 4 5 user_0 = { 'username' : 'efermi' 'first' : 'enrico' 'last' : 'fermi' } You can access any single piece of information about user_0 based on what you've already learned in this chapter. But what if you wanted to see everything stored in this user's dictionary? To do so, you could loop through the dictionary using a for loop. 1 2 3 4 5 6 7 8 9 user_0 = { 'username' : 'efermi' , 'first' : 'enrico' , 'last' : 'fermi' , } for key , value in user_0 . items (): print ( f \" \\n Key: { key } \" ) print ( f \"Value: { value } \" ) As shown on line 7, to write a for loop for a dictionary, you create names for the two variables that will hold the key and value in each key-value pair. You can choose any names you want for these two variables. This code would work just as well if you had used abbreviated for the variable names, like this: for k , v in user_0 . items () The second half of the for statement on line 7 includes the name of the dictionary followed by the method items() , which returns a list of key-value pairs. The for loop then assigns each of these pairs to the two vairbales provided. In the preceding example, we use the variables to print each key (line 8), followed by the associated value (line 9). The \"\\n\" in the first print () call ensures that a blank line is inserted bfore each key-value pair in the output: Key: username Value: efermi Key: first Value: enrico Key: last Value: fermi Looping through all key-value pairs works particularly well for dictionaries like the favorite_languages example from above , which stores the same kind of information for many different keys. If you loop through the favorite_languages dictionary, you get the name of each person in the dictionary and their favorite programming language. Because the keys always refer to a person's name and the value is always language, we'll use the variables name and language in the loop, instead of key and value . This will make it easier to follow what's happening inside the loop: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name , language in favorite_languages . items (): print ( f \" { name . title () } 's favorite language is { language . title () } !\" ) The code on line 8 tells Python to loop through each key-value pair in the dictionary. As it works through each pair the key is assigned to the variable name , and the value is assigned to the variable language . These descriptive names make it much easier to see what the print () call on line 9 is doing. Now, in just a few lines of code, we can display all the information from the poll: Jen's favorite language is Python! Sarah's favorite language is C! Edward's favorite language is Ruby! Phil's favorite language is Python! This type of looping would work just as well if our dictionary stored the results from polling a thousand or even a million people.","title":"Looping Through All Key-Value Pairs"},{"location":"py-dictionaries/#looping-through-all-the-keys-in-a-dictionary","text":"The keys() method is useful when you don't need to work with all of the values in a dictionary. Let's loop through the favorite_languages dictionary and print the names of everyone who answered: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name in favorite_languages . keys (): print ( name . title ()) The code on line 8 tells Python to pull all the keys from the dictionary favorite_languages and assign them one at a time to the variable name . The output shows the names of everyone who answered: Jen Sarah Edward Phil Looping through the keys is actually the default behavior when looping through a dictionary, so this code would have exactly the same output if you wrote: for name in favorite_languages : rather than: for name in favorite_languages . keys (): You can choose to use the keys() method explicitly if it makes your code easier to read, or you can omit it if you wish. You can access the value associated with any key you care about inside the loop by using the current key. Let's print a message to a couple of friends about the languages they chose. We'll loop through the names in the dictionary as we did previously, but when the name matches on of our friends, we'll display a message about their favorite language: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } friends = [ 'phil' , 'sarah' ] for name in favorite_languages . keys (): print ( f \"Hi, { name . title () } .\" ) if name in friends : language = favorite_languages [ name ] . title () print ( f \" \\t { name . title () } , I see you love { language } !\" ) On line 8 we make a list of friends that we want to print a message to. Inside the loop, we print each person's name. Then on line 12 we check whether the name we're working with is in the list friends . If it is, we determine the person's favorite language using the name of the dictionary and the current value of name as the key (line 13). We then print a special greeting, including a reference to their language of choice. Everyone's name is printed, but our friends receive a special message: Hi, Jen. Hi, Sarah. Sarah, I see you love C! Hi, Edward. Hi, Phil. Phil, I see you love Python! You can also use the keys() method to find out if a particular person was polled. This time, let's find out if Erin took the poll: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } if 'erin' not in favorite_languages . keys (): print ( \"Erin, please take our poll!\" ) The keys() method isn't just for looping: it actually returns a list of all the keys, and the code on line 8 simply checks if 'erin' is in the list. Because she is not, a message is printed inviting her to take the poll.","title":"Looping Through All The Keys in a Dictionary"},{"location":"py-dictionaries/#looping-through-a-dictionarys-keys-in-a-particular-order","text":"Starting in Python 3.7, looping through a dictionary returns the items in the same order they were inserted. Sometimes, though, you'll want to loop through a dictionary in a different order. One way to do this is to sort the keys as they're retunred in the for loop. You can use the sorted () function to get a copy of the keys in order: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name in sorted ( favorite_languages . keys ()): print ( f \" { name . title () } , thank you for taking the poll.\" ) This for statement is like other for statements except that we've wrapped the sorted () function around the dictionary . keys () method. This tells Python to list all keys in the dictionary and sort that list before looping through it. The output shows everyone who took the poll, with the names displayed in order: Edward, thank you for taking the poll. Jen, thank you for taking the poll. Phil, thank you for taking the poll. Sarah, thank you for taking the poll.","title":"Looping Through a Dictionary's Keys in a Particular Order"},{"location":"py-dictionaries/#looping-through-all-values-in-a-dictionary","text":"If you are primarily interested in the values that a dictionary contains, you can use the values () method to return a list of values without any keys. For example, say we simply want a list of all languages chosen in our programming language poll without the name of the person who chose each language: 1 2 3 4 5 6 7 8 9 10 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } print ( \"The following languages have been mentioned:\" ) for language in favorite_languages . values (): print ( language . title ()) The for statement here pulls each value from the dictionary and assigns it to the variable language . When these values are printed, we get a list of all chosen languages: The following languages have been mentioned: Python C Ruby Python This approach pulls all the values from the dictionary without checking for repeats. That might work fine with a small number of values, but in a poll with a large number of respondents, this would result in a very repetitive list. To see each language chosen without repitionm we can use a set. A set is a collection in which each item must be unique. We can use the following for loop in place of the one used above: for language in set ( favorite_languages . values ()): When you wrap set () around a list that contains duplicate items, Python identifies the unique items in the list and build a set from those items. The result is a nonrepetitive list of languages that have been menetioned: The following languages have been mentioned: C Ruby Python","title":"Looping Through All Values in a Dictionary"},{"location":"py-dictionaries/#nesting","text":"Sometimes you'll want to store multiple dictionaries in a list, or a list of items as a value in a dictionary. This is called nesting . You can nest dictionaries inside a list, a list of items inside a dictionary, or even a dictionary inside another dictionary. Nesting is a powerful feature, as the following examples will demonstrate.","title":"Nesting"},{"location":"py-dictionaries/#a-list-of-dictionaries","text":"The alien_0 dictionary contains a variety of information about one alien, but it has no room to store information about a second alien, much less a full screen of aliens. How can you managae a fleet of aliens? One way is to make a list of aliens in which each alien is a dictionary of information about that alien. For example, the following code builds a list of three aliens: 1 2 3 4 5 6 7 8 alien_0 = { 'color' : 'green' , 'points' : 5 } alien_1 = { 'color' : 'yellow' , 'points' : 10 } alien_2 = { 'color' : 'red' , 'points' : 15 } aliens = [ alien_0 , alien_1 , alien_2 ] for alien in aliens : print ( alien ) We first create three dictionaries, each representing a different alien. On line 5 we store each of these dictionaries in a list called aliens . Finally, we loop through the list and print out each alien: {'color': 'green', 'points': 5} {'color': 'yellow', 'points': 10} {'color': 'red', 'points': 15} A more realistic example would involve more than three alies with code that automatically generates each alien. In the following example we use range () to create a fleet of 30 aliens: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Make an empty list for storing aliens aliens = [] # Make 30 green aliens. for alien_number in range ( 30 ): new_alien = { 'color' : 'green' , 'points' : 5 , 'speed' : 'slow' } aliens . append ( new_alien ) # Show the first 5 aliens. for alien in aliens [: 5 ]: print ( alien ) print ( \"...\" ) # Show how many aliens have been created. print ( f \"Total number of aliens: { len ( aliens ) } \" ) This example befins with an empty list to hold all of the aliens that will created. At line 5 range () returns a series of numbers, which just tells Python how many times we want the loop to repeat. Each time the loop runs we create a new alien (line 6) and then append each new alien to the list aliens (line 7). On line 10 we us a slice to print the first five aliens, and then on line 15 we print the length of the list to prove we've actually generated the full fleet of 30 aliens: {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} ... Total number of aliens: 30 These aliens all have the same characteristics, but Python considers each one a separate object, which allows us to modify each alien individually. How might you work with a group of aliens like this? Imagine that one aspect of a game has some aliens changing color and moving faster as the game progress. When it's time to change colors, we can use a for loop and an if statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Make an empty list for storing aliens aliens = [] # Make 30 green aliens. for alien_number in range ( 30 ): new_alien = { 'color' : 'green' , 'points' : 5 , 'speed' : 'slow' } aliens . append ( new_alien ) for alien in aliens [: 3 ]: if alien [ 'color' ] == 'green' : alien [ 'color' ] = 'yellow' alien [ 'speed' ] = 'medium' alien [ 'points' ] = '10' # Show the first 5 aliens. for alien in aliens [: 5 ]: print ( alien ) print ( \"...\" ) Because we want to modify the first three aliens, we loop through a slice that includes only the first three aliens. All of the aliens are green now but that won't always be the case, so we write an if statement to make sure we're only modifying green aliens. If the alien is green, we change the color to 'yellow' , the speed to 'medium' , and the point value to 10 , as shown in the following output: {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} ... You could expand this loop by adding an elif block that turns yellow aliens into red, fast-moving ones worth 15 points each. Without showing the entire program again, that loop would look like this: 1 2 3 4 5 6 7 8 9 for alien in aliens [: 3 ]: if alien [ 'color' ] == 'green' : alien [ 'color' ] = 'yellow' alien [ 'speed' ] = 'medium' alien [ 'points' ] = '10' elif alien [ 'color' ] == 'yellow' : alien [ 'color' ] = 'red' alien [ 'speed' ] = 'fast' alien [ 'points' ] = 15 It's common to store a number of dictionaries in a list when each dictionary contains many kinds of information about one subject. For example, you might create a dictionary for each user on a website and store the individual dictionaries in a list called users . All of the dictionaries in the list should have an identical structure so you can loop through the list and work with each dictionary object in the same way.","title":"A List of Dictionaries"},{"location":"py-dictionaries/#a-list-in-a-dictionary","text":"Rather than putting a dictionary inside a list, it's sometimes useful to put a list inside a dictionary. For example, consider how you might describe a pizza that someone is ordering. If you were to use only a list, all you could really store is a list of the pizza's toppings. With a dictionary, a list of toppings can be just one aspect of the pizza you're describing. In the following example, two kinds of information are stored for each pizza: a type of crust and a list of toppings. The list of toppings is a value associated with the key 'toppings' . To use the items in the list, we give the name of the dictionary and the key 'toppings' , as we would any value in the dictionary. Instead of returning a single value, we get a list of toppings: 1 2 3 4 5 6 7 8 9 10 11 12 # Store information about a pizza being ordered. pizza = { 'crust' : 'thick' , 'toppings' : [ 'mushrooms' , 'extra cheese' ], } # Summarize the order. print ( f \"You ordered a { pizza [ 'crust' ] } -crust pizza \" \"with the following toppings:\" ) for topping in pizza [ 'toppings' ]: print ( \" \\t \" + topping ) We begin on line 2 with a dictionary that holds information about a pizza that has been ordered. One key in the dictionary is 'crust' , and the associated value is the string 'thick' . The next key, 'toppings' , has a list as its value that stores all the requested toppings. On line 8 we summarize the order before building the pizza. When you need to break up a long ling in a print () call, choose an appropriate point at which to break the line being printed and quotation mark. Indent the next line, add an opening quotation mark, and continue the string. Python will automatically combine all of the strings it finds inside the parentheses. To print the toppings, we write a for loop on line 10. To access the list of toppings, we use the key 'toppings' , and Python grabs the list of toppings from the dictionary. The following output summarizes the pizza that we plan to build: You ordered a thick-crust pizza with the following toppings: mushrooms extra cheese You can nest a list inside a dictionary any time you want more than one value to be associated with a single key in a dictionary. In the earlier example of favorite programming languages, if we were to store each person's responses in a list, people could choose more than one favorite language. When we loop through the dictionary, the value associated with each person would be a list of languages rather than a single language. Inside the dictionary's for loop, we use another for loop to run through the list of languages associated with each person: 1 2 3 4 5 6 7 8 9 10 11 favorite_languages = { 'jen' : [ 'python' , 'ruby' ], 'sarah' : [ 'c' ], 'edward' : [ 'ruby' , 'go' ], 'phil' : [ 'python' , 'haskell' ], } for name , languages in favorite_languages . items (): print ( f \" \\n { name . title () } 's favorite languages are:\" ) for language in languages : print ( f \" \\t { language . title () } \" ) As you can see on line 1, the value associated with each name is now a list. Notice that some people have one favorite language and others have multiple favorites. When we loop through the dictionary on line 8, we use the variable name languages to hold each value from the dictionary, because we know that each value will be a list. Inside the main dictionary loop, we use another for loop (line 10) to run through each persons list of favorite languages. Now each person can list as many favorite languages as they like: Jen's favorite languages are: Python Ruby Sarah's favorite languages are: C Edward's favorite languages are: Ruby Go Phil's favorite languages are: Python Haskell To refine this program even further, you can ad an if statement at the beginning of the dictionary's for loop to see whether each person has more than one favorite language by examining the value of len ( languages ) . If a person has more than one favoriem the output would stay the same. If the person has only one favorite language, you could change the wording to reflect that. For example, you could say \"Sarah's favorite language is C.\"","title":"A List in a Dictionary"},{"location":"py-dictionaries/#a-dictionary-in-a-dictionary","text":"You can nest a dictionary inside another dictionary, b ut your code can get complicated quickly when you do. For example, if you have several users for a website, each with a unique username, you can use the usernames as the keys in a dictionary. You can then store information about each user by using a dictionary as the value associated with their username. In the following listing, we store three pieces of information about each user: their first name, last name, and location. We'll access this information by looping through the usernames and the dictionary of information associated with each username: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 users = { 'aeinstein' : { 'first' : 'albert' , 'last' : 'einstein' , 'location' : 'princeton' , }, 'mcurie' : { 'first' : 'marie' , 'last' : 'curie' , 'location' : 'paris' , }, } for username , user_info in users . items (): print ( f \" \\n Username: { username } \" ) full_name = f \" { user_info [ 'first' ] } { user_info [ 'last' ] } \" location = user_info [ 'location' ] print ( f \" \\t Full name: { full_name . title () } \" ) print ( f \" \\t Location: { location . title () } \" ) We first define a dictionary called users with two keys: one each for the usernames 'aeinstein' and 'mcurie' . The value associated with each key is a dictionary that includes each user's first name, last name, and location. On line 14 we loop through the users dictionary. Python assigns each key to the variable username , and the dictionary associated with each username is assigned to the variable user_info . Once inside the main dictionary loop, we print the user-name at line 15. On line 16 we start accessing the inner dictionary. The variable user_info , which contains the dictionary of user information, has three keys: 'first' , 'last' , and 'location' . We use each key to generate a neatly formated full name and location for each person, and then print a summary of what we know about each user: Username: aeinstein Full name: Albert Einstein Location: Princeton Username: mcurie Full name: Marie Curie Location: Paris Notice that the structure of each user's dictionary is identical. Although not required by Python, this structure makes nested dictionaries easier to work with. If each user's dictionary had different keys, the code inside the for loop would be more complicated.","title":"A Dictionary in a Dictionary"},{"location":"py-functions/","text":"Functions On this page we'll learn how to write functions , which are named blocks of code that are designed to do one specific job. When you want to perform a particular task that you've defined in a function, you call the function responsible for it. If you need to perform that task multiple times throughout your program, you don't need to type all the code for the same task again and again; you just call the function dedicated to handling that task, and the call tells Python to run the code inside the function. You'll find that using functions makes your programs easier to write, read, test, and fix. We will also learn ways to pass information to functions. We will learn how to write certain functions whose primary job is to display information and other functions desinged to process data and return a value or a set of values. Finally, we will cover how to store functions in separate files called modules to help organize our main program files. Defining a Function Here is a simple function named greet_user() that prints a greeting: 1 2 3 4 def greet_user (): \"\"\"Display a simple greeting.\"\"\" print ( \"Hello!\" ) greet_user () This example shows the simplest structure of a function. The code on line 1 uses the keyword def to inform Python that you're defining a function. This is the function definition , which tells Python the name of the function and, if applicable, what kind of information the function needs to do its job. The parentheses hold that information. In this case, the name of the function is greet_user() , and it needs no information to do its job, so its parentheses are empty. (Even so, the parentheses are required.) Finally, the definition ends in a colon. An indented lines that follow def greet_user (): make up the body of the function. The text on line 2 is a comment called a docstring , which describes what the function does. Docstrings are enclosed in triple quotes, which Python looks for when it generates documentaion for the functions in your programs. The line print ( \"Hello!\" ) on line 3 is the only line of actual code in the body of this function, so greet_user() has just one job: print ( \"Hello!\" ) . When you want to use this function, you call it. A function call tells Python to execute the code in the function. To call a function, you write the name of the function, followed by any necessary information in parentheses, as shown on line 4. Because no information is needed here, calling our function is as simple as entering greet_user() . As expected, it prints Hello! . Passing Information to a Function Modified slightly, the function greet_user() can not only tell the user Hello! but also greet them by name. For the function to do this, you enter username in the parentheses of the function's definition at def greet_user () . By adding username here you allow the function to accept any value of username you specify. The function now expects you to provide a value for username each time you call it. When you call greet_user() , you can pass it a name, such as 'jesse' , inside the parentheses: 1 2 3 4 5 def greet_user ( username ): \"\"\"Display a simple greeting.\"\"\" print ( f \"Hello, { username . title () } !\" ) greet_user ( 'jesse' ) Entering greet_user ( 'jesse' ) calls greet_user () and give the function the information it needs to execute the print () call. The function acceptsthe name you passed it and displays the greeting for that name: Hello, Jesse! Arguments and Parameters In the preceding greet_user() function, we defined greet_user() to require a value for the variable username . Once we called the function and gave it the information (a person's name), it printed the right greeting. The variable username in the definition of greet_user() is an example of a parameter , a piece of information the function needs to do its job. The value 'jesse' is reet_user ( 'jesse' ) is an example of an argument . An argument is a piece of information that's passed from a function call to a function. When we call the function, we place the value we want the function to work with in the parenthese. In this case the argument 'jesse' was passed to the function greet_user() , and the value was assigned to the parameter username . Passing Arguments Because a function definition can have multiple parameters, a function call may need multiple arguments. You can pass arguments to your functions in a number of ways. You can use positional arguments , which need to be in the same order as the parameters were written; keyword arguements , where each argument consists of a variable name and a value; and lists and dictionaries of values. Positional Arguments When you call a function, Python must match each argument in the function call with a parameter in the function definition. The simplest way to do this is baased on the order of the arguments provided. Values matched up this way are called positional arguments . To see how this works, consider a function that displays information about pets. The function tells us what kind of animal each pet is and the pet's name, as shown here: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'hamster' , 'harry' ) The definition shows that this function needs a type of animal and the animal's name (line 1). When we call describe_pet() , we need to provide an animal type and a name, in that order. For example, in the function call, the argument 'hamster' is assigned to the parameter animal_type and the argument 'harry' is assigned to the parameter pet_name (line 6). In the function body, these two parameters are used to display information about the pet being described. The output describes a hamster named Harry: I have a hamster. My hamster's name is Harry. Multiple Function Calls You can call a function as many times as needed. Describing a second, different pet requires just one more call to describe_pet() : 1 2 3 4 5 6 7 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'hamster' , 'harry' ) describe_pet ( 'dog' , 'willie' ) The only change above was to line 7. In the second function call, we pass describe_pet() the arguments 'dog' and 'willie' . As with the previous set of arguments we used, Python matches 'dog' with the parameter animal_type and 'willie' with the parameter pet_name . As before, the function does its job, but this time it also prints the values for a Dog named Willie: I have a hamster. My hamster's name is Harry. I have a dog. My dog's name is Willie. Calling a function multiple times is a very efficient way to work. The code describing a pet is written once in the function. Then, anytime you want to describe a new pet, you call the function with the new pet's information. Even if the code for describing a pet were to expand to ten lines, you could still describe a new pet in just one line by calling the function again. You can use as many positional arguments as you need in your functions. Python works through the arguments you provide when calling the function and matches each one with the corresponding parameter in the function's definition. Order Matters in Positional Arguments You can get unexpected results if you mix up the order of the arguments in a function call when using positional arguments: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'harry' , 'hamster' ) In the above function, we list the name first and the type of animal second. Because the argument 'harry' is listed first this time, that value is assigned to the parameter animal_type . Likewise, 'hamster' is assigned to pet_name . Now we have a \"harry\" named \"Hamster\": I have a harry. My harry's name is Hamster. If you get funny results like this, check to make sure the order of the arguments in your function call matches the order of the parameters in the function's definition. Keyword Arguments A keyword argument is a name-value pair that you pass to a function. You directly associate the name of the value within the argument, so when you pass the argument to the function, there's no confusion (you won't end up with a harry named Hamster). Keyword arguments free you from having to worry about correctly ordering your arguments in the function call, and they clarify the role of each value in the function call. Let's rewrite the program from above using keyword arguments to call describe_pet() : 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) The function describe_pet() hasn't changed, but when we call the function, we explicitly tell Python which parameter each argument should be matched with. When Python reads the function call, it knows to assign the argument 'hamster' to the parameter animal_type and the argument 'harry' to pet_name . The output correctly shows that we have a hamster named Harry. The order of keyword arguments doesn't matter because Python knows where each value should go. The following two function calls are equivalent: 1 2 describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) Default Values When writing a function, you can define a default value for each parameter. If an argument for a parameter is proivided in the function call, Python uses the argument value. If not, it uses the parameter's default value. So when you define a default value for a parameter, you can exclude the corresponding argument you'd usually write in the function call. Using default values can simplify your function calls and clarify the ways in which your functions are typically used. For example, if you notice that most of the calls to describe_pet() are being used to describe dogs, you can set the default value of animal_type to 'dog' . Now anyone calling describe_pet() for a dog can omit that information: 1 2 3 4 5 6 def describe_pet ( pet_name , animal_type = 'dog' ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( pet_name = 'willie' ) We changed the definition of describe_pet() to include a default value, 'dog' , for animal_type . Now when the function is called with no animal_type specified, Python knows to use the value 'dog' for this parameter: I have a dog. My dog's name is Willie. Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet's name. Python still interprets this as a positional argument, so if the function is called with just the pet's name, that argument will match up with the first parameter listed in the function's definition. This is the reason the first parameter needs to be pet_name . The simplest way to use this function now is to provide just a dog's name in the function call: describe_pet ( 'willie' ) This function call would have the same output as the previous example. The only argument provided is 'willie' , so it is matched up with the first parameter in the definition, pet_name . Because no argument is provided for animal_type , Python uses the default value 'dog' . To describe an animal other than a dog, you could use a function call like this: describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) Because an explicit argument for animal_type is provoided, Python will ignore the parameter's default value. Note on default values When you use default values, any parameter with a default value needs to be listed after all the parameters that don't have default values. This allows Python to continue interpreting positional arguments correctly. Equivalent Function Calls Because positional arguments, keyword arguments, and default values can all be used together, often you'll have several equivalent ways to call a function. Consider the following definition for describe_pet() with one default value provided: def describe_pet ( pet_name , animal_type = 'dog' ): With this definition, an argument always needs to be provided for pet_name , and this value can be provided using the positional or keyword format. If the animal being described is not a dog, an argument for animal_type mist be included in the call, and this argument can also be specified using the positional or keyword format. All the follwoing calls would work for this function: 1 2 3 4 5 6 7 8 # A dog named Willie. describe_pet ( 'willie' ) describe_pet ( pet_name = 'willie' ) # A hamster named Harry. describe_pet ( 'harry' , 'hamster' ) describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) Each of these function calls would have the same output as the previous examples. It doesn't really matter which calling style you use. As long as your function calls produce the output you want, just use the style you find easiest to understand. Avoiding Argument Errors When you start to use functions, don't be surprides if you encounter errors about unmatched arguments. Unmatched arguments occur when you provide fewer or more arguments than a function needs to do its wor. For example, here's what happens if we try to call describe_pet() with no arguments: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet () Python recognizes that some information is missing from the function call, and the traceback tells us that: TypeError Traceback (most recent call last) File <\"pets.py\">, line 6, in <module> 4 print(f\"My {animal_type}'s name is {pet_name.title()}.\") 5 ----> 6 describe_pet() TypeError: describe_pet() missing 2 required positional arguments: 'animal_type' and 'pet_name' The traceback tells us the location of the problem (line 6), allowing us to look back and see that something went wrong in our function call. Next, the offending function call is written out for us to see. Finally, the traceback tells us the call is missing two arguments and reports the names of the missing arguments. If this function were in a separate file, we could probably rewrite the call correctly without having to open that file and read the function code. Python is helpful in that it reads the function's code for us and tells us the names of the argument we need to provide. This is another motivation for giving your variables and functions descriptive names. If you do, Pythons error messages will be more useful to you and anyone else who might use your code. If you provide too many arguments, you should get a similar traceback that cal help you correctly match your function call to the function definition. Return Values A function doesn't always have to display its output directly. Instead, it can process some data and then reutn a value or set of values. The value the function returns is called a return value . The return statement takes a value from inside a function and sends it back to the line that called the function. Return values allow you to move much of your program's grunt work into functions, which can simplify the body of your program. Returning a Simple Value Let's look at a function that takes a first and last name, and returns a neatly formatted name: 1 2 3 4 5 6 7 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, fully formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'jimi' , 'hendrix' ) print ( musician ) The defintion of get_formatted_name() takes as parameters a first and last name (line 1). The function combines these two names, adds a space between them, and assigns the result to full_name (line 3). The value of full_name is converted to title case, and then returned to the calling line at line 4. When you call a function that returns a value, you need to provide a variable that the return value can be assigned to. In this case, the returned value is assigned to the variable musician on line 6. The output shows a neatly formatted name made up of the parts of a person's name: Jimi Hendrix This might seem like a lot of work to get a neatly formatted name when we could have just written: print ( \"Jimi Hendrix\" ) But when you consider working with a large program that needs to store many first and last names separately, functions like get_formatted_name() become very useful. You store first and last names separately and then call this function whenever you want to display a full name. Making an Argument Optional Sometimes it makes sense to make an argument optional so that people using the function can choose to provide extra information only if they want to. You can use default values to make an argument optional. For example, say we want to exapand get_formatted_name() to handle middle names as well. A first attempt to include middle names might look like this: 1 2 3 4 5 6 7 def get_formatted_name ( first_name , middle_name , last_name ): \"\"\"Return a full name, fully formatted.\"\"\" full_name = f \" { first_name } { middle_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'john' , 'lee' 'hooker' ) print ( musician ) This function works when given a first, middle, and last name. The function takes in all three parts of a name and then builds a string out of them. The function adds spaces where appropriate and converts the full name to title case: John Lee Hooker But middle names aren't always needed, and this function as written would not work if you tried to call it with only a first name and a last name. To make a middle name optional, we can give the middle_name argument an empty default valuye and ignore the argument unless a user provides a value. To make get_formatted_name() work without a middle name, we set the default value of middle_name to an empty string and move it to the end of list of parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 def get_formatted_name ( first_name , last_name , middle_name = '' ): \"\"\"Return a full name, neatly formatted.\"\"\" if middle_name : full_name = f \" { first_name } { middle_name } { last_name } \" else : full_name = f \" { first_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'jimi' , 'hendrix' ) print ( musician ) musician = get_formatted_name ( 'john' , 'hooker' , 'lee' ) print ( musician ) In this example, the name is built from three possible parts. Because there's always a first and last name, these parameters are listed first in the function's definition. The middle name is optional, so it's listed last in the definition, and its default value is an empty string (line 1). In the body of the function, we check to see if a middle name has been provided. Python interprets non-empty strings as True , so if middle_name evaluates to True if a middle name argument is in the function call (line 3). If a middle name is provided, the first, middle, and last names are combined to form a full name. This name is then changed to title case and returned to the function call line where it's assigned to the variable musician and printed. If no middle name is provided, the empty string fails the if test and the else block runs (line 5). The full name is made with just a dirst and last name, and the formatted name is returned to the calling line where it's assigned to musician and printed. Calling this function with a first and last name is straightforward. If we're using a middle name, however, we have to make sure the middle name is the last argument passed so Python will match up the positional arguments correctly (line 12). This modified version of our function works for people with just a first and last name, and it works for people who have a middle name as well: Jimi Hendrix John Lee Hooker Optional values allow functions to handle a wide range of use cases while letting function calls remain as simple as possible. Returning a Dictionary A function can return any kind of value you need it to, including more complicated data structures like lists and dictionaries. For example, the following function takes in parts of a name and returns a dictionary representing a person: 1 2 3 4 5 6 7 def build_person ( first_name , last_name ): \"\"\"Return a dictionary of information about a person.\"\"\" person = { 'first' : first_name , 'last' : last_name } return person musician = build_person ( 'jimi' , 'hendrix' ) print ( musician ) The function build_person() takes in a first and last name, and puts these values into a dictionary (line 3). The value of first_name is stored with the key 'first' , and the value of last_name is stored with the key 'last' . The entire dictionary representing the person is returned at line 4. The return value is printed on the final line with the original two pieces of textual information now stored in a dictionary: {'first': 'jimi', 'last': 'hendrix'} This function takes in a simple textual information and puts it into a more meaningful data structure that lets you work with the information beyond just printing it. The strings 'jimi' and 'hendrix' are now labeled as a first name and last name. You can easily extend this function to accept optional values like a middle name, an age, an occupation, or any other information you want to store about a person. For example, the following change allows you to store a person's age as well: 1 2 3 4 5 6 7 8 9 def build_person ( first_name , last_name , age = None ): \"\"\"Return a dictionary of information about a person.\"\"\" person = { 'first' : first_name , 'last' : last_name } if age : person [ 'age' ] = age return person musician = build_person ( 'jimi' , 'hendrix' , age = 27 ) print ( musician ) We add a new optional parameter age to the function definition and assign the parameter the special value None , which is used when a variable has no specific value assigned to it. You can think of None as a placeholder value. In conditional tests, None evaluates to False . If the function call includes a value fo age , that value is stored in the dictionary. This function always stores a person's name, but it can also be modified to store any other information you want about a person. Using a Function with a while Loop You can use functions with all the Python structures you've learned about so far. For example, let's use the get_formatted_name() function with a while loop to greet users more formally. Here's a first attempt at greeting people using their first and last names: 1 2 3 4 5 6 7 8 9 10 11 12 13 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, neatly formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () # This is an infinite loop! while True : print ( \" \\n Please tell me your name:\" ) f_name = input ( \"First name: \" ) l_name = input ( \"Last name: \" ) formatted_name = get_formatted_name ( f_name , l_name ) print ( f \" \\n Hello, { formatted_name } !\" ) For this example, we use a simple version of get_formatted_name() that doesn't involve middle names. The while loop asks the user to enter their name, and we prompt for their first and last name separately (line 8). But there's one problem with this while loop: We haven't defined a quit condition. Where do you put a quit condition when you ask for a series of input? We want the user to be able to quit as easily as possible, so each prompt should offer a way to quit. The break statement offers a straightforward way to exit the loop at either prompt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, neatly formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () # This is an infinite loop! while True : print ( \" \\n Please tell me your name:\" ) print ( \"(enter 'q' at any time to quit)\" ) f_name = input ( \"First name: \" ) if f_name == 'q' : break l_name = input ( \"Last name: \" ) if l_name == 'q' : break formatted_name = get_formatted_name ( f_name , l_name ) print ( f \" \\n Hello, { formatted_name } !\" ) We add a message that informs the user how to quit, and then we break out of the loop if the user enters the quit value at either prompt. Now the program will continue greeting people until someone enters 'q' for either name: Please tell me your name: (enter 'q' at any time to quit) First name: Nick Last name: Platt Hello, Nick Platt! Please tell me your name: (enter 'q' at any time to quit) First name: q Passing a List You'll often find it useful to pass a list to a function, whether it's a list of names, numbers, or more complex objects, such as dictionaries. When you pass a list to a function, the function gets direct access to the contents of the list. Let's use functions to make working with lists more efficient. Say we have a list of users and want to print a greeting to each. The following example sends a list of names to a function called greet_users() , which greets each person in the list individually: 1 2 3 4 5 6 7 8 def greet_users ( names ): \"\"\"Print a simple greeting to each user in the list.\"\"\" for name in names : msg = f \"Hello, { name . title () } !\" print ( msg ) usernames = [ 'hannah' , 'ty' , 'margot' ] greet_users ( usernames ) We define greet_users() so it expects a list of names, which it assigns to the parameter names . The function loops through the list it receives and prints a greeting to each user. On line 7, we define a list of users and then pass the list usernames to greet_users() in our function call: Hello, Hannah! Hello, Ty! Hello, Margot! This is the output we wanted. Every user sees a personalized greeting, and you can call the function any time you want to greet a specific set of users. Modifying a List in a Function When you pass a list to a function, the function can modify the list. Any changes made to the list inside the function's body are permanent, allowing you to work efficiently even when you're dealing with large amounts of data. Consider a company that creates 3D printed models of designs that users submit. Designs that need to be printed are stored in a list, and after being printed they're moved to a separate list. The following code does this without using functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Start with some designs that need to be printed. unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] # Simulate printing each design, until none are left. # Move each design to completed_models after printing. while unprinted_designs : current_design = unprinted_designs . pop () print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) # Display all completed models. print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) This program starts with a list of designs that need to be printed and an empty list called completed_models that each design will be moved to after it has been printed. As long as designs remain unprinted_designs , the while loop simulates printing each design by removing a design from the end of the list, storing it in current_design , and displaying a message that current design is being printed. It then adds the design to the list of completed models. When the loop is finished running, a list of designs that have been printed is displayed: Printing model: dodecahedron Printing model: robot pendant Printing model: phone case The following models have been printed: dodecahedron robot pendant phone case We can reorganize this code by writing two functions, each of which does one specific job. Most of the code won't change; we're just making it more carefully structured. The first function will handle printing the designs, and the second will summarize the prints that have been made: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def print_models ( unprinted_designs , completed_models ): \"\"\" Simulate printing each design, until none are left. Move each design to completed_models after printing. \"\"\" while unprinted_designs : current_design = unprinted_designs . pop () print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) def show_completed_models ( completed_models ): \"\"\"Show all the models that were printed.\"\"\" print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] print_models ( unprinted_designs , completed_models ) show_completed_models ( completed_models ) On line 1 we define the function print_models() with two parameters: a list of designs that need to be printed and a list of completed models. Given these two lists, the function simulates printing each design by emptying the list of unprinted designs and filling up the list of completed models. On line 10 we define the function show_completed_models() with one parameter: the list of completed models. Given this list, show_completed_models() displays the name of each model that was printed. This program has the same output as the version without functions, but the code is much more organized. The code that does most of the work has been moved to two separate functions, which makes the main part of the program easier to understand. Look at the body of the program to see how much easier it is to understand what this program is doing: 1 2 3 4 5 unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] print_models ( unprinted_designs , completed_models ) show_completed_models ( completed_models ) We set up a list of unprinted designs and an empty list that will hold the completed models. Then, because we've already defined our two functions, all we have to do is call them and pass them the right arguments. We call print_models() and pass it the two lists it needs; as expected, print_models() simulates printing the designs. Then we call show_completed_models() and pass it the list of completed models so it can report the models that have been printed. The descriptive function names allow others to read this code and understand it, even without comments. This program is easier to extend and maintain than the version without functions. If we need to print more designs later on, we can simply call print_models() again. If we realize the printing code needs to be modified, we can change the code once, and our changes will take place everywhere the function is called. This technique is more efficient than having to update code separately in several places in the program. This example also demonstrates the idea that every function should have one specific job. The first function prints each design, and the second displays the completed models. This is more beneficial than using one function to do both jobs. If you're writing a function and notice the function is doing too many different tasks, try to split the code into two functions. Remember that you can always call a function from another function, which can be helpful when splitting a complex task into a series of steps. Preventing a Function from Modifying a List Sometimes you'll want to prevent a function from modifying a list. For example, say that you start with a list of unprinted designs and write a function to move them to a list of completed models, as in the previous example. You may decide that even though you've printed all the designs, you want to keep the original list of unprinted designs for your records. But because you moved all the desing names out of unprinted_designs , the list is now empty, and the empty list is the only version you have; the original is gone. In this case, you can address this issue by passing the function a copy of the list, not the original. Any changes the function makes to the list will affect only the copy, leaving the original list intact. You can send a copy of a list to a function like this: function_name ( list_name [:]) Ths slice notation [:] makes a copy of the list to send to the function. If we didn't want to empty the list of unprinted desings in printing_models.py , we could call print_models() like this: print_models ( unprinted_designs [:], completed_models ) The function print_models() can do its work because it still receives the names of all unprinted designs. But this time it uses a copy of the original unprinted desings list, not the actual unprinted_designs list. The list completed_models will fill up with the names of printed models like it did before, but original list of unprinted designs will be unaffected by the function. Even though you can preserve the contents of a list by passing a copy of it to your functions, you should pass the original list to functions unless you have a specific reason to pass a copy. It's more efficient for a function to work with an existing list to avoid using the time and memory needed to make a separate copy, especially when you're working with large lists. Passing an Arbitrary Number of Arguments Sometimes you won't know ahead of time how many arguments a function needs to accept. Fortunately, Python allows a function to collect an arbitrary number of arguments from the calling statement. For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can't know ahead of time how many toppings a person will want. The function in the following example has one parameter, *toppings , but this parameter collects as many arguments as the calling line provides: 1 2 3 4 5 6 def make_pizza ( * toppings ): \"\"\"Print the list of toppings that have been requested.\"\"\" print ( toppings ) make_pizza ( 'pepperoni' ) make_pizza ( 'mushrooms' , 'green peppers' , 'extra cheese' ) The asterisk ( * ) in the parameter name *toppings tells Python to make an empty tuple called toppings and pack whatever values it receives into this tuple. The print () call in the function body produces output showing that Python can handle a function call with one value and a call with three values. It treats the different calls similarly. Note that Python packs the arguments into a tuple, even if the function receives only one value: ('pepperoni',) ('mushrooms', 'green peppers', 'extra cheese') Now we can replace the print() call with a loop that runs through the list of toppings and describes the pizza being ordered: 1 2 3 4 5 6 7 8 def make_pizza ( * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( \" \\n Making a pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) make_pizza ( 'pepperoni' ) make_pizza ( 'mushrooms' , \"green peppers\" , \"extra cheese\" ) The function responds appropriately, whether it receives one value or three values: Making a pizza with the following toppings: - pepperoni Making a pizza with the following toppings: - mushrooms - green peppers - extra cheese This syntax works no matter how many arguments the function receives. Mixing Positional and Arbitrary Arguments If you want a function to accept several different kinds of arguments, the parameter that accepts an arbitrary number of arguments must be placed last in the function definition. Python matches positional and keyword arguments first and then collects any remaining arguments in the final parameter. For example, if the function needs to take in a size for the pizza, that parameter must come before the parameter *toppings : 1 2 3 4 5 6 7 8 def make_pizza ( size , * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( f \" \\n Making a { size } -inch pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) In the function definition, Python assigns the first value it reveives to the parameter size . All other values that come after are stored in the tuple toppings . The function calls include an argument for the size first, followed by as many toppings as needed. Now each pizza has a size and a number of toppings, and each piece of information is printed in the proper place, showing size first and toppings after: Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese Using Arbitrary Keyword Arguments Sometimes you'll want to accept an arbitrary number of arguments, but you won't know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you'll get information about a user, but you're not sure what kind of information you will receive. The function build_profile() in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well: 1 2 3 4 5 6 7 8 def build_profile ( first , last , ** user_info ): \"\"\"Build a dictionary containing everything we know about a user.\"\"\" user_info [ 'first_name' ] = first user_info [ 'last_name' ] = last return user_info user_profile = build_profile ( 'albert' , 'einstein' , location = 'princeton' , field = 'physics' ) print ( user_profile ) The definition of build_profile() expects a first and last name, and then it allows the user to pass in as many name-value pairs as they want. The double asterisks ( ** ) before the parameter **user_info cause Python to create an empty dictionary called user_info and pack whatever name-value pairs it receives into this dictionary. Within the function, you can access the key-value pairs in user_info just as you would for any dictionary. In the body of build_profile() , we add the first and last names to the user_info dictionary because we'll always receive these two pieces of information from the user (line \u00be), and they haven't been placed into the dictionary yet. Then we return the user_info dictionary to the function call line. We call build_profile() , passing it the first name 'albert' , the last name 'einstein' , and the two key-value pairs location = 'princeton' and field = 'physics' . We assign the returned profile to user_profile and print user_profile : {'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'} The returned dictionary contains the user's first and last names and, in this case, the location and field of study as well. The function would work no matter how many additional key-value pairs are provided in the function call. You can mix positional, keyword, and arbitrary values in many different ways when writing your own functions. It's useful to know that all these argument types exist because you'll see them often when you start reading other people's code. It takes practice to learn to use the different types correctly and to know when to use each type. Storing Your Functions in Modules One advantage of functions is the way they separate blocks of code from your main program. By using descriptive names for your functions, your program will be much easier to follow. You can go a step further by storing your function in a separate file called a module and then importing that module into your main program. An import statement tells Python to make the code in a module available in the currently running program file. Storing your functions in a separate file allows you to hide the details of your program's code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written. There are several ways to import a module: Importing an Entire Module To start importing functions, we first need to create a module. A module is a file ending in .py that contains the code you want to import into your program. Let's make a module that contains the function make_pizza() . To make this module, we'll remove everything from the file pizza.py except the function make_pizza() . pizza.py : 1 2 3 4 5 def make_pizza ( size , * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( f \" \\n Making a { size } -inch pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) Now we'll make a separate file called making_pizzas.py in the same directory as pizza.py . This file imports the module we just created and then makes two calls to make_pizza() . making_pizzas.py : 1 2 3 4 import pizza pizza . make_pizza ( 16 , 'pepperoni' ) pizza . make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) When Python reads this file, the line import pizza tells Python to open the file pizza.py and copy all the functions from it into this program. You don't actually see code being copied between files because Python copies the code behind the scenes just before the program runs. All you need to know is that any function defined in pizza.py will now be available in making_pizzas.py . To call a function from an imported module, enter the name of the module you imported, pizza , followed by the name of the function, make_pizza() , separated by a dot (line 3). This code produces the same output as the original program that didn't import a module: Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese This first approach to importing, in which you simply write import followed by the name of the module, makes every function from the module available in your program. If you use this kind of import statement to import an entire module named module_name.py , each function in the module is available through the following syntax: module_name . function_name () Importing Specific Functions You can also import a specific function from a module. Here's the general syntax for this approach: from module_name import function_name You can import as many functions as you want from a module by separating each function's name with a comma: from module_name import function_0 , function_1 , function_2 The making_pizzas.py example would look like this if we want to import just the function we're going to use: 1 2 3 4 from pizza import make_pizza make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) With this syntax, you don't need to use the dot notation when you call a function. Because we've explicitly imported the function make_pizza() in the import statement, we can call it by name when we use the function. Using as to Give a Function an Alias If the name of a function you're importing might conflict with an existing name in your program or if the function name is long, you can use a short, unique alias - an alternate name similar to a nickname for a function. You'll give the function this special nickname when you import the function. Here we give the function make_pizza() an alias, mp() by importing make_pizza as mp . The as keyword renames a function using the alias you provide: 1 2 3 4 from pizza import make_pizza as mp mp ( 16 , 'pepperoni' ) mp ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) The import statement shown here renames the function make_pizza() to mp() in this program. Any time we want to call make_pizza() we can simply write mp() instead, and Python will run the code in make_pizza() while avoiding any confusion with another make_pizza() function you might have written in this program file. The general syntax for providing an alias is: from module_name import function_name as fn Importing All Functions in a Module You can tell Python to import every function in a module by using the asterisk ( * ) operator: 1 2 3 4 from pizza import * make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) The asterisk in the import statement tells Python to copy every function from the module pizza ( pizza.py ) into this program file. Because every function is imported, you can call each function by name without using the dot notation. However, it is best not to use this approach when you're working with larger modules that you didn't write: if the module has a function name that matches an existing name in your project, you can get some unexpected results. Python may see several functions or variables with the same name, and instead of importing all the functions separately, it will overwrite the functions. The best approach is to import the function or functions you want, or import the entire module and use the dot notation. This leads to clear code that's easy to read and understand. I include this section so you'll recognize import statements like the following when you see them in other people's code: from module_name import * Styling Functions You need to keep a few details in mind when you're styling functions. Functions should have descriptive names, and these names should use lowecase letters and underscores. Descriptive names help you and other understand what your code is trying to do. Module names should use these conventions as well. Every function should have a comment that explains concisely what the function does. This comment should appear immediately after the function definition and use the docstring format. In a well-documented function, other programmers can use the function by reading only the description in the docstring. They should be able to trust that the code works as described, and as long as they the name of the function, the arguments it needs, and the kind of value it returns, they should be able to use it in their programs. If you specify a default value for a parameter, no spaces should be used on either side of the equal sign: def function_name ( parameter_0 , parameter_1 = 'default value' ) The same convention should be used for keyword arguments in function calls: function_name ( value_0 , parameter_1 = 'value' ) PEP 8 recommends that you limit lines of code to 79 characters so every line is visible in a reasonably sized editor window. If a set of parameters causes a function's definition to be longer than 79 character, press ENTER after opening parenthesis on the definition line. On the next line, press TAB twice to separate the list of arguments from the body of the function, which will only be indented by one level. Most editors automatically line up any additional lines of parameters to match the indentation you have established on the first line: 1 2 3 4 def function_name ( parameter_0 , parameter_1 , parameter_2 parameter_3 , parameter_4 , parameter_5 ): function body ... If your program or module has more than one function, you can separate each by two blank lines to make it easier to see where one function ends and the next one begins. All import statements should be written at the beginning of a file. The only exception is if you use comments at the beginning of your file to describe the overall program.","title":"Functions"},{"location":"py-functions/#functions","text":"On this page we'll learn how to write functions , which are named blocks of code that are designed to do one specific job. When you want to perform a particular task that you've defined in a function, you call the function responsible for it. If you need to perform that task multiple times throughout your program, you don't need to type all the code for the same task again and again; you just call the function dedicated to handling that task, and the call tells Python to run the code inside the function. You'll find that using functions makes your programs easier to write, read, test, and fix. We will also learn ways to pass information to functions. We will learn how to write certain functions whose primary job is to display information and other functions desinged to process data and return a value or a set of values. Finally, we will cover how to store functions in separate files called modules to help organize our main program files.","title":"Functions"},{"location":"py-functions/#defining-a-function","text":"Here is a simple function named greet_user() that prints a greeting: 1 2 3 4 def greet_user (): \"\"\"Display a simple greeting.\"\"\" print ( \"Hello!\" ) greet_user () This example shows the simplest structure of a function. The code on line 1 uses the keyword def to inform Python that you're defining a function. This is the function definition , which tells Python the name of the function and, if applicable, what kind of information the function needs to do its job. The parentheses hold that information. In this case, the name of the function is greet_user() , and it needs no information to do its job, so its parentheses are empty. (Even so, the parentheses are required.) Finally, the definition ends in a colon. An indented lines that follow def greet_user (): make up the body of the function. The text on line 2 is a comment called a docstring , which describes what the function does. Docstrings are enclosed in triple quotes, which Python looks for when it generates documentaion for the functions in your programs. The line print ( \"Hello!\" ) on line 3 is the only line of actual code in the body of this function, so greet_user() has just one job: print ( \"Hello!\" ) . When you want to use this function, you call it. A function call tells Python to execute the code in the function. To call a function, you write the name of the function, followed by any necessary information in parentheses, as shown on line 4. Because no information is needed here, calling our function is as simple as entering greet_user() . As expected, it prints Hello! .","title":"Defining a Function"},{"location":"py-functions/#passing-information-to-a-function","text":"Modified slightly, the function greet_user() can not only tell the user Hello! but also greet them by name. For the function to do this, you enter username in the parentheses of the function's definition at def greet_user () . By adding username here you allow the function to accept any value of username you specify. The function now expects you to provide a value for username each time you call it. When you call greet_user() , you can pass it a name, such as 'jesse' , inside the parentheses: 1 2 3 4 5 def greet_user ( username ): \"\"\"Display a simple greeting.\"\"\" print ( f \"Hello, { username . title () } !\" ) greet_user ( 'jesse' ) Entering greet_user ( 'jesse' ) calls greet_user () and give the function the information it needs to execute the print () call. The function acceptsthe name you passed it and displays the greeting for that name: Hello, Jesse!","title":"Passing Information to a Function"},{"location":"py-functions/#arguments-and-parameters","text":"In the preceding greet_user() function, we defined greet_user() to require a value for the variable username . Once we called the function and gave it the information (a person's name), it printed the right greeting. The variable username in the definition of greet_user() is an example of a parameter , a piece of information the function needs to do its job. The value 'jesse' is reet_user ( 'jesse' ) is an example of an argument . An argument is a piece of information that's passed from a function call to a function. When we call the function, we place the value we want the function to work with in the parenthese. In this case the argument 'jesse' was passed to the function greet_user() , and the value was assigned to the parameter username .","title":"Arguments and Parameters"},{"location":"py-functions/#passing-arguments","text":"Because a function definition can have multiple parameters, a function call may need multiple arguments. You can pass arguments to your functions in a number of ways. You can use positional arguments , which need to be in the same order as the parameters were written; keyword arguements , where each argument consists of a variable name and a value; and lists and dictionaries of values.","title":"Passing Arguments"},{"location":"py-functions/#positional-arguments","text":"When you call a function, Python must match each argument in the function call with a parameter in the function definition. The simplest way to do this is baased on the order of the arguments provided. Values matched up this way are called positional arguments . To see how this works, consider a function that displays information about pets. The function tells us what kind of animal each pet is and the pet's name, as shown here: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'hamster' , 'harry' ) The definition shows that this function needs a type of animal and the animal's name (line 1). When we call describe_pet() , we need to provide an animal type and a name, in that order. For example, in the function call, the argument 'hamster' is assigned to the parameter animal_type and the argument 'harry' is assigned to the parameter pet_name (line 6). In the function body, these two parameters are used to display information about the pet being described. The output describes a hamster named Harry: I have a hamster. My hamster's name is Harry.","title":"Positional Arguments"},{"location":"py-functions/#multiple-function-calls","text":"You can call a function as many times as needed. Describing a second, different pet requires just one more call to describe_pet() : 1 2 3 4 5 6 7 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'hamster' , 'harry' ) describe_pet ( 'dog' , 'willie' ) The only change above was to line 7. In the second function call, we pass describe_pet() the arguments 'dog' and 'willie' . As with the previous set of arguments we used, Python matches 'dog' with the parameter animal_type and 'willie' with the parameter pet_name . As before, the function does its job, but this time it also prints the values for a Dog named Willie: I have a hamster. My hamster's name is Harry. I have a dog. My dog's name is Willie. Calling a function multiple times is a very efficient way to work. The code describing a pet is written once in the function. Then, anytime you want to describe a new pet, you call the function with the new pet's information. Even if the code for describing a pet were to expand to ten lines, you could still describe a new pet in just one line by calling the function again. You can use as many positional arguments as you need in your functions. Python works through the arguments you provide when calling the function and matches each one with the corresponding parameter in the function's definition.","title":"Multiple Function Calls"},{"location":"py-functions/#order-matters-in-positional-arguments","text":"You can get unexpected results if you mix up the order of the arguments in a function call when using positional arguments: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'harry' , 'hamster' ) In the above function, we list the name first and the type of animal second. Because the argument 'harry' is listed first this time, that value is assigned to the parameter animal_type . Likewise, 'hamster' is assigned to pet_name . Now we have a \"harry\" named \"Hamster\": I have a harry. My harry's name is Hamster. If you get funny results like this, check to make sure the order of the arguments in your function call matches the order of the parameters in the function's definition.","title":"Order Matters in Positional Arguments"},{"location":"py-functions/#keyword-arguments","text":"A keyword argument is a name-value pair that you pass to a function. You directly associate the name of the value within the argument, so when you pass the argument to the function, there's no confusion (you won't end up with a harry named Hamster). Keyword arguments free you from having to worry about correctly ordering your arguments in the function call, and they clarify the role of each value in the function call. Let's rewrite the program from above using keyword arguments to call describe_pet() : 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) The function describe_pet() hasn't changed, but when we call the function, we explicitly tell Python which parameter each argument should be matched with. When Python reads the function call, it knows to assign the argument 'hamster' to the parameter animal_type and the argument 'harry' to pet_name . The output correctly shows that we have a hamster named Harry. The order of keyword arguments doesn't matter because Python knows where each value should go. The following two function calls are equivalent: 1 2 describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) describe_pet ( pet_name = 'harry' , animal_type = 'hamster' )","title":"Keyword Arguments"},{"location":"py-functions/#default-values","text":"When writing a function, you can define a default value for each parameter. If an argument for a parameter is proivided in the function call, Python uses the argument value. If not, it uses the parameter's default value. So when you define a default value for a parameter, you can exclude the corresponding argument you'd usually write in the function call. Using default values can simplify your function calls and clarify the ways in which your functions are typically used. For example, if you notice that most of the calls to describe_pet() are being used to describe dogs, you can set the default value of animal_type to 'dog' . Now anyone calling describe_pet() for a dog can omit that information: 1 2 3 4 5 6 def describe_pet ( pet_name , animal_type = 'dog' ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( pet_name = 'willie' ) We changed the definition of describe_pet() to include a default value, 'dog' , for animal_type . Now when the function is called with no animal_type specified, Python knows to use the value 'dog' for this parameter: I have a dog. My dog's name is Willie. Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet's name. Python still interprets this as a positional argument, so if the function is called with just the pet's name, that argument will match up with the first parameter listed in the function's definition. This is the reason the first parameter needs to be pet_name . The simplest way to use this function now is to provide just a dog's name in the function call: describe_pet ( 'willie' ) This function call would have the same output as the previous example. The only argument provided is 'willie' , so it is matched up with the first parameter in the definition, pet_name . Because no argument is provided for animal_type , Python uses the default value 'dog' . To describe an animal other than a dog, you could use a function call like this: describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) Because an explicit argument for animal_type is provoided, Python will ignore the parameter's default value. Note on default values When you use default values, any parameter with a default value needs to be listed after all the parameters that don't have default values. This allows Python to continue interpreting positional arguments correctly.","title":"Default Values"},{"location":"py-functions/#equivalent-function-calls","text":"Because positional arguments, keyword arguments, and default values can all be used together, often you'll have several equivalent ways to call a function. Consider the following definition for describe_pet() with one default value provided: def describe_pet ( pet_name , animal_type = 'dog' ): With this definition, an argument always needs to be provided for pet_name , and this value can be provided using the positional or keyword format. If the animal being described is not a dog, an argument for animal_type mist be included in the call, and this argument can also be specified using the positional or keyword format. All the follwoing calls would work for this function: 1 2 3 4 5 6 7 8 # A dog named Willie. describe_pet ( 'willie' ) describe_pet ( pet_name = 'willie' ) # A hamster named Harry. describe_pet ( 'harry' , 'hamster' ) describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) Each of these function calls would have the same output as the previous examples. It doesn't really matter which calling style you use. As long as your function calls produce the output you want, just use the style you find easiest to understand.","title":"Equivalent Function Calls"},{"location":"py-functions/#avoiding-argument-errors","text":"When you start to use functions, don't be surprides if you encounter errors about unmatched arguments. Unmatched arguments occur when you provide fewer or more arguments than a function needs to do its wor. For example, here's what happens if we try to call describe_pet() with no arguments: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet () Python recognizes that some information is missing from the function call, and the traceback tells us that: TypeError Traceback (most recent call last) File <\"pets.py\">, line 6, in <module> 4 print(f\"My {animal_type}'s name is {pet_name.title()}.\") 5 ----> 6 describe_pet() TypeError: describe_pet() missing 2 required positional arguments: 'animal_type' and 'pet_name' The traceback tells us the location of the problem (line 6), allowing us to look back and see that something went wrong in our function call. Next, the offending function call is written out for us to see. Finally, the traceback tells us the call is missing two arguments and reports the names of the missing arguments. If this function were in a separate file, we could probably rewrite the call correctly without having to open that file and read the function code. Python is helpful in that it reads the function's code for us and tells us the names of the argument we need to provide. This is another motivation for giving your variables and functions descriptive names. If you do, Pythons error messages will be more useful to you and anyone else who might use your code. If you provide too many arguments, you should get a similar traceback that cal help you correctly match your function call to the function definition.","title":"Avoiding Argument Errors"},{"location":"py-functions/#return-values","text":"A function doesn't always have to display its output directly. Instead, it can process some data and then reutn a value or set of values. The value the function returns is called a return value . The return statement takes a value from inside a function and sends it back to the line that called the function. Return values allow you to move much of your program's grunt work into functions, which can simplify the body of your program.","title":"Return Values"},{"location":"py-functions/#returning-a-simple-value","text":"Let's look at a function that takes a first and last name, and returns a neatly formatted name: 1 2 3 4 5 6 7 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, fully formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'jimi' , 'hendrix' ) print ( musician ) The defintion of get_formatted_name() takes as parameters a first and last name (line 1). The function combines these two names, adds a space between them, and assigns the result to full_name (line 3). The value of full_name is converted to title case, and then returned to the calling line at line 4. When you call a function that returns a value, you need to provide a variable that the return value can be assigned to. In this case, the returned value is assigned to the variable musician on line 6. The output shows a neatly formatted name made up of the parts of a person's name: Jimi Hendrix This might seem like a lot of work to get a neatly formatted name when we could have just written: print ( \"Jimi Hendrix\" ) But when you consider working with a large program that needs to store many first and last names separately, functions like get_formatted_name() become very useful. You store first and last names separately and then call this function whenever you want to display a full name.","title":"Returning a Simple Value"},{"location":"py-functions/#making-an-argument-optional","text":"Sometimes it makes sense to make an argument optional so that people using the function can choose to provide extra information only if they want to. You can use default values to make an argument optional. For example, say we want to exapand get_formatted_name() to handle middle names as well. A first attempt to include middle names might look like this: 1 2 3 4 5 6 7 def get_formatted_name ( first_name , middle_name , last_name ): \"\"\"Return a full name, fully formatted.\"\"\" full_name = f \" { first_name } { middle_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'john' , 'lee' 'hooker' ) print ( musician ) This function works when given a first, middle, and last name. The function takes in all three parts of a name and then builds a string out of them. The function adds spaces where appropriate and converts the full name to title case: John Lee Hooker But middle names aren't always needed, and this function as written would not work if you tried to call it with only a first name and a last name. To make a middle name optional, we can give the middle_name argument an empty default valuye and ignore the argument unless a user provides a value. To make get_formatted_name() work without a middle name, we set the default value of middle_name to an empty string and move it to the end of list of parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 def get_formatted_name ( first_name , last_name , middle_name = '' ): \"\"\"Return a full name, neatly formatted.\"\"\" if middle_name : full_name = f \" { first_name } { middle_name } { last_name } \" else : full_name = f \" { first_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'jimi' , 'hendrix' ) print ( musician ) musician = get_formatted_name ( 'john' , 'hooker' , 'lee' ) print ( musician ) In this example, the name is built from three possible parts. Because there's always a first and last name, these parameters are listed first in the function's definition. The middle name is optional, so it's listed last in the definition, and its default value is an empty string (line 1). In the body of the function, we check to see if a middle name has been provided. Python interprets non-empty strings as True , so if middle_name evaluates to True if a middle name argument is in the function call (line 3). If a middle name is provided, the first, middle, and last names are combined to form a full name. This name is then changed to title case and returned to the function call line where it's assigned to the variable musician and printed. If no middle name is provided, the empty string fails the if test and the else block runs (line 5). The full name is made with just a dirst and last name, and the formatted name is returned to the calling line where it's assigned to musician and printed. Calling this function with a first and last name is straightforward. If we're using a middle name, however, we have to make sure the middle name is the last argument passed so Python will match up the positional arguments correctly (line 12). This modified version of our function works for people with just a first and last name, and it works for people who have a middle name as well: Jimi Hendrix John Lee Hooker Optional values allow functions to handle a wide range of use cases while letting function calls remain as simple as possible.","title":"Making an Argument Optional"},{"location":"py-functions/#returning-a-dictionary","text":"A function can return any kind of value you need it to, including more complicated data structures like lists and dictionaries. For example, the following function takes in parts of a name and returns a dictionary representing a person: 1 2 3 4 5 6 7 def build_person ( first_name , last_name ): \"\"\"Return a dictionary of information about a person.\"\"\" person = { 'first' : first_name , 'last' : last_name } return person musician = build_person ( 'jimi' , 'hendrix' ) print ( musician ) The function build_person() takes in a first and last name, and puts these values into a dictionary (line 3). The value of first_name is stored with the key 'first' , and the value of last_name is stored with the key 'last' . The entire dictionary representing the person is returned at line 4. The return value is printed on the final line with the original two pieces of textual information now stored in a dictionary: {'first': 'jimi', 'last': 'hendrix'} This function takes in a simple textual information and puts it into a more meaningful data structure that lets you work with the information beyond just printing it. The strings 'jimi' and 'hendrix' are now labeled as a first name and last name. You can easily extend this function to accept optional values like a middle name, an age, an occupation, or any other information you want to store about a person. For example, the following change allows you to store a person's age as well: 1 2 3 4 5 6 7 8 9 def build_person ( first_name , last_name , age = None ): \"\"\"Return a dictionary of information about a person.\"\"\" person = { 'first' : first_name , 'last' : last_name } if age : person [ 'age' ] = age return person musician = build_person ( 'jimi' , 'hendrix' , age = 27 ) print ( musician ) We add a new optional parameter age to the function definition and assign the parameter the special value None , which is used when a variable has no specific value assigned to it. You can think of None as a placeholder value. In conditional tests, None evaluates to False . If the function call includes a value fo age , that value is stored in the dictionary. This function always stores a person's name, but it can also be modified to store any other information you want about a person.","title":"Returning a Dictionary"},{"location":"py-functions/#using-a-function-with-a-while-loop","text":"You can use functions with all the Python structures you've learned about so far. For example, let's use the get_formatted_name() function with a while loop to greet users more formally. Here's a first attempt at greeting people using their first and last names: 1 2 3 4 5 6 7 8 9 10 11 12 13 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, neatly formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () # This is an infinite loop! while True : print ( \" \\n Please tell me your name:\" ) f_name = input ( \"First name: \" ) l_name = input ( \"Last name: \" ) formatted_name = get_formatted_name ( f_name , l_name ) print ( f \" \\n Hello, { formatted_name } !\" ) For this example, we use a simple version of get_formatted_name() that doesn't involve middle names. The while loop asks the user to enter their name, and we prompt for their first and last name separately (line 8). But there's one problem with this while loop: We haven't defined a quit condition. Where do you put a quit condition when you ask for a series of input? We want the user to be able to quit as easily as possible, so each prompt should offer a way to quit. The break statement offers a straightforward way to exit the loop at either prompt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, neatly formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () # This is an infinite loop! while True : print ( \" \\n Please tell me your name:\" ) print ( \"(enter 'q' at any time to quit)\" ) f_name = input ( \"First name: \" ) if f_name == 'q' : break l_name = input ( \"Last name: \" ) if l_name == 'q' : break formatted_name = get_formatted_name ( f_name , l_name ) print ( f \" \\n Hello, { formatted_name } !\" ) We add a message that informs the user how to quit, and then we break out of the loop if the user enters the quit value at either prompt. Now the program will continue greeting people until someone enters 'q' for either name: Please tell me your name: (enter 'q' at any time to quit) First name: Nick Last name: Platt Hello, Nick Platt! Please tell me your name: (enter 'q' at any time to quit) First name: q","title":"Using a Function with a while Loop"},{"location":"py-functions/#passing-a-list","text":"You'll often find it useful to pass a list to a function, whether it's a list of names, numbers, or more complex objects, such as dictionaries. When you pass a list to a function, the function gets direct access to the contents of the list. Let's use functions to make working with lists more efficient. Say we have a list of users and want to print a greeting to each. The following example sends a list of names to a function called greet_users() , which greets each person in the list individually: 1 2 3 4 5 6 7 8 def greet_users ( names ): \"\"\"Print a simple greeting to each user in the list.\"\"\" for name in names : msg = f \"Hello, { name . title () } !\" print ( msg ) usernames = [ 'hannah' , 'ty' , 'margot' ] greet_users ( usernames ) We define greet_users() so it expects a list of names, which it assigns to the parameter names . The function loops through the list it receives and prints a greeting to each user. On line 7, we define a list of users and then pass the list usernames to greet_users() in our function call: Hello, Hannah! Hello, Ty! Hello, Margot! This is the output we wanted. Every user sees a personalized greeting, and you can call the function any time you want to greet a specific set of users.","title":"Passing a List"},{"location":"py-functions/#modifying-a-list-in-a-function","text":"When you pass a list to a function, the function can modify the list. Any changes made to the list inside the function's body are permanent, allowing you to work efficiently even when you're dealing with large amounts of data. Consider a company that creates 3D printed models of designs that users submit. Designs that need to be printed are stored in a list, and after being printed they're moved to a separate list. The following code does this without using functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Start with some designs that need to be printed. unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] # Simulate printing each design, until none are left. # Move each design to completed_models after printing. while unprinted_designs : current_design = unprinted_designs . pop () print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) # Display all completed models. print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) This program starts with a list of designs that need to be printed and an empty list called completed_models that each design will be moved to after it has been printed. As long as designs remain unprinted_designs , the while loop simulates printing each design by removing a design from the end of the list, storing it in current_design , and displaying a message that current design is being printed. It then adds the design to the list of completed models. When the loop is finished running, a list of designs that have been printed is displayed: Printing model: dodecahedron Printing model: robot pendant Printing model: phone case The following models have been printed: dodecahedron robot pendant phone case We can reorganize this code by writing two functions, each of which does one specific job. Most of the code won't change; we're just making it more carefully structured. The first function will handle printing the designs, and the second will summarize the prints that have been made: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def print_models ( unprinted_designs , completed_models ): \"\"\" Simulate printing each design, until none are left. Move each design to completed_models after printing. \"\"\" while unprinted_designs : current_design = unprinted_designs . pop () print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) def show_completed_models ( completed_models ): \"\"\"Show all the models that were printed.\"\"\" print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] print_models ( unprinted_designs , completed_models ) show_completed_models ( completed_models ) On line 1 we define the function print_models() with two parameters: a list of designs that need to be printed and a list of completed models. Given these two lists, the function simulates printing each design by emptying the list of unprinted designs and filling up the list of completed models. On line 10 we define the function show_completed_models() with one parameter: the list of completed models. Given this list, show_completed_models() displays the name of each model that was printed. This program has the same output as the version without functions, but the code is much more organized. The code that does most of the work has been moved to two separate functions, which makes the main part of the program easier to understand. Look at the body of the program to see how much easier it is to understand what this program is doing: 1 2 3 4 5 unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] print_models ( unprinted_designs , completed_models ) show_completed_models ( completed_models ) We set up a list of unprinted designs and an empty list that will hold the completed models. Then, because we've already defined our two functions, all we have to do is call them and pass them the right arguments. We call print_models() and pass it the two lists it needs; as expected, print_models() simulates printing the designs. Then we call show_completed_models() and pass it the list of completed models so it can report the models that have been printed. The descriptive function names allow others to read this code and understand it, even without comments. This program is easier to extend and maintain than the version without functions. If we need to print more designs later on, we can simply call print_models() again. If we realize the printing code needs to be modified, we can change the code once, and our changes will take place everywhere the function is called. This technique is more efficient than having to update code separately in several places in the program. This example also demonstrates the idea that every function should have one specific job. The first function prints each design, and the second displays the completed models. This is more beneficial than using one function to do both jobs. If you're writing a function and notice the function is doing too many different tasks, try to split the code into two functions. Remember that you can always call a function from another function, which can be helpful when splitting a complex task into a series of steps.","title":"Modifying a List in a Function"},{"location":"py-functions/#preventing-a-function-from-modifying-a-list","text":"Sometimes you'll want to prevent a function from modifying a list. For example, say that you start with a list of unprinted designs and write a function to move them to a list of completed models, as in the previous example. You may decide that even though you've printed all the designs, you want to keep the original list of unprinted designs for your records. But because you moved all the desing names out of unprinted_designs , the list is now empty, and the empty list is the only version you have; the original is gone. In this case, you can address this issue by passing the function a copy of the list, not the original. Any changes the function makes to the list will affect only the copy, leaving the original list intact. You can send a copy of a list to a function like this: function_name ( list_name [:]) Ths slice notation [:] makes a copy of the list to send to the function. If we didn't want to empty the list of unprinted desings in printing_models.py , we could call print_models() like this: print_models ( unprinted_designs [:], completed_models ) The function print_models() can do its work because it still receives the names of all unprinted designs. But this time it uses a copy of the original unprinted desings list, not the actual unprinted_designs list. The list completed_models will fill up with the names of printed models like it did before, but original list of unprinted designs will be unaffected by the function. Even though you can preserve the contents of a list by passing a copy of it to your functions, you should pass the original list to functions unless you have a specific reason to pass a copy. It's more efficient for a function to work with an existing list to avoid using the time and memory needed to make a separate copy, especially when you're working with large lists.","title":"Preventing a Function from Modifying a List"},{"location":"py-functions/#passing-an-arbitrary-number-of-arguments","text":"Sometimes you won't know ahead of time how many arguments a function needs to accept. Fortunately, Python allows a function to collect an arbitrary number of arguments from the calling statement. For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can't know ahead of time how many toppings a person will want. The function in the following example has one parameter, *toppings , but this parameter collects as many arguments as the calling line provides: 1 2 3 4 5 6 def make_pizza ( * toppings ): \"\"\"Print the list of toppings that have been requested.\"\"\" print ( toppings ) make_pizza ( 'pepperoni' ) make_pizza ( 'mushrooms' , 'green peppers' , 'extra cheese' ) The asterisk ( * ) in the parameter name *toppings tells Python to make an empty tuple called toppings and pack whatever values it receives into this tuple. The print () call in the function body produces output showing that Python can handle a function call with one value and a call with three values. It treats the different calls similarly. Note that Python packs the arguments into a tuple, even if the function receives only one value: ('pepperoni',) ('mushrooms', 'green peppers', 'extra cheese') Now we can replace the print() call with a loop that runs through the list of toppings and describes the pizza being ordered: 1 2 3 4 5 6 7 8 def make_pizza ( * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( \" \\n Making a pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) make_pizza ( 'pepperoni' ) make_pizza ( 'mushrooms' , \"green peppers\" , \"extra cheese\" ) The function responds appropriately, whether it receives one value or three values: Making a pizza with the following toppings: - pepperoni Making a pizza with the following toppings: - mushrooms - green peppers - extra cheese This syntax works no matter how many arguments the function receives.","title":"Passing an Arbitrary Number of Arguments"},{"location":"py-functions/#mixing-positional-and-arbitrary-arguments","text":"If you want a function to accept several different kinds of arguments, the parameter that accepts an arbitrary number of arguments must be placed last in the function definition. Python matches positional and keyword arguments first and then collects any remaining arguments in the final parameter. For example, if the function needs to take in a size for the pizza, that parameter must come before the parameter *toppings : 1 2 3 4 5 6 7 8 def make_pizza ( size , * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( f \" \\n Making a { size } -inch pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) In the function definition, Python assigns the first value it reveives to the parameter size . All other values that come after are stored in the tuple toppings . The function calls include an argument for the size first, followed by as many toppings as needed. Now each pizza has a size and a number of toppings, and each piece of information is printed in the proper place, showing size first and toppings after: Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese","title":"Mixing Positional and Arbitrary Arguments"},{"location":"py-functions/#using-arbitrary-keyword-arguments","text":"Sometimes you'll want to accept an arbitrary number of arguments, but you won't know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you'll get information about a user, but you're not sure what kind of information you will receive. The function build_profile() in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well: 1 2 3 4 5 6 7 8 def build_profile ( first , last , ** user_info ): \"\"\"Build a dictionary containing everything we know about a user.\"\"\" user_info [ 'first_name' ] = first user_info [ 'last_name' ] = last return user_info user_profile = build_profile ( 'albert' , 'einstein' , location = 'princeton' , field = 'physics' ) print ( user_profile ) The definition of build_profile() expects a first and last name, and then it allows the user to pass in as many name-value pairs as they want. The double asterisks ( ** ) before the parameter **user_info cause Python to create an empty dictionary called user_info and pack whatever name-value pairs it receives into this dictionary. Within the function, you can access the key-value pairs in user_info just as you would for any dictionary. In the body of build_profile() , we add the first and last names to the user_info dictionary because we'll always receive these two pieces of information from the user (line \u00be), and they haven't been placed into the dictionary yet. Then we return the user_info dictionary to the function call line. We call build_profile() , passing it the first name 'albert' , the last name 'einstein' , and the two key-value pairs location = 'princeton' and field = 'physics' . We assign the returned profile to user_profile and print user_profile : {'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'} The returned dictionary contains the user's first and last names and, in this case, the location and field of study as well. The function would work no matter how many additional key-value pairs are provided in the function call. You can mix positional, keyword, and arbitrary values in many different ways when writing your own functions. It's useful to know that all these argument types exist because you'll see them often when you start reading other people's code. It takes practice to learn to use the different types correctly and to know when to use each type.","title":"Using Arbitrary Keyword Arguments"},{"location":"py-functions/#storing-your-functions-in-modules","text":"One advantage of functions is the way they separate blocks of code from your main program. By using descriptive names for your functions, your program will be much easier to follow. You can go a step further by storing your function in a separate file called a module and then importing that module into your main program. An import statement tells Python to make the code in a module available in the currently running program file. Storing your functions in a separate file allows you to hide the details of your program's code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written. There are several ways to import a module:","title":"Storing Your Functions in Modules"},{"location":"py-functions/#importing-an-entire-module","text":"To start importing functions, we first need to create a module. A module is a file ending in .py that contains the code you want to import into your program. Let's make a module that contains the function make_pizza() . To make this module, we'll remove everything from the file pizza.py except the function make_pizza() . pizza.py : 1 2 3 4 5 def make_pizza ( size , * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( f \" \\n Making a { size } -inch pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) Now we'll make a separate file called making_pizzas.py in the same directory as pizza.py . This file imports the module we just created and then makes two calls to make_pizza() . making_pizzas.py : 1 2 3 4 import pizza pizza . make_pizza ( 16 , 'pepperoni' ) pizza . make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) When Python reads this file, the line import pizza tells Python to open the file pizza.py and copy all the functions from it into this program. You don't actually see code being copied between files because Python copies the code behind the scenes just before the program runs. All you need to know is that any function defined in pizza.py will now be available in making_pizzas.py . To call a function from an imported module, enter the name of the module you imported, pizza , followed by the name of the function, make_pizza() , separated by a dot (line 3). This code produces the same output as the original program that didn't import a module: Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese This first approach to importing, in which you simply write import followed by the name of the module, makes every function from the module available in your program. If you use this kind of import statement to import an entire module named module_name.py , each function in the module is available through the following syntax: module_name . function_name ()","title":"Importing an Entire Module"},{"location":"py-functions/#importing-specific-functions","text":"You can also import a specific function from a module. Here's the general syntax for this approach: from module_name import function_name You can import as many functions as you want from a module by separating each function's name with a comma: from module_name import function_0 , function_1 , function_2 The making_pizzas.py example would look like this if we want to import just the function we're going to use: 1 2 3 4 from pizza import make_pizza make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) With this syntax, you don't need to use the dot notation when you call a function. Because we've explicitly imported the function make_pizza() in the import statement, we can call it by name when we use the function.","title":"Importing Specific Functions"},{"location":"py-functions/#using-as-to-give-a-function-an-alias","text":"If the name of a function you're importing might conflict with an existing name in your program or if the function name is long, you can use a short, unique alias - an alternate name similar to a nickname for a function. You'll give the function this special nickname when you import the function. Here we give the function make_pizza() an alias, mp() by importing make_pizza as mp . The as keyword renames a function using the alias you provide: 1 2 3 4 from pizza import make_pizza as mp mp ( 16 , 'pepperoni' ) mp ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) The import statement shown here renames the function make_pizza() to mp() in this program. Any time we want to call make_pizza() we can simply write mp() instead, and Python will run the code in make_pizza() while avoiding any confusion with another make_pizza() function you might have written in this program file. The general syntax for providing an alias is: from module_name import function_name as fn","title":"Using as to Give a Function an Alias"},{"location":"py-functions/#importing-all-functions-in-a-module","text":"You can tell Python to import every function in a module by using the asterisk ( * ) operator: 1 2 3 4 from pizza import * make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) The asterisk in the import statement tells Python to copy every function from the module pizza ( pizza.py ) into this program file. Because every function is imported, you can call each function by name without using the dot notation. However, it is best not to use this approach when you're working with larger modules that you didn't write: if the module has a function name that matches an existing name in your project, you can get some unexpected results. Python may see several functions or variables with the same name, and instead of importing all the functions separately, it will overwrite the functions. The best approach is to import the function or functions you want, or import the entire module and use the dot notation. This leads to clear code that's easy to read and understand. I include this section so you'll recognize import statements like the following when you see them in other people's code: from module_name import *","title":"Importing All Functions in a Module"},{"location":"py-functions/#styling-functions","text":"You need to keep a few details in mind when you're styling functions. Functions should have descriptive names, and these names should use lowecase letters and underscores. Descriptive names help you and other understand what your code is trying to do. Module names should use these conventions as well. Every function should have a comment that explains concisely what the function does. This comment should appear immediately after the function definition and use the docstring format. In a well-documented function, other programmers can use the function by reading only the description in the docstring. They should be able to trust that the code works as described, and as long as they the name of the function, the arguments it needs, and the kind of value it returns, they should be able to use it in their programs. If you specify a default value for a parameter, no spaces should be used on either side of the equal sign: def function_name ( parameter_0 , parameter_1 = 'default value' ) The same convention should be used for keyword arguments in function calls: function_name ( value_0 , parameter_1 = 'value' ) PEP 8 recommends that you limit lines of code to 79 characters so every line is visible in a reasonably sized editor window. If a set of parameters causes a function's definition to be longer than 79 character, press ENTER after opening parenthesis on the definition line. On the next line, press TAB twice to separate the list of arguments from the body of the function, which will only be indented by one level. Most editors automatically line up any additional lines of parameters to match the indentation you have established on the first line: 1 2 3 4 def function_name ( parameter_0 , parameter_1 , parameter_2 parameter_3 , parameter_4 , parameter_5 ): function body ... If your program or module has more than one function, you can separate each by two blank lines to make it easier to see where one function ends and the next one begins. All import statements should be written at the beginning of a file. The only exception is if you use comments at the beginning of your file to describe the overall program.","title":"Styling Functions"},{"location":"py-if-statements/","text":"If Statements Python often involves examining a set of conditions and deciding which action to take based on those conditions. Python's if statement allows you to examine the current state of a program and respond appropriately to that state. A Simple Example The following short example shows how if tests let you respond to special situations correctly. Imagine you have a list of cars and you want to print out the name of each car. Car names are proper names, so the names of most cars should be printed in title case. However, the value 'bmw' should be printed in all uppercase. The following code loops through a list of car names and looks for the value 'bmw' . Whenever the value is 'bmw' , it's printed in uppercase instead of title case. 1 2 3 4 5 6 7 cars = [ 'audi' , 'bmw' , 'subaru' , 'toyota' ] for car in cars : if car == 'bmw' : print ( car . upper ()) else : print ( car . title ()) The loop in this example first checks to see if the current value of car is 'bmw' . If it is, the value is printed in all uppercase. If the value of car is anything other than 'bmw' , it's printed in title case: Audi BMW Subaru Toyota Conditional Tests At the heart of every if statement is an expression that canbe evaluated as True or False and is called a conditional test . Python uses the values True and False to decide whether the code in an if statement should be executed. If a conditional test evaluates to True , Python executes the code following the if statement. If the test evaluates to False , Python ignores the code following the if statement. Checking for Equality Most conditional tests compare the current value of a variable to a specific value of interest. The simplest conditional test checks whether the value of a variable is equal to the value of interest: 1 2 car = 'bmw' car == 'bmw' True The code at line 1 sets the value of car to 'bmw' using a single equal sign, as you've seen many times already. The code at line 2 checks whether the value of car is 'bmw' using a double equal sign ( == ). This equality operator returns True if the values on the left and right side of the operator match, and False if they don't match. The values in this example match, so Python returns True . When the value of car is anything other than 'bmw' , this test returns False . 1 2 car = 'audi' car == 'bmw' False A single equal sign is really a statment; you might read the code at line one as \"Set the value of car equal to 'audi' \". On the other side, a double equal sign, like the one on line 2, asks a question: \"Is the vale of car equal to 'bmw' ?\" Most programming languages use equal signs in this way. Ignoring Case When Checking for Equality Testing for equality is case sensitive in Python. For example, ywo values with different capitalization are not considered equal: 1 2 car = 'Audi' car == 'audi' False If case matters, this behavior is advantageous. But if case doesn't matter and instead you just want to test the value of a variable, you can convert the variable's value to lowercase before doing the comparison: 1 2 car = 'Audi' car . lower () == 'audi' True This test would return True no matter how the value 'Audi' is formatted because the test is now case insensitive. The lower () function doesn't change the value that was originally stored in car , so you can do this kind of comparison without affecting the original variable: 1 2 car = 'Audi' car . lower () == 'audi' True 1 car 'Audi' At the first line 1, we assigned the capitalized string 'Audi' to the variable car . At line 2, we convert the value of car to lowercase and compare the lowercase value to the string 'audi' . The two strings match, so Python returns True . When we check what is stored in car again, we can see that it has not been affected by the lower () method. Websites enforce certain rules for the data that users enter in a manner similar to this. For example, a site might use a conditional test like this to ensure that every user has a truly unique username, not just a variation on the capitalization of another person's username. When someone submits a username, that new username is converted to lowercase and compared to the lowercase versions of all existing usernames. During this check, a username like 'John' will be rejected if any variation of 'john' is already in use. Checking for Inequality When you want to determine whether two values are not equal, you can combine an exclamation point and an equal sign (!=). The exclamation point represents not , as it does in many programming languages. Let's use another if statement to examine how to use the inequality operator. We'll store a requested pizza topping in a variable and then print a message if the person did not order anchovies: 1 2 3 4 requested_topping = 'mushrooms' if requested_topping != 'anchovies' : print ( \"Hold the anchovies!\" ) The code on line 3 compares the value of requested_topping to the value anchovies . If these two values do not match, Python returns True and executes the code following the if statement. If the two values match, Python returns False and does not run the code following the if statement. Because the value of requested_topping is not anchovies , the print () function is executed: Hold the anchovies! Most of the conditional expressions you write will test for equality, but sometimes you'll find it more efficient to test for inequality. Numerical Comparisons Testing numerical values is pretty straightforward. For example, the following code checks whether a person is 18 years old: 1 2 age = '18' age == '18' True You can also test to see if two numbers are not equal. For example, the following code prints a message if the given answer is not correct: 1 2 3 4 answer = 17 if answer != 42 : print ( \"That is not the correct answer. Please try again!\" ) The conditional test at line 3 passes, because the value of answer (17) is not equal to 42. Because the test passes, the indented code block is executed. You can include various mathematical comparisons in your conditional statements as well, such as less than, less than or equal to, greater than, and greater than or equal to. Checking Multiple Conditions You may want to check multiple conditions at the same time. For example, sometimes you might need two conditions to be True to take an action. Other times you might be satisfied with just one condition being True . The keywords and and or can help you in these situations. Using and to Check Multiple Conditions To check whether two conditions are both True simultaneously, use the keyword and to combine the two conditional tests; if each test passes, the overall expression evaluates to True . If either test fails or if both tests fail, the expression evaluates to False . For example, you can check whether two people are both over 21 using the following test: 1 2 3 age_0 = 22 age_1 = 18 age_0 >= 21 and age_1 >= 21 False On line 1, we define two ages, age_0 and age_1 . On line 3, we check whether both ages are 21 or older. The test on the left passes, but the one on the right fails, so the overall conditional expression evaluates to False . 1 2 age_1 = 22 age_0 >= 21 and age_1 >= 21 True On line 1, we change age_1 to 22. The value of age_1 is now greater than 21, so both individual tests pass, causing the overal conditional expression to evaluate as True . To improve readability, you can use parentheses around the individual tests, but they are not required. If you use parentheses, your test would look like this: 1 ( age_0 >= 21 ) and ( age_1 >= 21 ) Using or to Check Multiple Conditions The keyword or allows you to check multiple conditions as well, but it passes when either or both of the individual test pass. As or expression fails onl when both individual tests fail. Let's consider two ages again, but this time we'll look for only one person to be over 21: age_0 = 22 age_1 = 18 age_0 >= 21 or age_1 >= 21 True We start with two variables again at line 1. Because the test for age_0 at line 3 passes, the overall expression evaluates to True . age_0 = 18 age_0 >= 21 or age_1 >= 21 We now lowe age_0 to 18. In the test at line 2, both tests now fail and the overall expression evaluates to False . Checking Whether a Value Is in a List Sometimes it is important to check whether a list contains a certain value before taking an action. For example, you might want to check whether a new username already exists in a list of current usernames before completeing someone's registration on a webstie. In a mapping project, you might want to check whether a submitted location already exists in a list of known locations. To find out whether a particular value is already in a list, use the keyword in . Let's consider some code you might write for a pizzeria. We'll make a list of toppings a customer has requested for a pizza and then check whether certain toppings are in the list. requested_toppings = [ 'mushrooms' , 'onions' , 'pineapple' ] 'mushrooms' in requested_toppings True 'pepperoni' in requested_toppings False We told Python to check for the existence of 'mushrooms' and 'pepperoni' in the list requested_toppings . This technique is quite powerful because you can create a list of essential values, and then easily check whether the value you're testing matches one of the values in the list. Checking Whether a Value is Not in a List Other times, it's important to know if a value does not appear in a list. You can use the keyword not in this situation. For example, consider a list of users who are banned from commenting in a forum. You can check whether a user has been banned before allowing that user to submit a comment: 1 2 3 4 5 banned_users = [ 'andrew' , 'carolina' , 'david' ] user = 'marie' if user not in banned_users : print ( f \" { user . title () } , you can post a response if you wish.\" ) The code on line 4 reads quite clearly. If the value of user is not in the list of banned_users , Python returns True and execites the indented line. The user 'marie' is not in the list banned_users , so she sees a message inviting her to post a response: Marie, you can post a response if you wish. Boolean Expressions A Boolean expression is just another name for a condtitional test. A Boolean value is either True or False , just like the value of a conditional expression after it has been evaluated. Boolean values are often used to keep track of certain conditions, such as whether a game is running or whether a user can edit certain content on a website. game_active = True can_edit = False if Statements When you understand conditional tests, you can start writing if statements. Several different kinds of if statments exist, and your choice of which to use depends on the number of conditions you need to test. You saw several examples of if statments in the discussion about conditional tests, but now let's dif deeper into the topic. Simple if Statements The simplest kind of if statment has one test and one action: if conditional_test : do something You can put any conditional test in the first line and just about any action in the indented block following the test. If the condtional test evaluates to True , Python executes the code following the if statement. If the test evaluates to False , Python ignores the code following the if statement. Let's say we have a variable representing a person's age, and we want to know if that person is old enough to vote. The following code tests whether the person can vote: 1 2 3 age = 19 if age >= 18 : print ( \"You are old enough to vote!\" ) On line 2, Python checks to see whether the value of age is greater than or equal to 18. It is, so Python executes the indented print () call on line 3: You are old enough to vote! Indentation plays the same role in if statements as it did in for loops. All indented lines after an if statement will be executed if the test passes, and the entire block if indented lines will be ignored if the test does not pass. You can have as many lines of code as you want in the block following the #!py if` statement. Let's add another line of output if the person is old enough to vote, asking if the individual has registered to vote yet: 1 2 3 4 age = 19 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registeredto vote yet?\" ) The conditional test passes, and both print () calls are indented, so both lines are printed: You are old enough to vote! Have you registered to vote yet? If the value of age is less than 18, this program would produce no output. if else Statements Often, you'll want to take one action when a conditional test passes and a different action in all other cases. Python's if else syntax makes this possible. An if else block is similar to a simple if statement, but the else statement allows you to define an action or set of actions that are executed when the conditional test fails. We'll display the same message we had previously if the person is old enough to vote, but this time we'll add a message for anyone who is not old enough to vote: 1 2 3 4 5 6 7 age = 17 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registeredto vote yet?\" ) else : print ( \"Sorry, you are too younng to vote.\" ) print ( \"Please register as soon as you turn 18!\" ) If the conditional test on line 2 passes, the first block of indented print () calls are executed. If the test evaluates to False , the else block on line 5 is executed. Because age is less than 18 this time, the conditional test fails and the code in the else block is executed. This code works because it only has two possible situations to evaluate: a person is either old enough to vote or not old enough to vote. The if - else structure works well in situation in which you want Python to always execute one of two possible actions. In a simple if - else chain like this, one of the two actions will always be executed. The if - elif - else Chain Often, you'll need to test more than two possible situations, and to evaluate these you can use Python's if - elif - else syntax. Python executes only one block in an if - elif - else chain. It runs each conditional test in order until one passes. When a test passes, the code following that test is executed and Python skips the rest of the test. Many real-world situations involve more than two possible conditions. For example, consider an amusement park that charges different rates for different age groups: Admission for anyone under age 4 is free. Admission for anyone between the ages of 4 and 18 is $25. Admission for anyone age 18 or older is $40. How can we use an if statement to determine a person's admission rate? The following code tests for the age group of a person and then prints an admission price message: 1 2 3 4 5 6 7 8 age = 12 if age < 4 : print ( \"Your admission cost is $0.\" ) elif age < 18 : print ( \"Your admission cost is $25.\" ) else : print ( \"Your admission cost is $40.\" ) The if test on line 3 tests whether a person is under 4 years old. If the test passes, an appropriate message is printed an Python skips the rest of the tests. The elif code on line 5 is really another if test, which runs only if the previous test fails. At this point in the chain, we know the person is at least 4 years old because the first test failed. If the person is under 18, an appropriate message is printed and Python skips the else block. If both the if and elif tests fail, Python runs the code in the else block on line 7. In this example, the test on line 3 evaluates to False , so its code block is not executed. However, the second test evaluates to True (12 is less than 18) so its code is executed. The output is one sentence, informing the user of the admission cost: Your admission cost is $25. Any age greater than 17 would cause the first two tests to fail. In these situations, the else block would be executed and the admission price would be $40. Rather than printing the admission price within the if - elif - else block, it would be more concise to just set the price inside the if - elif - else chain and then have a simple print () call that runs after the chain has been evaluated: 1 2 3 4 5 6 7 8 9 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 else : price = 40 print ( f \"Your admission cost is $ { price } .\" ) Lines 4, 6, and 8 set the value of price according to the person's age, as in the previous example. After the price is set by the if - elif - else chain, a separate unindented print () call line 9 uses this value to display a message reporting the person's admission price. This code produces the same output as the previous example, but the purpose of the if - elif - else chain is narrower. Instead of determining a price and displaying a message, it simply determines the admission price. In addition to being more efficient, this revised code is easier to modify than the original approach. To change the text of the output message, you would need to change only one print () call rather than three separate print () calls. We can also get user input for age by using a int ( input ()) call in line 1 as follows: age = int ( input ( \"What is your age? \\n \" )) Note : we must use int ( input ) instead of just input () because it will error out when mathematical checks ( < ) are used on a string. Setting the input and an int will make the mathematical checks function correctly. Using Multiple elif Blocks You can use as many elif blocks in your code as you like. For example, if the amusement park were to implement a discount for seniors, you could add one more conditional test to the code to determine whether someone qualified for the senior discount. Let's say anyone 65 or older pays half the regular admission, or $20: 1 2 3 4 5 6 7 8 9 10 11 12 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 elif age < 65 : price = 40 else : price = 20 print ( f \"Your admission cost is $ { price } .\" ) Most of this code is unchanged. The second elif block on line 7 now checks to make sure a person is less than 65 before assigning them the full admission rate of $40. Notice that the value assigned in the else block on line 9 needs to be changed to $20, because the only ages that make it to this block are people 65 or older. Omitting the else Block Python does not require an else block at the end of an if - lif chain. Sometimes an else block is useful; sometimes it is clearer to use an additional elif statement that catches the specific condition of interest: 1 2 3 4 5 6 7 8 9 10 11 12 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 elif age < 65 : price = 40 elif age >= 65 : price = 20 print ( f \"Your admission cost is $ { price } .\" ) The extra elif block on line 9 assigns a price of $20 when the person is 65 or older, which is a bit clearer than the general else block. With this change, every block of code must pass a specific test in order to be executed. The else block is a catchall statement. It matches any condition that wasn't matched by a sepcific if or elif test, and that can sometimes include invalid or even malicious data. If you have a specific final confition you are testing for, consider using a file elif block and omit the else block. As a result, you'll gain extra confidence that your code will run only under the correct conditions. Testing Multiple Conditions The if - elif - else chain is powerful, but it's only appropriate to use it when you just need one test to pass. As soon as Python finds one test that passes, it skips the rest of the tests. This behavior is beneficial, because it's efficient and allows you to test for one specific condition. However, sometimes it is important to check all of the conditions of interest. In this case, you should use a series of simple if statments with no elif or else blocks. This technique makes sense when more than one condition should be True . Let's reconsider the pizzeria example. If someone requests a two-topping pizza, you'll need to be sure to include both toppings on their pizza: 1 2 3 4 5 6 7 8 9 10 requested_toppings = [ 'mushrooms' , 'extra cheese' ] if 'mushrooms' in requested_toppings : print ( \"Adding mushrooms.\" ) if 'pepperoni' in requested_toppings : print ( \"Adding pepperoni.\" ) if 'extra cheese' in requested_toppings : print ( \"Adding extra cheese.\" ) print ( \" \\n Finished making your pizza!\" ) We start with a list containing the requested toppings. The if statement at line 3 checks to see whether the person requested mushrooms on their pizza. If so, a message is printed confirming the topping. The test for pepperoni on like 5 is another simple if statement, not an elif or else statement, so this test runs regardless of whether the previous test passed or not. The code on like 7 checks whether extra cheese was requested regardless of the results of the first two tests. These three independent tests are executed every time this program is run. Because every condition in this example is evaluated, bot mushrooms and extra cheese are added to the pizza: Adding mushrooms. Adding extra cheese. Finished making your pizza! This code would not work properly if we used an if - elif - else block, because the code would stop working after only one test passes. In summary, if you want only one block of code to run, use an if - elif - else chain. If more than one code of block needs to run, use a series of independent if statements. Using if Statements with Lists You can do some interesting work when you combine lists and if statements. You can watch for special values that need to be treated differently than other values in the list. You can manage changing conditions efficiently, such as the availability of certain items i a restaurant throughout a shift. You can also begin to prove that your code works as you expect it to in all possible situations. Checking for Special Items Earlier, we covered how to handle a special value like 'bmw', which needed to be printed in a different format than other values in the list. Now that we have a basic understanding of conditional tests and if statements, let's take a closer look at how you can watch for special values in a list and handle those values appropriately. Let's continue with the pizzeria example. The pizzeria displays a message whenever a topping is added to your pizza, as it's being made. The code for this action can be written very efficiently by making a list of toppings the customer has requested and using a loop to announce each topping as it's added to the pizza: 1 2 3 4 5 6 requested_toppings = [ 'mushrooms' , 'green peppers' , 'extra cheese' ] for requested_topping in requested_toppings : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) The output is straightforward because the code is just a simple for loop: Adding mushrooms. Adding green peppers. Adding extra cheese. Finished making your pizza! But what if the pizzeria runs out of green peppers? An if statement inside the for loop can handle this situation appropriately: 1 2 3 4 5 6 7 8 9 requested_toppings = [ 'mushrooms' , 'green peppers' , 'extra cheese' ] for requested_topping in requested_toppings : if requested_topping == 'green peppers' : print ( \"Sorry, we are out of green peppers right now.\" ) else : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) This time we check each requested item before adding it to the pizza. The code at line 4 checks to see if the person requested green peppers. If so, we display a message that we are out of green peppers. The else block on line 6 ensures that all other toppings are added to the pizza. Checking that a List is Not Empty We've made a simple assumption about every list we've worked with so far; we've assumed that each list has at least one item in it. Soon we'll let users provide the information that's stored in a list, so we won't be able to assume that a list has any items in it each time a loop is run. In this situation, it's useful to check whether a list is empty before running a for loop. As an example, let's check whether the list of requested toppings is empty before building the pizza. If the list is empty, we'll prompt the use and make sure they want a plain pizza. If the list is not empty, we'll build the pizza just as we did in the previous examples: 1 2 3 4 5 6 7 8 requested_toppings = [] if requested_toppings : for requested_topping in requested_toppings : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) else : print ( \"Are you sure you want a plain pizza?\" ) This time we start out with an empty list. Instead of jumping right into the for loop, we do a quick check on line 3. When the name of a list is used in an if statement, Python returns True if the list contains at least one item; an empty list evaluates to False . If requested_toppings passes the conditional test, we run the same for loop we used in the previous example. If the conditional test fails, we print a message asking the customer if they really want a plain pizza with no toppings. Using Multiple Lists People will ask for just about anything, especially when it comes to pizza toppings. What if a customer wants french fries on their pizza? You can use lists and if statements to make sure your input makes sense before you act on it. Let's watch out for unusual topping requests before we build a pizza. The following example defines two lists. The first is a list of available toppings at the pizzeria, and the second is the list of toppings that the user has requested. This time, each item in requested_toppings is checked against the list of available toppings before it is added to the pizza: 1 2 3 4 5 6 7 8 9 10 11 available_toppings = [ 'mushrooms' , 'olives' , 'green peppers' , 'pepperoni' , 'pineapple' , 'extra cheese' ] requested_toppings = [ 'mushrooms' , 'french fries' , 'extra cheese' ] for requested_topping in requested_toppings : if requested_topping in available_toppings : print ( f \"Adding { requested_topping } .\" ) else : print ( f \"Sorry, we don't have { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) On line 1, we defined a list of available toppings. Next, on line 3, we created a list of requested toppings from the customer (Note the unusual request for 'french fries'). On line 5, we loop through the list of requested toppings. Inside the loop, we first check to see if each requested topping is actually in the list of available toppings. If it is, we add the topping to the pizza. If the requested topping is not available, we run the else block and print a message saying that the topping is not available.","title":"If Statements"},{"location":"py-if-statements/#if-statements","text":"Python often involves examining a set of conditions and deciding which action to take based on those conditions. Python's if statement allows you to examine the current state of a program and respond appropriately to that state.","title":"If Statements"},{"location":"py-if-statements/#a-simple-example","text":"The following short example shows how if tests let you respond to special situations correctly. Imagine you have a list of cars and you want to print out the name of each car. Car names are proper names, so the names of most cars should be printed in title case. However, the value 'bmw' should be printed in all uppercase. The following code loops through a list of car names and looks for the value 'bmw' . Whenever the value is 'bmw' , it's printed in uppercase instead of title case. 1 2 3 4 5 6 7 cars = [ 'audi' , 'bmw' , 'subaru' , 'toyota' ] for car in cars : if car == 'bmw' : print ( car . upper ()) else : print ( car . title ()) The loop in this example first checks to see if the current value of car is 'bmw' . If it is, the value is printed in all uppercase. If the value of car is anything other than 'bmw' , it's printed in title case: Audi BMW Subaru Toyota","title":"A Simple Example"},{"location":"py-if-statements/#conditional-tests","text":"At the heart of every if statement is an expression that canbe evaluated as True or False and is called a conditional test . Python uses the values True and False to decide whether the code in an if statement should be executed. If a conditional test evaluates to True , Python executes the code following the if statement. If the test evaluates to False , Python ignores the code following the if statement.","title":"Conditional Tests"},{"location":"py-if-statements/#checking-for-equality","text":"Most conditional tests compare the current value of a variable to a specific value of interest. The simplest conditional test checks whether the value of a variable is equal to the value of interest: 1 2 car = 'bmw' car == 'bmw' True The code at line 1 sets the value of car to 'bmw' using a single equal sign, as you've seen many times already. The code at line 2 checks whether the value of car is 'bmw' using a double equal sign ( == ). This equality operator returns True if the values on the left and right side of the operator match, and False if they don't match. The values in this example match, so Python returns True . When the value of car is anything other than 'bmw' , this test returns False . 1 2 car = 'audi' car == 'bmw' False A single equal sign is really a statment; you might read the code at line one as \"Set the value of car equal to 'audi' \". On the other side, a double equal sign, like the one on line 2, asks a question: \"Is the vale of car equal to 'bmw' ?\" Most programming languages use equal signs in this way.","title":"Checking for Equality"},{"location":"py-if-statements/#ignoring-case-when-checking-for-equality","text":"Testing for equality is case sensitive in Python. For example, ywo values with different capitalization are not considered equal: 1 2 car = 'Audi' car == 'audi' False If case matters, this behavior is advantageous. But if case doesn't matter and instead you just want to test the value of a variable, you can convert the variable's value to lowercase before doing the comparison: 1 2 car = 'Audi' car . lower () == 'audi' True This test would return True no matter how the value 'Audi' is formatted because the test is now case insensitive. The lower () function doesn't change the value that was originally stored in car , so you can do this kind of comparison without affecting the original variable: 1 2 car = 'Audi' car . lower () == 'audi' True 1 car 'Audi' At the first line 1, we assigned the capitalized string 'Audi' to the variable car . At line 2, we convert the value of car to lowercase and compare the lowercase value to the string 'audi' . The two strings match, so Python returns True . When we check what is stored in car again, we can see that it has not been affected by the lower () method. Websites enforce certain rules for the data that users enter in a manner similar to this. For example, a site might use a conditional test like this to ensure that every user has a truly unique username, not just a variation on the capitalization of another person's username. When someone submits a username, that new username is converted to lowercase and compared to the lowercase versions of all existing usernames. During this check, a username like 'John' will be rejected if any variation of 'john' is already in use.","title":"Ignoring Case When Checking for Equality"},{"location":"py-if-statements/#checking-for-inequality","text":"When you want to determine whether two values are not equal, you can combine an exclamation point and an equal sign (!=). The exclamation point represents not , as it does in many programming languages. Let's use another if statement to examine how to use the inequality operator. We'll store a requested pizza topping in a variable and then print a message if the person did not order anchovies: 1 2 3 4 requested_topping = 'mushrooms' if requested_topping != 'anchovies' : print ( \"Hold the anchovies!\" ) The code on line 3 compares the value of requested_topping to the value anchovies . If these two values do not match, Python returns True and executes the code following the if statement. If the two values match, Python returns False and does not run the code following the if statement. Because the value of requested_topping is not anchovies , the print () function is executed: Hold the anchovies! Most of the conditional expressions you write will test for equality, but sometimes you'll find it more efficient to test for inequality.","title":"Checking for Inequality"},{"location":"py-if-statements/#numerical-comparisons","text":"Testing numerical values is pretty straightforward. For example, the following code checks whether a person is 18 years old: 1 2 age = '18' age == '18' True You can also test to see if two numbers are not equal. For example, the following code prints a message if the given answer is not correct: 1 2 3 4 answer = 17 if answer != 42 : print ( \"That is not the correct answer. Please try again!\" ) The conditional test at line 3 passes, because the value of answer (17) is not equal to 42. Because the test passes, the indented code block is executed. You can include various mathematical comparisons in your conditional statements as well, such as less than, less than or equal to, greater than, and greater than or equal to.","title":"Numerical Comparisons"},{"location":"py-if-statements/#checking-multiple-conditions","text":"You may want to check multiple conditions at the same time. For example, sometimes you might need two conditions to be True to take an action. Other times you might be satisfied with just one condition being True . The keywords and and or can help you in these situations.","title":"Checking Multiple Conditions"},{"location":"py-if-statements/#using-and-to-check-multiple-conditions","text":"To check whether two conditions are both True simultaneously, use the keyword and to combine the two conditional tests; if each test passes, the overall expression evaluates to True . If either test fails or if both tests fail, the expression evaluates to False . For example, you can check whether two people are both over 21 using the following test: 1 2 3 age_0 = 22 age_1 = 18 age_0 >= 21 and age_1 >= 21 False On line 1, we define two ages, age_0 and age_1 . On line 3, we check whether both ages are 21 or older. The test on the left passes, but the one on the right fails, so the overall conditional expression evaluates to False . 1 2 age_1 = 22 age_0 >= 21 and age_1 >= 21 True On line 1, we change age_1 to 22. The value of age_1 is now greater than 21, so both individual tests pass, causing the overal conditional expression to evaluate as True . To improve readability, you can use parentheses around the individual tests, but they are not required. If you use parentheses, your test would look like this: 1 ( age_0 >= 21 ) and ( age_1 >= 21 )","title":"Using and to Check Multiple Conditions"},{"location":"py-if-statements/#using-or-to-check-multiple-conditions","text":"The keyword or allows you to check multiple conditions as well, but it passes when either or both of the individual test pass. As or expression fails onl when both individual tests fail. Let's consider two ages again, but this time we'll look for only one person to be over 21: age_0 = 22 age_1 = 18 age_0 >= 21 or age_1 >= 21 True We start with two variables again at line 1. Because the test for age_0 at line 3 passes, the overall expression evaluates to True . age_0 = 18 age_0 >= 21 or age_1 >= 21 We now lowe age_0 to 18. In the test at line 2, both tests now fail and the overall expression evaluates to False .","title":"Using or to Check Multiple Conditions"},{"location":"py-if-statements/#checking-whether-a-value-is-in-a-list","text":"Sometimes it is important to check whether a list contains a certain value before taking an action. For example, you might want to check whether a new username already exists in a list of current usernames before completeing someone's registration on a webstie. In a mapping project, you might want to check whether a submitted location already exists in a list of known locations. To find out whether a particular value is already in a list, use the keyword in . Let's consider some code you might write for a pizzeria. We'll make a list of toppings a customer has requested for a pizza and then check whether certain toppings are in the list. requested_toppings = [ 'mushrooms' , 'onions' , 'pineapple' ] 'mushrooms' in requested_toppings True 'pepperoni' in requested_toppings False We told Python to check for the existence of 'mushrooms' and 'pepperoni' in the list requested_toppings . This technique is quite powerful because you can create a list of essential values, and then easily check whether the value you're testing matches one of the values in the list.","title":"Checking Whether a Value Is in a List"},{"location":"py-if-statements/#checking-whether-a-value-is-not-in-a-list","text":"Other times, it's important to know if a value does not appear in a list. You can use the keyword not in this situation. For example, consider a list of users who are banned from commenting in a forum. You can check whether a user has been banned before allowing that user to submit a comment: 1 2 3 4 5 banned_users = [ 'andrew' , 'carolina' , 'david' ] user = 'marie' if user not in banned_users : print ( f \" { user . title () } , you can post a response if you wish.\" ) The code on line 4 reads quite clearly. If the value of user is not in the list of banned_users , Python returns True and execites the indented line. The user 'marie' is not in the list banned_users , so she sees a message inviting her to post a response: Marie, you can post a response if you wish.","title":"Checking Whether a Value is Not in a List"},{"location":"py-if-statements/#boolean-expressions","text":"A Boolean expression is just another name for a condtitional test. A Boolean value is either True or False , just like the value of a conditional expression after it has been evaluated. Boolean values are often used to keep track of certain conditions, such as whether a game is running or whether a user can edit certain content on a website. game_active = True can_edit = False","title":"Boolean Expressions"},{"location":"py-if-statements/#if-statements_1","text":"When you understand conditional tests, you can start writing if statements. Several different kinds of if statments exist, and your choice of which to use depends on the number of conditions you need to test. You saw several examples of if statments in the discussion about conditional tests, but now let's dif deeper into the topic.","title":"if Statements"},{"location":"py-if-statements/#simple-if-statements","text":"The simplest kind of if statment has one test and one action: if conditional_test : do something You can put any conditional test in the first line and just about any action in the indented block following the test. If the condtional test evaluates to True , Python executes the code following the if statement. If the test evaluates to False , Python ignores the code following the if statement. Let's say we have a variable representing a person's age, and we want to know if that person is old enough to vote. The following code tests whether the person can vote: 1 2 3 age = 19 if age >= 18 : print ( \"You are old enough to vote!\" ) On line 2, Python checks to see whether the value of age is greater than or equal to 18. It is, so Python executes the indented print () call on line 3: You are old enough to vote! Indentation plays the same role in if statements as it did in for loops. All indented lines after an if statement will be executed if the test passes, and the entire block if indented lines will be ignored if the test does not pass. You can have as many lines of code as you want in the block following the #!py if` statement. Let's add another line of output if the person is old enough to vote, asking if the individual has registered to vote yet: 1 2 3 4 age = 19 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registeredto vote yet?\" ) The conditional test passes, and both print () calls are indented, so both lines are printed: You are old enough to vote! Have you registered to vote yet? If the value of age is less than 18, this program would produce no output.","title":"Simple if Statements"},{"location":"py-if-statements/#if-else-statements","text":"Often, you'll want to take one action when a conditional test passes and a different action in all other cases. Python's if else syntax makes this possible. An if else block is similar to a simple if statement, but the else statement allows you to define an action or set of actions that are executed when the conditional test fails. We'll display the same message we had previously if the person is old enough to vote, but this time we'll add a message for anyone who is not old enough to vote: 1 2 3 4 5 6 7 age = 17 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registeredto vote yet?\" ) else : print ( \"Sorry, you are too younng to vote.\" ) print ( \"Please register as soon as you turn 18!\" ) If the conditional test on line 2 passes, the first block of indented print () calls are executed. If the test evaluates to False , the else block on line 5 is executed. Because age is less than 18 this time, the conditional test fails and the code in the else block is executed. This code works because it only has two possible situations to evaluate: a person is either old enough to vote or not old enough to vote. The if - else structure works well in situation in which you want Python to always execute one of two possible actions. In a simple if - else chain like this, one of the two actions will always be executed.","title":"if else Statements"},{"location":"py-if-statements/#the-if-elif-else-chain","text":"Often, you'll need to test more than two possible situations, and to evaluate these you can use Python's if - elif - else syntax. Python executes only one block in an if - elif - else chain. It runs each conditional test in order until one passes. When a test passes, the code following that test is executed and Python skips the rest of the test. Many real-world situations involve more than two possible conditions. For example, consider an amusement park that charges different rates for different age groups: Admission for anyone under age 4 is free. Admission for anyone between the ages of 4 and 18 is $25. Admission for anyone age 18 or older is $40. How can we use an if statement to determine a person's admission rate? The following code tests for the age group of a person and then prints an admission price message: 1 2 3 4 5 6 7 8 age = 12 if age < 4 : print ( \"Your admission cost is $0.\" ) elif age < 18 : print ( \"Your admission cost is $25.\" ) else : print ( \"Your admission cost is $40.\" ) The if test on line 3 tests whether a person is under 4 years old. If the test passes, an appropriate message is printed an Python skips the rest of the tests. The elif code on line 5 is really another if test, which runs only if the previous test fails. At this point in the chain, we know the person is at least 4 years old because the first test failed. If the person is under 18, an appropriate message is printed and Python skips the else block. If both the if and elif tests fail, Python runs the code in the else block on line 7. In this example, the test on line 3 evaluates to False , so its code block is not executed. However, the second test evaluates to True (12 is less than 18) so its code is executed. The output is one sentence, informing the user of the admission cost: Your admission cost is $25. Any age greater than 17 would cause the first two tests to fail. In these situations, the else block would be executed and the admission price would be $40. Rather than printing the admission price within the if - elif - else block, it would be more concise to just set the price inside the if - elif - else chain and then have a simple print () call that runs after the chain has been evaluated: 1 2 3 4 5 6 7 8 9 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 else : price = 40 print ( f \"Your admission cost is $ { price } .\" ) Lines 4, 6, and 8 set the value of price according to the person's age, as in the previous example. After the price is set by the if - elif - else chain, a separate unindented print () call line 9 uses this value to display a message reporting the person's admission price. This code produces the same output as the previous example, but the purpose of the if - elif - else chain is narrower. Instead of determining a price and displaying a message, it simply determines the admission price. In addition to being more efficient, this revised code is easier to modify than the original approach. To change the text of the output message, you would need to change only one print () call rather than three separate print () calls. We can also get user input for age by using a int ( input ()) call in line 1 as follows: age = int ( input ( \"What is your age? \\n \" )) Note : we must use int ( input ) instead of just input () because it will error out when mathematical checks ( < ) are used on a string. Setting the input and an int will make the mathematical checks function correctly.","title":"The if-elif-else Chain"},{"location":"py-if-statements/#using-multiple-elif-blocks","text":"You can use as many elif blocks in your code as you like. For example, if the amusement park were to implement a discount for seniors, you could add one more conditional test to the code to determine whether someone qualified for the senior discount. Let's say anyone 65 or older pays half the regular admission, or $20: 1 2 3 4 5 6 7 8 9 10 11 12 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 elif age < 65 : price = 40 else : price = 20 print ( f \"Your admission cost is $ { price } .\" ) Most of this code is unchanged. The second elif block on line 7 now checks to make sure a person is less than 65 before assigning them the full admission rate of $40. Notice that the value assigned in the else block on line 9 needs to be changed to $20, because the only ages that make it to this block are people 65 or older.","title":"Using Multiple elif Blocks"},{"location":"py-if-statements/#omitting-the-else-block","text":"Python does not require an else block at the end of an if - lif chain. Sometimes an else block is useful; sometimes it is clearer to use an additional elif statement that catches the specific condition of interest: 1 2 3 4 5 6 7 8 9 10 11 12 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 elif age < 65 : price = 40 elif age >= 65 : price = 20 print ( f \"Your admission cost is $ { price } .\" ) The extra elif block on line 9 assigns a price of $20 when the person is 65 or older, which is a bit clearer than the general else block. With this change, every block of code must pass a specific test in order to be executed. The else block is a catchall statement. It matches any condition that wasn't matched by a sepcific if or elif test, and that can sometimes include invalid or even malicious data. If you have a specific final confition you are testing for, consider using a file elif block and omit the else block. As a result, you'll gain extra confidence that your code will run only under the correct conditions.","title":"Omitting the else Block"},{"location":"py-if-statements/#testing-multiple-conditions","text":"The if - elif - else chain is powerful, but it's only appropriate to use it when you just need one test to pass. As soon as Python finds one test that passes, it skips the rest of the tests. This behavior is beneficial, because it's efficient and allows you to test for one specific condition. However, sometimes it is important to check all of the conditions of interest. In this case, you should use a series of simple if statments with no elif or else blocks. This technique makes sense when more than one condition should be True . Let's reconsider the pizzeria example. If someone requests a two-topping pizza, you'll need to be sure to include both toppings on their pizza: 1 2 3 4 5 6 7 8 9 10 requested_toppings = [ 'mushrooms' , 'extra cheese' ] if 'mushrooms' in requested_toppings : print ( \"Adding mushrooms.\" ) if 'pepperoni' in requested_toppings : print ( \"Adding pepperoni.\" ) if 'extra cheese' in requested_toppings : print ( \"Adding extra cheese.\" ) print ( \" \\n Finished making your pizza!\" ) We start with a list containing the requested toppings. The if statement at line 3 checks to see whether the person requested mushrooms on their pizza. If so, a message is printed confirming the topping. The test for pepperoni on like 5 is another simple if statement, not an elif or else statement, so this test runs regardless of whether the previous test passed or not. The code on like 7 checks whether extra cheese was requested regardless of the results of the first two tests. These three independent tests are executed every time this program is run. Because every condition in this example is evaluated, bot mushrooms and extra cheese are added to the pizza: Adding mushrooms. Adding extra cheese. Finished making your pizza! This code would not work properly if we used an if - elif - else block, because the code would stop working after only one test passes. In summary, if you want only one block of code to run, use an if - elif - else chain. If more than one code of block needs to run, use a series of independent if statements.","title":"Testing Multiple Conditions"},{"location":"py-if-statements/#using-if-statements-with-lists","text":"You can do some interesting work when you combine lists and if statements. You can watch for special values that need to be treated differently than other values in the list. You can manage changing conditions efficiently, such as the availability of certain items i a restaurant throughout a shift. You can also begin to prove that your code works as you expect it to in all possible situations.","title":"Using if Statements with Lists"},{"location":"py-if-statements/#checking-for-special-items","text":"Earlier, we covered how to handle a special value like 'bmw', which needed to be printed in a different format than other values in the list. Now that we have a basic understanding of conditional tests and if statements, let's take a closer look at how you can watch for special values in a list and handle those values appropriately. Let's continue with the pizzeria example. The pizzeria displays a message whenever a topping is added to your pizza, as it's being made. The code for this action can be written very efficiently by making a list of toppings the customer has requested and using a loop to announce each topping as it's added to the pizza: 1 2 3 4 5 6 requested_toppings = [ 'mushrooms' , 'green peppers' , 'extra cheese' ] for requested_topping in requested_toppings : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) The output is straightforward because the code is just a simple for loop: Adding mushrooms. Adding green peppers. Adding extra cheese. Finished making your pizza! But what if the pizzeria runs out of green peppers? An if statement inside the for loop can handle this situation appropriately: 1 2 3 4 5 6 7 8 9 requested_toppings = [ 'mushrooms' , 'green peppers' , 'extra cheese' ] for requested_topping in requested_toppings : if requested_topping == 'green peppers' : print ( \"Sorry, we are out of green peppers right now.\" ) else : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) This time we check each requested item before adding it to the pizza. The code at line 4 checks to see if the person requested green peppers. If so, we display a message that we are out of green peppers. The else block on line 6 ensures that all other toppings are added to the pizza.","title":"Checking for Special Items"},{"location":"py-if-statements/#checking-that-a-list-is-not-empty","text":"We've made a simple assumption about every list we've worked with so far; we've assumed that each list has at least one item in it. Soon we'll let users provide the information that's stored in a list, so we won't be able to assume that a list has any items in it each time a loop is run. In this situation, it's useful to check whether a list is empty before running a for loop. As an example, let's check whether the list of requested toppings is empty before building the pizza. If the list is empty, we'll prompt the use and make sure they want a plain pizza. If the list is not empty, we'll build the pizza just as we did in the previous examples: 1 2 3 4 5 6 7 8 requested_toppings = [] if requested_toppings : for requested_topping in requested_toppings : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) else : print ( \"Are you sure you want a plain pizza?\" ) This time we start out with an empty list. Instead of jumping right into the for loop, we do a quick check on line 3. When the name of a list is used in an if statement, Python returns True if the list contains at least one item; an empty list evaluates to False . If requested_toppings passes the conditional test, we run the same for loop we used in the previous example. If the conditional test fails, we print a message asking the customer if they really want a plain pizza with no toppings.","title":"Checking that a List is Not Empty"},{"location":"py-if-statements/#using-multiple-lists","text":"People will ask for just about anything, especially when it comes to pizza toppings. What if a customer wants french fries on their pizza? You can use lists and if statements to make sure your input makes sense before you act on it. Let's watch out for unusual topping requests before we build a pizza. The following example defines two lists. The first is a list of available toppings at the pizzeria, and the second is the list of toppings that the user has requested. This time, each item in requested_toppings is checked against the list of available toppings before it is added to the pizza: 1 2 3 4 5 6 7 8 9 10 11 available_toppings = [ 'mushrooms' , 'olives' , 'green peppers' , 'pepperoni' , 'pineapple' , 'extra cheese' ] requested_toppings = [ 'mushrooms' , 'french fries' , 'extra cheese' ] for requested_topping in requested_toppings : if requested_topping in available_toppings : print ( f \"Adding { requested_topping } .\" ) else : print ( f \"Sorry, we don't have { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) On line 1, we defined a list of available toppings. Next, on line 3, we created a list of requested toppings from the customer (Note the unusual request for 'french fries'). On line 5, we loop through the list of requested toppings. Inside the loop, we first check to see if each requested topping is actually in the list of available toppings. If it is, we add the topping to the pizza. If the requested topping is not available, we run the else block and print a message saying that the topping is not available.","title":"Using Multiple Lists"},{"location":"py-lists/","text":"Lists What is a List? A list is a collection of items in a particular order. You can make a list that includes the letters of the alphabet, the digits from 0-9, or the names of people in your family. You can put anything into a list, and the items in your list don't have to be related in any particular way. Because a list usually contains more than one element, it's a good idea to make the name of your list plural, such as letters , digits , or names . In Python, square brackets ([ ]) indicate a list, and individual elements in the list are separated by commas. Here is a simple example of a list that contains a few kinds of bicylces: 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces ) If you ask Python to print a list, Python returns its representation of the list, including the square brackets: 1 [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] Because this isn't the output you want your users to see, let's learn how to access the individual items in a list. Accessing Elements in a List Lists are ordered collections, so you can access any element in a list by telling Python the position, or index , of the item desired. To access an elemenet in a list, write the name of the list followed by the index of the item enclosed in square brackets. For example, let's pull out the first bicycle in the list bicycles : 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces [ 0 ]) Index Positions Just like in C, and most other programming languages, index positions start at 0, not 1 . This is usually something that takes some time for beginner programmers to commit to memory. It is also useful to remember that you can count backwards in a list as well, with the last element in a list being located at position [-1]. When you print out a single item from a list, Python will return just that element without square brackets: 1 trek We can also use the . title () method, discussed in variables and simple data types . This will capitalize the first letter of the element: 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces [ 0 ] . title ()) The above example would print out the first element as follows: 1 Trek Using Individual Values from a List You can use individual values from a list just as you would any other variable. For example, you can use f-strings to create a message based on a value from a list. Let's try pulling the first bicycly from the list and composing a message using that value: 1 2 3 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] message = f \"My first bicycle was a { bicycles [ 0 ] . title () } .\" print ( message ) This code would have the following output: My first bicycles was a Trek. Changing, Adding, and Removing Elements Most lists you create will be dynamic, meaning you'll build a list and then add and remove elements from it as your program runs its course. For example, you might create a game in which a player has to shoot aliens out of the sky. You could store the initial set of aliens in a list and then remove an alien from the list each time one is shot down. Each time a new alien appears on the screen, you add it to the list. Your list of aliens will increase and decrease in length throughout the course of the game. Modifying Elements in a List The syntax for modifying an element is similar to the syntax for accessing an element in a list . To change an element, use the name of the list followed by the index of the element you want to change, and then provide the new value you want that item to have. For example, let's say we have a list of motorcycles, and the first item in the list is 'honda' . How would we go about changing the value of the first item? 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) motorcycles [ 0 ] = 'ducati' print ( motorcycles ) The first code set defines the original list, with 'honda' as the first element. The second code set changes the value of the first item ( [0] ) to 'ducati' . The output shows the first item ahs indeed been changed, and the rest of the list stays the same. ['honda', 'yamaha', 'suzuki'] ['ducati', 'yamaha', 'suzuki'] Note: You can change the value of any item in a list, not just the first. Adding Elements to a List You might want to add a new element to a list for many reasons. For example, you might want to make new aliend appear in a game, add new data to a visualization, or add new registered users to a website you've built. Python provides several ways to add new data to existing lists. Appending Elements to the End of a List The simplest way to add a new element to a list is to append the item to the list. When you append an item to a list, the new element is added to the end of the list. Using the same list we had in the previous example, we'll add the new element 'ducati' to the end of the list: 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) motorcycles . append ( 'ducati' ) print ( motorcycles ) The append() method adds 'ducati' to the end of the list without affecting any of the other elements in the list: ['honda', 'yamaha', 'suzuki'] ['honda', 'yamaha', 'suzuki', 'ducati'] The append () method makes it easy to build lists dynamically. For example, you can start with an empty list and then add items to the list using a series of append() calls. Using an empty list, let\u2019s add the elements 'honda' , 'yamaha' , and 'suzuki' to the list: 1 2 3 4 5 6 7 motorcycles = [] motorcycles . append ( 'honda' ) motorcycles . append ( 'yamaha' ) motorcycles . append ( 'suzuki' ) print ( motorcycles ) The resulting list looks exactly the same as the lists in previous examples: ['honda', 'yamaha', 'suzuki'] Building lists this way is very common, because you often won\u2019t know the data your users want to store in a program until after the program is running. To put your users in control, start by defining an empty list that will hold the users\u2019 values. Then append each new value provided to the list you just created. Inserting Elements into a List You can also add a new element at any position in your list by using the insert () method. You do this by specifying the index of the new element and the value of the new item: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] motorcycles . insert ( 0 , 'ducati' ) print ( motorcycles ) The above code inserts the value 'ducati' at position 0 . So running this program will have the following output: ['ducati', 'honda', 'yamaha', 'suzuki'] Removing Elements from a List Often, you'll want to remove an item or a set of items from a list. You can remove an item according to its position in the list or according to its value. Removing an Item using the del Statement If you know the position of the item you want to remove from a list, you can use the del statement. 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) del motorcycles [ 0 ] print ( motorcycles ) The del statement will remove the item at index [0] from the list motorcycles . If you were to run the above code you would get the following result: ['honda', 'yamaha', 'suzuki'] ['yamaha', 'suzuki'] Removing an Item using the pop () Method Sometimes you'll want to use the value of an item after you remove it from a list. For example, you might want to get the x and y position of an alien that was just shot down, so you can draw an explosion at that position. In a web application, you might want to remove a user from a list of active member and then add that user to a list of inactive members. The pop () method removes the last item in a list, but it lets you work with them after removing it. The term pop comes from thinking of a list as a stack of items and popping one item off the top of a stack. In this analogy, the top of a stack corresponds to the end of a list. Let's pop a motorcycle from a list of motorcycles: 1 2 3 4 5 6 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) popped_motorcycle = motorcycles . pop () print ( motorcycles ) print ( popped_motorcycle ) We start by defining and printing the list motorcycles . Next, we pop a value ( suzuki ) from the list and store that value in the variable popped_motorcycle . Finally, we print the lists to show that a value has been successfully removed from the initial list. Then we print the popped list and prove we still have access to it. The above code would yield the following result: ['honda', 'yamaha', 'suzuki'] ['honda', 'yamaha'] suzuki How might this pop () method be useful? Imagine that the motorcycles in the list are store in chronological order according to when we owned them. If this is the case, we can use the pop () method to print a statement about the last motorcycle we bought: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] last_owned = motorcycles . pop () print ( f \"The last motorcycle I owned was a { last_owned . title () } .\" ) The output of the above would be: The last motorcycle I owned was a Suzuki. Popping Items from any Position in a List We can use pop () to remove an item from any position in a list by including the index of the item you want to remove in parenthese: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] first_owned = motorcycles . pop ( 0 ) print ( f \"The first motorcycle I owned was a { first_owned . title () } .\" ) We start by popping the first motorcycle in the list (located at index 0 ), and then we print a message about the motorcycle. The output is a simple sentence describing the first motorcycle owned: The first motorcycle I owned was a Honda Remember that each time we use pop () , the item we were working with is no longer stored in the list. When to use del or pop () When you want to delete an item from a list and not use that item in any way, use the del statement; if you want to use an item as you remove it, use the pop () method. Removing an Item by Value Sometimes you won't know the position of the value you want to remove from a list. If you only know the value of the item you want to remove, you can use the remove () method. For example, let's say we want to remove the value 'ducati' from the list of motorcycles: 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' , 'ducati' ] print ( motorcycles ) motorcycles . remove ( 'ducati' ) print ( motorcycles ) The above code tells Python to find and remove 'ducati' from within the motorcycles list. It would give the following result when ran: ['honda', 'yamaha', 'suzuki', 'ducati'] ['honda', 'yamaha', 'suzuki'] You can also use the remove () method to work with a value that's being removed form a list. Let's remove the value 'ducati' and print a reason for removing it from the list: 1 2 3 4 5 6 7 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' , 'ducati' ] print ( motorcycles ) too_expensive = 'ducati' motorcycles . remove ( too_expensive ) print ( motorcycles ) print ( f \" \\n A { too_expensive . title () } is too expensive for me.\" ) After defining the list on line 1, we assign the value 'ducati' to a variable called too_expensive . We then use this variable to tell Python which value to remove from the list. 'ducati' is removed from the list, but is still accessible through the variable too_expensive , allowing us to print a statement about why we removed 'ducati' from the list of motorcycles. The code above would have the following output: ['honda', 'yamaha', 'suzuki', 'ducati'] ['honda', 'yamaha', 'suzuki'] A Ducati is too expensive for me. Note on remove () The remove() method deletes only the first occurrence of the value you specify. If there\u2019s a possibility the value appears more than once in the list, you\u2019ll need to use a loop to make sure all occurrences of the value are removed. Organizing a List Often, your lists will be created in an unpredictable order, because you can't always control the order in which your users provide their data. Although this is unavoidable in most circumstances, you'll frequently want to present your information in a particular order. Sometimes you'll want to preserve the original order of your list, and other times you'll want to change the original order. Python provides a number of different ways to organize your lists, depending on the situation. Sorting a List Permanently with the sort () Method Python's sort () method makes it relatively easy to sort a list. Imagine we have a list of cars and want to change the order of the list to store them alphabetically. To keep the task simple, let's assume that all the values in the list are lowercase: 1 2 3 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] cars . sort () print ( cars ) The sort () method, shown above changes the order of the list permanently. The cars are now in alphabetical order, and we can never revert to the original order: ['audi', 'bmw', 'subaru', 'toyota'] You can also sort this list in reverse alphabetical order by passing the argument reverse = True to the sort () method. The following example sorts the list of cars in reverse alphabetical order: 1 2 3 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] cars . sort ( reverse = True ) print ( cars ) Sorting a List Temporarily with the sorted () Function To maintain the original order of a list but present it in a sorted order, you can use the sorted () function. The sorted () function lets you display your list in a particular order but doesn't affect the actual order of the list. Let's try this function on the list of cars: 1 2 3 4 5 6 7 8 9 10 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] print ( \"Here is the orginal list:\" ) print ( cars ) print ( \" \\n Here is the sorted list:\" ) print ( sorted ( cars )) print ( \" \\n Here is the original list again:\" ) print ( cars ) This should have the following output: Here is the orginal list: ['bmw', 'audi', 'toyota', 'subaru'] Here is the sorted list: ['audi', 'bmw', 'subaru', 'toyota'] Here is the original list again: ['bmw', 'audi', 'toyota', 'subaru'] Note on Sorting Sorting a list alphabetically is a bit more complicated when all the values are not in lowercase. There are several ways to interpret capital letters when determining a sort order, and specifying the exact order can be more complex than we want to deal with at this time. Printing a List in Reverse Order To reverse the original order of a list, we can use the reverse () method. If we originally stored the list of cars in chronological order according to when we owned them, we could easily rearrange the list into reverse chronological order: 1 2 3 4 5 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] print ( cars ) cars . reverse () print ( cars ) After running this code will will get the following result: ['bmw', 'audi', 'toyota', 'subaru'] ['subaru', 'toyota', 'audi', 'bmw'] The reverse () method changes the order of a list permanently, but you can always simply run the reverse () function again to get back to the original order. Finding the Length of a List You can quickly find the length of a list by using the len () funtion. The list in this example has four items, so the output will be the integer 4: 1 2 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] len ( cars ) Avoiding Index Errors When Working with Lists One type of error is common when you're working with lists for the first time. Let's say we have a list with three items, and you ask for the fourth item: 1 2 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles [ 3 ]) Running this code results in an index error : 1 2 3 4 5 6 7 --------------------------------------------------------------------------- IndexError Traceback ( most recent call last ) < ipython - input - 10 - 9811709 cfb18 > in < module > 1 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] ----> 2 print ( motorcycles [ 3 ]) IndexError : list index out of range Python attempts to give you the item at index 3 , but when it searches the list, there is no item in index 3 in motorcycles . You must remember that indexing starts at 0 in Python. Note on Index Errors If an index error occurs and you can\u2019t figure out how to resolve it, try printing your list or just printing the length of your list. Your list might look much different than you thought it did, especially if it has been managed dynamically by your program. Seeing the actual list, or the exact number of items in your list, can help you sort out such logical errors.","title":"Lists"},{"location":"py-lists/#lists","text":"","title":"Lists"},{"location":"py-lists/#what-is-a-list","text":"A list is a collection of items in a particular order. You can make a list that includes the letters of the alphabet, the digits from 0-9, or the names of people in your family. You can put anything into a list, and the items in your list don't have to be related in any particular way. Because a list usually contains more than one element, it's a good idea to make the name of your list plural, such as letters , digits , or names . In Python, square brackets ([ ]) indicate a list, and individual elements in the list are separated by commas. Here is a simple example of a list that contains a few kinds of bicylces: 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces ) If you ask Python to print a list, Python returns its representation of the list, including the square brackets: 1 [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] Because this isn't the output you want your users to see, let's learn how to access the individual items in a list.","title":"What is a List?"},{"location":"py-lists/#accessing-elements-in-a-list","text":"Lists are ordered collections, so you can access any element in a list by telling Python the position, or index , of the item desired. To access an elemenet in a list, write the name of the list followed by the index of the item enclosed in square brackets. For example, let's pull out the first bicycle in the list bicycles : 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces [ 0 ]) Index Positions Just like in C, and most other programming languages, index positions start at 0, not 1 . This is usually something that takes some time for beginner programmers to commit to memory. It is also useful to remember that you can count backwards in a list as well, with the last element in a list being located at position [-1]. When you print out a single item from a list, Python will return just that element without square brackets: 1 trek We can also use the . title () method, discussed in variables and simple data types . This will capitalize the first letter of the element: 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces [ 0 ] . title ()) The above example would print out the first element as follows: 1 Trek","title":"Accessing Elements in a List"},{"location":"py-lists/#using-individual-values-from-a-list","text":"You can use individual values from a list just as you would any other variable. For example, you can use f-strings to create a message based on a value from a list. Let's try pulling the first bicycly from the list and composing a message using that value: 1 2 3 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] message = f \"My first bicycle was a { bicycles [ 0 ] . title () } .\" print ( message ) This code would have the following output: My first bicycles was a Trek.","title":"Using Individual Values from a List"},{"location":"py-lists/#changing-adding-and-removing-elements","text":"Most lists you create will be dynamic, meaning you'll build a list and then add and remove elements from it as your program runs its course. For example, you might create a game in which a player has to shoot aliens out of the sky. You could store the initial set of aliens in a list and then remove an alien from the list each time one is shot down. Each time a new alien appears on the screen, you add it to the list. Your list of aliens will increase and decrease in length throughout the course of the game.","title":"Changing, Adding, and Removing Elements"},{"location":"py-lists/#modifying-elements-in-a-list","text":"The syntax for modifying an element is similar to the syntax for accessing an element in a list . To change an element, use the name of the list followed by the index of the element you want to change, and then provide the new value you want that item to have. For example, let's say we have a list of motorcycles, and the first item in the list is 'honda' . How would we go about changing the value of the first item? 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) motorcycles [ 0 ] = 'ducati' print ( motorcycles ) The first code set defines the original list, with 'honda' as the first element. The second code set changes the value of the first item ( [0] ) to 'ducati' . The output shows the first item ahs indeed been changed, and the rest of the list stays the same. ['honda', 'yamaha', 'suzuki'] ['ducati', 'yamaha', 'suzuki'] Note: You can change the value of any item in a list, not just the first.","title":"Modifying Elements in a List"},{"location":"py-lists/#adding-elements-to-a-list","text":"You might want to add a new element to a list for many reasons. For example, you might want to make new aliend appear in a game, add new data to a visualization, or add new registered users to a website you've built. Python provides several ways to add new data to existing lists.","title":"Adding Elements to a List"},{"location":"py-lists/#appending-elements-to-the-end-of-a-list","text":"The simplest way to add a new element to a list is to append the item to the list. When you append an item to a list, the new element is added to the end of the list. Using the same list we had in the previous example, we'll add the new element 'ducati' to the end of the list: 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) motorcycles . append ( 'ducati' ) print ( motorcycles ) The append() method adds 'ducati' to the end of the list without affecting any of the other elements in the list: ['honda', 'yamaha', 'suzuki'] ['honda', 'yamaha', 'suzuki', 'ducati'] The append () method makes it easy to build lists dynamically. For example, you can start with an empty list and then add items to the list using a series of append() calls. Using an empty list, let\u2019s add the elements 'honda' , 'yamaha' , and 'suzuki' to the list: 1 2 3 4 5 6 7 motorcycles = [] motorcycles . append ( 'honda' ) motorcycles . append ( 'yamaha' ) motorcycles . append ( 'suzuki' ) print ( motorcycles ) The resulting list looks exactly the same as the lists in previous examples: ['honda', 'yamaha', 'suzuki'] Building lists this way is very common, because you often won\u2019t know the data your users want to store in a program until after the program is running. To put your users in control, start by defining an empty list that will hold the users\u2019 values. Then append each new value provided to the list you just created.","title":"Appending Elements to the End of a List"},{"location":"py-lists/#inserting-elements-into-a-list","text":"You can also add a new element at any position in your list by using the insert () method. You do this by specifying the index of the new element and the value of the new item: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] motorcycles . insert ( 0 , 'ducati' ) print ( motorcycles ) The above code inserts the value 'ducati' at position 0 . So running this program will have the following output: ['ducati', 'honda', 'yamaha', 'suzuki']","title":"Inserting Elements into a List"},{"location":"py-lists/#removing-elements-from-a-list","text":"Often, you'll want to remove an item or a set of items from a list. You can remove an item according to its position in the list or according to its value.","title":"Removing Elements from a List"},{"location":"py-lists/#removing-an-item-using-the-del-statement","text":"If you know the position of the item you want to remove from a list, you can use the del statement. 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) del motorcycles [ 0 ] print ( motorcycles ) The del statement will remove the item at index [0] from the list motorcycles . If you were to run the above code you would get the following result: ['honda', 'yamaha', 'suzuki'] ['yamaha', 'suzuki']","title":"Removing an Item using the del Statement"},{"location":"py-lists/#removing-an-item-using-the-pop-method","text":"Sometimes you'll want to use the value of an item after you remove it from a list. For example, you might want to get the x and y position of an alien that was just shot down, so you can draw an explosion at that position. In a web application, you might want to remove a user from a list of active member and then add that user to a list of inactive members. The pop () method removes the last item in a list, but it lets you work with them after removing it. The term pop comes from thinking of a list as a stack of items and popping one item off the top of a stack. In this analogy, the top of a stack corresponds to the end of a list. Let's pop a motorcycle from a list of motorcycles: 1 2 3 4 5 6 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) popped_motorcycle = motorcycles . pop () print ( motorcycles ) print ( popped_motorcycle ) We start by defining and printing the list motorcycles . Next, we pop a value ( suzuki ) from the list and store that value in the variable popped_motorcycle . Finally, we print the lists to show that a value has been successfully removed from the initial list. Then we print the popped list and prove we still have access to it. The above code would yield the following result: ['honda', 'yamaha', 'suzuki'] ['honda', 'yamaha'] suzuki How might this pop () method be useful? Imagine that the motorcycles in the list are store in chronological order according to when we owned them. If this is the case, we can use the pop () method to print a statement about the last motorcycle we bought: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] last_owned = motorcycles . pop () print ( f \"The last motorcycle I owned was a { last_owned . title () } .\" ) The output of the above would be: The last motorcycle I owned was a Suzuki.","title":"Removing an Item using the pop() Method"},{"location":"py-lists/#popping-items-from-any-position-in-a-list","text":"We can use pop () to remove an item from any position in a list by including the index of the item you want to remove in parenthese: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] first_owned = motorcycles . pop ( 0 ) print ( f \"The first motorcycle I owned was a { first_owned . title () } .\" ) We start by popping the first motorcycle in the list (located at index 0 ), and then we print a message about the motorcycle. The output is a simple sentence describing the first motorcycle owned: The first motorcycle I owned was a Honda Remember that each time we use pop () , the item we were working with is no longer stored in the list. When to use del or pop () When you want to delete an item from a list and not use that item in any way, use the del statement; if you want to use an item as you remove it, use the pop () method.","title":"Popping Items from any Position in a List"},{"location":"py-lists/#removing-an-item-by-value","text":"Sometimes you won't know the position of the value you want to remove from a list. If you only know the value of the item you want to remove, you can use the remove () method. For example, let's say we want to remove the value 'ducati' from the list of motorcycles: 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' , 'ducati' ] print ( motorcycles ) motorcycles . remove ( 'ducati' ) print ( motorcycles ) The above code tells Python to find and remove 'ducati' from within the motorcycles list. It would give the following result when ran: ['honda', 'yamaha', 'suzuki', 'ducati'] ['honda', 'yamaha', 'suzuki'] You can also use the remove () method to work with a value that's being removed form a list. Let's remove the value 'ducati' and print a reason for removing it from the list: 1 2 3 4 5 6 7 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' , 'ducati' ] print ( motorcycles ) too_expensive = 'ducati' motorcycles . remove ( too_expensive ) print ( motorcycles ) print ( f \" \\n A { too_expensive . title () } is too expensive for me.\" ) After defining the list on line 1, we assign the value 'ducati' to a variable called too_expensive . We then use this variable to tell Python which value to remove from the list. 'ducati' is removed from the list, but is still accessible through the variable too_expensive , allowing us to print a statement about why we removed 'ducati' from the list of motorcycles. The code above would have the following output: ['honda', 'yamaha', 'suzuki', 'ducati'] ['honda', 'yamaha', 'suzuki'] A Ducati is too expensive for me. Note on remove () The remove() method deletes only the first occurrence of the value you specify. If there\u2019s a possibility the value appears more than once in the list, you\u2019ll need to use a loop to make sure all occurrences of the value are removed.","title":"Removing an Item by Value"},{"location":"py-lists/#organizing-a-list","text":"Often, your lists will be created in an unpredictable order, because you can't always control the order in which your users provide their data. Although this is unavoidable in most circumstances, you'll frequently want to present your information in a particular order. Sometimes you'll want to preserve the original order of your list, and other times you'll want to change the original order. Python provides a number of different ways to organize your lists, depending on the situation.","title":"Organizing a List"},{"location":"py-lists/#sorting-a-list-permanently-with-the-sort-method","text":"Python's sort () method makes it relatively easy to sort a list. Imagine we have a list of cars and want to change the order of the list to store them alphabetically. To keep the task simple, let's assume that all the values in the list are lowercase: 1 2 3 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] cars . sort () print ( cars ) The sort () method, shown above changes the order of the list permanently. The cars are now in alphabetical order, and we can never revert to the original order: ['audi', 'bmw', 'subaru', 'toyota'] You can also sort this list in reverse alphabetical order by passing the argument reverse = True to the sort () method. The following example sorts the list of cars in reverse alphabetical order: 1 2 3 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] cars . sort ( reverse = True ) print ( cars )","title":"Sorting a List Permanently with the sort() Method"},{"location":"py-lists/#sorting-a-list-temporarily-with-the-sorted-function","text":"To maintain the original order of a list but present it in a sorted order, you can use the sorted () function. The sorted () function lets you display your list in a particular order but doesn't affect the actual order of the list. Let's try this function on the list of cars: 1 2 3 4 5 6 7 8 9 10 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] print ( \"Here is the orginal list:\" ) print ( cars ) print ( \" \\n Here is the sorted list:\" ) print ( sorted ( cars )) print ( \" \\n Here is the original list again:\" ) print ( cars ) This should have the following output: Here is the orginal list: ['bmw', 'audi', 'toyota', 'subaru'] Here is the sorted list: ['audi', 'bmw', 'subaru', 'toyota'] Here is the original list again: ['bmw', 'audi', 'toyota', 'subaru'] Note on Sorting Sorting a list alphabetically is a bit more complicated when all the values are not in lowercase. There are several ways to interpret capital letters when determining a sort order, and specifying the exact order can be more complex than we want to deal with at this time.","title":"Sorting a List Temporarily with the sorted() Function"},{"location":"py-lists/#printing-a-list-in-reverse-order","text":"To reverse the original order of a list, we can use the reverse () method. If we originally stored the list of cars in chronological order according to when we owned them, we could easily rearrange the list into reverse chronological order: 1 2 3 4 5 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] print ( cars ) cars . reverse () print ( cars ) After running this code will will get the following result: ['bmw', 'audi', 'toyota', 'subaru'] ['subaru', 'toyota', 'audi', 'bmw'] The reverse () method changes the order of a list permanently, but you can always simply run the reverse () function again to get back to the original order.","title":"Printing a List in Reverse Order"},{"location":"py-lists/#finding-the-length-of-a-list","text":"You can quickly find the length of a list by using the len () funtion. The list in this example has four items, so the output will be the integer 4: 1 2 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] len ( cars )","title":"Finding the Length of a List"},{"location":"py-lists/#avoiding-index-errors-when-working-with-lists","text":"One type of error is common when you're working with lists for the first time. Let's say we have a list with three items, and you ask for the fourth item: 1 2 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles [ 3 ]) Running this code results in an index error : 1 2 3 4 5 6 7 --------------------------------------------------------------------------- IndexError Traceback ( most recent call last ) < ipython - input - 10 - 9811709 cfb18 > in < module > 1 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] ----> 2 print ( motorcycles [ 3 ]) IndexError : list index out of range Python attempts to give you the item at index 3 , but when it searches the list, there is no item in index 3 in motorcycles . You must remember that indexing starts at 0 in Python. Note on Index Errors If an index error occurs and you can\u2019t figure out how to resolve it, try printing your list or just printing the length of your list. Your list might look much different than you thought it did, especially if it has been managed dynamically by your program. Seeing the actual list, or the exact number of items in your list, can help you sort out such logical errors.","title":"Avoiding Index Errors When Working with Lists"},{"location":"py-random/","text":"Random Programs Cash In cash.py we will calculate the minimum number of coins required to give a user change. Ex: $ python cash.py Change owed: 0.41 4 We will first ask a user how much changed they are owed and then tell them the minimum number of coins (.25, .10, .05, and .01) with which said change can be made. We will utilized get_float from the CS50 library to get the user's input and print () to output the answer. Remember, if the user provides a non-negative value, our program should reprompt the user for a valid amount again and again until the user complies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from cs50 import get_float while True : dollars = get_float ( \"Change owed: \" ) if dollars >= 0 : break cents = int ( dollars * 100 ) total_coins = 0 for coin in [ 25 , 10 , 5 , 1 ]: total_coins += cents // coin cents %= coin print ( total_coins ) Readability In readability.py we will compute the approximate grade level of given text. Ex: $ python readability.py Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 This is a complete copy of readbility.c , which uses the Coleman-Liau index to output grade level from text, but created using Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from cs50 import get_string text = get_string ( \"Text: \" ) letters = sentences = words = 0 for char in text : if char . isalpha (): letters += 1 if char . isspace (): words += 1 if char in [ '?' , '!' , '.' ]: sentences += 1 words += 1 L = ( letters * 100 ) / words S = ( sentences * 100 ) / words result = int ( round ( 0.0588 * L - 0.296 * S - 15.8 )) if result < 1 : print ( \"Before Grade 1\" ) elif result >= 16 : print ( \"Grade 16+\" ) else : print ( f \"Grade { result } \" ) DNA In this dna.py we will identify a person based on their DNA. DNA, the carrier of genetic information in living things, has been used in criminal justice for decades. But how, exactly, does DNA profiling work? Given a sequence of DNA, how can forensic investigators identify to whom it belongs? Well, DNA is really just a sequence of molecules called nucleotides, arranged into a particular shape (a double helix). Each nucleotide of DNA contains one of four different bases: adenine (A), cytosine (C), guanine (G), or thymine (T). Every human cell has billions of these nucleotides arranged in sequence. Some portions of this sequence (i.e. genome) are the same, or at least very similar, across almost all humans, but other portions of the sequence have a higher genetic diversity and thus vary more across the population. One place where DNA tends to have high genetic diversity is in Short Tandem Repeats (STRs). An STR is a short sequence of DNA bases that tends to repeat consecutively numerous times at specific locations inside of a person\u2019s DNA. The number of times any particular STR repeats varies a lot among individuals. In the DNA samples below, for example, Alice has the STR AGAT repeated four times in her DNA, while Bob has the same STR repeated five times. Alice: CT AGAT AGAT AGAT AGAT GACT A Bob: CT AGAT AGAT AGAT AGAT AGAT T Using multiple STRs, rather than just one, can improve the accuracy of DNA profiling. If the probability that two people have the same number of repeats for a single STR is 5%, and the analyst looks at 10 different STRs, then the probability that two DNA samples match purely by chance is about 1 in 1 quadrillion (assuming all STRs are independent of each other). So if two DNA samples match in the number of repeats for each of the STRs, the analyst can be pretty confident they came from the same person. CODIS, The FBI\u2019s DNA database , uses 20 different STRs as part of its DNA profiling process. What might such a DNA database look like? Well, in its simplest form, you could imagine formatting a DNA database as a CSV file, wherein each row corresponds to an individual, and each column corresponds to a particular STR. name,AGAT,AATG,TATC Alice,28,42,14 Bob,17,22,19 Charlie,36,18,25 The data in the above file would suggest that Alice has the sequence AGAT repeated 28 times consecutively somewhere in her DNA, the sequence AATG repeated 42 times, and TATC repeated 14 times. Bob, meanwhile, has those same three STRs repeated 17 times, 22 times, and 19 times, respectively. And Charlie has those same three STRs repeated 36, 18, and 25 times, respectively. So given a sequence of DNA, how might you identify to whom it belongs? Well, imagine that you looked through the DNA sequence for the longest consecutive sequence of repeated AGAT s and found that the longest sequence was 17 repeats long. If you then found that the longest sequence of AATG is 22 repeats long, and the longest sequence of TATC is 19 repeats long, that would provide pretty good evidence that the DNA was Bob\u2019s. Of course, it\u2019s also possible that once you take the counts for each of the STRs, it doesn\u2019t match anyone in your DNA database, in which case you have no match. In practice, since analysts know on which chromosome and at which location in the DNA an STR will be found, they can localize their search to just a narrow section of DNA. But we\u2019ll ignore that detail for this problem. .zip file for CSV . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 from csv import reader , DictReader from sys import argv if len ( argv ) < 3 : print ( \"usage error, dna.py sequence.txt database.csv\" ) exit () # read the dna sequence from the file with open ( argv [ 2 ]) as dnafile : dnareader = reader ( dnafile ) for row in dnareader : dnalist = row # store it in a string dna = dnalist [ 0 ] # create a dictionary where we will store the sequences we intend to count sequences = {} # extract the sequences from the database into a list with open ( argv [ 1 ]) as peoplefile : people = reader ( peoplefile ) for row in people : dnaSequences = row dnaSequences . pop ( 0 ) break # copy the list in a dictionary where the genes are the keys for item in dnaSequences : sequences [ item ] = 1 # iterate trough the dna sequence, when it finds repetitions of the values from sequence dictionary it counts them for key in sequences : l = len ( key ) tempMax = 0 temp = 0 for i in range ( len ( dna )): # after having counted a sequence it skips at the end of it to avoid counting again while temp > 0 : temp -= 1 continue # if the segment of dna corresponds to the key and there is a repetition of it we start counting if dna [ i : i + l ] == key : while dna [ i - l : i ] == dna [ i : i + l ]: temp += 1 i += l # it compares the value to the previous longest sequence and if it is longer it overrides it if temp > tempMax : tempMax = temp # store the longest sequences in the dictionary using the correspondent key sequences [ key ] += tempMax # open and iterate trough the database of people treating each one like a dictionary so it can compare to the sequences one with open ( argv [ 1 ], newline = '' ) as peoplefile : people = DictReader ( peoplefile ) for person in people : match = 0 # compares the sequences to every person and prints name before leaving the program if there is a match for dna in sequences : if sequences [ dna ] == int ( person [ dna ]): match += 1 if match == len ( sequences ): print ( person [ 'name' ]) exit () print ( \"No match\" )","title":"Random Programs"},{"location":"py-random/#random-programs","text":"","title":"Random Programs"},{"location":"py-random/#cash","text":"In cash.py we will calculate the minimum number of coins required to give a user change. Ex: $ python cash.py Change owed: 0.41 4 We will first ask a user how much changed they are owed and then tell them the minimum number of coins (.25, .10, .05, and .01) with which said change can be made. We will utilized get_float from the CS50 library to get the user's input and print () to output the answer. Remember, if the user provides a non-negative value, our program should reprompt the user for a valid amount again and again until the user complies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from cs50 import get_float while True : dollars = get_float ( \"Change owed: \" ) if dollars >= 0 : break cents = int ( dollars * 100 ) total_coins = 0 for coin in [ 25 , 10 , 5 , 1 ]: total_coins += cents // coin cents %= coin print ( total_coins )","title":"Cash"},{"location":"py-random/#readability","text":"In readability.py we will compute the approximate grade level of given text. Ex: $ python readability.py Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 This is a complete copy of readbility.c , which uses the Coleman-Liau index to output grade level from text, but created using Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from cs50 import get_string text = get_string ( \"Text: \" ) letters = sentences = words = 0 for char in text : if char . isalpha (): letters += 1 if char . isspace (): words += 1 if char in [ '?' , '!' , '.' ]: sentences += 1 words += 1 L = ( letters * 100 ) / words S = ( sentences * 100 ) / words result = int ( round ( 0.0588 * L - 0.296 * S - 15.8 )) if result < 1 : print ( \"Before Grade 1\" ) elif result >= 16 : print ( \"Grade 16+\" ) else : print ( f \"Grade { result } \" )","title":"Readability"},{"location":"py-random/#dna","text":"In this dna.py we will identify a person based on their DNA. DNA, the carrier of genetic information in living things, has been used in criminal justice for decades. But how, exactly, does DNA profiling work? Given a sequence of DNA, how can forensic investigators identify to whom it belongs? Well, DNA is really just a sequence of molecules called nucleotides, arranged into a particular shape (a double helix). Each nucleotide of DNA contains one of four different bases: adenine (A), cytosine (C), guanine (G), or thymine (T). Every human cell has billions of these nucleotides arranged in sequence. Some portions of this sequence (i.e. genome) are the same, or at least very similar, across almost all humans, but other portions of the sequence have a higher genetic diversity and thus vary more across the population. One place where DNA tends to have high genetic diversity is in Short Tandem Repeats (STRs). An STR is a short sequence of DNA bases that tends to repeat consecutively numerous times at specific locations inside of a person\u2019s DNA. The number of times any particular STR repeats varies a lot among individuals. In the DNA samples below, for example, Alice has the STR AGAT repeated four times in her DNA, while Bob has the same STR repeated five times. Alice: CT AGAT AGAT AGAT AGAT GACT A Bob: CT AGAT AGAT AGAT AGAT AGAT T Using multiple STRs, rather than just one, can improve the accuracy of DNA profiling. If the probability that two people have the same number of repeats for a single STR is 5%, and the analyst looks at 10 different STRs, then the probability that two DNA samples match purely by chance is about 1 in 1 quadrillion (assuming all STRs are independent of each other). So if two DNA samples match in the number of repeats for each of the STRs, the analyst can be pretty confident they came from the same person. CODIS, The FBI\u2019s DNA database , uses 20 different STRs as part of its DNA profiling process. What might such a DNA database look like? Well, in its simplest form, you could imagine formatting a DNA database as a CSV file, wherein each row corresponds to an individual, and each column corresponds to a particular STR. name,AGAT,AATG,TATC Alice,28,42,14 Bob,17,22,19 Charlie,36,18,25 The data in the above file would suggest that Alice has the sequence AGAT repeated 28 times consecutively somewhere in her DNA, the sequence AATG repeated 42 times, and TATC repeated 14 times. Bob, meanwhile, has those same three STRs repeated 17 times, 22 times, and 19 times, respectively. And Charlie has those same three STRs repeated 36, 18, and 25 times, respectively. So given a sequence of DNA, how might you identify to whom it belongs? Well, imagine that you looked through the DNA sequence for the longest consecutive sequence of repeated AGAT s and found that the longest sequence was 17 repeats long. If you then found that the longest sequence of AATG is 22 repeats long, and the longest sequence of TATC is 19 repeats long, that would provide pretty good evidence that the DNA was Bob\u2019s. Of course, it\u2019s also possible that once you take the counts for each of the STRs, it doesn\u2019t match anyone in your DNA database, in which case you have no match. In practice, since analysts know on which chromosome and at which location in the DNA an STR will be found, they can localize their search to just a narrow section of DNA. But we\u2019ll ignore that detail for this problem. .zip file for CSV . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 from csv import reader , DictReader from sys import argv if len ( argv ) < 3 : print ( \"usage error, dna.py sequence.txt database.csv\" ) exit () # read the dna sequence from the file with open ( argv [ 2 ]) as dnafile : dnareader = reader ( dnafile ) for row in dnareader : dnalist = row # store it in a string dna = dnalist [ 0 ] # create a dictionary where we will store the sequences we intend to count sequences = {} # extract the sequences from the database into a list with open ( argv [ 1 ]) as peoplefile : people = reader ( peoplefile ) for row in people : dnaSequences = row dnaSequences . pop ( 0 ) break # copy the list in a dictionary where the genes are the keys for item in dnaSequences : sequences [ item ] = 1 # iterate trough the dna sequence, when it finds repetitions of the values from sequence dictionary it counts them for key in sequences : l = len ( key ) tempMax = 0 temp = 0 for i in range ( len ( dna )): # after having counted a sequence it skips at the end of it to avoid counting again while temp > 0 : temp -= 1 continue # if the segment of dna corresponds to the key and there is a repetition of it we start counting if dna [ i : i + l ] == key : while dna [ i - l : i ] == dna [ i : i + l ]: temp += 1 i += l # it compares the value to the previous longest sequence and if it is longer it overrides it if temp > tempMax : tempMax = temp # store the longest sequences in the dictionary using the correspondent key sequences [ key ] += tempMax # open and iterate trough the database of people treating each one like a dictionary so it can compare to the sequences one with open ( argv [ 1 ], newline = '' ) as peoplefile : people = DictReader ( peoplefile ) for person in people : match = 0 # compares the sequences to every person and prints name before leaving the program if there is a match for dna in sequences : if sequences [ dna ] == int ( person [ dna ]): match += 1 if match == len ( sequences ): print ( person [ 'name' ]) exit () print ( \"No match\" )","title":"DNA"},{"location":"py-user-input-while-loops/","text":"User Input and while Loops Most programs will require a user's input to function. For a simple example, let's say someone wants to find out whether they're old enough to vote. If you write a program to answer this question, you need to know the user's age before you can provide an answer. The program will need to ask the user to enter, or input , their age; once the program has this input, it can compare it to the voting age to determine if the user is old enough and then report the result. In this chapter you'll learn how to accept user input so your program can then work with it. When your program needs a name, you'll be able to prompt the user for a name. When your program needs a list of names, you'll be able to prompt the user for a name. When your program needs a list of names, you'll be able to prompt the user for a series of names. To do this, you'll use the input () function. We'll also learn how to keep programs running as long as users want them to, so they can enter as much information as they need to; then, your program can work with this information. You'll use Python's while loop to keep programs running as long as certain conditons remain true . How the input () Function Works The input () function pauses your program and waits for the user to enter some text. Once Python receives the user's input, it assigns that input to a variable to make it convenient for you to work with. For example, the following program asks the user to enter some text, then displays that message back to the user: 1 2 message = input ( \"Tell me something, and I will repeat it back to you: \" ) print ( message ) The input () function takes one argument: the prompt , or instructions, that we want to display to the user so they know what to do. In this example when Python runs the first line, the user sees the prompt Tell me something, and I will repeat it back to you: . The program waits while the user enters their response and continues after the user presses ENTER / The response is assigned to the variable message , then print ( message ) displays the input back to the user: Tell me something, and I will repeat it back to you: Hello Everyone! Hello Everyone! Writing Clear Prompts Each time you use the input () function, you should include a clear, easy-to-follow prompt that tells the suer exactly what kind of information you're looking for. Any statment that tells the user what to enter should work. For example: 1 2 name = input ( \"Please enter your name: \" ) print ( f \" \\n Hello, { name } !\" ) Add a space at the end of your prompts (after the colon in the preceding example) to separate the prompt from the user's response and to make it clear to your user where to enter their text. Sometimes you'll want to write a prompt that is longer than one line. For example, you might want to tel the user why you're asking for certain input. You can assign your prompt to a variable and pass that variable to the input () function. This allows you to build your prompt over several lines, then write a clean input () statement. 1 2 3 4 5 prompt = \"If you tell us who you are, we can personalize the messages you see.\" prompt += \" \\n What is your first name? \" name = input ( prompt ) print ( f \" \\n Hello, { name } !\" ) This example shows one way to build a multi-line string. The first line assigns the first part of the message to the variable prompt . In the second line, the operator =+ takes the string that was assigned to prompt and adds the new string onto the end. The above prompt now spans two lines, again with space after the question mark for clarity: If you tell us who you are, we can personalize the messages you see. What is your first name? Nick Hello, Nick! Using int () to Accept Numerical Input When you use the input () function, Python interprets everything the user enters as a string. Consider the following interpreter session, which asks for the user's age: >>> age = input(\"How old are you? \") How old are you? 21 >>> age '21' The user enters the number 21, but when we ask Python for the value of age, it returns '21' , the string representation of the numerical value entered. We know Python interpreted the input as a string because the number is now enclosed in quites. If all you want to do is print the input, this works well. But if you try to use the input as a number, you'll get an error: >>> age = input(\"How old are you? \") How old are you? 21 >>> age >= 18 Traceback (most recent call last): file \"<stdin>\", line 1, in <module> TypeError: unorderable types: str() >= int() When you try to use the input to do a numerical comparison, Python produces an error because it can't compare a string to an integer: the string '21' that's assigned to age can't be compared to the numerical value 18 . We can resolve this by using the int () function, which tells Python to treat the input as a numerica value. We can do this by wrapping the input () statement in an int () : age = int ( input ( \"How old are you? \" )) How do you use the int () function in an actual program? Consider a program that determins whether people are tall enough to ride a roller coaster: 1 2 3 4 5 6 height = int ( input ( \"How tall are you, in inches? \" )) if height >= 48 : print ( \" \\n You're tall enough to ride!\" ) else : print ( \" \\n You're not tall enough to ride!\" ) The program can compare height to 48 because the input () for the height is wrapped in an int () . The Modulo Operator A useful tool for working with numerical information is the modulo operator (%) , which divides one number by another and returns the remainder. For example: 4 % 3 1 or 6 % 3 0 The modulo operator doesn't tell you how many times one number fits into another; it just tells you what the remainder is. When one number is divisible by another number, the remainder is 0, so the modulo operator always returns 0. You can use this fact to determine if a number is even or odd: 1 2 3 4 5 6 number = int ( input ( \"Enter a number, and I'll tell you if it's even or odd: \" )) if number % 2 == 0 : print ( f \" \\n The number { number } is even.\" ) else : print ( f \" \\n The number { number } is odd.\" ) Even numbers are always divisible by two, so if the modulo of a number and two is zero (here, if number % 2 == 0 ) the number is even. Otherwise, it's odd. Enter a number, and I'll tell you if it's even or odd: 5 The number 5 is odd. Introducing while Loops The for loop takes a collection of items and executes a block of code once for each item in a collection. In contrast, the while loop runs as lons as, or while , a certain condition is true. The while Loop in Action You can use a while loop to count up through a series of numbers. For example, the following while loop counts from 1 to 5: 1 2 3 4 current_number = 1 while current_number <= 5 : print ( current_number ) current_number += 1 In the first line, we start counting from 1 by assigning current_number to the value 1 . The while loop is then set to keep running as long as the value of current_number is less than or equal to 5. The code inside the loop prints the value of current_number and then adds 1 to that value with the current_number += 1 . (The += operator is shorthand for current_number = current_number + 1 ). Python repeats the loop as long as the condition current_number <= 5 is true. Each time it loops it will check the value of current_number and add 1 (if less than 5), until it reaches 5. 1 2 3 4 5 The programs you use every day most likely contain while loops. For example, a game needs a while loop to keep running as long as you want to keep playing, and so it can stop running as soon as you ask it to quit. Programs wouldn't be fun to use if they stopped running before we told them to or kept running even after we wanted to quit, so while loops are quite useful. Letting the User Choose When to Quit We can make a program as long as the user wants by putting most of the program inside a while loop. We'll define a quit value and then keep the program running as long as the user has not entered the quit value: 1 2 3 4 5 6 7 prompt = \" \\n Tell me something, and I will repeat it back to you:\" prompt += \" \\n Enter 'quit' to end the program.\" message = \"\" while message != 'quit' : message = input ( prompt ) print ( message ) On line 1, we define a prompt that tells the user their two options: entering a message or entering a quit value (in this case, 'quit'). Then we set up a variable message (line 4) to keep track of whatever value the user enters. We define message as an empty string, \"\", so Python has something to check the first time it reaches the while line. The first time the program runs and Python reaches the while statementm it needs to compare the value of message to quit , but no user input has been entered yet. If Python has nothing to compare, it won't be able to continue running the program. To solve this provlem, we make sure to give message an initial value. Although it's just an empty string, it will make sense to Python and allow it to perform the comparison that makes the while loop work. This while loop (line 5) runs as long as the value of message is not 'quit' . The first time through the loop, message is just an empty string, so Python enters the loop. At message = input ( prompt ) , Python displays the prompt and waits for the user to enter their input. Whatever they enter is assigned to message and printed; then, Python reevaluates the condition in the while statement. As long as the user has not entered the word 'quit' , the prompt is displayed again and Python waits for more input. When the user finally enters 'quit' , Python stops executing the while loop and the program ends: Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. Hello everyone! Hello everyone! Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. Hello again. Hello again. Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. quit quit The progam works well, except that it prints the word 'quit' as if it were an actual message. A simple if test fixes this: if message != 'quit' : print ( message ) Now the program will quit immediately after the input, instead of printing 'quit' . Using a Flag In the previous example, we had the program perform certain tasks while a given condition was true. But what about more complicated programs in which many different events could cause the program to stop running? For example, in a game, several different event can end the game. When the player runs out of ships, their time runs out, or the cities they were supposed to protect are all destroyed, the game should end. It needs to end if any one of these event happen. If many possible events might occur to stop the program, trying to test all these conditions in one while statement becomes complicated and difficult. For a program that should run only as long as many conditions are true, you can define one variable that determines whether or not the entire program is active. This varibale, called a flag , acts as a signal to the program. We can write our programs so they run while the flag is set to True and stop running when any of several events sets the value of the flag to False . As a result, our overall while statement needs to check only one condition: whether or not the flag is currently True . Then, all our other tests (to see if an event has occurred that should set the flag to False ) can be neatly organized in the rest of the program. Let's add a flag to the program from the previous section. This flag, which we'll call active (though you can call it anything), will monitor whether or not the program should continue running: 1 2 3 4 5 6 7 8 9 10 11 prompt = \" \\n Tell me something, and I will repeat it back to you:\" prompt += \" \\n Enter 'quit' to end the program.\" active = True while active : message = input ( prompt ) if message == 'quit' : active = False else : print ( message ) We set the variable active to True on line 4 so the program starts in an active state. Doing so makes the while statement simpler because no comparison is made in the while statement itself; the logic is taken care of in other parts of the program. As long as the active variable remains True , the loop will continue running (line 5). In the if statement inside the while loop, we check the value of message once the user enters their input. If the user enters 'quit' (line 8), we set active to False , and the while loop stops. If the user enters anything other than 'quit' , we print the input as a message. This program has the same output as the previous example where we placed the conditional test directly in the while statement. But now that we have a flag to indicate whether the overal program is in an active state, it would be easy to add more tests (such as elif statements) for events that should cause active to become False . This is useful in complicated programs like games in which there may be many evenet that should each make the program stop running. When any of these events causes the active flag to become False , the main loop will exit, a Game Over message can be displayed, and the player can be given the option to play again. Using break to Exit a Loop To exit a while loop immediately without running any remaining code in the loop, regardless of the results of any conditional test, use the break statement. The break statement directs the flow of your program; you can use it to control which lines of code are executed and which aren't, so the program only executes code that you want it to, when you want it to. Note on break You can use the break statement in any of Python's loops. For example, you could use break to quite a for loop that's working through a list or a dictionary. Using continue in a Loop Rather than breaking out of a loop entirely without executing the rest of its code, you can use the continue statement to return to the beginning of the loop based on the result of a conditional test. For example, consider a loop that counts from 1 to 10 but prints only the odd numbers in the range: 1 2 3 4 5 6 7 current_number = 0 while current_number < 10 : current_number += 1 if current_number % 2 == 0 : continue print ( current_number ) First we set current_number to 0. Because it's less than 10, Python enters the while loop. Once inside the loop, we increment the count by 1 (line 3), so the current_number is 1. The if statement then checks the modulo of current_number and 2. If the modulo is 0 (which means current_number is divisible by 2), the continue statement tells Python to ignore the rest of the loop and return to the beginning. If the current number is not divisible by 2, the rest of the loop is executed and Python prints the current number: 1 3 5 7 9 Avoiding Infinite Loops Every while loop needs a way to stop running so it won't continue to run forever. For example, this counting loop should count from 1 to 5: 1 2 3 4 x = 1 while x < 5 : print ( x ) x += 1 But if you accidentally omit the line x += 1 (as shown next), the loop will run forever: 1 2 3 x = 1 while x < 5 : print ( x ) Now the value of x will start at 1 but never change. As a result, the conditional test x <= 5 will always evaluate to True and the while loop will run forever, printing a series of 1s. Every programmer accidentally writes and infinite while loop from time to time, especially when a program's loops have subtle exit conditions. If your program gets stuck in an infinite loop, press CTRL-C or just close the terminal window displaying the program's output. To avoid writing infinite loops, test every while loop and make sure the loop stops when you expect it to. If you want your program to end when the user enters a certain input value, run the program and enter that value. If the program doesn't end, scrutinize the way your program handles the value that should cause the loop to exit. Make sure at least one part of the program can make the loop's condition False or cause it to reach a break statement. Using a while Loop with Lists and Dicitonaries So far, we've worked with only one piece of user information at a time. We received the user's input and then printed the input or a response to it. The next time through the while loop, we'd receive another input value and respond to that. But to keep track of many users and pieces of information, we'll need to use lists and dictionaries with our while loops. A for loop is effective for looping through a lsit, but you shouldn't modify a list inside a for loop because Python will have trouble keeping track of the items in the list. To modify a list as you work through it, use a while loop. Using while loops with lists and dictionaries allow you to collect, store, and organize lots of input to examine and report on later. Moving Items from One List to Another Consider a list of newly registered but unverified users of a website. After we verify these users, how can we move them to a separate list of confirmed users? One way would be to use a while loop to pull users from the list of unconfirmed users as we verify them and then add them to a separate list of confirmed users. Here's what that code might look like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Start with users that need to be verified, # and an empty list to hold confirmed users. unconfirmed_users = [ 'alice' , 'brian' , 'candace' ] confirmed_users = [] # Verify each user until there are no more unconfirmed users. # Move each verified user into the list of confirmed users. while unconfirmed_users : current_user = unconfirmed_users . pop () print ( f \"Verifying user: { current_user . title () } \" ) confirmed_users . append ( current_user ) #Display all confirmed users. print ( \" \\n The following users have been confirmed:\" ) for confirmed_user in confirmed_users : print ( confirmed_user . title ()) We begin with a list of unconfirmed users on line 3 (Alice, Brian, and Candace) and an empty list to hold confirmed users. The while loop on line 8 runs as long as the list unconfirmed_users is not empty. Within this loop, the pop () function (line 9) removes unverified users one at a time from the end of unconfirmed_users . Here, because Candace is te last in the unconfirmed_users list, her name will be the first to be removed, assigned to current_user , and added to the confirmed_users list on line 12. Next is Brian, then Alice. We simulate confirming each user by printing a verification message then adding them to the list of confirmed users. As the list of unconfirmed users shrinks, the list of confirmed users grows. When the list of unconfirmed users is empty, the loop stops and the list of confirmed users in printed: Verifying user: Candace Verifying user: Brian Verifying user: Alice The following users have been confirmed: Candace Brian Alice Removing All Instances of Specific Values from a List In previous notes ( located here ) we used remove () to remove a specific value from a list. The remove () function worked because the value we were interested in appeared only once in the list. But what if you want to remove all instances of a value from a list? Say you have a list of pets with the value 'cat' repeated several times. To remove all instances of that value, you can run a while loop until 'cat' is no longer in the list, as shown here: 1 2 3 4 5 6 7 pets = [ 'dog' , 'cat' , 'dog' , 'goldfish' , 'cat' , 'rabbit' , 'cat' ] print ( pets ) while 'cat' in pets : pets . remove ( 'cat' ) print ( pets ) We start with a list containing multiple instances of 'cat' . After printing the list, Python enters the while loop because it finds the value 'cat' in the list at least once. Once insidethe loop, Python removes the first instance of 'cat' , returns to the while line, and then reenters the loop when it finds that 'cat' is still in the list. It removes each instance of 'cat' until the value is no longer in the list, at which point Python exits the loop and prints the list again: ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat'] ['dog', 'dog', 'goldfish', 'rabbit'] Filling a Dictionary with User Input You can prompt for as much input as you need in each pass through a while loop. Let's make a polling program in which each pass through the loop prompts for the participant's name and response. We'll store the data we gather in a dictionary, because we want to connect each response with a particular user: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 responses = {} # Set a flag to indicate that polling is active polling_active = True while polling_active : # Prompt for the person's name and response. name = input ( \" \\n What is your name? \" ) response = input ( \"Which mountain would you like to climb someday? \" ) # Store the response in the dictionary responses [ name ] = response # Find out if anyone else if going to take the poll. repeat = input ( \"Would you like to let another person respond? (yes/no) \" ) if repeat == 'no' : polling_active = False # Polling is complete. Show the results. print ( \" \\n --- Poll Results ---\" ) for name , response in responses . items (): print ( f \" { name } would like to climb { response } .\" ) The program first defines an empty dictionary ( responses ) and sets a flag ( polling_active ) to indicate that polling is active. As long as polling_active is True , Python will run the code in the while loop. Within the loop, the user is prompted to enter their name and a mountain they'd like to climb (line 8). That information is stored in the responses dictionary (line 12), and the user is asked whether or not to keep the poll running (line 15). If they enter yes, the program enters the while loop again. If they enter no, the polling_active flag is set to False , the while loop stops running, and the final code block at line 20 displays the results of the poll. If you run this program and enter sample resonses, you should see output like this: What is your name? Eric Which mountain would you like to climb someday? Denali Would you like to let another person respond? (yes/ no) yes What is your name? Lynn Which mountain would you like to climb someday? Devil's Thumb Would you like to let another person respond? (yes/ no) no --- Poll Results --- Lynn would like to climb Devil's Thumb. Eric would like to climb Denali.","title":"User Input and while Loops"},{"location":"py-user-input-while-loops/#user-input-and-while-loops","text":"Most programs will require a user's input to function. For a simple example, let's say someone wants to find out whether they're old enough to vote. If you write a program to answer this question, you need to know the user's age before you can provide an answer. The program will need to ask the user to enter, or input , their age; once the program has this input, it can compare it to the voting age to determine if the user is old enough and then report the result. In this chapter you'll learn how to accept user input so your program can then work with it. When your program needs a name, you'll be able to prompt the user for a name. When your program needs a list of names, you'll be able to prompt the user for a name. When your program needs a list of names, you'll be able to prompt the user for a series of names. To do this, you'll use the input () function. We'll also learn how to keep programs running as long as users want them to, so they can enter as much information as they need to; then, your program can work with this information. You'll use Python's while loop to keep programs running as long as certain conditons remain true .","title":"User Input and while Loops"},{"location":"py-user-input-while-loops/#how-the-input-function-works","text":"The input () function pauses your program and waits for the user to enter some text. Once Python receives the user's input, it assigns that input to a variable to make it convenient for you to work with. For example, the following program asks the user to enter some text, then displays that message back to the user: 1 2 message = input ( \"Tell me something, and I will repeat it back to you: \" ) print ( message ) The input () function takes one argument: the prompt , or instructions, that we want to display to the user so they know what to do. In this example when Python runs the first line, the user sees the prompt Tell me something, and I will repeat it back to you: . The program waits while the user enters their response and continues after the user presses ENTER / The response is assigned to the variable message , then print ( message ) displays the input back to the user: Tell me something, and I will repeat it back to you: Hello Everyone! Hello Everyone!","title":"How the input() Function Works"},{"location":"py-user-input-while-loops/#writing-clear-prompts","text":"Each time you use the input () function, you should include a clear, easy-to-follow prompt that tells the suer exactly what kind of information you're looking for. Any statment that tells the user what to enter should work. For example: 1 2 name = input ( \"Please enter your name: \" ) print ( f \" \\n Hello, { name } !\" ) Add a space at the end of your prompts (after the colon in the preceding example) to separate the prompt from the user's response and to make it clear to your user where to enter their text. Sometimes you'll want to write a prompt that is longer than one line. For example, you might want to tel the user why you're asking for certain input. You can assign your prompt to a variable and pass that variable to the input () function. This allows you to build your prompt over several lines, then write a clean input () statement. 1 2 3 4 5 prompt = \"If you tell us who you are, we can personalize the messages you see.\" prompt += \" \\n What is your first name? \" name = input ( prompt ) print ( f \" \\n Hello, { name } !\" ) This example shows one way to build a multi-line string. The first line assigns the first part of the message to the variable prompt . In the second line, the operator =+ takes the string that was assigned to prompt and adds the new string onto the end. The above prompt now spans two lines, again with space after the question mark for clarity: If you tell us who you are, we can personalize the messages you see. What is your first name? Nick Hello, Nick!","title":"Writing Clear Prompts"},{"location":"py-user-input-while-loops/#using-int-to-accept-numerical-input","text":"When you use the input () function, Python interprets everything the user enters as a string. Consider the following interpreter session, which asks for the user's age: >>> age = input(\"How old are you? \") How old are you? 21 >>> age '21' The user enters the number 21, but when we ask Python for the value of age, it returns '21' , the string representation of the numerical value entered. We know Python interpreted the input as a string because the number is now enclosed in quites. If all you want to do is print the input, this works well. But if you try to use the input as a number, you'll get an error: >>> age = input(\"How old are you? \") How old are you? 21 >>> age >= 18 Traceback (most recent call last): file \"<stdin>\", line 1, in <module> TypeError: unorderable types: str() >= int() When you try to use the input to do a numerical comparison, Python produces an error because it can't compare a string to an integer: the string '21' that's assigned to age can't be compared to the numerical value 18 . We can resolve this by using the int () function, which tells Python to treat the input as a numerica value. We can do this by wrapping the input () statement in an int () : age = int ( input ( \"How old are you? \" )) How do you use the int () function in an actual program? Consider a program that determins whether people are tall enough to ride a roller coaster: 1 2 3 4 5 6 height = int ( input ( \"How tall are you, in inches? \" )) if height >= 48 : print ( \" \\n You're tall enough to ride!\" ) else : print ( \" \\n You're not tall enough to ride!\" ) The program can compare height to 48 because the input () for the height is wrapped in an int () .","title":"Using int() to Accept Numerical Input"},{"location":"py-user-input-while-loops/#the-modulo-operator","text":"A useful tool for working with numerical information is the modulo operator (%) , which divides one number by another and returns the remainder. For example: 4 % 3 1 or 6 % 3 0 The modulo operator doesn't tell you how many times one number fits into another; it just tells you what the remainder is. When one number is divisible by another number, the remainder is 0, so the modulo operator always returns 0. You can use this fact to determine if a number is even or odd: 1 2 3 4 5 6 number = int ( input ( \"Enter a number, and I'll tell you if it's even or odd: \" )) if number % 2 == 0 : print ( f \" \\n The number { number } is even.\" ) else : print ( f \" \\n The number { number } is odd.\" ) Even numbers are always divisible by two, so if the modulo of a number and two is zero (here, if number % 2 == 0 ) the number is even. Otherwise, it's odd. Enter a number, and I'll tell you if it's even or odd: 5 The number 5 is odd.","title":"The Modulo Operator"},{"location":"py-user-input-while-loops/#introducing-while-loops","text":"The for loop takes a collection of items and executes a block of code once for each item in a collection. In contrast, the while loop runs as lons as, or while , a certain condition is true.","title":"Introducing while Loops"},{"location":"py-user-input-while-loops/#the-while-loop-in-action","text":"You can use a while loop to count up through a series of numbers. For example, the following while loop counts from 1 to 5: 1 2 3 4 current_number = 1 while current_number <= 5 : print ( current_number ) current_number += 1 In the first line, we start counting from 1 by assigning current_number to the value 1 . The while loop is then set to keep running as long as the value of current_number is less than or equal to 5. The code inside the loop prints the value of current_number and then adds 1 to that value with the current_number += 1 . (The += operator is shorthand for current_number = current_number + 1 ). Python repeats the loop as long as the condition current_number <= 5 is true. Each time it loops it will check the value of current_number and add 1 (if less than 5), until it reaches 5. 1 2 3 4 5 The programs you use every day most likely contain while loops. For example, a game needs a while loop to keep running as long as you want to keep playing, and so it can stop running as soon as you ask it to quit. Programs wouldn't be fun to use if they stopped running before we told them to or kept running even after we wanted to quit, so while loops are quite useful.","title":"The while Loop in Action"},{"location":"py-user-input-while-loops/#letting-the-user-choose-when-to-quit","text":"We can make a program as long as the user wants by putting most of the program inside a while loop. We'll define a quit value and then keep the program running as long as the user has not entered the quit value: 1 2 3 4 5 6 7 prompt = \" \\n Tell me something, and I will repeat it back to you:\" prompt += \" \\n Enter 'quit' to end the program.\" message = \"\" while message != 'quit' : message = input ( prompt ) print ( message ) On line 1, we define a prompt that tells the user their two options: entering a message or entering a quit value (in this case, 'quit'). Then we set up a variable message (line 4) to keep track of whatever value the user enters. We define message as an empty string, \"\", so Python has something to check the first time it reaches the while line. The first time the program runs and Python reaches the while statementm it needs to compare the value of message to quit , but no user input has been entered yet. If Python has nothing to compare, it won't be able to continue running the program. To solve this provlem, we make sure to give message an initial value. Although it's just an empty string, it will make sense to Python and allow it to perform the comparison that makes the while loop work. This while loop (line 5) runs as long as the value of message is not 'quit' . The first time through the loop, message is just an empty string, so Python enters the loop. At message = input ( prompt ) , Python displays the prompt and waits for the user to enter their input. Whatever they enter is assigned to message and printed; then, Python reevaluates the condition in the while statement. As long as the user has not entered the word 'quit' , the prompt is displayed again and Python waits for more input. When the user finally enters 'quit' , Python stops executing the while loop and the program ends: Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. Hello everyone! Hello everyone! Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. Hello again. Hello again. Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. quit quit The progam works well, except that it prints the word 'quit' as if it were an actual message. A simple if test fixes this: if message != 'quit' : print ( message ) Now the program will quit immediately after the input, instead of printing 'quit' .","title":"Letting the User Choose When to Quit"},{"location":"py-user-input-while-loops/#using-a-flag","text":"In the previous example, we had the program perform certain tasks while a given condition was true. But what about more complicated programs in which many different events could cause the program to stop running? For example, in a game, several different event can end the game. When the player runs out of ships, their time runs out, or the cities they were supposed to protect are all destroyed, the game should end. It needs to end if any one of these event happen. If many possible events might occur to stop the program, trying to test all these conditions in one while statement becomes complicated and difficult. For a program that should run only as long as many conditions are true, you can define one variable that determines whether or not the entire program is active. This varibale, called a flag , acts as a signal to the program. We can write our programs so they run while the flag is set to True and stop running when any of several events sets the value of the flag to False . As a result, our overall while statement needs to check only one condition: whether or not the flag is currently True . Then, all our other tests (to see if an event has occurred that should set the flag to False ) can be neatly organized in the rest of the program. Let's add a flag to the program from the previous section. This flag, which we'll call active (though you can call it anything), will monitor whether or not the program should continue running: 1 2 3 4 5 6 7 8 9 10 11 prompt = \" \\n Tell me something, and I will repeat it back to you:\" prompt += \" \\n Enter 'quit' to end the program.\" active = True while active : message = input ( prompt ) if message == 'quit' : active = False else : print ( message ) We set the variable active to True on line 4 so the program starts in an active state. Doing so makes the while statement simpler because no comparison is made in the while statement itself; the logic is taken care of in other parts of the program. As long as the active variable remains True , the loop will continue running (line 5). In the if statement inside the while loop, we check the value of message once the user enters their input. If the user enters 'quit' (line 8), we set active to False , and the while loop stops. If the user enters anything other than 'quit' , we print the input as a message. This program has the same output as the previous example where we placed the conditional test directly in the while statement. But now that we have a flag to indicate whether the overal program is in an active state, it would be easy to add more tests (such as elif statements) for events that should cause active to become False . This is useful in complicated programs like games in which there may be many evenet that should each make the program stop running. When any of these events causes the active flag to become False , the main loop will exit, a Game Over message can be displayed, and the player can be given the option to play again.","title":"Using a Flag"},{"location":"py-user-input-while-loops/#using-break-to-exit-a-loop","text":"To exit a while loop immediately without running any remaining code in the loop, regardless of the results of any conditional test, use the break statement. The break statement directs the flow of your program; you can use it to control which lines of code are executed and which aren't, so the program only executes code that you want it to, when you want it to. Note on break You can use the break statement in any of Python's loops. For example, you could use break to quite a for loop that's working through a list or a dictionary.","title":"Using break to Exit a Loop"},{"location":"py-user-input-while-loops/#using-continue-in-a-loop","text":"Rather than breaking out of a loop entirely without executing the rest of its code, you can use the continue statement to return to the beginning of the loop based on the result of a conditional test. For example, consider a loop that counts from 1 to 10 but prints only the odd numbers in the range: 1 2 3 4 5 6 7 current_number = 0 while current_number < 10 : current_number += 1 if current_number % 2 == 0 : continue print ( current_number ) First we set current_number to 0. Because it's less than 10, Python enters the while loop. Once inside the loop, we increment the count by 1 (line 3), so the current_number is 1. The if statement then checks the modulo of current_number and 2. If the modulo is 0 (which means current_number is divisible by 2), the continue statement tells Python to ignore the rest of the loop and return to the beginning. If the current number is not divisible by 2, the rest of the loop is executed and Python prints the current number: 1 3 5 7 9","title":"Using continue in a Loop"},{"location":"py-user-input-while-loops/#avoiding-infinite-loops","text":"Every while loop needs a way to stop running so it won't continue to run forever. For example, this counting loop should count from 1 to 5: 1 2 3 4 x = 1 while x < 5 : print ( x ) x += 1 But if you accidentally omit the line x += 1 (as shown next), the loop will run forever: 1 2 3 x = 1 while x < 5 : print ( x ) Now the value of x will start at 1 but never change. As a result, the conditional test x <= 5 will always evaluate to True and the while loop will run forever, printing a series of 1s. Every programmer accidentally writes and infinite while loop from time to time, especially when a program's loops have subtle exit conditions. If your program gets stuck in an infinite loop, press CTRL-C or just close the terminal window displaying the program's output. To avoid writing infinite loops, test every while loop and make sure the loop stops when you expect it to. If you want your program to end when the user enters a certain input value, run the program and enter that value. If the program doesn't end, scrutinize the way your program handles the value that should cause the loop to exit. Make sure at least one part of the program can make the loop's condition False or cause it to reach a break statement.","title":"Avoiding Infinite Loops"},{"location":"py-user-input-while-loops/#using-a-while-loop-with-lists-and-dicitonaries","text":"So far, we've worked with only one piece of user information at a time. We received the user's input and then printed the input or a response to it. The next time through the while loop, we'd receive another input value and respond to that. But to keep track of many users and pieces of information, we'll need to use lists and dictionaries with our while loops. A for loop is effective for looping through a lsit, but you shouldn't modify a list inside a for loop because Python will have trouble keeping track of the items in the list. To modify a list as you work through it, use a while loop. Using while loops with lists and dictionaries allow you to collect, store, and organize lots of input to examine and report on later.","title":"Using a while Loop with Lists and Dicitonaries"},{"location":"py-user-input-while-loops/#moving-items-from-one-list-to-another","text":"Consider a list of newly registered but unverified users of a website. After we verify these users, how can we move them to a separate list of confirmed users? One way would be to use a while loop to pull users from the list of unconfirmed users as we verify them and then add them to a separate list of confirmed users. Here's what that code might look like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Start with users that need to be verified, # and an empty list to hold confirmed users. unconfirmed_users = [ 'alice' , 'brian' , 'candace' ] confirmed_users = [] # Verify each user until there are no more unconfirmed users. # Move each verified user into the list of confirmed users. while unconfirmed_users : current_user = unconfirmed_users . pop () print ( f \"Verifying user: { current_user . title () } \" ) confirmed_users . append ( current_user ) #Display all confirmed users. print ( \" \\n The following users have been confirmed:\" ) for confirmed_user in confirmed_users : print ( confirmed_user . title ()) We begin with a list of unconfirmed users on line 3 (Alice, Brian, and Candace) and an empty list to hold confirmed users. The while loop on line 8 runs as long as the list unconfirmed_users is not empty. Within this loop, the pop () function (line 9) removes unverified users one at a time from the end of unconfirmed_users . Here, because Candace is te last in the unconfirmed_users list, her name will be the first to be removed, assigned to current_user , and added to the confirmed_users list on line 12. Next is Brian, then Alice. We simulate confirming each user by printing a verification message then adding them to the list of confirmed users. As the list of unconfirmed users shrinks, the list of confirmed users grows. When the list of unconfirmed users is empty, the loop stops and the list of confirmed users in printed: Verifying user: Candace Verifying user: Brian Verifying user: Alice The following users have been confirmed: Candace Brian Alice","title":"Moving Items from One List to Another"},{"location":"py-user-input-while-loops/#removing-all-instances-of-specific-values-from-a-list","text":"In previous notes ( located here ) we used remove () to remove a specific value from a list. The remove () function worked because the value we were interested in appeared only once in the list. But what if you want to remove all instances of a value from a list? Say you have a list of pets with the value 'cat' repeated several times. To remove all instances of that value, you can run a while loop until 'cat' is no longer in the list, as shown here: 1 2 3 4 5 6 7 pets = [ 'dog' , 'cat' , 'dog' , 'goldfish' , 'cat' , 'rabbit' , 'cat' ] print ( pets ) while 'cat' in pets : pets . remove ( 'cat' ) print ( pets ) We start with a list containing multiple instances of 'cat' . After printing the list, Python enters the while loop because it finds the value 'cat' in the list at least once. Once insidethe loop, Python removes the first instance of 'cat' , returns to the while line, and then reenters the loop when it finds that 'cat' is still in the list. It removes each instance of 'cat' until the value is no longer in the list, at which point Python exits the loop and prints the list again: ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat'] ['dog', 'dog', 'goldfish', 'rabbit']","title":"Removing All Instances of Specific Values from a List"},{"location":"py-user-input-while-loops/#filling-a-dictionary-with-user-input","text":"You can prompt for as much input as you need in each pass through a while loop. Let's make a polling program in which each pass through the loop prompts for the participant's name and response. We'll store the data we gather in a dictionary, because we want to connect each response with a particular user: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 responses = {} # Set a flag to indicate that polling is active polling_active = True while polling_active : # Prompt for the person's name and response. name = input ( \" \\n What is your name? \" ) response = input ( \"Which mountain would you like to climb someday? \" ) # Store the response in the dictionary responses [ name ] = response # Find out if anyone else if going to take the poll. repeat = input ( \"Would you like to let another person respond? (yes/no) \" ) if repeat == 'no' : polling_active = False # Polling is complete. Show the results. print ( \" \\n --- Poll Results ---\" ) for name , response in responses . items (): print ( f \" { name } would like to climb { response } .\" ) The program first defines an empty dictionary ( responses ) and sets a flag ( polling_active ) to indicate that polling is active. As long as polling_active is True , Python will run the code in the while loop. Within the loop, the user is prompted to enter their name and a mountain they'd like to climb (line 8). That information is stored in the responses dictionary (line 12), and the user is asked whether or not to keep the poll running (line 15). If they enter yes, the program enters the while loop again. If they enter no, the polling_active flag is set to False , the while loop stops running, and the final code block at line 20 displays the results of the poll. If you run this program and enter sample resonses, you should see output like this: What is your name? Eric Which mountain would you like to climb someday? Denali Would you like to let another person respond? (yes/ no) yes What is your name? Lynn Which mountain would you like to climb someday? Devil's Thumb Would you like to let another person respond? (yes/ no) no --- Poll Results --- Lynn would like to climb Devil's Thumb. Eric would like to climb Denali.","title":"Filling a Dictionary with User Input"},{"location":"py-working-with-lists/","text":"Working with Lists Looping Through an Entire List You'll often want to run through all entries in a list, performing the same task with each item. For example, in a game you might want to move every element on the screen by the same amount, or in a list of numbers you might want to perform the same statistical operation on every element. Or perhaps, you'll want to display each headline from a list of articles on a website. When you want to do the sam eaction with every item in a list, you can use Python's for loop. Let's say we have a list of magician's names, and we want to print out each name in the list. We could do this by retrieving each name from the list individually, but this approach could cause several problems. For one, it would be repetitive to do this with a long list of names. Also, we'd have to change our code each time the list's length changed. A for loop avoids both of these issues by letting Python manage these issues internally. Let's use a for loop to print out each name in a list of magicians: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( magician ) We begin by defining the list ( magicians ). Next, we define a for loop. This line tells Python to pull a name from the list magicians , and associate it with the variable magician . Finally, we tell Python to print the name that's been assigned to magician . Python then repeats these steps for each name in the list. Pseudocode for this may look like: For every magician in the list of magicians print the magician's name The output is a simple printout of each name on the list: alice david carolina A Closer Look at Looping The concept of looping is important because it's one of the most common ways a computer automates repetitive tasks. For example, in a simple look, like the one above in magicians , Python initially reads the first line of the loop: 1 for magician in magicians This line tells Python to retrieve the first value from the list magicians and associate it with the variable magician . The first value is 'alice' . Python then reads the next line: 1 print ( magician ) Python prints the current value of magician , which is still 'alice' . Because the list contains more values, Python returns to the first line of the loop: 1 for magician in magicians Python retrieves the next name in the list, 'david' , and associates that value with the variable magician . Python then executes the line: 1 print ( magician ) Python prints the current value of magician again, which is now 'david' . Python repeats the entire loop once more with the last value in the list 'carolina' . Because no more values are in the list, Python moves on to the next line in the program. In this case nothing comes after the for loop, so the program simply ends. When you're using loops for the first time, keep in mind that the set of steps is repeated once for each item in the list, no matter how many items are in the list. If you have a million items in your list, Python repeats these steps a million times -- and usually very quickly. Also keep in mind when writing your own for loops that you can choose any name you want for the temporary variable that will be associated with each value in the list. However, it's helpful to choose a meaningful name that represents a single item from the list. For example, here's a good way to start a for loop for a list of cats, a list of dogs, and a general list of items: 1 2 3 for cat in cats : for dog in dogs : for item in list_of_items : These naming conventions can help you follow the action being done on each item within a for loop. Using a singular and plural names can help you identify whether a section of code is working with a single element from the list or the entire list. Doing More Work Within a for Loop You can do just about anything with each item in a for loop. Let's build on the previous example by printing a message to each magician, telling them that they performed a great trick: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) The only difference in this code is within the for loop, where we compose a message to each magician, starting with their name. The first time through the loop the value of magician is 'alice' , so Python starts the first message with the name 'alice' . The seond time through the message begins with the next index in the list ( 'david' ). The output should look as follows: Alice, that was a great trick! David, that was a great trick! Carolina, that was a great trick! You can also write as many lines of code as you like in the for loop. Every indented line following the line for magician in magicians is considered inside the loop , and each indented line is executed once for each value in the list. Therefore, you can do as much work as you like with each value in the list. Let's add a second line to our message, telling each magician that we're looking forward to their next trick: 1 2 3 4 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) Because both calls for print () are indented, each line will be executed once for every magician in the list. This will have the output: Alice, that was a great trick! I can't wait to see your next trick, Alice. David, that was a great trick! I can't wait to see your next trick, David. Carolina, that was a great trick! I can't wait to see your next trick, Carolina. Doing Something After a for Loop What happens once a for loop has finished executing? Usually, you'll want to summarize a block of output or move on to other work that your program must accomplish. Any lines of code after the for loop that are not indented are executed once without repition. Let's write a thank you to the group of magicians as a whole for putting on an excellent show. To display this group message after all the individual messages have been printed, we place the thank you message after the for loop without indentation: 1 2 3 4 5 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) print ( \"Thank you, everyone. That was a great magic show!\" ) The first two calls to print () are repeated once for each magician in the list, as you saw earlier. However, because the final line is not indented, it's printed only once: Alice, that was a great trick! I can't wait to see your next trick, Alice. David, that was a great trick! I can't wait to see your next trick, David. Carolina, that was a great trick! I can't wait to see your next trick, Carolina. Thank you, everyone. That was a great magic show! When you're processing data using a for loop, you'll find that this is a good way to summarize an operation that was performed on an entire data set. For example, you might use a for loop to initialize a game by running through a list of characters and displaying each character on the screen. You might then write some additional code after this loop tha displays a Play Now button after all the characters have been drawn to the screen. Avoiding Indentation Errors Python uses indentation to determine how a line, or group of lines, is related to the rest of the program. In the previous examples, the lines that printed messages to individual magicians were part of the for loop because they were indented. Python's use of indentation makes code very easy to read. Basically, it uses whitespace to force you to write neatly formatted code indented at a few different levels. These indentation levels help you gain a general sense of the overall program's organization. As you begin to write code that relies on proper indentation, you'll need to watch for a few common indentation errors . For example, people sometimes indent lines of code that don't need to be indented or forget to indent lines that need to be indented. Seeing examples of these errors now will help you avoid them in the future and correct them when they do appear in your own programs. Let's examine some of the more common indentation errors: Forgetting to Indent Always indent the line after the for statement in a loop. If you forget, Python will remind you: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( magician ) The call to print () above should be indented, but it is not. When Python expects an indented block and does not find one, it lets you know which line it had a problem with. The following is what would be output if you ran the code above: File \"<filename>\", line 3 print(magician) ^ IndentationError: expected an indented block You can usually resolve this kind of indentation error by indenting the line or lines immediately after the for statement. Forgetting to Indent Additional Lines Sometimes your loop will run without any errors but won't produce the expected result. This can happen when you're trying to do several tasks in a loop and you forget to indent some of its lines. For example, this is what happens when we forget to indent the seconf line in the loop that tells each magician we're looking forward to their next trick: 1 2 3 4 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) The second call to print should also be indented, but because Python finds at least one indented line after the for statement, it doen't report an error. As a result, the first print () is executed once for each name in the list, but because the second print () call is not indented, it will only run once. Because the final value associated with magician is 'carolina' , she is the only one who recieves the \"looking forward to the next trick message\": Alice, that was a great trick! David, that was a great trick! Carolina, that was a great trick! I can't wait to see your next trick, Carolina. This is a logical error . The syntax is valid Python code, but the code does not produce the desired result because a problem occurs in its logic. If you expect to see a certain action repeated once for each item in a list and it's only executed once, determine whether you need to simply indent a line or group of lines to remedy the problem. Indenting Unnecessarily If you accidentally indent a line that doesn't need to be indented, Python will inform you about the unexpected indent: 1 2 message = \"Hello Python World!\" print ( message ) We do not need the indent before the print () call, because it is not part of a loop. Python will report the following error: 1 2 3 4 File \"<ipython-input-1-2f2b50073239>\" , line 2 print ( message ) ^ IndentationError : unexpected indent You can avoid unexpected indentation errors by indenting only when you have a specific reason to do so. So far, we have only needed to indent when we used a for loop. Forgetting the Colon The colon at the end of a for statement tells Python to interpret the next line as the start of a loop: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians print ( magician ) Notice that we are missing the colon at the end of line 2. This will cause a syntax error in Python because it will not be able to interpret what we are trying to do. The above code will give you the following error: 1 2 3 4 File \"<ipython-input-2-082d5f15acfa>\" , line 2 for magician in magicians ^ SyntaxError : invalid syntax Making Numerical Lists Many reasons exist to store a set of numbers. For example, you'll need to keep track of the positions of each character in a game, and you might want to keep track of a player's high scores as well. In data visualizations, you'll almost always work with sets of numbers, such as termperatures, distances, population sizes, or latitude and logitude values, among other types of numerical sets. Lists are ideal for storing sets of numbers, and Python provides a vairety of tools to help you work effeciently with lists of numbers. Once you understand how to use these tools effectively, your code will work well even when your lists contain millions of items. Using the range () function Python's range () function makes it easy to generate a series of numbers. For example, you can use the range () function to print a series of numbers like this: 1 2 for value in range ( 1 , 5 ): print ( value ) Although this code looks like it should print numbers from 1 to 5, it does not print the number 5: 1 2 3 4 In this example, range () only prints the numbers 1 through 4. This is another result of the off-by-one behavior you'll often see in programming languages. The range () function causes Python to start counting at the first value you give it, and stops when it reaches the second value you provide. Because it stops at the second value, the output never contains the end value, which would have been 5 in this case. To print the numbers 1 to 5, you would use range ( 1 , 6 ) . If your output is different than what you expect when you're using range () , try adjusting your end value by 1. Using range () to Make a List of Numbers If you want to make a list of numbers you can conver the results of range () directly into a list using the list () function. When you wrap list () around a call to the range () function, the output will be a list of numbers. In the example in the previous section, we simply printed out a series of numbers. We can use the list () function to convert that same set of numbers into a list: 1 2 numbers = list ( range ( 1 , 6 )) print ( numbers ) And this is the result: [1, 2, 3, 4, 5] We can also use the range () function to tell Python to skip numbers in a given range. If you pass a third argument to range () , Python uses that value as a step size when generating numbers. For example, here's how to list the even numbers between 1 and 10: 1 2 even_numbers = list ( range ( 2 , 11 , 2 )) print ( even_numbers ) In this example, the range () function starts with the value 2 and then adds 2 to that value, until it reaches index 11 (the number 10). This will produce the following result: [2, 4, 6, 8, 10] You can create almost any set of numbers you want to using the range () function. For example, consider how you might make a list of the first 10 square numbers (that is, the square of each integer from 1 through 10). In Python, two asterisks ( ** ) represent exponents. Here's how you might put the first 10 square numbers into a list: 1 2 3 4 5 squares = [] for value in range ( 1 , 11 ): square = value ** 2 squares . append ( square ) print ( squares ) We start with an empty list called squares . Next, we tell Python to loop through each value from 1 to 10 using the range () function. Inside the loop, the current value is raised to the second power and assigned to the variable square . Finally, when the loop has finished running, the list of squares is printed: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] To write this code even more precisely, omit the temporary variable square and append each new value directly to the list: 1 2 3 4 squares = [] for value in range ( 1 , 11 ): squares . append ( value ** 2 ) print ( squares ) Sometimes using a temporary value makes our code easier to read; other times it makes the code unecessarily long. Simple Statistics with a List of Numbers A few Python functions are helpful when working with lists of numbers. For example, you can easily find the minimum, maximum, and sum of a list of numbers: 1 2 3 4 digits = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ] print ( min ( digits )) print ( max ( digits )) print ( sum ( digits )) The above code will give you the following result: 0 9 45 List Comprehensions The approach described earlier for generating the list squares consisted of using three or four lines of code. A list comprehension combines the for loop and the creating of new elements into one line, and automatically appends each new element. The following example builds the same list of square numbers you saw earlier but uses a list comprehension: 1 2 squares = [ value ** 2 for value in range ( 1 , 11 )] print ( squares ) To use this syntax, begin with a descriptive name for the list, such as squares . Next open a set of square brackets and define the expression for the values you want to store in the new list. In this example, the expression value ** 2 , which raises the value to the second power. Then, write a for loop to generate the numbers you want to feed into the expression, and close the square brackets. The for loop in this example is for value in range ( 1 , 11 ) , which feeds the values 1 through 10 into the expression value ** 2 . Notice that no colon is used at the end of the for statement. The result is the same list of square numbers you saw earlier: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] Extra Problems Use a for loop to print the numbers 1 to 20 1 2 3 4 numbers = list ( range ( 1 , 21 )) for number in numbers : print ( number ) Make a list from one to one million, and then use min () and max () to make sure your list is complete. Also use the sum () function 1 2 3 4 5 numbers = list ( range ( 1 , 1000001 )) print ( min ( numbers )) print ( max ( numbers )) print ( sum ( numbers )) Use the third argument of the range () function to make a list of the odd numbers from 1 to 20. Use a for () loop to print each number 1 2 3 4 odd_numbers = list ( range ( 1 , 21 , 2 )) for numbers in odd_numbers : print ( numbers ) Make a list of the multiples of 3 from 3 to 30. Use a for () loop to print the numbers in your list 1 2 3 4 multiples = list ( range ( 3 , 31 , 3 )) for numbers in multiples : print ( numbers ) Make a list of the first 10 cubes and use a for loop to print out each value of each cube 1 2 3 4 cubes = [] for value in range ( 1 , 11 ): cubes . append ( value ** 3 ) print ( cubes ) Use a list comprehension to generate a list of the first 10 cubes 1 2 cubes = [ value ** 3 for value in range ( 1 , 11 )] print ( cubes ) Working with Part of a List You are able to work with a specific group of items in a list, which Python calls a slice . Slicing a List To make a slice, you specify the index of the first and last elements you want to work with. As with the range () function, Python stops one item before the second index you specify. To output the first three elements in a list, you would request indices 0 through 3, which would return elements 0, 1, and 2. The following example involves a list of players on a team: 1 2 players = [ 'charles' , 'martina' , 'florence' , 'eli' ] print ( players [ 0 : 3 ]) The code on line 2 prints a slice of that list, including just the values at index 0 - 2. If you omit the first index in a slice, Python automaticaly starts your slice at the beginning of the list. Similarly, if you omit the second index, Python will go from the set starting index through the end of the list. You can also include a third value in the slice brackets, telling Python how many items to skip through while going through the specified range. Looping Through a Slice You can use a slice in a for loop if you want to loop through s subset of the elements in a list. In the next example, we loop through the first three players and print their names as part of a simple roster: 1 2 3 4 5 players = [ 'charles' , 'martina' , 'michael' , 'florence' , 'eli' ] print ( \"Here are the first three players on my team:\" ) for player in players [: 3 ]: print ( player . title ()) Instead of looping through the entire list of players, Python loops through only the first three names. Slices are very useful in a number of situations. For instance, when you're building a web application, you could use slices to display information in a series of pages with an appropriate ammount of information on each page. Copying a List Often, you'll want to start with an existing list and make an entirely new list based on the first one. Let's explore how copying a list works and examine one situation in which copying a list is useful. To copy a list, you can make a slice that include the entire original list by omitting the first and the second index ([:]). This tells Python to make a slice that starts at the first item and ends with the last item, producing a copy of the entire list. Let's copy a list using slice: 1 2 3 4 5 6 7 8 my_foods = [ 'pizza' , 'burgers' , 'steak' ] friend_foods = my_foods [:] print ( \"My favorite foods are:\" ) print ( my_foods ) print ( \" \\n My friend's favorite foods are:\" ) print ( friend_foods ) On the first line we created a list of our favorite foods called my_foods . Next, we made a copy of my_foods in a new list called friend_foods . We created the copy by asking for a slice without specifying an index ([:]). When we print each list, we see that they both contain the same foods: My favorite foods are: ['pizza', 'burgers', 'steak'] My friend's favorite foods are: ['pizza', 'burgers', 'steak'] To prove that we actually have two seperate lists, we'll add a new food to each list and show that each list keeps track of the appropriate person's favorite foods: 1 2 3 4 5 6 7 8 9 10 11 my_foods = [ 'pizza' , 'burgers' , 'steak' ] friend_foods = my_foods [:] my_foods . append ( 'canoli' ) friend_foods . append ( 'ice cream' ) print ( \"My favorite foods are:\" ) print ( my_foods ) print ( \" \\n My friend's favorite foods are:\" ) print ( friend_foods ) Now we get the result: My favorite foods are: ['pizza', 'burgers', 'steak', 'canoli'] My friend's favorite foods are: ['pizza', 'burgers', 'steak', 'ice cream'] Tuples Lists work well for storing collections of items that can change throughout the life of a program. The ability to modify lists is particularly important when you're working with a list of users on a website or a list of characters in a game. However, sometimes you'll want to create a list of items that cannot change. Tuples allow you to do just that. Python refers to values that cannot change as immutable , and an immutable list is called a tuple . Defining a Tuple A tuple looks just like a list except you use parentheses instead of square brackets. Once you define a tuple, you can access individual elements by using each item's index, just as you would for a list. For example, if we have a rectangle that should always be a certain size, we can ensure that its size doesn't change by putting the dimensions into a tuple: 1 2 3 dimensions = ( 200 , 50 ) print ( dimensions [ 0 ]) print ( dimensions [ 1 ]) We define a tuple dimensions in line 1, using parentheses instead of square brackets. Next, we print each element in the tuple individually, using the same syntax we've been using to access elements in a list: 200 50 Let's see what happens if we try to change one of the items in the tuples dimensions: 1 2 dimensions = ( 200 , 50 ) dimensions [ 0 ] = 250 Wehn we try to run the above code we get a \"tuple error\": Note on Tuples Tuples are technically defined by the presence of a comma; the parenthes make them look neater and more readable. If you want to define a tuple with one element, you need to include a trailing comma: 1 my_t = ( 3 ,) It doesn't often make sense to build a tuple with one element, but this can happen when tuples are generated automatically. Looping Through All Values in a Tuple You can loop over all the values in a tuple using a for loop, just as you did with a list: 1 2 3 dimensions = ( 200 , 50 ) for dimension in dimensions : print ( dimension ) Python will then return all the elements in the tuple, just as it would for a list. Writing over a Tuple Although you cannot modify a tuple, you can assign a new value to a variable that represents a tuple. So if we wanted to change our dimensions, we could redefine an entire tuple: 1 2 3 4 5 6 7 8 9 dimensions = ( 200 , 50 ) print ( \"Original dimensions:\" ) for dimension in dimensions : print ( dimension ) dimensions = ( 400 , 100 ) print ( \" \\n Modified dimensions:\" ) for dimension in dimensions : print ( dimension ) The code at line 1 defines the original tuple and print the initial dimensions. At line 6, we associate a new tuple with the variable dimensions . We then print the new dimensions at line 7. Python does not return any erros this time, because reassigning a variable is valid: Original dimensions: 200 50 Modified dimensions: 400 100 When compared with lists, tuples are simple data structures. Use them when you want to store a set of values that should not be changed throughout the life of a program.","title":"Working with Lists"},{"location":"py-working-with-lists/#working-with-lists","text":"","title":"Working with Lists"},{"location":"py-working-with-lists/#looping-through-an-entire-list","text":"You'll often want to run through all entries in a list, performing the same task with each item. For example, in a game you might want to move every element on the screen by the same amount, or in a list of numbers you might want to perform the same statistical operation on every element. Or perhaps, you'll want to display each headline from a list of articles on a website. When you want to do the sam eaction with every item in a list, you can use Python's for loop. Let's say we have a list of magician's names, and we want to print out each name in the list. We could do this by retrieving each name from the list individually, but this approach could cause several problems. For one, it would be repetitive to do this with a long list of names. Also, we'd have to change our code each time the list's length changed. A for loop avoids both of these issues by letting Python manage these issues internally. Let's use a for loop to print out each name in a list of magicians: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( magician ) We begin by defining the list ( magicians ). Next, we define a for loop. This line tells Python to pull a name from the list magicians , and associate it with the variable magician . Finally, we tell Python to print the name that's been assigned to magician . Python then repeats these steps for each name in the list. Pseudocode for this may look like: For every magician in the list of magicians print the magician's name The output is a simple printout of each name on the list: alice david carolina","title":"Looping Through an Entire List"},{"location":"py-working-with-lists/#a-closer-look-at-looping","text":"The concept of looping is important because it's one of the most common ways a computer automates repetitive tasks. For example, in a simple look, like the one above in magicians , Python initially reads the first line of the loop: 1 for magician in magicians This line tells Python to retrieve the first value from the list magicians and associate it with the variable magician . The first value is 'alice' . Python then reads the next line: 1 print ( magician ) Python prints the current value of magician , which is still 'alice' . Because the list contains more values, Python returns to the first line of the loop: 1 for magician in magicians Python retrieves the next name in the list, 'david' , and associates that value with the variable magician . Python then executes the line: 1 print ( magician ) Python prints the current value of magician again, which is now 'david' . Python repeats the entire loop once more with the last value in the list 'carolina' . Because no more values are in the list, Python moves on to the next line in the program. In this case nothing comes after the for loop, so the program simply ends. When you're using loops for the first time, keep in mind that the set of steps is repeated once for each item in the list, no matter how many items are in the list. If you have a million items in your list, Python repeats these steps a million times -- and usually very quickly. Also keep in mind when writing your own for loops that you can choose any name you want for the temporary variable that will be associated with each value in the list. However, it's helpful to choose a meaningful name that represents a single item from the list. For example, here's a good way to start a for loop for a list of cats, a list of dogs, and a general list of items: 1 2 3 for cat in cats : for dog in dogs : for item in list_of_items : These naming conventions can help you follow the action being done on each item within a for loop. Using a singular and plural names can help you identify whether a section of code is working with a single element from the list or the entire list.","title":"A Closer Look at Looping"},{"location":"py-working-with-lists/#doing-more-work-within-a-for-loop","text":"You can do just about anything with each item in a for loop. Let's build on the previous example by printing a message to each magician, telling them that they performed a great trick: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) The only difference in this code is within the for loop, where we compose a message to each magician, starting with their name. The first time through the loop the value of magician is 'alice' , so Python starts the first message with the name 'alice' . The seond time through the message begins with the next index in the list ( 'david' ). The output should look as follows: Alice, that was a great trick! David, that was a great trick! Carolina, that was a great trick! You can also write as many lines of code as you like in the for loop. Every indented line following the line for magician in magicians is considered inside the loop , and each indented line is executed once for each value in the list. Therefore, you can do as much work as you like with each value in the list. Let's add a second line to our message, telling each magician that we're looking forward to their next trick: 1 2 3 4 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) Because both calls for print () are indented, each line will be executed once for every magician in the list. This will have the output: Alice, that was a great trick! I can't wait to see your next trick, Alice. David, that was a great trick! I can't wait to see your next trick, David. Carolina, that was a great trick! I can't wait to see your next trick, Carolina.","title":"Doing More Work Within a for Loop"},{"location":"py-working-with-lists/#doing-something-after-a-for-loop","text":"What happens once a for loop has finished executing? Usually, you'll want to summarize a block of output or move on to other work that your program must accomplish. Any lines of code after the for loop that are not indented are executed once without repition. Let's write a thank you to the group of magicians as a whole for putting on an excellent show. To display this group message after all the individual messages have been printed, we place the thank you message after the for loop without indentation: 1 2 3 4 5 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) print ( \"Thank you, everyone. That was a great magic show!\" ) The first two calls to print () are repeated once for each magician in the list, as you saw earlier. However, because the final line is not indented, it's printed only once: Alice, that was a great trick! I can't wait to see your next trick, Alice. David, that was a great trick! I can't wait to see your next trick, David. Carolina, that was a great trick! I can't wait to see your next trick, Carolina. Thank you, everyone. That was a great magic show! When you're processing data using a for loop, you'll find that this is a good way to summarize an operation that was performed on an entire data set. For example, you might use a for loop to initialize a game by running through a list of characters and displaying each character on the screen. You might then write some additional code after this loop tha displays a Play Now button after all the characters have been drawn to the screen.","title":"Doing Something After a for Loop"},{"location":"py-working-with-lists/#avoiding-indentation-errors","text":"Python uses indentation to determine how a line, or group of lines, is related to the rest of the program. In the previous examples, the lines that printed messages to individual magicians were part of the for loop because they were indented. Python's use of indentation makes code very easy to read. Basically, it uses whitespace to force you to write neatly formatted code indented at a few different levels. These indentation levels help you gain a general sense of the overall program's organization. As you begin to write code that relies on proper indentation, you'll need to watch for a few common indentation errors . For example, people sometimes indent lines of code that don't need to be indented or forget to indent lines that need to be indented. Seeing examples of these errors now will help you avoid them in the future and correct them when they do appear in your own programs. Let's examine some of the more common indentation errors:","title":"Avoiding Indentation Errors"},{"location":"py-working-with-lists/#forgetting-to-indent","text":"Always indent the line after the for statement in a loop. If you forget, Python will remind you: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( magician ) The call to print () above should be indented, but it is not. When Python expects an indented block and does not find one, it lets you know which line it had a problem with. The following is what would be output if you ran the code above: File \"<filename>\", line 3 print(magician) ^ IndentationError: expected an indented block You can usually resolve this kind of indentation error by indenting the line or lines immediately after the for statement.","title":"Forgetting to Indent"},{"location":"py-working-with-lists/#forgetting-to-indent-additional-lines","text":"Sometimes your loop will run without any errors but won't produce the expected result. This can happen when you're trying to do several tasks in a loop and you forget to indent some of its lines. For example, this is what happens when we forget to indent the seconf line in the loop that tells each magician we're looking forward to their next trick: 1 2 3 4 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) The second call to print should also be indented, but because Python finds at least one indented line after the for statement, it doen't report an error. As a result, the first print () is executed once for each name in the list, but because the second print () call is not indented, it will only run once. Because the final value associated with magician is 'carolina' , she is the only one who recieves the \"looking forward to the next trick message\": Alice, that was a great trick! David, that was a great trick! Carolina, that was a great trick! I can't wait to see your next trick, Carolina. This is a logical error . The syntax is valid Python code, but the code does not produce the desired result because a problem occurs in its logic. If you expect to see a certain action repeated once for each item in a list and it's only executed once, determine whether you need to simply indent a line or group of lines to remedy the problem.","title":"Forgetting to Indent Additional Lines"},{"location":"py-working-with-lists/#indenting-unnecessarily","text":"If you accidentally indent a line that doesn't need to be indented, Python will inform you about the unexpected indent: 1 2 message = \"Hello Python World!\" print ( message ) We do not need the indent before the print () call, because it is not part of a loop. Python will report the following error: 1 2 3 4 File \"<ipython-input-1-2f2b50073239>\" , line 2 print ( message ) ^ IndentationError : unexpected indent You can avoid unexpected indentation errors by indenting only when you have a specific reason to do so. So far, we have only needed to indent when we used a for loop.","title":"Indenting Unnecessarily"},{"location":"py-working-with-lists/#forgetting-the-colon","text":"The colon at the end of a for statement tells Python to interpret the next line as the start of a loop: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians print ( magician ) Notice that we are missing the colon at the end of line 2. This will cause a syntax error in Python because it will not be able to interpret what we are trying to do. The above code will give you the following error: 1 2 3 4 File \"<ipython-input-2-082d5f15acfa>\" , line 2 for magician in magicians ^ SyntaxError : invalid syntax","title":"Forgetting the Colon"},{"location":"py-working-with-lists/#making-numerical-lists","text":"Many reasons exist to store a set of numbers. For example, you'll need to keep track of the positions of each character in a game, and you might want to keep track of a player's high scores as well. In data visualizations, you'll almost always work with sets of numbers, such as termperatures, distances, population sizes, or latitude and logitude values, among other types of numerical sets. Lists are ideal for storing sets of numbers, and Python provides a vairety of tools to help you work effeciently with lists of numbers. Once you understand how to use these tools effectively, your code will work well even when your lists contain millions of items.","title":"Making Numerical Lists"},{"location":"py-working-with-lists/#using-the-range-function","text":"Python's range () function makes it easy to generate a series of numbers. For example, you can use the range () function to print a series of numbers like this: 1 2 for value in range ( 1 , 5 ): print ( value ) Although this code looks like it should print numbers from 1 to 5, it does not print the number 5: 1 2 3 4 In this example, range () only prints the numbers 1 through 4. This is another result of the off-by-one behavior you'll often see in programming languages. The range () function causes Python to start counting at the first value you give it, and stops when it reaches the second value you provide. Because it stops at the second value, the output never contains the end value, which would have been 5 in this case. To print the numbers 1 to 5, you would use range ( 1 , 6 ) . If your output is different than what you expect when you're using range () , try adjusting your end value by 1.","title":"Using the range() function"},{"location":"py-working-with-lists/#using-range-to-make-a-list-of-numbers","text":"If you want to make a list of numbers you can conver the results of range () directly into a list using the list () function. When you wrap list () around a call to the range () function, the output will be a list of numbers. In the example in the previous section, we simply printed out a series of numbers. We can use the list () function to convert that same set of numbers into a list: 1 2 numbers = list ( range ( 1 , 6 )) print ( numbers ) And this is the result: [1, 2, 3, 4, 5] We can also use the range () function to tell Python to skip numbers in a given range. If you pass a third argument to range () , Python uses that value as a step size when generating numbers. For example, here's how to list the even numbers between 1 and 10: 1 2 even_numbers = list ( range ( 2 , 11 , 2 )) print ( even_numbers ) In this example, the range () function starts with the value 2 and then adds 2 to that value, until it reaches index 11 (the number 10). This will produce the following result: [2, 4, 6, 8, 10] You can create almost any set of numbers you want to using the range () function. For example, consider how you might make a list of the first 10 square numbers (that is, the square of each integer from 1 through 10). In Python, two asterisks ( ** ) represent exponents. Here's how you might put the first 10 square numbers into a list: 1 2 3 4 5 squares = [] for value in range ( 1 , 11 ): square = value ** 2 squares . append ( square ) print ( squares ) We start with an empty list called squares . Next, we tell Python to loop through each value from 1 to 10 using the range () function. Inside the loop, the current value is raised to the second power and assigned to the variable square . Finally, when the loop has finished running, the list of squares is printed: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] To write this code even more precisely, omit the temporary variable square and append each new value directly to the list: 1 2 3 4 squares = [] for value in range ( 1 , 11 ): squares . append ( value ** 2 ) print ( squares ) Sometimes using a temporary value makes our code easier to read; other times it makes the code unecessarily long.","title":"Using range() to Make a List of Numbers"},{"location":"py-working-with-lists/#simple-statistics-with-a-list-of-numbers","text":"A few Python functions are helpful when working with lists of numbers. For example, you can easily find the minimum, maximum, and sum of a list of numbers: 1 2 3 4 digits = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ] print ( min ( digits )) print ( max ( digits )) print ( sum ( digits )) The above code will give you the following result: 0 9 45","title":"Simple Statistics with a List of Numbers"},{"location":"py-working-with-lists/#list-comprehensions","text":"The approach described earlier for generating the list squares consisted of using three or four lines of code. A list comprehension combines the for loop and the creating of new elements into one line, and automatically appends each new element. The following example builds the same list of square numbers you saw earlier but uses a list comprehension: 1 2 squares = [ value ** 2 for value in range ( 1 , 11 )] print ( squares ) To use this syntax, begin with a descriptive name for the list, such as squares . Next open a set of square brackets and define the expression for the values you want to store in the new list. In this example, the expression value ** 2 , which raises the value to the second power. Then, write a for loop to generate the numbers you want to feed into the expression, and close the square brackets. The for loop in this example is for value in range ( 1 , 11 ) , which feeds the values 1 through 10 into the expression value ** 2 . Notice that no colon is used at the end of the for statement. The result is the same list of square numbers you saw earlier: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]","title":"List Comprehensions"},{"location":"py-working-with-lists/#extra-problems","text":"Use a for loop to print the numbers 1 to 20 1 2 3 4 numbers = list ( range ( 1 , 21 )) for number in numbers : print ( number ) Make a list from one to one million, and then use min () and max () to make sure your list is complete. Also use the sum () function 1 2 3 4 5 numbers = list ( range ( 1 , 1000001 )) print ( min ( numbers )) print ( max ( numbers )) print ( sum ( numbers )) Use the third argument of the range () function to make a list of the odd numbers from 1 to 20. Use a for () loop to print each number 1 2 3 4 odd_numbers = list ( range ( 1 , 21 , 2 )) for numbers in odd_numbers : print ( numbers ) Make a list of the multiples of 3 from 3 to 30. Use a for () loop to print the numbers in your list 1 2 3 4 multiples = list ( range ( 3 , 31 , 3 )) for numbers in multiples : print ( numbers ) Make a list of the first 10 cubes and use a for loop to print out each value of each cube 1 2 3 4 cubes = [] for value in range ( 1 , 11 ): cubes . append ( value ** 3 ) print ( cubes ) Use a list comprehension to generate a list of the first 10 cubes 1 2 cubes = [ value ** 3 for value in range ( 1 , 11 )] print ( cubes )","title":"Extra Problems"},{"location":"py-working-with-lists/#working-with-part-of-a-list","text":"You are able to work with a specific group of items in a list, which Python calls a slice .","title":"Working with Part of a List"},{"location":"py-working-with-lists/#slicing-a-list","text":"To make a slice, you specify the index of the first and last elements you want to work with. As with the range () function, Python stops one item before the second index you specify. To output the first three elements in a list, you would request indices 0 through 3, which would return elements 0, 1, and 2. The following example involves a list of players on a team: 1 2 players = [ 'charles' , 'martina' , 'florence' , 'eli' ] print ( players [ 0 : 3 ]) The code on line 2 prints a slice of that list, including just the values at index 0 - 2. If you omit the first index in a slice, Python automaticaly starts your slice at the beginning of the list. Similarly, if you omit the second index, Python will go from the set starting index through the end of the list. You can also include a third value in the slice brackets, telling Python how many items to skip through while going through the specified range.","title":"Slicing a List"},{"location":"py-working-with-lists/#looping-through-a-slice","text":"You can use a slice in a for loop if you want to loop through s subset of the elements in a list. In the next example, we loop through the first three players and print their names as part of a simple roster: 1 2 3 4 5 players = [ 'charles' , 'martina' , 'michael' , 'florence' , 'eli' ] print ( \"Here are the first three players on my team:\" ) for player in players [: 3 ]: print ( player . title ()) Instead of looping through the entire list of players, Python loops through only the first three names. Slices are very useful in a number of situations. For instance, when you're building a web application, you could use slices to display information in a series of pages with an appropriate ammount of information on each page.","title":"Looping Through a Slice"},{"location":"py-working-with-lists/#copying-a-list","text":"Often, you'll want to start with an existing list and make an entirely new list based on the first one. Let's explore how copying a list works and examine one situation in which copying a list is useful. To copy a list, you can make a slice that include the entire original list by omitting the first and the second index ([:]). This tells Python to make a slice that starts at the first item and ends with the last item, producing a copy of the entire list. Let's copy a list using slice: 1 2 3 4 5 6 7 8 my_foods = [ 'pizza' , 'burgers' , 'steak' ] friend_foods = my_foods [:] print ( \"My favorite foods are:\" ) print ( my_foods ) print ( \" \\n My friend's favorite foods are:\" ) print ( friend_foods ) On the first line we created a list of our favorite foods called my_foods . Next, we made a copy of my_foods in a new list called friend_foods . We created the copy by asking for a slice without specifying an index ([:]). When we print each list, we see that they both contain the same foods: My favorite foods are: ['pizza', 'burgers', 'steak'] My friend's favorite foods are: ['pizza', 'burgers', 'steak'] To prove that we actually have two seperate lists, we'll add a new food to each list and show that each list keeps track of the appropriate person's favorite foods: 1 2 3 4 5 6 7 8 9 10 11 my_foods = [ 'pizza' , 'burgers' , 'steak' ] friend_foods = my_foods [:] my_foods . append ( 'canoli' ) friend_foods . append ( 'ice cream' ) print ( \"My favorite foods are:\" ) print ( my_foods ) print ( \" \\n My friend's favorite foods are:\" ) print ( friend_foods ) Now we get the result: My favorite foods are: ['pizza', 'burgers', 'steak', 'canoli'] My friend's favorite foods are: ['pizza', 'burgers', 'steak', 'ice cream']","title":"Copying a List"},{"location":"py-working-with-lists/#tuples","text":"Lists work well for storing collections of items that can change throughout the life of a program. The ability to modify lists is particularly important when you're working with a list of users on a website or a list of characters in a game. However, sometimes you'll want to create a list of items that cannot change. Tuples allow you to do just that. Python refers to values that cannot change as immutable , and an immutable list is called a tuple .","title":"Tuples"},{"location":"py-working-with-lists/#defining-a-tuple","text":"A tuple looks just like a list except you use parentheses instead of square brackets. Once you define a tuple, you can access individual elements by using each item's index, just as you would for a list. For example, if we have a rectangle that should always be a certain size, we can ensure that its size doesn't change by putting the dimensions into a tuple: 1 2 3 dimensions = ( 200 , 50 ) print ( dimensions [ 0 ]) print ( dimensions [ 1 ]) We define a tuple dimensions in line 1, using parentheses instead of square brackets. Next, we print each element in the tuple individually, using the same syntax we've been using to access elements in a list: 200 50 Let's see what happens if we try to change one of the items in the tuples dimensions: 1 2 dimensions = ( 200 , 50 ) dimensions [ 0 ] = 250 Wehn we try to run the above code we get a \"tuple error\": Note on Tuples Tuples are technically defined by the presence of a comma; the parenthes make them look neater and more readable. If you want to define a tuple with one element, you need to include a trailing comma: 1 my_t = ( 3 ,) It doesn't often make sense to build a tuple with one element, but this can happen when tuples are generated automatically.","title":"Defining a Tuple"},{"location":"py-working-with-lists/#looping-through-all-values-in-a-tuple","text":"You can loop over all the values in a tuple using a for loop, just as you did with a list: 1 2 3 dimensions = ( 200 , 50 ) for dimension in dimensions : print ( dimension ) Python will then return all the elements in the tuple, just as it would for a list.","title":"Looping Through All Values in a Tuple"},{"location":"py-working-with-lists/#writing-over-a-tuple","text":"Although you cannot modify a tuple, you can assign a new value to a variable that represents a tuple. So if we wanted to change our dimensions, we could redefine an entire tuple: 1 2 3 4 5 6 7 8 9 dimensions = ( 200 , 50 ) print ( \"Original dimensions:\" ) for dimension in dimensions : print ( dimension ) dimensions = ( 400 , 100 ) print ( \" \\n Modified dimensions:\" ) for dimension in dimensions : print ( dimension ) The code at line 1 defines the original tuple and print the initial dimensions. At line 6, we associate a new tuple with the variable dimensions . We then print the new dimensions at line 7. Python does not return any erros this time, because reassigning a variable is valid: Original dimensions: 200 50 Modified dimensions: 400 100 When compared with lists, tuples are simple data structures. Use them when you want to store a set of values that should not be changed throughout the life of a program.","title":"Writing over a Tuple"},{"location":"py/","text":"Python Basics Quick Links Python Documentation Python Beginner's Help (PDF) Python Cheat Sheet Learning Python - 5 th Edition (2014) (PDF) Python Crash Course - 2 nd Edition (2019) (PDF) Python Crash Course - Basics Introduction Python is a powerful multiparadigm computer programming language, optimized for programmer productivity, code readability, and software quality. Python is a popular open source programming language used for both standalone programs and scripting applications in a wide variety of domains Python is an excellent and versatile language choice for making complex C operations much simpler: String manipulation Networking Python Syntax To start writing Python, open up a file with the .py file extension. Unlike a C program, which typically has to be compiled before you run it, a Python program can be run without explicitly compiling it first. Variables Python variables have three big differences from C: No type specifier Declared by initialization only Python statements do not need to be ended with semicolons Conditionals All of the old favorites from C are still available for you to use: elif - else if True / False (bool) input() - collects user input Loops Two varieties: while and for 1 2 3 4 counter = 0 while counter < 100 : print ( counter ) counter += 1 1 2 for x in range ( 100 ): print ( x ) Arrays Lists Here is where things really start to get a lot better than C. Python arrays (more appropriately known as lists ) are not fixed in size; they can grow or shrink as needed, and you can always tack extra elements onto your array and splce things in and out easily. 1 nums = [ 1 , 2 , 3 , 4 ] Instead of square bracket syntax, you can also simply use a function to create a list: 1 nums = list () Tuples Tuples are ordered, immutable sets of data; they are great for associating collections of data, sort of like a struct in C, but where those values are unlikely to change. Here is a list of tuples: 1 2 3 4 5 6 presidents = [ ( \"George Washington\" , 1789 ), ( \"John Adams\" , 1797 ), ( \"Thomas Jefferson\" , 1801 ), ( \"James Madison\" , 1809 ) ] This list is iterable as well: 1 2 for prez , year in presidents : print ( \"In {1} , {0} took office\" . format ( prez , year )) Dictionaries Python also has built in support for dictionaries, allowing you to specifiy list indices with words or phrases (keys). 1 2 3 4 5 6 pizzas = { \"cheese\" : 9 , \"pepperoni\" : 10 , \"vegetable\" : 11 , \"buffalo chicken\" : 12 } Functions Python has support fr functions as well. Like variables, we don't need to specifiy the return type of the function (because it doesn't matter), nor the data types of any parameters. All functions are introduced with the def keyword. 1 2 3 4 5 def square ( x ): result = 0 for i in range ( 0 , x ): result += x return result Objects Python is an object-oriented programming language. Objects have properties and methods , or functions that are inherent to the object, and mean nothing outside of it. You must also define methods inside the object. 1 object . method () You define a type of object using the class keyword in Python. Classes require an initialization function, also more-generally known as a constructor , which sets the starting values of the properties of the object. In defining each method of an object, self should be its first parameter, which stipulates on what object the method is called. 1 2 3 4 5 6 7 8 9 10 11 class Student (): def __init__ ( self , name , id ): self . name = name self . id = id def changeID ( self , id ): self . id = id def print ( self ): print ( \" {} - {} \" . format ( self . name , self . id )) Style If you haven't noticed by now, good style is crucial in Python. Tabs and indentation actually matter in this language, and things will not work the way you intend for them to if you disregard styling! First Program 1 print ( \"Hello Python World!\" ) If you compare this to C's first code , you will notice that we no longer need to create a main function or import the <stdio.h> library. Troubleshooting in Python When a program contains a significant error, Python displays a trace-back , which is an error report. Python looks through the file and tries to identify the problem. Check the traceback; it might give you a clue as to what the issue is preventing the program from running. Remember how important syntax is in Python, and every other programming language, and review your code.","title":"Python Basics"},{"location":"py/#python-basics","text":"","title":"Python Basics"},{"location":"py/#quick-links","text":"Python Documentation Python Beginner's Help (PDF) Python Cheat Sheet Learning Python - 5 th Edition (2014) (PDF) Python Crash Course - 2 nd Edition (2019) (PDF) Python Crash Course - Basics","title":"Quick Links"},{"location":"py/#introduction","text":"Python is a powerful multiparadigm computer programming language, optimized for programmer productivity, code readability, and software quality. Python is a popular open source programming language used for both standalone programs and scripting applications in a wide variety of domains Python is an excellent and versatile language choice for making complex C operations much simpler: String manipulation Networking","title":"Introduction"},{"location":"py/#python-syntax","text":"To start writing Python, open up a file with the .py file extension. Unlike a C program, which typically has to be compiled before you run it, a Python program can be run without explicitly compiling it first.","title":"Python Syntax"},{"location":"py/#variables","text":"Python variables have three big differences from C: No type specifier Declared by initialization only Python statements do not need to be ended with semicolons","title":"Variables"},{"location":"py/#conditionals","text":"All of the old favorites from C are still available for you to use: elif - else if True / False (bool) input() - collects user input Loops Two varieties: while and for 1 2 3 4 counter = 0 while counter < 100 : print ( counter ) counter += 1 1 2 for x in range ( 100 ): print ( x )","title":"Conditionals"},{"location":"py/#arrays-lists","text":"Here is where things really start to get a lot better than C. Python arrays (more appropriately known as lists ) are not fixed in size; they can grow or shrink as needed, and you can always tack extra elements onto your array and splce things in and out easily. 1 nums = [ 1 , 2 , 3 , 4 ] Instead of square bracket syntax, you can also simply use a function to create a list: 1 nums = list ()","title":"Arrays Lists"},{"location":"py/#tuples","text":"Tuples are ordered, immutable sets of data; they are great for associating collections of data, sort of like a struct in C, but where those values are unlikely to change. Here is a list of tuples: 1 2 3 4 5 6 presidents = [ ( \"George Washington\" , 1789 ), ( \"John Adams\" , 1797 ), ( \"Thomas Jefferson\" , 1801 ), ( \"James Madison\" , 1809 ) ] This list is iterable as well: 1 2 for prez , year in presidents : print ( \"In {1} , {0} took office\" . format ( prez , year ))","title":"Tuples"},{"location":"py/#dictionaries","text":"Python also has built in support for dictionaries, allowing you to specifiy list indices with words or phrases (keys). 1 2 3 4 5 6 pizzas = { \"cheese\" : 9 , \"pepperoni\" : 10 , \"vegetable\" : 11 , \"buffalo chicken\" : 12 }","title":"Dictionaries"},{"location":"py/#functions","text":"Python has support fr functions as well. Like variables, we don't need to specifiy the return type of the function (because it doesn't matter), nor the data types of any parameters. All functions are introduced with the def keyword. 1 2 3 4 5 def square ( x ): result = 0 for i in range ( 0 , x ): result += x return result","title":"Functions"},{"location":"py/#objects","text":"Python is an object-oriented programming language. Objects have properties and methods , or functions that are inherent to the object, and mean nothing outside of it. You must also define methods inside the object. 1 object . method () You define a type of object using the class keyword in Python. Classes require an initialization function, also more-generally known as a constructor , which sets the starting values of the properties of the object. In defining each method of an object, self should be its first parameter, which stipulates on what object the method is called. 1 2 3 4 5 6 7 8 9 10 11 class Student (): def __init__ ( self , name , id ): self . name = name self . id = id def changeID ( self , id ): self . id = id def print ( self ): print ( \" {} - {} \" . format ( self . name , self . id ))","title":"Objects"},{"location":"py/#style","text":"If you haven't noticed by now, good style is crucial in Python. Tabs and indentation actually matter in this language, and things will not work the way you intend for them to if you disregard styling!","title":"Style"},{"location":"py/#first-program","text":"1 print ( \"Hello Python World!\" ) If you compare this to C's first code , you will notice that we no longer need to create a main function or import the <stdio.h> library.","title":"First Program"},{"location":"py/#troubleshooting-in-python","text":"When a program contains a significant error, Python displays a trace-back , which is an error report. Python looks through the file and tries to identify the problem. Check the traceback; it might give you a clue as to what the issue is preventing the program from running. Remember how important syntax is in Python, and every other programming language, and review your code.","title":"Troubleshooting in Python"},{"location":"sql-joins-and-other-queries/","text":"SQL Joins and Other Query Types Multi-Table queries with JOIN s Up to now, we've been working with a single table, but entity data in the real world is often broken down into pieces and stored across multiple orthogonal tables using a process known as normalization . Database Normalization Tables that share information about a single entity need to have a primary key that identifies that entity uniquely across the database. One common primary key type is an auto-incrementing integer (because they are space efficient), but it can also be a string, hashed value, so long as it is unique. Using the JOIN clause in a query, we can combine row data across two separate tables using this unique key. The first of the joins that we will introduce is the INNER JOIN . SELECT column , another_table_column , ... FROM mytable INNER JOIN another_table ON mytable . id = another_table . id WHERE condition ( s ) ORDER BY column , ... ASC / DESC LIMIT num_limit OFFSET num_offset ; The INNER JOIN is a process that matches rows from the first table and the second table which have the same key (as defined by the ON constraint) to create a result row with the combined columns from both tables. After the tables are joined, the other clauses we learned previously are then applied. JOIN vs. INNER JOIN You may see queries where the INNER JOIN is written simply as a JOIN . These two are equivalent, but we will continue to refer to these joins as inner-joins because they make the query easier to read once you start using other types of joins. Let's do some exercises where we look at multiple tables. We will use the Movies.csv file from previous examples and a new Boxoffice.csv file with additional movie information. Find the domestic and international sales for each movie: SELECT title , domestic_sales , international_sales FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; Show the sales numbers for each movie that did better internationally rather than domestically: SELECT title , domestic_sales , international_sales FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id WHERE international_sales > domestic_sales ; List all the movies by their ratings in descending order: SELECT title , rating FROM movies JOIN boxoffice on movies . id = boxoffice . movie_id ORDER BY rating DESC ; Outer Joins Depending on how you want to analyze the data, the INNER JOIN might not be sufficient because the resulting table only contains data that belongs in both of the tables. If the two tables have asymmetric data, which can easily happen when data is entered in different stages, then we would have to use a LEFT JOIN , RIGHT JOIN , or FULL JOIN instead to ensure that the data you need is not left out of the results. SELECT column , another_column , ... FROM mytable INNER / LEFT / RIGHT / FULL JOIN another_table ON mytable . id = another_table . matching_id WHERE condition ( s ) ORDER BY column , ... ASC / DESC LIMIT num_limit OFFSET num_offset ; Like the INNER JOIN these three new joins have to specify which column to join the data on. When joining table A to table B, a LEFT JOIN simply includes rows from A regardless of whether a matching row is found in B. the RIGHT JOIN is the same, but reversed, keeping rows in B regardless of whether a match is found in A. Finally, a FULL JOIN simply means that rows from both tables are kept, regardless of whether a matching row exists in the other table. When using any of these new joins, you will likely have to write additional logic to deal with NULL s in the result and constraints. JOINS You might see queries with these joins written as LEFT OUTER JOIN , RIGHT OUTER JOIN , or FULL OUTER JOIN , but the OUTER keyword is really kept for SQL-92 compatibility and these queries are simply equivalent to LEFT JOIN , RIGHT JOIN , and FULL JOIN respectively. For the following exercises we will be using new tables. We will use a table which stores fictional data about Employees in the film studio and their assigned office Buildings . Some of the buildings are new, so they don't have any employees in them yet, but we need to find some information about them regardless. Find the list of all buildings that have employees: SELECT DISTINCT building FROM employees ; Find the list of all buildings and their capacity: SELECT building_name , capacity FROM buildings ; List all buildings and the distinct employee roles in each building (including empty buildings): SELECT DISTINCT building_name , role FROM buildings LEFT JOIN employees on building_name = building ; A short note on NULL s It's always good to reduce the possibility of NULL values in databases because they require special attention when constructing queries, constraints (certain functions behave differently with null values) and when processing the results. An alternative to NULL values in your database is to have data-type appropriate default values , like 0 for numerical data, empty strings for text data, etc. But if your database needs to store incomplete data, then NULL values can be appropriate if the default values will skew later analysics (for example, when taking averages of numerical data). Sometimes, it's also not possible to avoid NULL values, as we saw in the last lesson when outer-joining two tables with asymmetric data. In these cases, you can test a column for NULL values in a WHERE clause by using either the IS NULL or IS NOT NULL constraint. SELECT column , another_column , ... FROM mytable WHERE column IS / IS NOT NULL AND / OR another_condition AND / OR ...; For the following exercises, we will be using the same Employees and Buildings tables from the last exercises. Find the name and role of all employees who have not been assigned to a building: SELECT name , role FROM employees WHERE building IS NULL ; Find the names of the buildings that hold no employees: SELECT DISTINCT building_name FROM buildings LEFT JOIN employees ON building_name = building WHERE role IS NULL ; Queries with Expressions In addition to querying and referencing raw column data with SQL, you can also use expressions to write more complex logic on column calues in a query. These expressions can use mathematical and string functions along with basic arithmetic to transform values when the query is executed, as shown in this physics example: SELECT particle_speed / 2 . 0 AS half_particle_speed FROM physics_data WHERE ABS ( particle_position ) * 10 . 0 > 500 ; Each database has its own supported set of mathematical, string, and date functions that can be used in a query, which you can find in their own respective docs. The use of expressions can save time and extra post-processing of the result data, but can also make the query harder to read, so we recommend that when expressions are used in the SELECT part of the query, that they are also given a descriptive alias using the AS keyword. SELECT col_expression AS expr_description , ... FROM mytable ; In addition to expressions, regular columns and even tables can also have aliases to make them easier to reference in the output and as a part of simplifying more complex queries. SELECT column AS better_column_name , ... FROM a_long_widgets_table_name AS mywidgets INNER JOIN widget_sales ON mywidgets . id = widgets_sales . widget_id ; We are now going to use expressions to transform the BoxOffice data into something easier to understand for the tasks below. We will use the Movies.csv and Boxoffice.csv files for the following exercise: List all movies and their combines sales in millions of dollars: SELECT title , ( domestic_sales + international_sales ) / 1000000 AS gross_sales_millions FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; List all movies and their ratings in percent: SELECT title , rating * 10 AS rating_percent FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; List all movies that we released on even number years SELECT title , year FROM movies WHERE year % 2 = 0 ; Odd Vs. Even Remember that to determine if a SQL value is even or odd, we use the module operator ( % ), which returns the remainder after division of its operands. Since the remainder of an even number divided by 2 is always 0, and the remainder of an odd number divided by 2 is always 1 - this makes modulo an easy way to find even/odd numbers. Queries with Aggregates In addition to the simple expressions from above, SQL also supports the use of aggregate expressions (or functions) that allow you to summarize information about a group of rows of data. With the Pixar database we have been using, aggregate functions can be used to answer questions like, \"How many movies has Pixar produced?\", or \"What is the highest grossing Pixar film each year?\". SELECT AGG_FUNC ( column_or_expression ) AS aggregate_description , ... FROM mytable WHERE constraint_expression ; Without a specified grouping, each aggregate function is going to run on the whole set of result rows and return a single value. And like normal expressionsm giving your aggregate functions an alias ensures that the results will be easier to read and process. Common Aggregate Functions Below are some common aggregate functions that we will be using in fututre exercises: Function Description COUNT(*) COUNT (column) A common function used to count the number of rows in the group is no column name is specified. Otherwise, count the number of rows in the group with non-NULL values in the specified column. MIN (column) Finds the smallest numerical value in the specified column for all rows in the group. MAX (column) Finds the largest numerical value in the specified column for all rows in the group. AVG (column) Finds the average numerical value in the specified column for all rows in the group. SUM (column) Finds the sum of all numerical values in the specified column for the rows in the group. Docs: MySQL , Postgres , SQLite","title":"Joins and Other Query Types"},{"location":"sql-joins-and-other-queries/#sql-joins-and-other-query-types","text":"","title":"SQL Joins and Other Query Types"},{"location":"sql-joins-and-other-queries/#multi-table-queries-with-joins","text":"Up to now, we've been working with a single table, but entity data in the real world is often broken down into pieces and stored across multiple orthogonal tables using a process known as normalization .","title":"Multi-Table queries with JOINs"},{"location":"sql-joins-and-other-queries/#database-normalization","text":"Tables that share information about a single entity need to have a primary key that identifies that entity uniquely across the database. One common primary key type is an auto-incrementing integer (because they are space efficient), but it can also be a string, hashed value, so long as it is unique. Using the JOIN clause in a query, we can combine row data across two separate tables using this unique key. The first of the joins that we will introduce is the INNER JOIN . SELECT column , another_table_column , ... FROM mytable INNER JOIN another_table ON mytable . id = another_table . id WHERE condition ( s ) ORDER BY column , ... ASC / DESC LIMIT num_limit OFFSET num_offset ; The INNER JOIN is a process that matches rows from the first table and the second table which have the same key (as defined by the ON constraint) to create a result row with the combined columns from both tables. After the tables are joined, the other clauses we learned previously are then applied. JOIN vs. INNER JOIN You may see queries where the INNER JOIN is written simply as a JOIN . These two are equivalent, but we will continue to refer to these joins as inner-joins because they make the query easier to read once you start using other types of joins. Let's do some exercises where we look at multiple tables. We will use the Movies.csv file from previous examples and a new Boxoffice.csv file with additional movie information. Find the domestic and international sales for each movie: SELECT title , domestic_sales , international_sales FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; Show the sales numbers for each movie that did better internationally rather than domestically: SELECT title , domestic_sales , international_sales FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id WHERE international_sales > domestic_sales ; List all the movies by their ratings in descending order: SELECT title , rating FROM movies JOIN boxoffice on movies . id = boxoffice . movie_id ORDER BY rating DESC ;","title":"Database Normalization"},{"location":"sql-joins-and-other-queries/#outer-joins","text":"Depending on how you want to analyze the data, the INNER JOIN might not be sufficient because the resulting table only contains data that belongs in both of the tables. If the two tables have asymmetric data, which can easily happen when data is entered in different stages, then we would have to use a LEFT JOIN , RIGHT JOIN , or FULL JOIN instead to ensure that the data you need is not left out of the results. SELECT column , another_column , ... FROM mytable INNER / LEFT / RIGHT / FULL JOIN another_table ON mytable . id = another_table . matching_id WHERE condition ( s ) ORDER BY column , ... ASC / DESC LIMIT num_limit OFFSET num_offset ; Like the INNER JOIN these three new joins have to specify which column to join the data on. When joining table A to table B, a LEFT JOIN simply includes rows from A regardless of whether a matching row is found in B. the RIGHT JOIN is the same, but reversed, keeping rows in B regardless of whether a match is found in A. Finally, a FULL JOIN simply means that rows from both tables are kept, regardless of whether a matching row exists in the other table. When using any of these new joins, you will likely have to write additional logic to deal with NULL s in the result and constraints. JOINS You might see queries with these joins written as LEFT OUTER JOIN , RIGHT OUTER JOIN , or FULL OUTER JOIN , but the OUTER keyword is really kept for SQL-92 compatibility and these queries are simply equivalent to LEFT JOIN , RIGHT JOIN , and FULL JOIN respectively. For the following exercises we will be using new tables. We will use a table which stores fictional data about Employees in the film studio and their assigned office Buildings . Some of the buildings are new, so they don't have any employees in them yet, but we need to find some information about them regardless. Find the list of all buildings that have employees: SELECT DISTINCT building FROM employees ; Find the list of all buildings and their capacity: SELECT building_name , capacity FROM buildings ; List all buildings and the distinct employee roles in each building (including empty buildings): SELECT DISTINCT building_name , role FROM buildings LEFT JOIN employees on building_name = building ;","title":"Outer Joins"},{"location":"sql-joins-and-other-queries/#a-short-note-on-nulls","text":"It's always good to reduce the possibility of NULL values in databases because they require special attention when constructing queries, constraints (certain functions behave differently with null values) and when processing the results. An alternative to NULL values in your database is to have data-type appropriate default values , like 0 for numerical data, empty strings for text data, etc. But if your database needs to store incomplete data, then NULL values can be appropriate if the default values will skew later analysics (for example, when taking averages of numerical data). Sometimes, it's also not possible to avoid NULL values, as we saw in the last lesson when outer-joining two tables with asymmetric data. In these cases, you can test a column for NULL values in a WHERE clause by using either the IS NULL or IS NOT NULL constraint. SELECT column , another_column , ... FROM mytable WHERE column IS / IS NOT NULL AND / OR another_condition AND / OR ...; For the following exercises, we will be using the same Employees and Buildings tables from the last exercises. Find the name and role of all employees who have not been assigned to a building: SELECT name , role FROM employees WHERE building IS NULL ; Find the names of the buildings that hold no employees: SELECT DISTINCT building_name FROM buildings LEFT JOIN employees ON building_name = building WHERE role IS NULL ;","title":"A short note on NULLs"},{"location":"sql-joins-and-other-queries/#queries-with-expressions","text":"In addition to querying and referencing raw column data with SQL, you can also use expressions to write more complex logic on column calues in a query. These expressions can use mathematical and string functions along with basic arithmetic to transform values when the query is executed, as shown in this physics example: SELECT particle_speed / 2 . 0 AS half_particle_speed FROM physics_data WHERE ABS ( particle_position ) * 10 . 0 > 500 ; Each database has its own supported set of mathematical, string, and date functions that can be used in a query, which you can find in their own respective docs. The use of expressions can save time and extra post-processing of the result data, but can also make the query harder to read, so we recommend that when expressions are used in the SELECT part of the query, that they are also given a descriptive alias using the AS keyword. SELECT col_expression AS expr_description , ... FROM mytable ; In addition to expressions, regular columns and even tables can also have aliases to make them easier to reference in the output and as a part of simplifying more complex queries. SELECT column AS better_column_name , ... FROM a_long_widgets_table_name AS mywidgets INNER JOIN widget_sales ON mywidgets . id = widgets_sales . widget_id ; We are now going to use expressions to transform the BoxOffice data into something easier to understand for the tasks below. We will use the Movies.csv and Boxoffice.csv files for the following exercise: List all movies and their combines sales in millions of dollars: SELECT title , ( domestic_sales + international_sales ) / 1000000 AS gross_sales_millions FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; List all movies and their ratings in percent: SELECT title , rating * 10 AS rating_percent FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; List all movies that we released on even number years SELECT title , year FROM movies WHERE year % 2 = 0 ; Odd Vs. Even Remember that to determine if a SQL value is even or odd, we use the module operator ( % ), which returns the remainder after division of its operands. Since the remainder of an even number divided by 2 is always 0, and the remainder of an odd number divided by 2 is always 1 - this makes modulo an easy way to find even/odd numbers.","title":"Queries with Expressions"},{"location":"sql-joins-and-other-queries/#queries-with-aggregates","text":"In addition to the simple expressions from above, SQL also supports the use of aggregate expressions (or functions) that allow you to summarize information about a group of rows of data. With the Pixar database we have been using, aggregate functions can be used to answer questions like, \"How many movies has Pixar produced?\", or \"What is the highest grossing Pixar film each year?\". SELECT AGG_FUNC ( column_or_expression ) AS aggregate_description , ... FROM mytable WHERE constraint_expression ; Without a specified grouping, each aggregate function is going to run on the whole set of result rows and return a single value. And like normal expressionsm giving your aggregate functions an alias ensures that the results will be easier to read and process.","title":"Queries with Aggregates"},{"location":"sql-joins-and-other-queries/#common-aggregate-functions","text":"Below are some common aggregate functions that we will be using in fututre exercises: Function Description COUNT(*) COUNT (column) A common function used to count the number of rows in the group is no column name is specified. Otherwise, count the number of rows in the group with non-NULL values in the specified column. MIN (column) Finds the smallest numerical value in the specified column for all rows in the group. MAX (column) Finds the largest numerical value in the specified column for all rows in the group. AVG (column) Finds the average numerical value in the specified column for all rows in the group. SUM (column) Finds the sum of all numerical values in the specified column for the rows in the group. Docs: MySQL , Postgres , SQLite","title":"Common Aggregate Functions"},{"location":"sql-random/","text":"Random SQL Problems Movies Exercise In the following problems we will be using movies.db . This database is made of of multiple tables: movies, ratings, stars, and directors. We will need to JOIN some of these tables to answer some of the following problems: Write a SQL query to list the titles of all movies released in 2008. Your query should output a table with a single column for the title of each movie. SELECT title FROM movies WHERE year = 2008 ; Write a SQL query to determine the birth year of Emma Stone. Your query should output a table with a single column and a single row (plus optional header) containing Emma Stone\u2019s birth year. You may assume that there is only one person in the database with the name Emma Stone. SELECT birth FROM people WHERE name = 'Emma Stone' ; Write a SQL query to list the titles of all movies with a release date on or after 2018, in alphabetical order. Your query should output a table with a single column for the title of each movie. Movies released in 2018 should be included, as should movies with release dates in the future. SELECT title FROM movies WHERE year >= 2018 ORDER BY title ; Write a SQL query to determine the number of movies with an IMDb rating of 10.0. Your query should output a table with a single column and a single row (plus optional header) containing the number of movies with a 10.0 rating. SELECT COUNT ( * ) AS NumberOfMoviesWith10Rating FROM ratings WHERE rating = 10 ; Write a SQL query to list the titles and release years of all Harry Potter movies, in chronological order. Your query should output a table with two columns, one for the title of each movie and one for the release year of each movie. You may assume that the title of all Harry Potter movies will begin with the words \u201cHarry Potter\u201d, and that if a movie title begins with the words \u201cHarry Potter\u201d, it is a Harry Potter movie. SELECT title , year FROM movies WHERE title LIKE \"Harry Potter%\" ORDER BY year ; Write a SQL query to determine the average rating of all movies released in 2012. Your query should output a table with a single column and a single row (plus optional header) containing the average rating. SELECT AVG ( rating ) FROM ratings JOIN movies ON movies . id = ratings . movie_id WHERE year = 2012 ; Write a SQL query to list all movies released in 2010 and their ratings, in descending order by rating. For movies with the same rating, order them alphabetically by title. Your query should output a table with two columns, one for the title of each movie and one for the rating of each movie. Movies that do not have ratings should not be included in the result. SELECT title , rating FROM movies JOIN ratings on movies . id = ratings . movie_id WHERE year = 2010 ORDER BY rating DESC , title ; Write a SQL query to list the names of all people who starred in Toy Story. Your query should output a table with a single column for the name of each person. You may assume that there is only one movie in the database with the title Toy Story. SELECT name FROM people JOIN stars ON people . id = stars . person_id JOIN movies ON movies . id = stars . movie_id WHERE title = \"Toy Story\" ; Write a SQL query to list the names of all people who starred in a movie released in 2004, ordered by birth year. Your query should output a table with a single column for the name of each person. People with the same birth year may be listed in any order. No need to worry about people who have no birth year listed, so long as those who do have a birth year are listed in order. If a person appeared in more than one movie in 2004, they should only appear in your results once. SELECT DISTINCT name FROM people JOIN stars ON people . id = stars . person_id JOIN movies on movies . id = stars . movie_id WHERE year = 2004 ORDER BY birth ; Write a SQL query to list the names of all people who have directed a movie that received a rating of at least 9.0. Your query should output a table with a single column for the name of each person. SELECT name FROM people JOIN directors ON directors . person_id = people . id JOIN ratings ON directors . movie_id = ratings . movie_id WHERE rating >= 9 . 0 ; Write a SQL query to list the titles of the five highest rated movies (in order) that Chadwick Boseman starred in, starting with the highest rated. Your query should output a table with a single column for the title of each movie. You may assume that there is only one person in the database with the name Chadwick Boseman. SELECT DISTINCT title FROM people JOIN stars ON people . id = stars . person_id JOIN ratings ON ratings . movie_id = stars . movie_id JOIN movies ON movies . id = stars . movie_id WHERE name = \"Chadwick Boseman\" ORDER BY rating DESC LIMIT 5 ; Write a SQL query to list the titles of all movies in which both Johnny Depp and Helena Bonham Carter starred. Your query should output a table with a single column for the title of each movie. You may assume that there is only one person in the database with the name Johnny Depp. You may assume that there is only one person in the database with the name Helena Bonham Carter. SELECT title FROM people JOIN stars ON stars . person_id = people . id JOIN movies ON stars . movie_id = movies . id WHERE name = \"Johnny Depp\" AND movie_id IN ( SELECT movie_id FROM people JOIN stars ON stars . person_id = people . id WHERE name = \"Helena Bonham Carter\" ); Write a SQL query to list the names of all people who starred in a movie in which Kevin Bacon also starred. Your query should output a table with a single column for the name of each person. There may be multiple people named Kevin Bacon in the database. Be sure to only select the Kevin Bacon born in 1958. Kevin Bacon himself should not be included in the resulting list. SELECT DISTINCT name FROM people JOIN stars ON stars . person_id = people . id WHERE name != \"Kevin Bacon\" AND movie_id IN ( SELECT movie_id FROM people JOIN stars ON stars . person_id = people . id WHERE name = \"Kevin Bacon\" AND birth = 1958 ) Houses Exercise We are now going to implement a program to import Hogwarts student data into a database, and then produce class roseters. For this exercise we are going to use the files found in houses.zip . You will find the files characters.csv , import.py , roster.py , and students.db . We will import all of the school's data into a database and write a Python program to query that database to get house rosters. Breakdown In import.py , we will write a program that imports data from a CSV spreadsheet. The program should accept the name of a CSV file as a command-line argument. If the incorrect number of command-line arguments are provided, our program should print an error and exit. We are going to assume that the CSV file exists, and will have columns name , house , and birth . For each student in the CSV file, we are going to insert the student into the students table in the students.db database. While the CSV file provided in houses.zip has just a name column, that database has separate columns for first , middle , and last names. We will then want to first parse each name and separate it into first, middle, and last names. We are going to assume that each person's name field will contain either two space-separated names (a first and last name) or three space-separated names (a first, middle, and last name). For students without a middle name, we will leave their middle name field as NULL in the table. In roster.py , we will write a program that prints a list of students for a given house in alphabetical order. We will make the program accept the name of a house as a command-line argument. If the incorrect number of command-line arguments are provided, we will print an error or exit. Our program will query the students table in the students.db database for all students in the specified house. Or program should then print out each student's full name and birth year (formatted as, e.g., Harry James Potter, born 1980 or Luna Lovegood, born 1981 ). Each student will be printed on their own line. Students should be ordered by last name. If students share the same last name, we will order them by first name. Solution import.py from cs50 import SQL from sys import argv from sys import exit import csv #splits the names from the name column into their own array def partition_name ( full_name ): names = full_name . split () return names if len ( names ) >= 3 else [ names [ 0 ], None , names [ 1 ]] #checks argument count if len ( argv ) != 2 : print ( \"Arguments error\" ) exit ( 1 ) db = SQL ( \"sqlite:///students.db\" ) csv_path = argv [ 1 ] with open ( csv_path ) as csv_file : reader = csv . DictReader ( csv_file ) for row in reader : names = partition_name ( row [ \"name\" ]) #partition_name gives an array db . execute ( \"INSERT INTO students(first, middle, last, house, birth) VALUES(?, ?, ?, ?, ?)\" , names [ 0 ], names [ 1 ], names [ 2 ], row [ \"house\" ], row [ \"birth\" ]) roster.py from cs50 import SQL from sys import argv from sys import exit if len ( argv ) != 2 : print ( \"Argument Error\" ) exit ( 1 ) db = SQL ( \"sqlite:///students.db\" ) house_chosen = argv [ 1 ] rows = db . execute ( \"SELECT * FROM students WHERE house = ? ORDER BY last, first\" , house_chosen ) for row in rows : first , middle , last , birth = row [ \"first\" ], row [ \"middle\" ], row [ \"last\" ], row [ \"birth\" ] if row [ \"middle\" ] == None : print ( f \" { first } { last } , born { birth } \" ) else : print ( f \" { first } { middle } { last } , born { birth } \" ) Now try running the following commands and check your answer: $ python import.py characters.csv $ python roster.py Gryffindor Lavender Brown, born 1979 Colin Creevey, born 1981 Seamus Finnigan, born 1979 Hermione Jean Granger, born 1979 Neville Longbottom, born 1980 Parvati Patil, born 1979 Harry James Potter, born 1980 Dean Thomas, born 1980 Romilda Vane, born 1981 Ginevra Molly Weasley, born 1981 Ronald Bilius Weasley, born 1980","title":"Random Problems"},{"location":"sql-random/#random-sql-problems","text":"","title":"Random SQL Problems"},{"location":"sql-random/#movies-exercise","text":"In the following problems we will be using movies.db . This database is made of of multiple tables: movies, ratings, stars, and directors. We will need to JOIN some of these tables to answer some of the following problems: Write a SQL query to list the titles of all movies released in 2008. Your query should output a table with a single column for the title of each movie. SELECT title FROM movies WHERE year = 2008 ; Write a SQL query to determine the birth year of Emma Stone. Your query should output a table with a single column and a single row (plus optional header) containing Emma Stone\u2019s birth year. You may assume that there is only one person in the database with the name Emma Stone. SELECT birth FROM people WHERE name = 'Emma Stone' ; Write a SQL query to list the titles of all movies with a release date on or after 2018, in alphabetical order. Your query should output a table with a single column for the title of each movie. Movies released in 2018 should be included, as should movies with release dates in the future. SELECT title FROM movies WHERE year >= 2018 ORDER BY title ; Write a SQL query to determine the number of movies with an IMDb rating of 10.0. Your query should output a table with a single column and a single row (plus optional header) containing the number of movies with a 10.0 rating. SELECT COUNT ( * ) AS NumberOfMoviesWith10Rating FROM ratings WHERE rating = 10 ; Write a SQL query to list the titles and release years of all Harry Potter movies, in chronological order. Your query should output a table with two columns, one for the title of each movie and one for the release year of each movie. You may assume that the title of all Harry Potter movies will begin with the words \u201cHarry Potter\u201d, and that if a movie title begins with the words \u201cHarry Potter\u201d, it is a Harry Potter movie. SELECT title , year FROM movies WHERE title LIKE \"Harry Potter%\" ORDER BY year ; Write a SQL query to determine the average rating of all movies released in 2012. Your query should output a table with a single column and a single row (plus optional header) containing the average rating. SELECT AVG ( rating ) FROM ratings JOIN movies ON movies . id = ratings . movie_id WHERE year = 2012 ; Write a SQL query to list all movies released in 2010 and their ratings, in descending order by rating. For movies with the same rating, order them alphabetically by title. Your query should output a table with two columns, one for the title of each movie and one for the rating of each movie. Movies that do not have ratings should not be included in the result. SELECT title , rating FROM movies JOIN ratings on movies . id = ratings . movie_id WHERE year = 2010 ORDER BY rating DESC , title ; Write a SQL query to list the names of all people who starred in Toy Story. Your query should output a table with a single column for the name of each person. You may assume that there is only one movie in the database with the title Toy Story. SELECT name FROM people JOIN stars ON people . id = stars . person_id JOIN movies ON movies . id = stars . movie_id WHERE title = \"Toy Story\" ; Write a SQL query to list the names of all people who starred in a movie released in 2004, ordered by birth year. Your query should output a table with a single column for the name of each person. People with the same birth year may be listed in any order. No need to worry about people who have no birth year listed, so long as those who do have a birth year are listed in order. If a person appeared in more than one movie in 2004, they should only appear in your results once. SELECT DISTINCT name FROM people JOIN stars ON people . id = stars . person_id JOIN movies on movies . id = stars . movie_id WHERE year = 2004 ORDER BY birth ; Write a SQL query to list the names of all people who have directed a movie that received a rating of at least 9.0. Your query should output a table with a single column for the name of each person. SELECT name FROM people JOIN directors ON directors . person_id = people . id JOIN ratings ON directors . movie_id = ratings . movie_id WHERE rating >= 9 . 0 ; Write a SQL query to list the titles of the five highest rated movies (in order) that Chadwick Boseman starred in, starting with the highest rated. Your query should output a table with a single column for the title of each movie. You may assume that there is only one person in the database with the name Chadwick Boseman. SELECT DISTINCT title FROM people JOIN stars ON people . id = stars . person_id JOIN ratings ON ratings . movie_id = stars . movie_id JOIN movies ON movies . id = stars . movie_id WHERE name = \"Chadwick Boseman\" ORDER BY rating DESC LIMIT 5 ; Write a SQL query to list the titles of all movies in which both Johnny Depp and Helena Bonham Carter starred. Your query should output a table with a single column for the title of each movie. You may assume that there is only one person in the database with the name Johnny Depp. You may assume that there is only one person in the database with the name Helena Bonham Carter. SELECT title FROM people JOIN stars ON stars . person_id = people . id JOIN movies ON stars . movie_id = movies . id WHERE name = \"Johnny Depp\" AND movie_id IN ( SELECT movie_id FROM people JOIN stars ON stars . person_id = people . id WHERE name = \"Helena Bonham Carter\" ); Write a SQL query to list the names of all people who starred in a movie in which Kevin Bacon also starred. Your query should output a table with a single column for the name of each person. There may be multiple people named Kevin Bacon in the database. Be sure to only select the Kevin Bacon born in 1958. Kevin Bacon himself should not be included in the resulting list. SELECT DISTINCT name FROM people JOIN stars ON stars . person_id = people . id WHERE name != \"Kevin Bacon\" AND movie_id IN ( SELECT movie_id FROM people JOIN stars ON stars . person_id = people . id WHERE name = \"Kevin Bacon\" AND birth = 1958 )","title":"Movies Exercise"},{"location":"sql-random/#houses-exercise","text":"We are now going to implement a program to import Hogwarts student data into a database, and then produce class roseters. For this exercise we are going to use the files found in houses.zip . You will find the files characters.csv , import.py , roster.py , and students.db . We will import all of the school's data into a database and write a Python program to query that database to get house rosters.","title":"Houses Exercise"},{"location":"sql-random/#breakdown","text":"In import.py , we will write a program that imports data from a CSV spreadsheet. The program should accept the name of a CSV file as a command-line argument. If the incorrect number of command-line arguments are provided, our program should print an error and exit. We are going to assume that the CSV file exists, and will have columns name , house , and birth . For each student in the CSV file, we are going to insert the student into the students table in the students.db database. While the CSV file provided in houses.zip has just a name column, that database has separate columns for first , middle , and last names. We will then want to first parse each name and separate it into first, middle, and last names. We are going to assume that each person's name field will contain either two space-separated names (a first and last name) or three space-separated names (a first, middle, and last name). For students without a middle name, we will leave their middle name field as NULL in the table. In roster.py , we will write a program that prints a list of students for a given house in alphabetical order. We will make the program accept the name of a house as a command-line argument. If the incorrect number of command-line arguments are provided, we will print an error or exit. Our program will query the students table in the students.db database for all students in the specified house. Or program should then print out each student's full name and birth year (formatted as, e.g., Harry James Potter, born 1980 or Luna Lovegood, born 1981 ). Each student will be printed on their own line. Students should be ordered by last name. If students share the same last name, we will order them by first name.","title":"Breakdown"},{"location":"sql-random/#solution","text":"import.py from cs50 import SQL from sys import argv from sys import exit import csv #splits the names from the name column into their own array def partition_name ( full_name ): names = full_name . split () return names if len ( names ) >= 3 else [ names [ 0 ], None , names [ 1 ]] #checks argument count if len ( argv ) != 2 : print ( \"Arguments error\" ) exit ( 1 ) db = SQL ( \"sqlite:///students.db\" ) csv_path = argv [ 1 ] with open ( csv_path ) as csv_file : reader = csv . DictReader ( csv_file ) for row in reader : names = partition_name ( row [ \"name\" ]) #partition_name gives an array db . execute ( \"INSERT INTO students(first, middle, last, house, birth) VALUES(?, ?, ?, ?, ?)\" , names [ 0 ], names [ 1 ], names [ 2 ], row [ \"house\" ], row [ \"birth\" ]) roster.py from cs50 import SQL from sys import argv from sys import exit if len ( argv ) != 2 : print ( \"Argument Error\" ) exit ( 1 ) db = SQL ( \"sqlite:///students.db\" ) house_chosen = argv [ 1 ] rows = db . execute ( \"SELECT * FROM students WHERE house = ? ORDER BY last, first\" , house_chosen ) for row in rows : first , middle , last , birth = row [ \"first\" ], row [ \"middle\" ], row [ \"last\" ], row [ \"birth\" ] if row [ \"middle\" ] == None : print ( f \" { first } { last } , born { birth } \" ) else : print ( f \" { first } { middle } { last } , born { birth } \" ) Now try running the following commands and check your answer: $ python import.py characters.csv $ python roster.py Gryffindor Lavender Brown, born 1979 Colin Creevey, born 1981 Seamus Finnigan, born 1979 Hermione Jean Granger, born 1979 Neville Longbottom, born 1980 Parvati Patil, born 1979 Harry James Potter, born 1980 Dean Thomas, born 1980 Romilda Vane, born 1981 Ginevra Molly Weasley, born 1981 Ronald Bilius Weasley, born 1980","title":"Solution"},{"location":"sql/","text":"SQL Basics SQL (Structured Query Language) is a language designed to allow both technical and non-technical users query, manipulate, and transform data from a relational database. And due to its simplicity, SQL databases provide safe and scalable storage for millions of websites and mobile applications. Often times, in order for us to build the most function website we can, we depend on a database to store information. Databases often are set up as tables with information in columns and rows (e.g. Excel Spreadsheets & Google Sheets). Quick Links SQL Cheat Sheets Free SQL Course SQL for Dummies (PDF) Additional SQL Reference Material For the following examples we will be using sqlite3, which is a SQL command line program, on the CS50 IDE . We will also be using the following .csv file which contains a database with data about some of Pixar's classic movies. Let's import this into the IDE. First drag and drop the file into the left side of the IDE, preferably a folder. Next, let's run the following commands: sqlite3 movies.db This creates a new database called 'movies' . .mode csv This changes mode of the program to be able to read .csv files. .import \"Movies.csv\" movies This imports the Movies.csv file into a table called \"movies\". We should now be able to see and interact with the data inside our database. SELECT Queries 101 To retrieve data from a SQL database, we need to write SELECT statements, which are often colloquially refered to as queries . A query itself is just a statement which declares what data we are looking for, where to find it in the database, and optionally, how to transform it before it is returned. We can think of a table in SQL as a type of entity (i.e. dogs) and each row in that table as a specific instance of that type (i.e. pug, beagle, border collie, etc.). This means that the columns would then represent the common properties shared by all instances of that entity (i.e. color of fur, length of tail, etc.). And given a table of data, the most basic query we could write would be one that selects for a couple columns (properties) of the table with all the rows (instances), SELECT column , another_column , ... FROM mytable ; The result of this query will be a two-dimensional set of rows and columns, effectively a copy of the table, but only with the columns that we requested. If we want to retrieve all the columns of data from a table, we can then use the asterisk ( * ) shorthand in place of listing all the column names individually. SELECT * from mytable ; This query, in particular, is really useful because it's a simple way to inspect a table by dumping all the data at once. Now, lets begin using the .csv file from above for some exercises: Find the title of each film: SELECT title FROM movies ; Find the director of each film: SELECT director FROM movies ; Find the title and director of each film: SELECT title , director FROM movies ; Find the title and year of each film: SELECT title , year FROM movies ; Find all information about each film: SELECT * FROM movies ; Queries with Constraints Now we know how to select for specific columns of data from a table, but if you had a table with a hundred million rows of data, reading through all the rows would be inefficient and perhaps even impossible. In order to filter certain results from being returned, we need to use a WHERE clause in the query. The clause is applied to each row of data by checking specific column values to determine whether it should be included in the results or not. SELECT column , another_column , ... FROM mytable WHERE condition AND / OR another_condition AND / OR ...; More complex clauses can be constructed by joining numerous AND or OR logical keywords (i.e. num_wheels >= 4 AND doors <= 2). Below are some useful operators that you can use for numerical data (i.e. integer or floating point): Operator Condition SQL Example =, !=, <, <=, >, >= Standard numerical operators col_name ! = 4 BETWEEN ... AND ... Number is within a range of two values (inclusive) col_name BETWEEN 1.5 AND 10.5 NOT BETWEEN ... AND ... Number is not within range of two values (inclusive) col_name NOT BETWEEN 1 AND 10 IN (...) Number exists in a list col_name IN (2, 4, 6) NOT IN (...) Number does not exist in a list col_name NOT IN (1, 3, 5) In addition to making the results more manageable to understand, writing clauses to constrain the set of rows returned also allows the query to run faster due to the reduction in unnecessary data being returned. SQL Syntax As you may have noticed by now, SQL doesn't require you to write the keywords all capitalized, but as convention, it helps people distinguish SQL keywords from column and table names, and makes the query code easier to read. Now let's do some exercises using the same .csv from above: Find the movie with a row id of 6 : SELECT id , title FROM movies WHERE id = 6 ; Find the movies released in the year s between 2000 and 2010: SELECT title , year FROM movies WHERE year BETWEEN 2000 AND 2010 ; Find the movies not released in the year s between 2000 and 2010: SELECT title , year FROM movies WHERE year NOT BETWEEN 2000 AND 2010 ; Find the first 5 Pizar movies and their release year : SELECT title , year FROM movies WHERE year <= 2003 ; When Writing WHERE clauses with columns containing text data, SQL supports a number of useful operators to do things like case-insensitive string comparison and wildcard pattern matching. Below are a few common text-data specific operators: Operator Condition SQL Example = Case sensitive exact string comparison ( notice the single equals ) col_name = \"abc\" != or <> Case sensitive exact string inequality comparison col_name != \"abcd\" LIKE Case insensitive exact string comparison col_name LIKE \"ABC\" NOT LIKE Case insensitive exact string inequality comparison col_name NOT LIKE \"ABCD\" % Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) col_name LIKE \"%AT%\" (matches \"AT\", \"ATTIC\", \"CAT\" or even \"BATS\") _ Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) col_name LIKE \"AN_\" (matches \"AND\" but not \"AN\") IN (...) String exists in a list col_name IN (\"A\", \"B\", \"C\") NOT IN (...) String does not exist in a list col_name NOT IN (\"D\", \"E\", \"F\") String Quotes All strings must be quoted so that the query parser can distinguish words in the string from SQL keywords. We should not that while most database implementations are quite efficient when using these operators, full-text search is best left to dedicated libraries like Apache Lucene or Sphinx . These libraries are designed specifically to do full text search, and as a result are more efficient and can support a wider variety of search features including internationalization and advanced queries. Now let's test these operators using the same .csv from above: Find all the Toy Story movies: SELECT title , director FROM movies WHERE title LIKE \"Toy Story%\" ; Find all the movies directed by John Lasseter: SELECT title , director FROM movies WHERE director LIKE \"John Lasseter\" ; Find all the movies (and director) not directed by John Lasseter: SELECT title , director FROM movies WHERE director NOT LIKE \"John Lasseter\" ; Find all the WALL-* movies: SELECT title FROM movies WHERE title LIKE \"WALL-_\" ; Filtering and Sorting Query Results Even though the data in a database may be unique, the results of any particular query may not be - take our Movies table for example, many different movies can be released the same year. In such cases, SQL provides a convenient way to discard rows that have a duplicate column value by using the DISTINCT keyword. SELECT DISTINCT column , another_column , ... FROM mytable WHERE condition ( s ); Since the DISTINCT keyword will blindly remove duplicate values, we will learn in a future lesson how to discard duplicated based on specific columns using grouping and the GROUP BY cluase. Ordering Results Unlike our neatly ordered table in the last few lessons, most data in real databases are added in no particular column order. As a result, it can be difficult to read through and understand the results of a query as the size of a table increases to thousands or even millions of rows. To help with this, SQL provides a way to sort your results by a given column in ascending or descending order using the ORDER BY clause: SELECT column , another_column , ... FROM mytable WHERE condition ( s ) ORDER BY column ASC / DESC ; When an ORDER BY clause is specified, each row is sorted alpha-numerically based on the specified column's value. In some databases, you can also specify a collation to better sort data containing international text. Limiting Results to a Subset Another clause which is commonly used with the ORDER BY clause are the LIMIT and OFFSET clauses, which are a useful optimization to indicate to the database the subset of the results you care about. The LIMIT will reduce the number of rows to return, and the optional OFFSET will specify where to begin counting the number rows from: SELECT column , another_column , ... FROM mytable WHERE condition ( s ) ORDER BY column ASC / DESC LIMIT num_limit OFFSET num_offset ; If you think about websites like Reddit or Pinterest, the front page is a list of links sorted by popularity and time, and each subsequent page can be represented by sets of links at different offsets in the database. Using these clauses, the database can then execute queries faster and more efficiently by processing and returning only the requested content. Order of Execution LIMIT and OFFSET are applied relative to the other parts of a query, generally done last after other clauses have been aplied. Now let's do some exercises using the previous .csv used above: List all directors of Pixar movies (alphabetically), without duplicates: SELECT DISTINCT director FROM movies ORDER BY director ASC ; List the last four Pixar movies released (ordered from most recent to last): SELECT title FROM movies ORDER BY year DESC LIMIT 4 ; List the first 5 Pixar movies sorted alphabetically: SELECT title FROM movies ORDER BY title ASC LIMIT 5 ; List the next 5 Pixar movies sorted alphabetically: SELECT title FROM movies ORDER BY title ASC LIMIT 5 OFFSET 5 ; Review Exercises Let's take a new .csv file containing a few of the most populous cities in North America and do some review exercises from what has been learned above: List all the Canadian cities and their populations: SELECT city , population FROM north_american_cities WHERE country = \"Canada\" ; Order all the cities in the United States by their latitude from north to south: SELECT city , latitude FROM north_american_cities WHERE country = \"United States\" ORDER BY latitude DESC ; List all the cities west of Chicago, ordered from west to east: SELECT city , longitude FROM north_american_cities WHERE longitude < - 87 . 629798 ORDER BY longitude ASC ; List the two largest cities in Mexico (by population): SELECT city , population FROM north_american_cities WHERE country = \"Mexico\" ORDER BY population DESC LIMIT 2 ; List the third and fourth largest cities (by population) in the United States and their population: SELECT city , population FROM north_american_cities WHERE country = \"United States\" ORDER BY population DESC LIMIT 2 OFFSET 2 ;","title":"SQL Basics"},{"location":"sql/#sql-basics","text":"SQL (Structured Query Language) is a language designed to allow both technical and non-technical users query, manipulate, and transform data from a relational database. And due to its simplicity, SQL databases provide safe and scalable storage for millions of websites and mobile applications. Often times, in order for us to build the most function website we can, we depend on a database to store information. Databases often are set up as tables with information in columns and rows (e.g. Excel Spreadsheets & Google Sheets). Quick Links SQL Cheat Sheets Free SQL Course SQL for Dummies (PDF) Additional SQL Reference Material For the following examples we will be using sqlite3, which is a SQL command line program, on the CS50 IDE . We will also be using the following .csv file which contains a database with data about some of Pixar's classic movies. Let's import this into the IDE. First drag and drop the file into the left side of the IDE, preferably a folder. Next, let's run the following commands: sqlite3 movies.db This creates a new database called 'movies' . .mode csv This changes mode of the program to be able to read .csv files. .import \"Movies.csv\" movies This imports the Movies.csv file into a table called \"movies\". We should now be able to see and interact with the data inside our database.","title":"SQL Basics"},{"location":"sql/#select-queries-101","text":"To retrieve data from a SQL database, we need to write SELECT statements, which are often colloquially refered to as queries . A query itself is just a statement which declares what data we are looking for, where to find it in the database, and optionally, how to transform it before it is returned. We can think of a table in SQL as a type of entity (i.e. dogs) and each row in that table as a specific instance of that type (i.e. pug, beagle, border collie, etc.). This means that the columns would then represent the common properties shared by all instances of that entity (i.e. color of fur, length of tail, etc.). And given a table of data, the most basic query we could write would be one that selects for a couple columns (properties) of the table with all the rows (instances), SELECT column , another_column , ... FROM mytable ; The result of this query will be a two-dimensional set of rows and columns, effectively a copy of the table, but only with the columns that we requested. If we want to retrieve all the columns of data from a table, we can then use the asterisk ( * ) shorthand in place of listing all the column names individually. SELECT * from mytable ; This query, in particular, is really useful because it's a simple way to inspect a table by dumping all the data at once. Now, lets begin using the .csv file from above for some exercises: Find the title of each film: SELECT title FROM movies ; Find the director of each film: SELECT director FROM movies ; Find the title and director of each film: SELECT title , director FROM movies ; Find the title and year of each film: SELECT title , year FROM movies ; Find all information about each film: SELECT * FROM movies ;","title":"SELECT Queries 101"},{"location":"sql/#queries-with-constraints","text":"Now we know how to select for specific columns of data from a table, but if you had a table with a hundred million rows of data, reading through all the rows would be inefficient and perhaps even impossible. In order to filter certain results from being returned, we need to use a WHERE clause in the query. The clause is applied to each row of data by checking specific column values to determine whether it should be included in the results or not. SELECT column , another_column , ... FROM mytable WHERE condition AND / OR another_condition AND / OR ...; More complex clauses can be constructed by joining numerous AND or OR logical keywords (i.e. num_wheels >= 4 AND doors <= 2). Below are some useful operators that you can use for numerical data (i.e. integer or floating point): Operator Condition SQL Example =, !=, <, <=, >, >= Standard numerical operators col_name ! = 4 BETWEEN ... AND ... Number is within a range of two values (inclusive) col_name BETWEEN 1.5 AND 10.5 NOT BETWEEN ... AND ... Number is not within range of two values (inclusive) col_name NOT BETWEEN 1 AND 10 IN (...) Number exists in a list col_name IN (2, 4, 6) NOT IN (...) Number does not exist in a list col_name NOT IN (1, 3, 5) In addition to making the results more manageable to understand, writing clauses to constrain the set of rows returned also allows the query to run faster due to the reduction in unnecessary data being returned. SQL Syntax As you may have noticed by now, SQL doesn't require you to write the keywords all capitalized, but as convention, it helps people distinguish SQL keywords from column and table names, and makes the query code easier to read. Now let's do some exercises using the same .csv from above: Find the movie with a row id of 6 : SELECT id , title FROM movies WHERE id = 6 ; Find the movies released in the year s between 2000 and 2010: SELECT title , year FROM movies WHERE year BETWEEN 2000 AND 2010 ; Find the movies not released in the year s between 2000 and 2010: SELECT title , year FROM movies WHERE year NOT BETWEEN 2000 AND 2010 ; Find the first 5 Pizar movies and their release year : SELECT title , year FROM movies WHERE year <= 2003 ; When Writing WHERE clauses with columns containing text data, SQL supports a number of useful operators to do things like case-insensitive string comparison and wildcard pattern matching. Below are a few common text-data specific operators: Operator Condition SQL Example = Case sensitive exact string comparison ( notice the single equals ) col_name = \"abc\" != or <> Case sensitive exact string inequality comparison col_name != \"abcd\" LIKE Case insensitive exact string comparison col_name LIKE \"ABC\" NOT LIKE Case insensitive exact string inequality comparison col_name NOT LIKE \"ABCD\" % Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) col_name LIKE \"%AT%\" (matches \"AT\", \"ATTIC\", \"CAT\" or even \"BATS\") _ Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) col_name LIKE \"AN_\" (matches \"AND\" but not \"AN\") IN (...) String exists in a list col_name IN (\"A\", \"B\", \"C\") NOT IN (...) String does not exist in a list col_name NOT IN (\"D\", \"E\", \"F\") String Quotes All strings must be quoted so that the query parser can distinguish words in the string from SQL keywords. We should not that while most database implementations are quite efficient when using these operators, full-text search is best left to dedicated libraries like Apache Lucene or Sphinx . These libraries are designed specifically to do full text search, and as a result are more efficient and can support a wider variety of search features including internationalization and advanced queries. Now let's test these operators using the same .csv from above: Find all the Toy Story movies: SELECT title , director FROM movies WHERE title LIKE \"Toy Story%\" ; Find all the movies directed by John Lasseter: SELECT title , director FROM movies WHERE director LIKE \"John Lasseter\" ; Find all the movies (and director) not directed by John Lasseter: SELECT title , director FROM movies WHERE director NOT LIKE \"John Lasseter\" ; Find all the WALL-* movies: SELECT title FROM movies WHERE title LIKE \"WALL-_\" ;","title":"Queries with Constraints"},{"location":"sql/#filtering-and-sorting-query-results","text":"Even though the data in a database may be unique, the results of any particular query may not be - take our Movies table for example, many different movies can be released the same year. In such cases, SQL provides a convenient way to discard rows that have a duplicate column value by using the DISTINCT keyword. SELECT DISTINCT column , another_column , ... FROM mytable WHERE condition ( s ); Since the DISTINCT keyword will blindly remove duplicate values, we will learn in a future lesson how to discard duplicated based on specific columns using grouping and the GROUP BY cluase.","title":"Filtering and Sorting Query Results"},{"location":"sql/#ordering-results","text":"Unlike our neatly ordered table in the last few lessons, most data in real databases are added in no particular column order. As a result, it can be difficult to read through and understand the results of a query as the size of a table increases to thousands or even millions of rows. To help with this, SQL provides a way to sort your results by a given column in ascending or descending order using the ORDER BY clause: SELECT column , another_column , ... FROM mytable WHERE condition ( s ) ORDER BY column ASC / DESC ; When an ORDER BY clause is specified, each row is sorted alpha-numerically based on the specified column's value. In some databases, you can also specify a collation to better sort data containing international text.","title":"Ordering Results"},{"location":"sql/#limiting-results-to-a-subset","text":"Another clause which is commonly used with the ORDER BY clause are the LIMIT and OFFSET clauses, which are a useful optimization to indicate to the database the subset of the results you care about. The LIMIT will reduce the number of rows to return, and the optional OFFSET will specify where to begin counting the number rows from: SELECT column , another_column , ... FROM mytable WHERE condition ( s ) ORDER BY column ASC / DESC LIMIT num_limit OFFSET num_offset ; If you think about websites like Reddit or Pinterest, the front page is a list of links sorted by popularity and time, and each subsequent page can be represented by sets of links at different offsets in the database. Using these clauses, the database can then execute queries faster and more efficiently by processing and returning only the requested content. Order of Execution LIMIT and OFFSET are applied relative to the other parts of a query, generally done last after other clauses have been aplied. Now let's do some exercises using the previous .csv used above: List all directors of Pixar movies (alphabetically), without duplicates: SELECT DISTINCT director FROM movies ORDER BY director ASC ; List the last four Pixar movies released (ordered from most recent to last): SELECT title FROM movies ORDER BY year DESC LIMIT 4 ; List the first 5 Pixar movies sorted alphabetically: SELECT title FROM movies ORDER BY title ASC LIMIT 5 ; List the next 5 Pixar movies sorted alphabetically: SELECT title FROM movies ORDER BY title ASC LIMIT 5 OFFSET 5 ;","title":"Limiting Results to a Subset"},{"location":"sql/#review-exercises","text":"Let's take a new .csv file containing a few of the most populous cities in North America and do some review exercises from what has been learned above: List all the Canadian cities and their populations: SELECT city , population FROM north_american_cities WHERE country = \"Canada\" ; Order all the cities in the United States by their latitude from north to south: SELECT city , latitude FROM north_american_cities WHERE country = \"United States\" ORDER BY latitude DESC ; List all the cities west of Chicago, ordered from west to east: SELECT city , longitude FROM north_american_cities WHERE longitude < - 87 . 629798 ORDER BY longitude ASC ; List the two largest cities in Mexico (by population): SELECT city , population FROM north_american_cities WHERE country = \"Mexico\" ORDER BY population DESC LIMIT 2 ; List the third and fourth largest cities (by population) in the United States and their population: SELECT city , population FROM north_american_cities WHERE country = \"United States\" ORDER BY population DESC LIMIT 2 OFFSET 2 ;","title":"Review Exercises"}]}