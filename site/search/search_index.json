{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Nick's Docs This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here . Portfolio Quick Links: Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018) SoccerFront.io - Web Application Project (2020) Programming Notes C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures Python Python Basics Variables and Simple Data Types Lists Working with Lists If Statements Dictionaries User Input and while Loops Functions Classes Random Programs Java Java Overview Java Basics Variables Classes Conditionals/Control Flow Arrays Loops String Methods Access, Encapsulation, & Scope Inheritance & Polymorphism Debugging 2D Arrays JavaScript JavaScript Basics Variables and Simple Data Types Conditional Statements Functions SQL SQL Basics Joins and Other Query Types SQL Random Problems Misc. Notes APIs Overview Django Quick Links IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Home"},{"location":"#welcome-to-nicks-docs","text":"This is a place for documentation examples, programming notes, and projects. If you are looking for Nick's Portfolio, please click here .","title":"Welcome to Nick's Docs "},{"location":"#portfolio-quick-links","text":"Google Chrome User Guide Release Notes Example - Firefox (2020) Installation Guide Example - Firefox (2018) SoccerFront.io - Web Application Project (2020)","title":"Portfolio Quick Links:"},{"location":"#programming-notes","text":"C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures Python Python Basics Variables and Simple Data Types Lists Working with Lists If Statements Dictionaries User Input and while Loops Functions Classes Random Programs Java Java Overview Java Basics Variables Classes Conditionals/Control Flow Arrays Loops String Methods Access, Encapsulation, & Scope Inheritance & Polymorphism Debugging 2D Arrays JavaScript JavaScript Basics Variables and Simple Data Types Conditional Statements Functions SQL SQL Basics Joins and Other Query Types SQL Random Problems Misc. Notes APIs Overview Django","title":"Programming Notes"},{"location":"#quick-links","text":"IDE Sandbox LinkedIn GitHub Nicklyss Homepage","title":"Quick Links"},{"location":"about/","text":"About About Me Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I began my Master's in Software Engineering in January 2021 (WOO!). I have basic knowledge in HTML, CSS, JavaScript, Python, SQL, Markdown, and C (hopefully more to come in the near future). Outside of work, I love watching European soccer (Go Bayern!), building keyboards, and spending time with my wife and pup. If you have any questions, please feel free to reach out to me through the contact info below. Creating robust and easy-to-understand documentation is what I do best. While teaching myself to program, along with my daily work as a technical writer, I have learned how important well written documentation is! Being able to convey a message to a wide-range of people is more difficult than you would think. Making sure you are writing at a level and tone that makes it so the most basic users can understand, while not insulting the advanced users' intelligence, can be quite the challenge. I created this docs website for my programming notes and random projects. I also have a blog that I update sporadically, which can be found here . Random Projects .center{ text-align: center; } Soccerfront.io Soccerfront.io is a soccer live score web application built using Nodejs, Expressjs, HTML, CSS, and JavaScript. Soccerfront pulls data from the API-FOOTBALL API and displays the information in a easy to use live score table and league table (standings) view. This is an ongoing project and new features will be added sporadically. Custom Keyboard Builds Below are some keyboards I have built! Custom Keyboards Canoe PC - Gateron Ink Yellow Custom Acrylic - Gateron Ink Blacks TX-87 - C\u00b3Equalz X TKC Banana Splits Satisfaction 75 - Zealios V2 K75 - Gateron Ink Blacks Canon Keys Devastating TKL - Tealios Mysterium - Kailh Purple Pro Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn lightGallery(document.getElementById('lightgallery'));","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#about-me","text":"Hi, my name is Nick Platt. I am currently a technical writer for Boeing Intelligence & Analytics and work with multiple development teams. I recently graduated from the University of Maryland with a Bachelor's in Computer Networking and Cybersecurity. I began my Master's in Software Engineering in January 2021 (WOO!). I have basic knowledge in HTML, CSS, JavaScript, Python, SQL, Markdown, and C (hopefully more to come in the near future). Outside of work, I love watching European soccer (Go Bayern!), building keyboards, and spending time with my wife and pup. If you have any questions, please feel free to reach out to me through the contact info below. Creating robust and easy-to-understand documentation is what I do best. While teaching myself to program, along with my daily work as a technical writer, I have learned how important well written documentation is! Being able to convey a message to a wide-range of people is more difficult than you would think. Making sure you are writing at a level and tone that makes it so the most basic users can understand, while not insulting the advanced users' intelligence, can be quite the challenge. I created this docs website for my programming notes and random projects. I also have a blog that I update sporadically, which can be found here .","title":"About Me"},{"location":"about/#random-projects","text":".center{ text-align: center; }","title":"Random Projects"},{"location":"about/#soccerfrontio","text":"Soccerfront.io is a soccer live score web application built using Nodejs, Expressjs, HTML, CSS, and JavaScript. Soccerfront pulls data from the API-FOOTBALL API and displays the information in a easy to use live score table and league table (standings) view. This is an ongoing project and new features will be added sporadically.","title":"Soccerfront.io"},{"location":"about/#custom-keyboard-builds","text":"Below are some keyboards I have built! Custom Keyboards Canoe PC - Gateron Ink Yellow Custom Acrylic - Gateron Ink Blacks TX-87 - C\u00b3Equalz X TKC Banana Splits Satisfaction 75 - Zealios V2 K75 - Gateron Ink Blacks Canon Keys Devastating TKL - Tealios Mysterium - Kailh Purple Pro","title":"Custom Keyboard Builds"},{"location":"about/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn lightGallery(document.getElementById('lightgallery'));","title":"Contact"},{"location":"api/","text":"Introduction to APIs Quick Links API Introduction Docs Working with Web APIs (Online Book) Overview An API (Application Programming Interface) is a way for different machines and software to talk to each other to create ever more complex applications. It is a contract of sorts: it defines how it is expected to be used and what you can expect to receive by using it. When most people hear the acronym API, they most likely are thinking about web-based APIs, which is completely understandable. You must also know about the many APIs that are built into all modern programming languages. For example, let's say you wanted to capitalize a string of text. We could write a long code to translate each individual letter to the uppercase version through low level bitmath OR we could use the uppercase API: Python 'yeet!' . upper () # YEET! JavaScript 'yeet!' . toUpperCase (); // YEET! Java \"yeet!\" . toUpperCase (); // YEET! Basically, programmers use APIs to avoid recreating the wheel. APIs assist us in accomplishing tasks that we need to perform, by abstracting away a ton of work for us. Remote APIs The above examples we gave were local APIs, built into the programming language. Remote APIs can be looked at similarly to your TV's remote. You work with the interface on the remote to make changes to the TV, as if you were using the interface on the device itself. Its not just physical objects that benefit from remote APIs. Sometimes, we don't have space on our local machines for all the data that is available. For example, when we use an app like Shazam to find out what song is playing, the app doesn't store ALL the songs in the world on your phone; it instead uses a remote API to send data to the app serice for indentification. Remote APIs also offer another benefit of computational power. Because an API removes the limitations of your local machine, you can gain access to huge amounts of computational power. A good example of this is the AR feature in the Google Translate app. The app allows you to use the camera on your phone to translate what you are seeing directly to your screen in near real-time. This app requires a ton of computational power and it is getting it elsewhere (through cloud computing). REST ( RE presentational S tate T ransfer) The struggle to achieve the concept of remote APIs was very real. The biggest problem was that there was no standard that everyone loved. Overtime, a clear winner came forward that offered a clean and universally-accepted format, REST. The popularity of REST spread so rapidly that it nearly took over the word API (think how XEROX almost took over the term photocopy). REST is not the end-all, be-all of remote APIs, but it is one of the most common and documented solution. The following notes will cover the REST framework! RESTful When APIs embrace the styles and constraints of REST, they are said to be RESTful. Here are the guiding architectural constraints for an API to be considered RESTful: Client-Server Architecture Statelessness Layered System Cacheability Uniform Design Code on Demand Let's cover these topics by discussing how APIs sit on top of web technology. Much like the web, the client (web browser/program) makes a request to a server. Your program will most likely be using some type of library to create the request to the server. The protocol used for these requests are through HTTP and it is stateless (the server won't remember anything about the particular client (state can be maintained through headers)). This request was almost certainly requesting information about a resource. The \"resource\" is a little absract, it is the R in U R L or U R I. We use the term resource to reference an object, which is also abstract. This is because we can use resources to describe just about anything we build. For example, let's imagine an e-book store website. Each book available for purchase is a resource. If we click into it, we may see a link to the author, which is also a resource. When we click on a resource the browser sends a GET request to the server. The RESTful API follows the same logic; your program will send a GET request to a URI (Uniform Resource Identifier), then the server responds with data. The body of the data returned is typically represented today as JSON (JavaScript Object Notation). JSON provides a great way to structure and nest the data. Here are a few HTTP verbs that are used in REST APIs to clearly state the intention of your request: HTTP Verbs CRUD (Create, Read, Update, Delete) GET Read POST Create PUT Update PATCH Update DELETE Delete Want to add an author? POST to the /authors and send them the data you want to update in the body of your request: POST /au t hors/ { au t hor_Name : \"Dave Eggers\" } Want to remove an author? Send a DELETE to that specific author: DELETE /au t hors/ { HBWSG 123 } This means that you can interact with any application out there that exposes their REST API. Exploring an API Online Let's look at a real API online and see what we can learn. For this, we are going to be looking at Spotify's API . Here we can see all the different features that Spotify allows user's to use in their API. Let's go down to the Search section and read the documentation . We can click on the API beta link at the top and then look for the \"Search for an Item\" link. This documentation explains the \"contract\" of what we need to do in order to use the API. In this documentation we can see which type of headers and query parameters in the request are required or optional for the API to work. You can also see the types of reponses your request can receive. Reading the documentation for APIs is perhaps the most important step in implementing an API in your code. You will see notes from the programmers on how to actually make it work! Let's work with Spotify's Web Console , which allows us to test their APIs and play around with the different features. The Console will show us where it will query: GET https://api.spotify.com/v1/search and how it will query: curl -X \"GET\" \"https://api.spotify.com/v1/search?q=Palace&type=artist&market=US&limit=2\" -H \"Accept: application/json\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer BQBBI2LYRwSAZ__Agy0GV0BU_i3adk4b4Wsv7eQbfsgdOJUn0HJDgCJpF3v6g_oJ6rcZjOeEdVVz4FrIKZWoAixqhEhJYtqByw0jQfC5ZMHq-wqJACdyrQ7sIQlpeZXemL2jGhfa728ckA9\" If we break down the above API GET request, we can see that we are searching for ?q=Palace&type=artist along with some other bits. I have limited the results to 2 ( &limit=2 ) in order to keep the result set small. You can also see the Bearer OAuth token at the end, which I have changed in order for my account to remain anonymous. If we run this in the Console, we will get a result that looks something like the following: { \"artists\" : { \"href\" : \"https://api.spotify.com/v1/search?query=Palace&type=artist&market=US&offset=0&limit=2\" , \"items\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"followers\" : { \"href\" : null , \"total\" : 107224 }, \"genres\" : [ \"english indie rock\" , \"indie soul\" , \"vapor soul\" ], \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/8b76736404ceb4bc72669f44908dea557ab03083\" , \"width\" : 640 }, { \"height\" : 320 , \"url\" : \"https://i.scdn.co/image/0c135b9e55b911a37b7aee00af60630c777d4c04\" , \"width\" : 320 }, { \"height\" : 160 , \"url\" : \"https://i.scdn.co/image/79c30a9ba1518749fb74cc449bcaa060f8aa8151\" , \"width\" : 160 } ], \"name\" : \"Palace\" , \"popularity\" : 59 , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" }, { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/37J1PlAkhRK7yrZUtqaUpQ\" }, \"followers\" : { \"href\" : null , \"total\" : 716429 }, \"genres\" : [ \"electro swing\" , \"nu jazz\" ], \"href\" : \"https://api.spotify.com/v1/artists/37J1PlAkhRK7yrZUtqaUpQ\" , \"id\" : \"37J1PlAkhRK7yrZUtqaUpQ\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/adc8c619e766119fabd784a257d6376a653d41ea\" , \"width\" : 640 }, { \"height\" : 320 , \"url\" : \"https://i.scdn.co/image/65df61829bfdb02f7e068de1b3c28799bdc5ace6\" , \"width\" : 320 }, { \"height\" : 160 , \"url\" : \"https://i.scdn.co/image/e86351da17029aa21616d98104bbc6f3c61109d7\" , \"width\" : 160 } ], \"name\" : \"Caravan Palace\" , \"popularity\" : 67 , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:37J1PlAkhRK7yrZUtqaUpQ\" } ], \"limit\" : 2 , \"next\" : \"https://api.spotify.com/v1/search?query=Palace&type=artist&market=US&offset=2&limit=2\" , \"offset\" : 0 , \"previous\" : null , \"total\" : 448 } } Above you can see the response from the Search API of Spotify. There is some interesting information in here, including the artists unique artist identifier ( 48vDIufGC8ujPuBiTxY8dm for my favorite band Palace), as well as the popularity, folowers, genres, and links to images. Let's take that artist id and plug it into the \"Get an Artist's Top Tracks\" API. Here we can see that the API URL has changed to: https://api.spotify.com/v1/artists/{id}/top-tracks Let's plug in Palace's artist id into the API call: curl -X \"GET\" \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm/top-tracks?country=US\" -H \"Accept: application/json\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer BQBBI2LYRwSAZ__Agy0GV0BU_i3adk4b4Wsv7eQbfsgdOJUn0HJDgCJpF3v6g_oJ6rcZjOeEdVVz4FrIKZWoAixqhEhJYtqByw0jQfC5ZMHq-wqJACdyrQ7sIQlpeZZXemL2jGhfa728ckA9\" We should get the following resutl: JSON Response { \"tracks\" : [ { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 249840 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603029\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/2H30WL3exSctlDC9GyRbD4\" }, \"href\" : \"https://api.spotify.com/v1/tracks/2H30WL3exSctlDC9GyRbD4\" , \"id\" : \"2H30WL3exSctlDC9GyRbD4\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Live Well\" , \"popularity\" : 64 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/516b9622373316d4ebbfd4baab240a8217b01952?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 3 , \"type\" : \"track\" , \"uri\" : \"spotify:track:2H30WL3exSctlDC9GyRbD4\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/2gnr57XaEBXSDlfbkowBP8\" }, \"href\" : \"https://api.spotify.com/v1/albums/2gnr57XaEBXSDlfbkowBP8\" , \"id\" : \"2gnr57XaEBXSDlfbkowBP8\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273287d57f51a9220e1b972d576\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02287d57f51a9220e1b972d576\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851287d57f51a9220e1b972d576\" , \"width\" : 64 } ], \"name\" : \"Life After\" , \"release_date\" : \"2019-07-12\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:2gnr57XaEBXSDlfbkowBP8\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 437577 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71806918\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/3Rl26h1HiMCV0HFHHVb2IM\" }, \"href\" : \"https://api.spotify.com/v1/tracks/3Rl26h1HiMCV0HFHHVb2IM\" , \"id\" : \"3Rl26h1HiMCV0HFHHVb2IM\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Heaven Up There\" , \"popularity\" : 58 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9bfd400bc1701508933e11dd88edbaa3743e726e?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 11 , \"type\" : \"track\" , \"uri\" : \"spotify:track:3Rl26h1HiMCV0HFHHVb2IM\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 233360 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603022\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/2DkZisoN9h1dLa8Sn5sx0n\" }, \"href\" : \"https://api.spotify.com/v1/tracks/2DkZisoN9h1dLa8Sn5sx0n\" , \"id\" : \"2DkZisoN9h1dLa8Sn5sx0n\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Bitter\" , \"popularity\" : 58 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/df18b5b91c3b46589dc1bbca26fbdfd895028995?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 2 , \"type\" : \"track\" , \"uri\" : \"spotify:track:2DkZisoN9h1dLa8Sn5sx0n\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/161a4wcY3Lh9xN8OEF0RMr\" }, \"href\" : \"https://api.spotify.com/v1/albums/161a4wcY3Lh9xN8OEF0RMr\" , \"id\" : \"161a4wcY3Lh9xN8OEF0RMr\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b27390912ce0aad8b575d3cd1b50\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e0290912ce0aad8b575d3cd1b50\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d0000485190912ce0aad8b575d3cd1b50\" , \"width\" : 64 } ], \"name\" : \"Someday, Somewhere\" , \"release_date\" : \"2020-07-17\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:161a4wcY3Lh9xN8OEF0RMr\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 192461 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM72002794\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/75Ibf9kajH52v2uBNc7pkp\" }, \"href\" : \"https://api.spotify.com/v1/tracks/75Ibf9kajH52v2uBNc7pkp\" , \"id\" : \"75Ibf9kajH52v2uBNc7pkp\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Someday, Somewhere\" , \"popularity\" : 55 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9a45e9861c165c1c653f1f54b9049f7033134bd7?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:75Ibf9kajH52v2uBNc7pkp\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/0LyecvMmiD3grsZtkEQQJM\" }, \"href\" : \"https://api.spotify.com/v1/albums/0LyecvMmiD3grsZtkEQQJM\" , \"id\" : \"0LyecvMmiD3grsZtkEQQJM\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273ca84a453df6f486114bcc774\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02ca84a453df6f486114bcc774\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851ca84a453df6f486114bcc774\" , \"width\" : 64 } ], \"name\" : \"Veins\" , \"release_date\" : \"2014-07-15\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:0LyecvMmiD3grsZtkEQQJM\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 269974 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400017\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/1UsXMQwIzCKSk6oIdRE5Jc\" }, \"href\" : \"https://api.spotify.com/v1/tracks/1UsXMQwIzCKSk6oIdRE5Jc\" , \"id\" : \"1UsXMQwIzCKSk6oIdRE5Jc\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Veins\" , \"popularity\" : 52 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/69efa6483c01ab1c3bd323d7a71287aa9b126317?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:1UsXMQwIzCKSk6oIdRE5Jc\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/1SJbZWC9jhrR1m4fDYP1ys\" }, \"href\" : \"https://api.spotify.com/v1/albums/1SJbZWC9jhrR1m4fDYP1ys\" , \"id\" : \"1SJbZWC9jhrR1m4fDYP1ys\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273f490d80a7841c5bd61a4f694\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02f490d80a7841c5bd61a4f694\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851f490d80a7841c5bd61a4f694\" , \"width\" : 64 } ], \"name\" : \"Bitter\" , \"release_date\" : \"2014-08-11\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:1SJbZWC9jhrR1m4fDYP1ys\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 234674 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400014\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/6xxy4SktborcH1wRjISek5\" }, \"href\" : \"https://api.spotify.com/v1/tracks/6xxy4SktborcH1wRjISek5\" , \"id\" : \"6xxy4SktborcH1wRjISek5\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Bitter\" , \"popularity\" : 48 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/36eda2cdf0d31e8b694552159d012fc677296af1?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:6xxy4SktborcH1wRjISek5\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/50lmuZTx1lNcNFjY2cr3HB\" }, \"href\" : \"https://api.spotify.com/v1/albums/50lmuZTx1lNcNFjY2cr3HB\" , \"id\" : \"50lmuZTx1lNcNFjY2cr3HB\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273e84adb5bc350142cb67a5656\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02e84adb5bc350142cb67a5656\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851e84adb5bc350142cb67a5656\" , \"width\" : 64 } ], \"name\" : \"Lost in the Night\" , \"release_date\" : \"2014-10-20\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 5 , \"type\" : \"album\" , \"uri\" : \"spotify:album:50lmuZTx1lNcNFjY2cr3HB\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 242430 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400015\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/6wimdClggXbqamkhOsyRQ9\" }, \"href\" : \"https://api.spotify.com/v1/tracks/6wimdClggXbqamkhOsyRQ9\" , \"id\" : \"6wimdClggXbqamkhOsyRQ9\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"I Want What You Got\" , \"popularity\" : 47 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9c7ba3c471bfaa2fe5ff68ca87402fa8e65ee80f?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 2 , \"type\" : \"track\" , \"uri\" : \"spotify:track:6wimdClggXbqamkhOsyRQ9\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 246893 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71602810\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/23uCHFc7xcQWgXh2oelMOe\" }, \"href\" : \"https://api.spotify.com/v1/tracks/23uCHFc7xcQWgXh2oelMOe\" , \"id\" : \"23uCHFc7xcQWgXh2oelMOe\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Have Faith\" , \"popularity\" : 46 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/634c490bc66b42bc99b7637b0abfb24b47853214?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 7 , \"type\" : \"track\" , \"uri\" : \"spotify:track:23uCHFc7xcQWgXh2oelMOe\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 305040 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603024\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/0s2mDwSz2RvcHE3DYhSkL2\" }, \"href\" : \"https://api.spotify.com/v1/tracks/0s2mDwSz2RvcHE3DYhSkL2\" , \"id\" : \"0s2mDwSz2RvcHE3DYhSkL2\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"So Long Forever\" , \"popularity\" : 45 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/257b17e1ea6c76bce48e02bdf416c8c6600a65e8?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 8 , \"type\" : \"track\" , \"uri\" : \"spotify:track:0s2mDwSz2RvcHE3DYhSkL2\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 198013 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603030\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/3SJI20YW5l5Ri1etVIx1Vo\" }, \"href\" : \"https://api.spotify.com/v1/tracks/3SJI20YW5l5Ri1etVIx1Vo\" , \"id\" : \"3SJI20YW5l5Ri1etVIx1Vo\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Holy Smoke\" , \"popularity\" : 45 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/636cebb17ae17e216bfb39cb276ba29a21003ffb?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 10 , \"type\" : \"track\" , \"uri\" : \"spotify:track:3SJI20YW5l5Ri1etVIx1Vo\" } ] } Here we can see information about their top songs, including name, release date, total tracks, type, direct URI, if it is explicit, the popularity, the track number, and much more. It even includes a link to a preview URL ! This is a great example of a layered system because the results are not rendered on every request! The results can be cached because artist data doesn't update very often. Using an API from the Command Line Let's try making an API request from our own command line, not a website! Let's use a different API this time, one from Twilio . We will be working with the \"Programmable Messaging\" API. Let's click on \"build\" and try sending a message to our phone number from the website. We can do this by adding whatever we want in the \"Body\" section and then clicking on \"Make Request\". You should now receive a text message with whatever you wrote. Let's take this a step further and open a terminal. Let's make a Python program first to interact with this API and send the message: 1 2 3 4 5 6 7 8 9 10 11 12 from twilio.rest import Client account_sid = 'AC504e58232220f1698dbf3c144af87g2z' #these have been changed for security auth_token = '261209ecabd9de3cec413a4b458a423za' client = Client ( account_sid , auth_token ) message = client . messages . create ( from_ = '+12057654321' , to = '+19091234567' ) print ( message . sid ) After running the above Python program, we should get a response like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"sid\" : \"SM55d7040dd06b4c33a19b38863843acea\" , \"date_created\" : \"Wed, 02 Sep 2020 17:41:14 +0000\" , \"date_updated\" : \"Wed, 02 Sep 2020 17:41:14 +0000\" , \"date_sent\" : null , \"account_sid\" : \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"to\" : \"+19091234567\" , \"from\" : \"+12057654321\" , \"messaging_service_sid\" : null , \"body\" : \"Sent from your Twilio trial account - Hello!\" , \"status\" : \"queued\" , \"num_segments\" : \"1\" , \"num_media\" : \"0\" , \"direction\" : \"outbound-api\" , \"api_version\" : \"2010-04-01\" , \"price\" : null , \"price_unit\" : \"USD\" , \"error_code\" : null , \"error_message\" : null , \"uri\" : \"/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages/SM55d7040dd06b4c33a19b38863843acea.json\" , \"subresource_uris\" : { \"media\" : \"/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages/SM55d7040dd06b4c33a19b38863843acea/Media.json\" } } Or an error message telling you what went wrong. We can also do this as a cURL command: curl 'https://api.twilio.com/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages.json' -X POST \\ --data-urlencode 'To=+19091234567' \\ --data-urlencode 'From=+12057654321' \\ --data-urlencode 'Body=Hello!' \\ -u AC504e58232220f1698dbf3c115a8ggt52:[AuthToken] If it worked, you should see the message pop up on a verifed phone! Using Postman to Explore APIs Postman is a feature rich tool that helps users explore new APIs. We can use either the browser application or the desktop application for the following. Let's click on \"Create a New Collection\", which keeps all request that we make grouped together. Let's recreate the calls we made to the Twilio API from above. Let's name the collection \"Twilio\" and click \"Create\". It should now show up in the collections area on the left sidebar. Click on the Twilio collection and then \"Add requests\". We can name the Request \"Message Log\", and add a descriptive description like the following: All messages sent from my account. [Twilio Documentation](https://www.twilio.com/docs/sms/api/message-resource?code-sample=code-read-list-all-messages&code-language=Node.js&code-sdk-version=3.x) It is best practice to reference to the parent documentation whenever using an API for ease of access. Now, let's click on the new GET request we have created to open it in the Launchpad. We can now grab the URL from the Twilio cURL GET request from earlier: https://api.twilio.com/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages.json Before we click \"Send\", we need to make sure we include our auth for Twilio in the \"Authorization\" in Postman. We also need to add some variables in the \"Variables\" tab, specifically TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN . We can now use these variables in the authorization tab with {{TWILIO_ACCOUNT_SID}} in the username field and {{TWILIO_AUTH_TOKEN}} in the password field. Now let's click \"Send\". We should get a response with an array filled out will our previous message body, to/from info, date/time, etc. POST Request on Postman Let's create another request within the Twilio collection titled \"Create a message\". Remember to put a description with a link to the documentation! After creating the request, let's open it and change GET to POST in the dropdown menu. We will need to look through the documentation on how to implement this request and make it follow the API's rules. First, ets fill in the URL: https://api.twilio.com/2010-04-01/Accounts/{{TWILIO_ACCOUNT_SID}}/Messages.json Notice how we used the {{TWILIO_ACCOUNT_SID}} instead of the long id from the last request we made. Now in the Body tab, lets add a to key with a value of the number you want to message. Next, let's create a body key with whatever text you want to be sent. We also need to add a from key with our {{TWILIO_NUMBER}} (we can add this to the credentials tab). Now when we click \"Send\", a message should be sent to the verified number of your choice. Using Helper Libraries in JavaScript In order to avoid writing repitive code, we can use helper libraries or SDKs Software Development Kits). SDKs are unique to each programming language and help make your code more concise and legible. We are going to start out by working with Node . Node.js is an open-source, cross-platform, JavaScript runtime environment that executes JavaScript code outside of a web browser. After installing Node, we can open a command prompt and type in the command node -v to check what version of Node is loaded. If an error occurs, Node is not installed properly on your machine. First, let's create a new directory to work inside with the mkdir scratch command. In that directory let's make a directory called javascript with the mkdir javascript command. Lets open this folder in Visual Studio Code (VS Code) and create a new file called explore.js in the javascript folder. Let's open the terminal in VS Code and install the twilio library with the following command: npm install twilio Now that we have downloaded the file, let's write some code in the explore.js file we made earlier: 1 2 3 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); The two variables we using in the string are are account SID and Auth Token. The problem with this is whenever we upload or share this with anyone, our account credentials are right there to be seen. Later, we will put these into environment variables, but for now, we will stick with this for ease of demonstration. The Twilio JS Client works like most JavaScript libraries. It is asynchronous, and it relies on a concept called promises . The way promises work is that there are set handlers for when a method call completes. To get our message log, we would use the following method (line 5): 1 2 3 4 5 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list (); The client.messages.list() method returns an object called a promise. It is a promise of a future value, which in this case will be our messages. Promises have an important method on them, and it's called then . We can chain on a .then to the end of the method (this method should also be given a function that accepts a value). To pass messages a function, we use something called a fat arrow function (see below). In the .then method, we will put the name of the value ( messages ), because this is what we are expecting to return. Next we are going to put a fat arrow => , followed by the function body. Fat Arrow Functions \" Fat arrow functions \" are a more concise syntax for writing function expressions. They utilize a new token, => , that looks like a fat arrow. Arrow functions are anonymous and change the way this binds in functions. By using arrow functions, we avoid having to type the function keyword, return keyword (it\u2019s implicit in arrow functions), and curly brackets. Let's simply log out the most recent message. To do that we add: 1 2 3 4 5 6 7 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` )); Finally, we will add a console.log to show that this is running asynchronously: 1 2 3 4 5 6 7 8 9 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` )); console . log ( 'Gathering your message log.' ); Now when we run the following command in a terminal: node explore.js We should get the following response: Gathering your message log. The most recent message is: Sent from your Twilio trial account - Hello! If your file errored out, you would see the following response: Gathering your message log. Let's catch any error that may occur and display what the error was: 1 2 3 4 5 6 7 8 9 10 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` ) ). catch ( err => console . error ( err )); console . log ( 'Gathering your message log.' ); Let's remove one character from our account SID from the code and try running to file again. We should see the following response: Gathering your message log. RestException [Error]: The requested resource /2010-04-01/Accounts/AC504e58232220f1698dbf3c1169ef0d8/Messages.json was not found at MessagePage.Page.processResponse (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\base\\Page.js:156:11) at MessagePage.Page (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\base\\Page.js:16:22) at new MessagePage (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\rest\\api\\v2010\\account\\message.js:467:30) at Function.<anonymous> (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\rest\\api\\v2010\\account\\message.js:360:24) at Promise_then_fulfilled (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:766:44) at Promise_done_fulfilled (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:835:31) at Fulfilled_dispatch [as dispatch] (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:1229:9) at Pending_become_eachMessage_task (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:1369:30) at RawTask.call (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\asap\\asap.js:40:19) at flush (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\asap\\raw.js:50:29) { status: 404, code: 20404, moreInfo: 'https://www.twilio.com/docs/errors/20404', details: undefined } Using Helper Libraries in Python In that same scratch directory that we created earlier, let's create a new directory called python. Next, let's create a file called explore.py . Finally, let's install the Twilio helper library by running the following code: pip install twilio Now that the Twilio library is installed we can begin working on the explore.py file. Let's print out the messages we have sent out: 1 2 3 4 5 6 7 8 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) for msg in client . messages . list (): print ( msg . body ) You should get the following result: Sent from your Twilio trial account - Hello! Sent from your Twilio trial account - Test 123! Let's go a little bit deeper and write some code to actually send a message in Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) msg = client . messages . create ( to = \"+19091234567\" , from_ = \"+12057654321\" , body = \"hello from Python!\" ) print ( f \"Created a new message: { msg . sid } .\" ) After running this, our phone should receive a text message and we will get the following return in the terminal: Created a new message: SMb3f7a74a5e754437acf9c7eecfded389. Now let's run the get messages code from earlier to see if it shows up! Sent from your Twilio trial account - Hello from Python! Sent from your Twilio trial account - Hello! Sent from your Twilio trial account - Test 123! Now let's delete ALL messages that we have sent from our Twilio account. This is fairly simple code: 1 2 3 4 5 6 7 8 9 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) for msg in client . messages . list (): print ( f \"Deleting { msg . body } \" ) msg . delete () It will now show all the messages it is deleting: Deleting Sent from your Twilio trial account - Hello from Python! Deleting Sent from your Twilio trial account - Hello! Deleting Sent from your Twilio trial account - Test 123! These helper libraries are able to extract out the HTTP calls we would have had to code out for us! Flask Application Build Let's build a simple Complimenter application! This application will take a name and phone number to compliment and the sender's name and compliment to be sent. To do this, we are going to use Flask. Flask is a web framework that provides an API that let's you extend the framework to create your application. This application is going to be doing server-side rendering, which means that pages will only be created on the server-side and any change/navigation will require a full reload. We are going to be using Glitch to provide a free web server for this project. Let's create an account and click on \"New Project\" \"Clone Git Repo\". We're going to use the following repo . If we click on \"Tools\" \"Log\", we will see all logs of setup and a URL to our local server. If you click on \"Show\" in the top, we can see a preview of our code! We will start with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import os from dotenv import load_dotenv from flask import ( Flask , flash , render_template , redirect , request , url_for , ) from twilio.rest import Client load_dotenv () app = Flask ( __name__ ) app . secret_key = \"ssssh don't tell anyone\" TWILIO_PHONE_NUMBER = os . getenv ( 'TWILIO_PHONE_NUMBER' ) #This pulls our phone number from the .env file from the repo. Make sure to replace the account SID, Auth Token, and Phone number client = Client () def get_sent_messages (): messages = client . messages . list ( from_ = TWILIO_PHONE_NUMBER ) return messages def send_message ( to , body ): client . messages . create ( to = to , from_ = TWILIO_PHONE_NUMBER , body = body ) @app . route ( \"/\" , methods = [ \"GET\" ]) def index (): messages = get_sent_messages () return render_template ( \"index.html\" , messages = messages ) @app . route ( \"/add-compliment\" , methods = [ \"POST\" ]) def add_compliment (): sender = request . values . get ( 'sender' , 'Someone' ) receiver = request . values . get ( 'receiver' , 'Someone' ) compliment = request . values . get ( 'compliment' , 'wonderful' ) to = request . values . get ( 'to' ) body = f ' { sender } says: { receiver } is { compliment } . See more compliments at { request . url_root } ' send_message ( to , body ) flash ( 'Your message was successfully sent' ) return redirect ( url_for ( 'index' )) if __name__ == '__main__' : app . run () We used similar code from above sections to both the get_sent_messages() and send_message functions. Dealing with API Limits API developers need to consider the possiblity of their APIs being hammered by hundreds of thousands or even millions of requests in a short amount of time. The web server may not be able to handle these requests and crash. In order to prevent this, API developers have to code limits or throttle the number of queries possible by each user. For example, Twilio limits the numbers you can text to verified numbers (at least in the Trial version). If we attempt to text a number a message using our Complimentr application that is not verified we will get a long traceback error in the logs. If we look at these logs, we will see that we receive an HTTP 400 error: Unable to create record: The number is unverified... . Being aware of an API's limits can help you better plan your development. JavaScript Single Page Application Now let's try to implement the previous Complimentr application using only JavaScript. For this, we are going to use a full-stack JavaScript application. Full-stack means that the server code and front-end application is written in JS. On the server side, the application uses Node.js and the web framework Express. On the front-end, we will use the client-side framework Vue. Let's use the following repo . The JS version of the Complimentr app is implemented as a Very Simple Single Page Application (SPA). This mean that once the page is loaded, the client will be responsible for rendering parts of the page. We won't need to rely on a full page reload from the server each time something changes. Let's take a look at app.js (the server-side of our application) from the repo. require ( \"dotenv\" ). config (); const express = require ( \"express\" ); const bodyParser = require ( \"body-parser\" ); const app = express (); const port = 3000 ; // This is a single page application and it's all rendered in public/index.html app . use ( express . static ( \"public\" )); // Parse the body of requests automatically app . use ( bodyParser . json ()); app . get ( \"/api/compliments\" , async ( req , res ) => { // TODO: Get a list of messages sent from a specific number const sentMessages = []; // TODO: Gather only the body of those messages for sending to the client const compliments = []; res . json ( compliments ); }); app . post ( \"/api/compliments\" , async ( req , res ) => { const to = req . body . to ; const from = process . env . TWILIO_PHONE_NUMBER ; const body = ` ${ req . body . sender } says: ${ req . body . receiver } is ${ req . body . compliment } . See more compliments at ${ req . headers . referer } ` ; // TODO: Send a message res . json ({ success : false }); }); app . listen ( port , () => console . log ( `Prototype is listening on port ${ port } !` ));","title":"API Overview"},{"location":"api/#introduction-to-apis","text":"","title":"Introduction to APIs"},{"location":"api/#quick-links","text":"API Introduction Docs Working with Web APIs (Online Book)","title":"Quick Links"},{"location":"api/#overview","text":"An API (Application Programming Interface) is a way for different machines and software to talk to each other to create ever more complex applications. It is a contract of sorts: it defines how it is expected to be used and what you can expect to receive by using it. When most people hear the acronym API, they most likely are thinking about web-based APIs, which is completely understandable. You must also know about the many APIs that are built into all modern programming languages. For example, let's say you wanted to capitalize a string of text. We could write a long code to translate each individual letter to the uppercase version through low level bitmath OR we could use the uppercase API: Python 'yeet!' . upper () # YEET! JavaScript 'yeet!' . toUpperCase (); // YEET! Java \"yeet!\" . toUpperCase (); // YEET! Basically, programmers use APIs to avoid recreating the wheel. APIs assist us in accomplishing tasks that we need to perform, by abstracting away a ton of work for us.","title":"Overview"},{"location":"api/#remote-apis","text":"The above examples we gave were local APIs, built into the programming language. Remote APIs can be looked at similarly to your TV's remote. You work with the interface on the remote to make changes to the TV, as if you were using the interface on the device itself. Its not just physical objects that benefit from remote APIs. Sometimes, we don't have space on our local machines for all the data that is available. For example, when we use an app like Shazam to find out what song is playing, the app doesn't store ALL the songs in the world on your phone; it instead uses a remote API to send data to the app serice for indentification. Remote APIs also offer another benefit of computational power. Because an API removes the limitations of your local machine, you can gain access to huge amounts of computational power. A good example of this is the AR feature in the Google Translate app. The app allows you to use the camera on your phone to translate what you are seeing directly to your screen in near real-time. This app requires a ton of computational power and it is getting it elsewhere (through cloud computing).","title":"Remote APIs"},{"location":"api/#rest-representational-state-transfer","text":"The struggle to achieve the concept of remote APIs was very real. The biggest problem was that there was no standard that everyone loved. Overtime, a clear winner came forward that offered a clean and universally-accepted format, REST. The popularity of REST spread so rapidly that it nearly took over the word API (think how XEROX almost took over the term photocopy). REST is not the end-all, be-all of remote APIs, but it is one of the most common and documented solution. The following notes will cover the REST framework! RESTful When APIs embrace the styles and constraints of REST, they are said to be RESTful. Here are the guiding architectural constraints for an API to be considered RESTful: Client-Server Architecture Statelessness Layered System Cacheability Uniform Design Code on Demand Let's cover these topics by discussing how APIs sit on top of web technology. Much like the web, the client (web browser/program) makes a request to a server. Your program will most likely be using some type of library to create the request to the server. The protocol used for these requests are through HTTP and it is stateless (the server won't remember anything about the particular client (state can be maintained through headers)). This request was almost certainly requesting information about a resource. The \"resource\" is a little absract, it is the R in U R L or U R I. We use the term resource to reference an object, which is also abstract. This is because we can use resources to describe just about anything we build. For example, let's imagine an e-book store website. Each book available for purchase is a resource. If we click into it, we may see a link to the author, which is also a resource. When we click on a resource the browser sends a GET request to the server. The RESTful API follows the same logic; your program will send a GET request to a URI (Uniform Resource Identifier), then the server responds with data. The body of the data returned is typically represented today as JSON (JavaScript Object Notation). JSON provides a great way to structure and nest the data. Here are a few HTTP verbs that are used in REST APIs to clearly state the intention of your request: HTTP Verbs CRUD (Create, Read, Update, Delete) GET Read POST Create PUT Update PATCH Update DELETE Delete Want to add an author? POST to the /authors and send them the data you want to update in the body of your request: POST /au t hors/ { au t hor_Name : \"Dave Eggers\" } Want to remove an author? Send a DELETE to that specific author: DELETE /au t hors/ { HBWSG 123 } This means that you can interact with any application out there that exposes their REST API.","title":"REST (REpresentational State Transfer)"},{"location":"api/#exploring-an-api-online","text":"Let's look at a real API online and see what we can learn. For this, we are going to be looking at Spotify's API . Here we can see all the different features that Spotify allows user's to use in their API. Let's go down to the Search section and read the documentation . We can click on the API beta link at the top and then look for the \"Search for an Item\" link. This documentation explains the \"contract\" of what we need to do in order to use the API. In this documentation we can see which type of headers and query parameters in the request are required or optional for the API to work. You can also see the types of reponses your request can receive. Reading the documentation for APIs is perhaps the most important step in implementing an API in your code. You will see notes from the programmers on how to actually make it work! Let's work with Spotify's Web Console , which allows us to test their APIs and play around with the different features. The Console will show us where it will query: GET https://api.spotify.com/v1/search and how it will query: curl -X \"GET\" \"https://api.spotify.com/v1/search?q=Palace&type=artist&market=US&limit=2\" -H \"Accept: application/json\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer BQBBI2LYRwSAZ__Agy0GV0BU_i3adk4b4Wsv7eQbfsgdOJUn0HJDgCJpF3v6g_oJ6rcZjOeEdVVz4FrIKZWoAixqhEhJYtqByw0jQfC5ZMHq-wqJACdyrQ7sIQlpeZXemL2jGhfa728ckA9\" If we break down the above API GET request, we can see that we are searching for ?q=Palace&type=artist along with some other bits. I have limited the results to 2 ( &limit=2 ) in order to keep the result set small. You can also see the Bearer OAuth token at the end, which I have changed in order for my account to remain anonymous. If we run this in the Console, we will get a result that looks something like the following: { \"artists\" : { \"href\" : \"https://api.spotify.com/v1/search?query=Palace&type=artist&market=US&offset=0&limit=2\" , \"items\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"followers\" : { \"href\" : null , \"total\" : 107224 }, \"genres\" : [ \"english indie rock\" , \"indie soul\" , \"vapor soul\" ], \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/8b76736404ceb4bc72669f44908dea557ab03083\" , \"width\" : 640 }, { \"height\" : 320 , \"url\" : \"https://i.scdn.co/image/0c135b9e55b911a37b7aee00af60630c777d4c04\" , \"width\" : 320 }, { \"height\" : 160 , \"url\" : \"https://i.scdn.co/image/79c30a9ba1518749fb74cc449bcaa060f8aa8151\" , \"width\" : 160 } ], \"name\" : \"Palace\" , \"popularity\" : 59 , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" }, { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/37J1PlAkhRK7yrZUtqaUpQ\" }, \"followers\" : { \"href\" : null , \"total\" : 716429 }, \"genres\" : [ \"electro swing\" , \"nu jazz\" ], \"href\" : \"https://api.spotify.com/v1/artists/37J1PlAkhRK7yrZUtqaUpQ\" , \"id\" : \"37J1PlAkhRK7yrZUtqaUpQ\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/adc8c619e766119fabd784a257d6376a653d41ea\" , \"width\" : 640 }, { \"height\" : 320 , \"url\" : \"https://i.scdn.co/image/65df61829bfdb02f7e068de1b3c28799bdc5ace6\" , \"width\" : 320 }, { \"height\" : 160 , \"url\" : \"https://i.scdn.co/image/e86351da17029aa21616d98104bbc6f3c61109d7\" , \"width\" : 160 } ], \"name\" : \"Caravan Palace\" , \"popularity\" : 67 , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:37J1PlAkhRK7yrZUtqaUpQ\" } ], \"limit\" : 2 , \"next\" : \"https://api.spotify.com/v1/search?query=Palace&type=artist&market=US&offset=2&limit=2\" , \"offset\" : 0 , \"previous\" : null , \"total\" : 448 } } Above you can see the response from the Search API of Spotify. There is some interesting information in here, including the artists unique artist identifier ( 48vDIufGC8ujPuBiTxY8dm for my favorite band Palace), as well as the popularity, folowers, genres, and links to images. Let's take that artist id and plug it into the \"Get an Artist's Top Tracks\" API. Here we can see that the API URL has changed to: https://api.spotify.com/v1/artists/{id}/top-tracks Let's plug in Palace's artist id into the API call: curl -X \"GET\" \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm/top-tracks?country=US\" -H \"Accept: application/json\" -H \"Content-Type: application/json\" -H \"Authorization: Bearer BQBBI2LYRwSAZ__Agy0GV0BU_i3adk4b4Wsv7eQbfsgdOJUn0HJDgCJpF3v6g_oJ6rcZjOeEdVVz4FrIKZWoAixqhEhJYtqByw0jQfC5ZMHq-wqJACdyrQ7sIQlpeZZXemL2jGhfa728ckA9\" We should get the following resutl: JSON Response { \"tracks\" : [ { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 249840 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603029\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/2H30WL3exSctlDC9GyRbD4\" }, \"href\" : \"https://api.spotify.com/v1/tracks/2H30WL3exSctlDC9GyRbD4\" , \"id\" : \"2H30WL3exSctlDC9GyRbD4\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Live Well\" , \"popularity\" : 64 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/516b9622373316d4ebbfd4baab240a8217b01952?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 3 , \"type\" : \"track\" , \"uri\" : \"spotify:track:2H30WL3exSctlDC9GyRbD4\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/2gnr57XaEBXSDlfbkowBP8\" }, \"href\" : \"https://api.spotify.com/v1/albums/2gnr57XaEBXSDlfbkowBP8\" , \"id\" : \"2gnr57XaEBXSDlfbkowBP8\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273287d57f51a9220e1b972d576\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02287d57f51a9220e1b972d576\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851287d57f51a9220e1b972d576\" , \"width\" : 64 } ], \"name\" : \"Life After\" , \"release_date\" : \"2019-07-12\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:2gnr57XaEBXSDlfbkowBP8\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 437577 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71806918\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/3Rl26h1HiMCV0HFHHVb2IM\" }, \"href\" : \"https://api.spotify.com/v1/tracks/3Rl26h1HiMCV0HFHHVb2IM\" , \"id\" : \"3Rl26h1HiMCV0HFHHVb2IM\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Heaven Up There\" , \"popularity\" : 58 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9bfd400bc1701508933e11dd88edbaa3743e726e?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 11 , \"type\" : \"track\" , \"uri\" : \"spotify:track:3Rl26h1HiMCV0HFHHVb2IM\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 233360 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603022\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/2DkZisoN9h1dLa8Sn5sx0n\" }, \"href\" : \"https://api.spotify.com/v1/tracks/2DkZisoN9h1dLa8Sn5sx0n\" , \"id\" : \"2DkZisoN9h1dLa8Sn5sx0n\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Bitter\" , \"popularity\" : 58 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/df18b5b91c3b46589dc1bbca26fbdfd895028995?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 2 , \"type\" : \"track\" , \"uri\" : \"spotify:track:2DkZisoN9h1dLa8Sn5sx0n\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/161a4wcY3Lh9xN8OEF0RMr\" }, \"href\" : \"https://api.spotify.com/v1/albums/161a4wcY3Lh9xN8OEF0RMr\" , \"id\" : \"161a4wcY3Lh9xN8OEF0RMr\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b27390912ce0aad8b575d3cd1b50\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e0290912ce0aad8b575d3cd1b50\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d0000485190912ce0aad8b575d3cd1b50\" , \"width\" : 64 } ], \"name\" : \"Someday, Somewhere\" , \"release_date\" : \"2020-07-17\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:161a4wcY3Lh9xN8OEF0RMr\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 192461 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM72002794\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/75Ibf9kajH52v2uBNc7pkp\" }, \"href\" : \"https://api.spotify.com/v1/tracks/75Ibf9kajH52v2uBNc7pkp\" , \"id\" : \"75Ibf9kajH52v2uBNc7pkp\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Someday, Somewhere\" , \"popularity\" : 55 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9a45e9861c165c1c653f1f54b9049f7033134bd7?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:75Ibf9kajH52v2uBNc7pkp\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/0LyecvMmiD3grsZtkEQQJM\" }, \"href\" : \"https://api.spotify.com/v1/albums/0LyecvMmiD3grsZtkEQQJM\" , \"id\" : \"0LyecvMmiD3grsZtkEQQJM\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273ca84a453df6f486114bcc774\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02ca84a453df6f486114bcc774\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851ca84a453df6f486114bcc774\" , \"width\" : 64 } ], \"name\" : \"Veins\" , \"release_date\" : \"2014-07-15\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:0LyecvMmiD3grsZtkEQQJM\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 269974 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400017\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/1UsXMQwIzCKSk6oIdRE5Jc\" }, \"href\" : \"https://api.spotify.com/v1/tracks/1UsXMQwIzCKSk6oIdRE5Jc\" , \"id\" : \"1UsXMQwIzCKSk6oIdRE5Jc\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Veins\" , \"popularity\" : 52 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/69efa6483c01ab1c3bd323d7a71287aa9b126317?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:1UsXMQwIzCKSk6oIdRE5Jc\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/1SJbZWC9jhrR1m4fDYP1ys\" }, \"href\" : \"https://api.spotify.com/v1/albums/1SJbZWC9jhrR1m4fDYP1ys\" , \"id\" : \"1SJbZWC9jhrR1m4fDYP1ys\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273f490d80a7841c5bd61a4f694\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02f490d80a7841c5bd61a4f694\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851f490d80a7841c5bd61a4f694\" , \"width\" : 64 } ], \"name\" : \"Bitter\" , \"release_date\" : \"2014-08-11\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 1 , \"type\" : \"album\" , \"uri\" : \"spotify:album:1SJbZWC9jhrR1m4fDYP1ys\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 234674 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400014\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/6xxy4SktborcH1wRjISek5\" }, \"href\" : \"https://api.spotify.com/v1/tracks/6xxy4SktborcH1wRjISek5\" , \"id\" : \"6xxy4SktborcH1wRjISek5\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Bitter\" , \"popularity\" : 48 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/36eda2cdf0d31e8b694552159d012fc677296af1?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 1 , \"type\" : \"track\" , \"uri\" : \"spotify:track:6xxy4SktborcH1wRjISek5\" }, { \"album\" : { \"album_type\" : \"single\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/50lmuZTx1lNcNFjY2cr3HB\" }, \"href\" : \"https://api.spotify.com/v1/albums/50lmuZTx1lNcNFjY2cr3HB\" , \"id\" : \"50lmuZTx1lNcNFjY2cr3HB\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273e84adb5bc350142cb67a5656\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02e84adb5bc350142cb67a5656\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851e84adb5bc350142cb67a5656\" , \"width\" : 64 } ], \"name\" : \"Lost in the Night\" , \"release_date\" : \"2014-10-20\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 5 , \"type\" : \"album\" , \"uri\" : \"spotify:album:50lmuZTx1lNcNFjY2cr3HB\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 242430 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBLVL1400015\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/6wimdClggXbqamkhOsyRQ9\" }, \"href\" : \"https://api.spotify.com/v1/tracks/6wimdClggXbqamkhOsyRQ9\" , \"id\" : \"6wimdClggXbqamkhOsyRQ9\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"I Want What You Got\" , \"popularity\" : 47 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/9c7ba3c471bfaa2fe5ff68ca87402fa8e65ee80f?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 2 , \"type\" : \"track\" , \"uri\" : \"spotify:track:6wimdClggXbqamkhOsyRQ9\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 246893 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71602810\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/23uCHFc7xcQWgXh2oelMOe\" }, \"href\" : \"https://api.spotify.com/v1/tracks/23uCHFc7xcQWgXh2oelMOe\" , \"id\" : \"23uCHFc7xcQWgXh2oelMOe\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Have Faith\" , \"popularity\" : 46 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/634c490bc66b42bc99b7637b0abfb24b47853214?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 7 , \"type\" : \"track\" , \"uri\" : \"spotify:track:23uCHFc7xcQWgXh2oelMOe\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 305040 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603024\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/0s2mDwSz2RvcHE3DYhSkL2\" }, \"href\" : \"https://api.spotify.com/v1/tracks/0s2mDwSz2RvcHE3DYhSkL2\" , \"id\" : \"0s2mDwSz2RvcHE3DYhSkL2\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"So Long Forever\" , \"popularity\" : 45 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/257b17e1ea6c76bce48e02bdf416c8c6600a65e8?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 8 , \"type\" : \"track\" , \"uri\" : \"spotify:track:0s2mDwSz2RvcHE3DYhSkL2\" }, { \"album\" : { \"album_type\" : \"album\" , \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/album/6cmFNl8lllA6BGc7SKLy3y\" }, \"href\" : \"https://api.spotify.com/v1/albums/6cmFNl8lllA6BGc7SKLy3y\" , \"id\" : \"6cmFNl8lllA6BGc7SKLy3y\" , \"images\" : [ { \"height\" : 640 , \"url\" : \"https://i.scdn.co/image/ab67616d0000b273929dae46c6b93942c7499b7d\" , \"width\" : 640 }, { \"height\" : 300 , \"url\" : \"https://i.scdn.co/image/ab67616d00001e02929dae46c6b93942c7499b7d\" , \"width\" : 300 }, { \"height\" : 64 , \"url\" : \"https://i.scdn.co/image/ab67616d00004851929dae46c6b93942c7499b7d\" , \"width\" : 64 } ], \"name\" : \"So Long Forever\" , \"release_date\" : \"2016-11-04\" , \"release_date_precision\" : \"day\" , \"total_tracks\" : 11 , \"type\" : \"album\" , \"uri\" : \"spotify:album:6cmFNl8lllA6BGc7SKLy3y\" }, \"artists\" : [ { \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/artist/48vDIufGC8ujPuBiTxY8dm\" }, \"href\" : \"https://api.spotify.com/v1/artists/48vDIufGC8ujPuBiTxY8dm\" , \"id\" : \"48vDIufGC8ujPuBiTxY8dm\" , \"name\" : \"Palace\" , \"type\" : \"artist\" , \"uri\" : \"spotify:artist:48vDIufGC8ujPuBiTxY8dm\" } ], \"disc_number\" : 1 , \"duration_ms\" : 198013 , \"explicit\" : false , \"external_ids\" : { \"isrc\" : \"GBUM71603030\" }, \"external_urls\" : { \"spotify\" : \"https://open.spotify.com/track/3SJI20YW5l5Ri1etVIx1Vo\" }, \"href\" : \"https://api.spotify.com/v1/tracks/3SJI20YW5l5Ri1etVIx1Vo\" , \"id\" : \"3SJI20YW5l5Ri1etVIx1Vo\" , \"is_local\" : false , \"is_playable\" : true , \"name\" : \"Holy Smoke\" , \"popularity\" : 45 , \"preview_url\" : \"https://p.scdn.co/mp3-preview/636cebb17ae17e216bfb39cb276ba29a21003ffb?cid=774b29d4f13844c495f206cafdad9c86\" , \"track_number\" : 10 , \"type\" : \"track\" , \"uri\" : \"spotify:track:3SJI20YW5l5Ri1etVIx1Vo\" } ] } Here we can see information about their top songs, including name, release date, total tracks, type, direct URI, if it is explicit, the popularity, the track number, and much more. It even includes a link to a preview URL ! This is a great example of a layered system because the results are not rendered on every request! The results can be cached because artist data doesn't update very often.","title":"Exploring an API Online"},{"location":"api/#using-an-api-from-the-command-line","text":"Let's try making an API request from our own command line, not a website! Let's use a different API this time, one from Twilio . We will be working with the \"Programmable Messaging\" API. Let's click on \"build\" and try sending a message to our phone number from the website. We can do this by adding whatever we want in the \"Body\" section and then clicking on \"Make Request\". You should now receive a text message with whatever you wrote. Let's take this a step further and open a terminal. Let's make a Python program first to interact with this API and send the message: 1 2 3 4 5 6 7 8 9 10 11 12 from twilio.rest import Client account_sid = 'AC504e58232220f1698dbf3c144af87g2z' #these have been changed for security auth_token = '261209ecabd9de3cec413a4b458a423za' client = Client ( account_sid , auth_token ) message = client . messages . create ( from_ = '+12057654321' , to = '+19091234567' ) print ( message . sid ) After running the above Python program, we should get a response like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { \"sid\" : \"SM55d7040dd06b4c33a19b38863843acea\" , \"date_created\" : \"Wed, 02 Sep 2020 17:41:14 +0000\" , \"date_updated\" : \"Wed, 02 Sep 2020 17:41:14 +0000\" , \"date_sent\" : null , \"account_sid\" : \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"to\" : \"+19091234567\" , \"from\" : \"+12057654321\" , \"messaging_service_sid\" : null , \"body\" : \"Sent from your Twilio trial account - Hello!\" , \"status\" : \"queued\" , \"num_segments\" : \"1\" , \"num_media\" : \"0\" , \"direction\" : \"outbound-api\" , \"api_version\" : \"2010-04-01\" , \"price\" : null , \"price_unit\" : \"USD\" , \"error_code\" : null , \"error_message\" : null , \"uri\" : \"/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages/SM55d7040dd06b4c33a19b38863843acea.json\" , \"subresource_uris\" : { \"media\" : \"/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages/SM55d7040dd06b4c33a19b38863843acea/Media.json\" } } Or an error message telling you what went wrong. We can also do this as a cURL command: curl 'https://api.twilio.com/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages.json' -X POST \\ --data-urlencode 'To=+19091234567' \\ --data-urlencode 'From=+12057654321' \\ --data-urlencode 'Body=Hello!' \\ -u AC504e58232220f1698dbf3c115a8ggt52:[AuthToken] If it worked, you should see the message pop up on a verifed phone!","title":"Using an API from the Command Line"},{"location":"api/#using-postman-to-explore-apis","text":"Postman is a feature rich tool that helps users explore new APIs. We can use either the browser application or the desktop application for the following. Let's click on \"Create a New Collection\", which keeps all request that we make grouped together. Let's recreate the calls we made to the Twilio API from above. Let's name the collection \"Twilio\" and click \"Create\". It should now show up in the collections area on the left sidebar. Click on the Twilio collection and then \"Add requests\". We can name the Request \"Message Log\", and add a descriptive description like the following: All messages sent from my account. [Twilio Documentation](https://www.twilio.com/docs/sms/api/message-resource?code-sample=code-read-list-all-messages&code-language=Node.js&code-sdk-version=3.x) It is best practice to reference to the parent documentation whenever using an API for ease of access. Now, let's click on the new GET request we have created to open it in the Launchpad. We can now grab the URL from the Twilio cURL GET request from earlier: https://api.twilio.com/2010-04-01/Accounts/AC504e58232220f1698dbf3c55a8ff73jm/Messages.json Before we click \"Send\", we need to make sure we include our auth for Twilio in the \"Authorization\" in Postman. We also need to add some variables in the \"Variables\" tab, specifically TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN . We can now use these variables in the authorization tab with {{TWILIO_ACCOUNT_SID}} in the username field and {{TWILIO_AUTH_TOKEN}} in the password field. Now let's click \"Send\". We should get a response with an array filled out will our previous message body, to/from info, date/time, etc.","title":"Using Postman to Explore APIs"},{"location":"api/#post-request-on-postman","text":"Let's create another request within the Twilio collection titled \"Create a message\". Remember to put a description with a link to the documentation! After creating the request, let's open it and change GET to POST in the dropdown menu. We will need to look through the documentation on how to implement this request and make it follow the API's rules. First, ets fill in the URL: https://api.twilio.com/2010-04-01/Accounts/{{TWILIO_ACCOUNT_SID}}/Messages.json Notice how we used the {{TWILIO_ACCOUNT_SID}} instead of the long id from the last request we made. Now in the Body tab, lets add a to key with a value of the number you want to message. Next, let's create a body key with whatever text you want to be sent. We also need to add a from key with our {{TWILIO_NUMBER}} (we can add this to the credentials tab). Now when we click \"Send\", a message should be sent to the verified number of your choice.","title":"POST Request on Postman"},{"location":"api/#using-helper-libraries-in-javascript","text":"In order to avoid writing repitive code, we can use helper libraries or SDKs Software Development Kits). SDKs are unique to each programming language and help make your code more concise and legible. We are going to start out by working with Node . Node.js is an open-source, cross-platform, JavaScript runtime environment that executes JavaScript code outside of a web browser. After installing Node, we can open a command prompt and type in the command node -v to check what version of Node is loaded. If an error occurs, Node is not installed properly on your machine. First, let's create a new directory to work inside with the mkdir scratch command. In that directory let's make a directory called javascript with the mkdir javascript command. Lets open this folder in Visual Studio Code (VS Code) and create a new file called explore.js in the javascript folder. Let's open the terminal in VS Code and install the twilio library with the following command: npm install twilio Now that we have downloaded the file, let's write some code in the explore.js file we made earlier: 1 2 3 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); The two variables we using in the string are are account SID and Auth Token. The problem with this is whenever we upload or share this with anyone, our account credentials are right there to be seen. Later, we will put these into environment variables, but for now, we will stick with this for ease of demonstration. The Twilio JS Client works like most JavaScript libraries. It is asynchronous, and it relies on a concept called promises . The way promises work is that there are set handlers for when a method call completes. To get our message log, we would use the following method (line 5): 1 2 3 4 5 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list (); The client.messages.list() method returns an object called a promise. It is a promise of a future value, which in this case will be our messages. Promises have an important method on them, and it's called then . We can chain on a .then to the end of the method (this method should also be given a function that accepts a value). To pass messages a function, we use something called a fat arrow function (see below). In the .then method, we will put the name of the value ( messages ), because this is what we are expecting to return. Next we are going to put a fat arrow => , followed by the function body. Fat Arrow Functions \" Fat arrow functions \" are a more concise syntax for writing function expressions. They utilize a new token, => , that looks like a fat arrow. Arrow functions are anonymous and change the way this binds in functions. By using arrow functions, we avoid having to type the function keyword, return keyword (it\u2019s implicit in arrow functions), and curly brackets. Let's simply log out the most recent message. To do that we add: 1 2 3 4 5 6 7 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` )); Finally, we will add a console.log to show that this is running asynchronously: 1 2 3 4 5 6 7 8 9 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` )); console . log ( 'Gathering your message log.' ); Now when we run the following command in a terminal: node explore.js We should get the following response: Gathering your message log. The most recent message is: Sent from your Twilio trial account - Hello! If your file errored out, you would see the following response: Gathering your message log. Let's catch any error that may occur and display what the error was: 1 2 3 4 5 6 7 8 9 10 const Twilio = require ( \"twilio\" ) const client = new Twilio ( \"AC504e58232220f1698dbf3c55a8ff73jm\" , \"261209ecabd9de3cec413a4b458a423za\" ); client . messages . list () . then ( messages => console . log ( `The most recent message is: ${ messages [ 0 ]. body } ` ) ). catch ( err => console . error ( err )); console . log ( 'Gathering your message log.' ); Let's remove one character from our account SID from the code and try running to file again. We should see the following response: Gathering your message log. RestException [Error]: The requested resource /2010-04-01/Accounts/AC504e58232220f1698dbf3c1169ef0d8/Messages.json was not found at MessagePage.Page.processResponse (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\base\\Page.js:156:11) at MessagePage.Page (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\base\\Page.js:16:22) at new MessagePage (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\rest\\api\\v2010\\account\\message.js:467:30) at Function.<anonymous> (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\twilio\\lib\\rest\\api\\v2010\\account\\message.js:360:24) at Promise_then_fulfilled (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:766:44) at Promise_done_fulfilled (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:835:31) at Fulfilled_dispatch [as dispatch] (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:1229:9) at Pending_become_eachMessage_task (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\q\\q.js:1369:30) at RawTask.call (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\asap\\asap.js:40:19) at flush (C:\\Users\\nickp\\Desktop\\scratch\\node_modules\\asap\\raw.js:50:29) { status: 404, code: 20404, moreInfo: 'https://www.twilio.com/docs/errors/20404', details: undefined }","title":"Using Helper Libraries in JavaScript"},{"location":"api/#using-helper-libraries-in-python","text":"In that same scratch directory that we created earlier, let's create a new directory called python. Next, let's create a file called explore.py . Finally, let's install the Twilio helper library by running the following code: pip install twilio Now that the Twilio library is installed we can begin working on the explore.py file. Let's print out the messages we have sent out: 1 2 3 4 5 6 7 8 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) for msg in client . messages . list (): print ( msg . body ) You should get the following result: Sent from your Twilio trial account - Hello! Sent from your Twilio trial account - Test 123! Let's go a little bit deeper and write some code to actually send a message in Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) msg = client . messages . create ( to = \"+19091234567\" , from_ = \"+12057654321\" , body = \"hello from Python!\" ) print ( f \"Created a new message: { msg . sid } .\" ) After running this, our phone should receive a text message and we will get the following return in the terminal: Created a new message: SMb3f7a74a5e754437acf9c7eecfded389. Now let's run the get messages code from earlier to see if it shows up! Sent from your Twilio trial account - Hello from Python! Sent from your Twilio trial account - Hello! Sent from your Twilio trial account - Test 123! Now let's delete ALL messages that we have sent from our Twilio account. This is fairly simple code: 1 2 3 4 5 6 7 8 9 from twilio.rest import Client client = Client ( \"AC504e58232220f1698dbf3c55a8ff73jmv\" , \"261209ecabd9de3cec413a4b458a423za\" ) for msg in client . messages . list (): print ( f \"Deleting { msg . body } \" ) msg . delete () It will now show all the messages it is deleting: Deleting Sent from your Twilio trial account - Hello from Python! Deleting Sent from your Twilio trial account - Hello! Deleting Sent from your Twilio trial account - Test 123! These helper libraries are able to extract out the HTTP calls we would have had to code out for us!","title":"Using Helper Libraries in Python"},{"location":"api/#flask-application-build","text":"Let's build a simple Complimenter application! This application will take a name and phone number to compliment and the sender's name and compliment to be sent. To do this, we are going to use Flask. Flask is a web framework that provides an API that let's you extend the framework to create your application. This application is going to be doing server-side rendering, which means that pages will only be created on the server-side and any change/navigation will require a full reload. We are going to be using Glitch to provide a free web server for this project. Let's create an account and click on \"New Project\" \"Clone Git Repo\". We're going to use the following repo . If we click on \"Tools\" \"Log\", we will see all logs of setup and a URL to our local server. If you click on \"Show\" in the top, we can see a preview of our code! We will start with the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import os from dotenv import load_dotenv from flask import ( Flask , flash , render_template , redirect , request , url_for , ) from twilio.rest import Client load_dotenv () app = Flask ( __name__ ) app . secret_key = \"ssssh don't tell anyone\" TWILIO_PHONE_NUMBER = os . getenv ( 'TWILIO_PHONE_NUMBER' ) #This pulls our phone number from the .env file from the repo. Make sure to replace the account SID, Auth Token, and Phone number client = Client () def get_sent_messages (): messages = client . messages . list ( from_ = TWILIO_PHONE_NUMBER ) return messages def send_message ( to , body ): client . messages . create ( to = to , from_ = TWILIO_PHONE_NUMBER , body = body ) @app . route ( \"/\" , methods = [ \"GET\" ]) def index (): messages = get_sent_messages () return render_template ( \"index.html\" , messages = messages ) @app . route ( \"/add-compliment\" , methods = [ \"POST\" ]) def add_compliment (): sender = request . values . get ( 'sender' , 'Someone' ) receiver = request . values . get ( 'receiver' , 'Someone' ) compliment = request . values . get ( 'compliment' , 'wonderful' ) to = request . values . get ( 'to' ) body = f ' { sender } says: { receiver } is { compliment } . See more compliments at { request . url_root } ' send_message ( to , body ) flash ( 'Your message was successfully sent' ) return redirect ( url_for ( 'index' )) if __name__ == '__main__' : app . run () We used similar code from above sections to both the get_sent_messages() and send_message functions.","title":"Flask Application Build"},{"location":"api/#dealing-with-api-limits","text":"API developers need to consider the possiblity of their APIs being hammered by hundreds of thousands or even millions of requests in a short amount of time. The web server may not be able to handle these requests and crash. In order to prevent this, API developers have to code limits or throttle the number of queries possible by each user. For example, Twilio limits the numbers you can text to verified numbers (at least in the Trial version). If we attempt to text a number a message using our Complimentr application that is not verified we will get a long traceback error in the logs. If we look at these logs, we will see that we receive an HTTP 400 error: Unable to create record: The number is unverified... . Being aware of an API's limits can help you better plan your development.","title":"Dealing with API Limits"},{"location":"api/#javascript-single-page-application","text":"Now let's try to implement the previous Complimentr application using only JavaScript. For this, we are going to use a full-stack JavaScript application. Full-stack means that the server code and front-end application is written in JS. On the server side, the application uses Node.js and the web framework Express. On the front-end, we will use the client-side framework Vue. Let's use the following repo . The JS version of the Complimentr app is implemented as a Very Simple Single Page Application (SPA). This mean that once the page is loaded, the client will be responsible for rendering parts of the page. We won't need to rely on a full page reload from the server each time something changes. Let's take a look at app.js (the server-side of our application) from the repo. require ( \"dotenv\" ). config (); const express = require ( \"express\" ); const bodyParser = require ( \"body-parser\" ); const app = express (); const port = 3000 ; // This is a single page application and it's all rendered in public/index.html app . use ( express . static ( \"public\" )); // Parse the body of requests automatically app . use ( bodyParser . json ()); app . get ( \"/api/compliments\" , async ( req , res ) => { // TODO: Get a list of messages sent from a specific number const sentMessages = []; // TODO: Gather only the body of those messages for sending to the client const compliments = []; res . json ( compliments ); }); app . post ( \"/api/compliments\" , async ( req , res ) => { const to = req . body . to ; const from = process . env . TWILIO_PHONE_NUMBER ; const body = ` ${ req . body . sender } says: ${ req . body . receiver } is ${ req . body . compliment } . See more compliments at ${ req . headers . referer } ` ; // TODO: Send a message res . json ({ success : false }); }); app . listen ( port , () => console . log ( `Prototype is listening on port ${ port } !` ));","title":"JavaScript Single Page Application"},{"location":"c-algorithms-problems/","text":"Algorithm Problems Plurality Problem Now let's take our new knowledge of algorithms and create a program that runs a plurality election that will yield the following output: $ ./plurality Alice Bob Charlie Number of voters: 4 Vote: Alice Vote: Bob Vote: Charlie Vote: Alice Alice Background Elections come in all shapes and sizes. In the UK, the Prime Minister is officially appointed by the monarch, who generally chooses the leader of the political party that wins the most seats in the House of Commons. The United States uses a multi-step Electoral College process where citizens vote on how each state should allocate Electors who then elect the President. Perhaps the simplest way to hold an election, though, is via a method commonly known as the \u201cplurality vote\u201d (also known as \u201cfirst-past-the-post\u201d or \u201cwinner take all\u201d). In the plurality vote, every voter gets to vote for one candidate. At the end of the election, whichever candidate has the greatest number of votes is declared the winner of the election. Getting Started We are going to take the following code and complete the vote and print_winner functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } // Update vote totals given a new vote bool vote ( string name ) { // TODO return false ; } // Print the winner (or winners) of the election void print_winner ( void ) { // TODO return ; } We can make up the following code for the vote and print_winner functions that solves the problem: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } int get_index ( string name ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( name , candidates [ i ]. name ) == 0 ) return i ; } return -1 ; } // Update vote totals given a new vote bool vote ( string name ) { int candidate_index = get_index ( name ); // gets the index for name user inputs if ( candidate_index != -1 ) { candidates [ candidate_index ]. votes ++ ; // increments vote count for each candidate return true ; } return false ; } int get_max ( void ) { int max_votes = candidates [ 0 ]. votes ; for ( int i = 1 ; i < candidate_count ; i ++ ) if ( candidates [ i ]. votes > max_votes ) max_votes = candidates [ i ]. votes ; return max_votes ; } // Print the winner (or winners) of the election void print_winner ( void ) { int max_votes = get_max (); // see who has the most voites for ( int i = 0 ; i < candidate_count ; i ++ ) // prints name of candidate with most votes { if ( candidates [ i ]. votes == max_votes ) printf ( \"%s \\n \" , candidates [ i ]. name ); } } Runoff Now let's take the previous problem and make it a little more intricate. You already know about plurality elections, which follow a very simple algorithm for determining the winner of an election: every voter gets one vote, and the candidate with the most votes wins. But the plurality vote does have some disadvantages. What happens, for instance, in an election with three candidates, and the ballots below are cast? Ballot Ballot Ballot Ballot Ballot Alice Alice Bob Bob Charlie A plurality vote would here declare a tie between Alice and Bob, since each has two votes. But is that the right outcome? There\u2019s another kind of voting system known as a ranked-choice voting system. In a ranked-choice system, voters can vote for more than one candidate. Instead of just voting for their top choice, they can rank the candidates in order of preference. The resulting ballots might therefore look like the below. Ballot Ballot Ballot Ballot Ballot 1.Alice 1.Alice 1.Bob 1.Bob 1.Charlie 2.Bob 2.Charlie 2.Alice 2.Alice 2.Alice 3.Charlie 3.Bob 3.Charlie 3.Charlie 3.Bob Here, each voter, in addition to specifying their first preference candidate, has also indicated their second and third choices. And now, what was previously a tied election could now have a winner. The race was originally tied between Alice and Bob, so Charlie was out of the running. But the voter who chose Charlie preferred Alice over Bob, so Alice could here be declared the winner. One such ranked choice voting system is the instant runoff system. In an instant runoff election, voters can rank as many candidates as they wish. If any candidate has a majority (more than 50%) of the first preference votes, that candidate is declared the winner of the election. Let's look at the following code and see how we can implement this type of voting system. We will need to fill in the correct code for the following functions: vote , tabulate , print_winner , find_min , is_tie , and eliminate . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 #include <cs50.h> #include <stdio.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; int candidate_count ; // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO return ; } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO return 0 ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO return false ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO return ; } Let's take a look at the vote , tabulate , print_winner , find_min , is_tie , and eliminate functions to see what exactly we need to do. vote The function takes arguments voter , rank , and name . If name is a match for the name of a valid candidate, then you should update the global preferences array to indicate that the voter voter has that candidate as their rank preference (where 0 is the first preference, 1 is the second preference, etc.). If the preference is successfully recorded, the function should return true ; the function should return false otherwise (if, for instance, name is not the name of one of the candidates). You may assume that no two candidates will have the same name. tabulate The function should update the number of votes each candidate has at this stage in the runoff. Recall that at each stage in the runoff, every voter effectively votes for their top-preferred candidate who has not already been eliminated. print_winner If any candidate has more than half of the vote, their name should be printed to stdout and the function should return true . If nobody has won the election yet, the function should return false . find_min The function should return the minimum vote total for any candidate who is still in the election. is_tie The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should return true if every candidate remaining in the election has the same number of votes, and should return false otherwise. eliminate The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should eliminate the candidate (or candidates) who have min number of votes. Your program should behave per the example below: ./runoff Alice Bob Charlie Number of voters: 5 Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Charlie Rank 2: Alice Rank 3: Bob Alice The correct code looks as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 #include <cs50.h> #include <stdio.h> #include <string.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; // global variable int candidate_count ; // global variable // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( candidates [ i ]. name , name ) == 0 ) { preferences [ voter ][ rank ] = i ; return true ; } } return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO for ( int i = 0 ; i < voter_count ; i ++ ) { for ( int j = 0 ; j < candidate_count ; j ++ ) // j is rank { int candidate_index = preferences [ i ][ j ]; if ( ! candidates [ candidate_index ]. eliminated ) { candidates [ candidate_index ]. votes ++ ; // update vote count if candidate has not been eliminated break ; } } } } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( candidates [ i ]. votes > ( voter_count / 2 )) // checks to see if one candidate has over half the votes { printf ( \"%s \\n \" , candidates [ i ]. name ); return true ; } } return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO int min = 0 ; // start from zero bool find_first = false ; for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) // see if candidate has been eliminated { if ( ! find_first ) { min = candidates [ i ]. votes ; find_first = true ; } else if ( candidates [ i ]. votes < min ) { min = candidates [ i ]. votes ; } } } return min ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) if ( candidates [ i ]. votes != min ) return false ; } return true ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { if ( candidates [ i ]. votes == min ) candidates [ i ]. eliminated = true ; } } }","title":"Algorithm Problems"},{"location":"c-algorithms-problems/#algorithm-problems","text":"","title":"Algorithm Problems"},{"location":"c-algorithms-problems/#plurality-problem","text":"Now let's take our new knowledge of algorithms and create a program that runs a plurality election that will yield the following output: $ ./plurality Alice Bob Charlie Number of voters: 4 Vote: Alice Vote: Bob Vote: Charlie Vote: Alice Alice Background Elections come in all shapes and sizes. In the UK, the Prime Minister is officially appointed by the monarch, who generally chooses the leader of the political party that wins the most seats in the House of Commons. The United States uses a multi-step Electoral College process where citizens vote on how each state should allocate Electors who then elect the President. Perhaps the simplest way to hold an election, though, is via a method commonly known as the \u201cplurality vote\u201d (also known as \u201cfirst-past-the-post\u201d or \u201cwinner take all\u201d). In the plurality vote, every voter gets to vote for one candidate. At the end of the election, whichever candidate has the greatest number of votes is declared the winner of the election. Getting Started We are going to take the following code and complete the vote and print_winner functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } // Update vote totals given a new vote bool vote ( string name ) { // TODO return false ; } // Print the winner (or winners) of the election void print_winner ( void ) { // TODO return ; } We can make up the following code for the vote and print_winner functions that solves the problem: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include <cs50.h> #include <stdio.h> #include <string.h> // Max number of candidates #define MAX 9 // Candidates have name and vote count typedef struct { string name ; int votes ; } candidate ; // Array of candidates candidate candidates [ MAX ]; // Number of candidates int candidate_count ; // Function prototypes bool vote ( string name ); void print_winner ( void ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: plurality [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; } int voter_count = get_int ( \"Number of voters: \" ); // Loop over all voters for ( int i = 0 ; i < voter_count ; i ++ ) { string name = get_string ( \"Vote: \" ); // Check for invalid vote if ( ! vote ( name )) { printf ( \"Invalid vote. \\n \" ); } } // Display winner of election print_winner (); } int get_index ( string name ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( name , candidates [ i ]. name ) == 0 ) return i ; } return -1 ; } // Update vote totals given a new vote bool vote ( string name ) { int candidate_index = get_index ( name ); // gets the index for name user inputs if ( candidate_index != -1 ) { candidates [ candidate_index ]. votes ++ ; // increments vote count for each candidate return true ; } return false ; } int get_max ( void ) { int max_votes = candidates [ 0 ]. votes ; for ( int i = 1 ; i < candidate_count ; i ++ ) if ( candidates [ i ]. votes > max_votes ) max_votes = candidates [ i ]. votes ; return max_votes ; } // Print the winner (or winners) of the election void print_winner ( void ) { int max_votes = get_max (); // see who has the most voites for ( int i = 0 ; i < candidate_count ; i ++ ) // prints name of candidate with most votes { if ( candidates [ i ]. votes == max_votes ) printf ( \"%s \\n \" , candidates [ i ]. name ); } }","title":"Plurality Problem"},{"location":"c-algorithms-problems/#runoff","text":"Now let's take the previous problem and make it a little more intricate. You already know about plurality elections, which follow a very simple algorithm for determining the winner of an election: every voter gets one vote, and the candidate with the most votes wins. But the plurality vote does have some disadvantages. What happens, for instance, in an election with three candidates, and the ballots below are cast? Ballot Ballot Ballot Ballot Ballot Alice Alice Bob Bob Charlie A plurality vote would here declare a tie between Alice and Bob, since each has two votes. But is that the right outcome? There\u2019s another kind of voting system known as a ranked-choice voting system. In a ranked-choice system, voters can vote for more than one candidate. Instead of just voting for their top choice, they can rank the candidates in order of preference. The resulting ballots might therefore look like the below. Ballot Ballot Ballot Ballot Ballot 1.Alice 1.Alice 1.Bob 1.Bob 1.Charlie 2.Bob 2.Charlie 2.Alice 2.Alice 2.Alice 3.Charlie 3.Bob 3.Charlie 3.Charlie 3.Bob Here, each voter, in addition to specifying their first preference candidate, has also indicated their second and third choices. And now, what was previously a tied election could now have a winner. The race was originally tied between Alice and Bob, so Charlie was out of the running. But the voter who chose Charlie preferred Alice over Bob, so Alice could here be declared the winner. One such ranked choice voting system is the instant runoff system. In an instant runoff election, voters can rank as many candidates as they wish. If any candidate has a majority (more than 50%) of the first preference votes, that candidate is declared the winner of the election. Let's look at the following code and see how we can implement this type of voting system. We will need to fill in the correct code for the following functions: vote , tabulate , print_winner , find_min , is_tie , and eliminate . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 #include <cs50.h> #include <stdio.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; int candidate_count ; // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO return ; } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO return 0 ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO return false ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO return ; } Let's take a look at the vote , tabulate , print_winner , find_min , is_tie , and eliminate functions to see what exactly we need to do. vote The function takes arguments voter , rank , and name . If name is a match for the name of a valid candidate, then you should update the global preferences array to indicate that the voter voter has that candidate as their rank preference (where 0 is the first preference, 1 is the second preference, etc.). If the preference is successfully recorded, the function should return true ; the function should return false otherwise (if, for instance, name is not the name of one of the candidates). You may assume that no two candidates will have the same name. tabulate The function should update the number of votes each candidate has at this stage in the runoff. Recall that at each stage in the runoff, every voter effectively votes for their top-preferred candidate who has not already been eliminated. print_winner If any candidate has more than half of the vote, their name should be printed to stdout and the function should return true . If nobody has won the election yet, the function should return false . find_min The function should return the minimum vote total for any candidate who is still in the election. is_tie The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should return true if every candidate remaining in the election has the same number of votes, and should return false otherwise. eliminate The function takes an argument min , which will be the minimum number of votes that anyone in the election currently has. The function should eliminate the candidate (or candidates) who have min number of votes. Your program should behave per the example below: ./runoff Alice Bob Charlie Number of voters: 5 Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Alice Rank 2: Charlie Rank 3: Bob Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Bob Rank 2: Charlie Rank 3: Alice Rank 1: Charlie Rank 2: Alice Rank 3: Bob Alice The correct code looks as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 #include <cs50.h> #include <stdio.h> #include <string.h> // Max voters and candidates #define MAX_VOTERS 100 #define MAX_CANDIDATES 9 // preferences[i][j] is jth preference for voter i int preferences [ MAX_VOTERS ][ MAX_CANDIDATES ]; // Candidates have name, vote count, eliminated status typedef struct { string name ; int votes ; bool eliminated ; } candidate ; // Array of candidates candidate candidates [ MAX_CANDIDATES ]; // Numbers of voters and candidates int voter_count ; // global variable int candidate_count ; // global variable // Function prototypes bool vote ( int voter , int rank , string name ); void tabulate ( void ); bool print_winner ( void ); int find_min ( void ); bool is_tie ( int min ); void eliminate ( int min ); int main ( int argc , string argv []) { // Check for invalid usage if ( argc < 2 ) { printf ( \"Usage: runoff [candidate ...] \\n \" ); return 1 ; } // Populate array of candidates candidate_count = argc - 1 ; if ( candidate_count > MAX_CANDIDATES ) { printf ( \"Maximum number of candidates is %i \\n \" , MAX_CANDIDATES ); return 2 ; } for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. name = argv [ i + 1 ]; candidates [ i ]. votes = 0 ; candidates [ i ]. eliminated = false ; } voter_count = get_int ( \"Number of voters: \" ); if ( voter_count > MAX_VOTERS ) { printf ( \"Maximum number of voters is %i \\n \" , MAX_VOTERS ); return 3 ; } // Keep querying for votes for ( int i = 0 ; i < voter_count ; i ++ ) { // Query for each rank for ( int j = 0 ; j < candidate_count ; j ++ ) { string name = get_string ( \"Rank %i: \" , j + 1 ); // Record vote, unless it's invalid if ( ! vote ( i , j , name )) { printf ( \"Invalid vote. \\n \" ); return 4 ; } } printf ( \" \\n \" ); } // Keep holding runoffs until winner exists while ( true ) { // Calculate votes given remaining candidates tabulate (); // Check if election has been won bool won = print_winner (); if ( won ) { break ; } // Eliminate last-place candidates int min = find_min (); bool tie = is_tie ( min ); // If tie, everyone wins if ( tie ) { for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { printf ( \"%s \\n \" , candidates [ i ]. name ); } } break ; } // Eliminate anyone with minimum number of votes eliminate ( min ); // Reset vote counts back to zero for ( int i = 0 ; i < candidate_count ; i ++ ) { candidates [ i ]. votes = 0 ; } } return 0 ; } // Record preference if vote is valid bool vote ( int voter , int rank , string name ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( strcmp ( candidates [ i ]. name , name ) == 0 ) { preferences [ voter ][ rank ] = i ; return true ; } } return false ; } // Tabulate votes for non-eliminated candidates void tabulate ( void ) { // TODO for ( int i = 0 ; i < voter_count ; i ++ ) { for ( int j = 0 ; j < candidate_count ; j ++ ) // j is rank { int candidate_index = preferences [ i ][ j ]; if ( ! candidates [ candidate_index ]. eliminated ) { candidates [ candidate_index ]. votes ++ ; // update vote count if candidate has not been eliminated break ; } } } } // Print the winner of the election, if there is one bool print_winner ( void ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( candidates [ i ]. votes > ( voter_count / 2 )) // checks to see if one candidate has over half the votes { printf ( \"%s \\n \" , candidates [ i ]. name ); return true ; } } return false ; } // Return the minimum number of votes any remaining candidate has int find_min ( void ) { // TODO int min = 0 ; // start from zero bool find_first = false ; for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) // see if candidate has been eliminated { if ( ! find_first ) { min = candidates [ i ]. votes ; find_first = true ; } else if ( candidates [ i ]. votes < min ) { min = candidates [ i ]. votes ; } } } return min ; } // Return true if the election is tied between all candidates, false otherwise bool is_tie ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) if ( candidates [ i ]. votes != min ) return false ; } return true ; } // Eliminate the candidate (or candidiates) in last place void eliminate ( int min ) { // TODO for ( int i = 0 ; i < candidate_count ; i ++ ) { if ( ! candidates [ i ]. eliminated ) { if ( candidates [ i ]. votes == min ) candidates [ i ]. eliminated = true ; } } }","title":"Runoff"},{"location":"c-algorithms/","text":"Algorithms An algorithm is step-by-step set of instructions for completing a task. Searching In computer science, a search algorithm is any algorithm which solves the search problem, namely, to retrieve information stored within some data structure, or calculates in the search space of a problem domain, either with discrete or continuous values. For now, we are going to go over two different types of searches: Linear Search Binary Search For the following examples, we are going to be using a row of lockers with numbers inside (an array) and we will look through them to find something, while returning a boolean ( true or false ) as a result. A linear search is where we move in a line (usually start to end or end to start). The idea of the algorithm is to iterate across the array from left to right, searching for a specified element. Worst-case scenario : We have to look through the entire array of n elements, either because the target element is the last element of the array or doesn't exist in the array at all. Best-case scenario : The target element is the first element of the array, and so we can stop looking immediately after we start. Now lets look through the lockers to find one with the number 50 inside. Some pseudocode for linear search could be written as: For i from 0 to n\u20131 // from start (0) to end (n-1) If i'th element is 50 Return true // if the i'th element is 50 - return true Return false // if not 50, return false A binary search is where we start in the middle and move left or right, depending on what we're looking for. \"Divide & Conquer\". In order to leverage the power of binary search, our array must be sorted , else we cannot make assumptions about the array's content. Worst-case scenario : We have to divide a list of n elements in half repeatedly to find the target element, either because the target element will be found at the end of the last division or doesn't exist in the array at all. Best-case scenario : The target element is at the midpoint of the full array, and so we can stop looking immediately after we start. Some pseudocode for binary search could be written as: If no items Return false If middle item is 50 Return true Else if 50 < middle item Search left half Else if 50 > middle item Search right half Big O Computer scientists have created a way to describe algorithms (how well it is designed), and it's generally called big O . The more formal way to describe this is with big O notation, which we can think of as \u201con the order of\u201d. For example, if our algorithm is linear search, it will take approximately O( n ) steps, \u201con the order of n \u201d. In fact, even an algorithm that looks at two items at a time and takes n /2 steps has O( n ). This is because, as n gets bigger and bigger, only the largest term, n , matters. There are some common running times (how many seconds does it take, how many steps does it take, etc.): (lower is better) O( n 2 ) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) Computer scientists might also use big \u03a9, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big O is the upper bound of number of steps, or the worst case, and typically what we care about more.) With linear search, for example, the worst case is n steps, but the best case is 1 step since our item might happen to be the first item we check. The best case for binary search, too, is 1 since our item might be in the middle of the array. And we have a similar set of the most common big \u03a9 running times: (lower is better) \u03a9(n2) \u03a9(n log n) \u03a9(n) (counting the number of items) \u03a9(log n) \u03a9(1) (linear search, binary search) Linear Search Now let's create a program to better visualize a lienar search: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cs50.h> #include <stdio.h> int main ( void ) { int numbers [ 6 ] = { 4 , 8 , 15 , 16 , 23 , 42 }; for ( int i = 0 ; i < 6 ; i ++ ) { if ( numbers [ i ] == 50 ) { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Here we initialize an array with some values, and we check the items in the array one at a time, in order. And in each case, depending on whether the value was found or not, we can return an exit code of either 0 (for success) or 1 (for failure). We can do the same for names: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma is the name we're looking for. note the use of strcmp { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can\u2019t compare strings directly, since they\u2019re not a simple data type but rather an array of many characters, and we need to compare them differently. Luckily, the string library has a strcmp function which compares strings for us and returns 0 if they\u2019re the same, so we can use that. Now lets implement a phone book with the same ideas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; string numbers [ 4 ] = { \"617\u2013555\u20130100\" , \"617\u2013555\u20130101\" , \"617\u2013555\u20130102\" , \"617\u2013555\u20130103\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma's phone number is what we're looking for { printf ( \"Found %s \\n \" , numbers [ i ]); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Now, if the name at a certain index in the names array matches who we\u2019re looking for, we\u2019ll return the phone number in the numbers array, at the same index. But that means we need to particularly careful to make sure that each number corresponds to the name at each index, especially if we add or remove names and numbers. Let's improve the above code using our own custom data type! Structs We can make our own custom data types called structs : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include <cs50.h> #include <stdio.h> #include <string.h> typedef struct { string name ; string number ; } person ; // we are encapsulating both the strings name and number inside our struct \"person\" int main ( void ) { person people [ 4 ]; people [ 0 ]. name = \"EMMA\" ; people [ 0 ]. number = \"617\u2013555\u20130100\" ; people [ 1 ]. name = \"RODRIGO\" ; people [ 1 ]. number = \"617\u2013555\u20130101\" ; people [ 2 ]. name = \"BRIAN\" ; people [ 2 ]. number = \"617\u2013555\u20130102\" ; people [ 3 ]. name = \"DAVID\" ; people [ 3 ]. number = \"617\u2013555\u20130103\" ; // Search for EMMA for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( people [ i ]. name , \"EMMA\" ) == 0 ) { printf ( \"Found %s \\n \" , people [ i ]. number ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can think of structs as containers, inside of which are multiple other data types. Here, we create our own type with a struct called person , which will have a string called name and a string called number . Then, we can create an array of these struct types and initialize the values inside each of them, using a new syntax, . , to access the properties of each person . In our loop, we can now be more certain that the number corresponds to the name since they are from the same person element. Sorting The process of Sorting can be explained as a technique of rearranging the elements in any particular order, which can be set ready for further processing by the program logic. In C, there are multiple sorting algorithms available, which can be incorporated inside the code. Bubble Sort In bubble stort, the idea of the algorithm is to move higher valued elements generally towards the right and lower value elements generally towards the left. Let's take 8 random numbers ( 6 , 3 , 8 , 5 , 2 , 7 , 4 , 1 ) and try to sort them in C. First, we can look at the first two numbers and swap them so they are in order: 6 3 8 5 2 7 4 1 3 6 8 5 2 7 4 1 The next pair, 6 and 8 , are in order, so we don\u2019t need to swap them. The next pair, 8 and 5 , need to be swapped: 3 6 8 5 2 7 4 1 3 6 5 8 2 7 4 1 We continue until we reach the end of the list: 3 6 5 8 2 7 4 1 3 6 5 2 8 7 4 1 3 6 5 2 7 8 4 1 3 6 5 2 7 4 8 1 3 6 5 2 7 4 1 8 Our list isn\u2019t sorted yet, but we\u2019re slightly closer to the solution because the biggest value, 8 , has been shifted all the way to the right. We repeat this with another pass through the list, over and over, until it is sorted correctly. The pseudocode for this might look like: Repeat n\u20131 times For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Since we are comparing the i'th and i+1'th element, we only need to go up to n \u2013 2 for i . Then, we swap the two elements if they\u2019re out of order. And we can stop after we\u2019ve made n \u2013 1 passes, since we know the largest n \u20131 elements will have bubbled to the right. We have n \u2013 2 steps for the inner loop, and n \u2013 1 loops, so we get n 2 \u2013 3 n + 2 steps total. But the largest factor, or dominant term, is n 2 , as n gets larger and larger, so we can say that bubble sort is O ( n 2 ). Worst-case scenario : The array is in rever order; we have to \"bubble\" each of the n elements all the way across the array, and since we can only fully bubble one element into position per pass, we must do this n times. Best-case scenario : The array is already perfectly sorted, and we make no swaps on the first pass. We\u2019ve seen running times like the following, and so even though binary search is much faster than linear search, it might not be worth the one\u2013time cost of sorting the list first, unless we do lots of searches over time: O( n 2 ) (bubble sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) And \u03a9 for bubble sort is still n 2 , since we still check each pair of elements for n \u2013 1 passes. Selection Sort In selection sort, the idea of the algorithm is to find the smallest unsorted element and add it to the end of the sorted list. This basically builds a sorted list, one element at a time. We can take another approach with the same set of numbers: 6 3 8 5 2 7 4 1 First, we\u2019ll look at each number, and remember the smallest one we\u2019ve seen. Then, we can swap it with the first number in our list, since we know it\u2019s the smallest: 6 3 8 5 2 7 4 1 1 3 8 5 2 7 4 6 Now we know at least the first element of our list is in the right place, so we can look for the smallest element among the rest, and swap it with the next unsorted element (now the second element): 1 3 8 5 2 7 4 6 1 2 8 5 3 7 4 6 We can repeat this over and over, until we have a sorted list. The pseudocode for this might look like: For i from 0 to n\u20131 Find smallest item between i'th item and last item Swap smallest item with i'th item With big O notation, we still have running time of O ( n 2 ), since we were looking at roughly all n elements to find the smallest, and making n passes to sort all the elements. Worst-case scenario : We have to iterate over each of the n elements of the array (to find the smallest unsorted element) and we must repeat this process n times, since only one element gets sorted on each pass. Best-case scenario : Exactly the same! There's no way to gurantee this array is sorted until we go through this process for all the elements. So it turns out that selection sort is fundamentally about the same as bubble sort in running time: O( n 2 ) (bubble sort, selection sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) The best case, \u03a9, is also n 2 . We can go back to bubble sort and change its algorithm to be something like this, which will allow us to stop early if all the elements are sorted: Repeat until no swaps For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Now, we only need to look at each element once, so the best case is now \u03a9( n ): \u03a9(n 2 ) (selection sort) \u03a9( n log n ) \u03a9( n ) (bubble sort) \u03a9(log n ) \u03a9(1) (linear search, binary search) Insertion Sort In insertion sort, the idea of the algorithm is to build your sorted array in place, shifting elements out of the way if necessary to make room as you go. This is different to bubble sort and selection sort, where we slide actually slide elements out of the way while sorting. In pseudo code: Call the first element of the array \"sorted\". Repeat until all elements are sorted: Look at the next unsorted element. Insert into the \"sorted\" portion by shifting the requisite number of elements. Worst-case scenario : The array is in reverse order; we have to shift each of the n elements n positions each time we make an insertion. Best-case scenario : The array is already perfectly sorted, and we simply keep moving the line between \"unsorted\" and \"sorted\" as we examine each element. Insertion sort can be seen as: O( n 2 ) and \u03a9( n ). We can use a visualization tool, found here , with animations for how the elements move within arrays for both bubble sort and insertion sort. Recursion Recall that in week 0, we had pseudocode for finding a name in a phone book, where we had lines telling us to \u201cgo back\u201d and repeat some steps: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 Open to middle of left half of book 8 **Go back to line 3** 9 Else if Smith is later in book 10 Open to middle of right half of book 11 **Go back to line 3** 12 Else 13 Quit We could instead just repeat our entire algorithm on the half of the book we have left: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 **Search left half of book** 8 Else if Smith is later in book 9 **Search right half of book** 10 Else 11 Quit This seems like a cyclical process that will never end, but we\u2019re actually dividing the problem in half each time, and stopping once there\u2019s no more book left. Recursion occurs when a function or algorithm refers to itself (references its own name in the code), as in the new pseudocode above. Let's try to visualize this with simple code. The factorial function ( n !) is defined over all positive integers. n ! equals all of the positive integers less than or equal to n , multiplied together. Thinking in terms programming, we'll define the mathematical function n ! as fact(n) . fact(1) = 1 fact(2) = 2 * 1 fact(3) = 3 * 2 * 1 fact(4) = 4 * 3 * 2 * 1 ... This can also be seen as: fact(1) = 1 fact(2) = 2 * fact(1) fact(3) = 3 * fact(2) fact(4) = 4 * fact(3) ... This can be seen as fact(n) = n * fact(n-1) . This forms the basis for a recusive definition of the factorial function. Every recursive function has two cases that could apply, given any input: The base case , which when triggered will terminate the recursive process. The recursive case , which is where the recursion will actually occur. We can see this in the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 //recursive version int fact ( int n ) { if ( n == 1 ) // base case { return 1 ; } else // recursive case { return n * fact ( n - 1 ); } } In general, but not always, recursive functions replace loops in non-recursive functions: Below is the iterative version of the same code above (notice how much simpler the recursive version is). 1 2 3 4 5 6 7 8 9 10 11 //iterative version int fact2 ( int n ) { int product = 1 ; while w ( n > 0 ) { product *= n ; n -- ; } return product ; } In week 1, we implemented a \u201cpyramid\u201d of blocks in the following shape : # ## ### #### This was the code we created for that problem set: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // Draw pyramid of height h for ( int i = 1 ; i <= h ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } } Here, we use for loops to print each block in each row. But notice that a pyramid of height 4 is actually a pyramid of height 3, with an extra row of 4 blocks added on. And a pyramid of height 3 is a pyramid of height 2, with an extra row of 3 blocks. A pyramid of height 2 is a pyramid of height 1, with an extra row of 2 blocks. And finally, a pyramid of height 1 is just a pyramid of height 0, or nothing, with another row of a single block added on. With this idea in mind, we can write: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // If nothing to draw if ( h == 0 ) { return ; } // Draw pyramid of height h - 1 draw ( h - 1 ); // Notice how we are referring to itself (draw) within the code // Draw one more row of width h for ( int i = 0 ; i < h ; i ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } Now, our draw function first calls itself recursively , drawing a pyramid of height h - 1 . But even before that, we need to stop if h is 0, since there won\u2019t be anything left to drawn. After, we draw the next row, or a row of width h . Merge Sort In merge sort, the idea of the algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order. We can take the idea of recusion to sorting, with another algorithm called merge sort. The pseudocode might look like: If only one item Return Else Sort left half of items (assuming n > 1) Sort right half of items (assuming n > 1) Merge sorted halves We will use an unsorted list to demonstrate merge sorting: 7 4 5 2 6 3 8 1 First, we'll sort the left half (the first four elements): 7 4 5 2 | 6 3 8 1 - - - - Well, to sort that, we need to sort the left half of the left half first: 7 4 | 5 2 | 6 3 8 1 - - Now, we have just one item, 7 , in the left half, and one item, 4 , in the right half. So we\u2019ll merge that together, by taking the smallest item from each list first: - - | 5 2 | 6 3 8 1 4 7 And now we go back to the right half of the left half, and sort it: - - | - - | 6 3 8 1 4 7 2 5 Now, both halves of the left half are sorted, so we can merge the two of them together. We look at the start of each list, and take 2 since it\u2019s smaller than 4 . Then, we take 4 , since it\u2019s now the smallest item at the front of both lists. Then, we take 5 , and finally, 7 , to get: - - - - | 6 3 8 1 - - - - 2 4 5 7 Next, we do the same thing for the right half of numbers and end up with: - - - - | - - - - - - - - - - - - 2 4 5 7 1 3 6 8 And finally, we can merge both halves of the whole list, following the same steps as before. Notice that we don\u2019t need to check all the elements of each half to find the smallest, since we know that each half is already sorted. Instead, we just take the smallest element of the two at the start of each half. It took a lot of steps, but it actually took fewer steps than the other algorithms we\u2019ve seen so far. We broke our list in half each time, until we were \u201csorting\u201d eight lists with one element each. Since our algorithm divided the problem in half each time, its running time is logarithmic with O(log n). And after we sorted each half (or half of a half), we needed to merge together all the elements, with n steps since we had to look at each element once. Worst-case scenario : We have to split n elements up and then recombine them, effectively doubling the sorted subarrays as we build them. (Combining sorted 1-element arrays into 2-element arrays, combining soorted 2-element arrays into 4-element arrays...) - O ( n log n ). Best-case scenario : The array is already perfectly sorted. But we still have to split and recombine it back together with this algorithm. - \u03a9( n log n ). So our total running time is O ( n log n ): O( n 2 ) (bubble sort, selection sort) O( n log n ) (merge search) O( n ) (linear search) O(log n ) (binary search) O(1) To see this in real time, watch this video to see multiple sorting algorithms running at the same time. Algorithms Summary Algorithm Name Basic Concept O \u03a9 Selection Sort Find the smallest unsorted element in an array and swap it with the first unsorted element of that array. n 2 n 2 Bubble Sort Swap adjacent pairs of elements if they are out of order, effectively \"bubbling\" larger elements to the right and smaller ones to the left. n 2 n Insertion Sort Proceed through the array from left-to-right, shifting elements as necessary to insert each element into its correct place. n 2 n Merge Sort Split the full array into subarrays, then merge those subarrays back together in the correct order. n log n n log n Linear Search Iterate across the array from left-to-right, trying to find the target element. n 1 Binary Search Given a sorted array, divide and conquer by systematically eliminating half of the remaining elements in the search for the target element. log n 1 Algorithm Problems To see the problem sets for the covered algorithms, please click here .","title":"Algorithm Overview"},{"location":"c-algorithms/#algorithms","text":"An algorithm is step-by-step set of instructions for completing a task.","title":"Algorithms"},{"location":"c-algorithms/#searching","text":"In computer science, a search algorithm is any algorithm which solves the search problem, namely, to retrieve information stored within some data structure, or calculates in the search space of a problem domain, either with discrete or continuous values. For now, we are going to go over two different types of searches: Linear Search Binary Search For the following examples, we are going to be using a row of lockers with numbers inside (an array) and we will look through them to find something, while returning a boolean ( true or false ) as a result. A linear search is where we move in a line (usually start to end or end to start). The idea of the algorithm is to iterate across the array from left to right, searching for a specified element. Worst-case scenario : We have to look through the entire array of n elements, either because the target element is the last element of the array or doesn't exist in the array at all. Best-case scenario : The target element is the first element of the array, and so we can stop looking immediately after we start. Now lets look through the lockers to find one with the number 50 inside. Some pseudocode for linear search could be written as: For i from 0 to n\u20131 // from start (0) to end (n-1) If i'th element is 50 Return true // if the i'th element is 50 - return true Return false // if not 50, return false A binary search is where we start in the middle and move left or right, depending on what we're looking for. \"Divide & Conquer\". In order to leverage the power of binary search, our array must be sorted , else we cannot make assumptions about the array's content. Worst-case scenario : We have to divide a list of n elements in half repeatedly to find the target element, either because the target element will be found at the end of the last division or doesn't exist in the array at all. Best-case scenario : The target element is at the midpoint of the full array, and so we can stop looking immediately after we start. Some pseudocode for binary search could be written as: If no items Return false If middle item is 50 Return true Else if 50 < middle item Search left half Else if 50 > middle item Search right half","title":"Searching"},{"location":"c-algorithms/#big-o","text":"Computer scientists have created a way to describe algorithms (how well it is designed), and it's generally called big O . The more formal way to describe this is with big O notation, which we can think of as \u201con the order of\u201d. For example, if our algorithm is linear search, it will take approximately O( n ) steps, \u201con the order of n \u201d. In fact, even an algorithm that looks at two items at a time and takes n /2 steps has O( n ). This is because, as n gets bigger and bigger, only the largest term, n , matters. There are some common running times (how many seconds does it take, how many steps does it take, etc.): (lower is better) O( n 2 ) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) Computer scientists might also use big \u03a9, big Omega notation, which is the lower bound of number of steps for our algorithm. (Big O is the upper bound of number of steps, or the worst case, and typically what we care about more.) With linear search, for example, the worst case is n steps, but the best case is 1 step since our item might happen to be the first item we check. The best case for binary search, too, is 1 since our item might be in the middle of the array. And we have a similar set of the most common big \u03a9 running times: (lower is better) \u03a9(n2) \u03a9(n log n) \u03a9(n) (counting the number of items) \u03a9(log n) \u03a9(1) (linear search, binary search)","title":"Big O"},{"location":"c-algorithms/#linear-search","text":"Now let's create a program to better visualize a lienar search: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cs50.h> #include <stdio.h> int main ( void ) { int numbers [ 6 ] = { 4 , 8 , 15 , 16 , 23 , 42 }; for ( int i = 0 ; i < 6 ; i ++ ) { if ( numbers [ i ] == 50 ) { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Here we initialize an array with some values, and we check the items in the array one at a time, in order. And in each case, depending on whether the value was found or not, we can return an exit code of either 0 (for success) or 1 (for failure). We can do the same for names: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma is the name we're looking for. note the use of strcmp { printf ( \"Found \\n \" ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can\u2019t compare strings directly, since they\u2019re not a simple data type but rather an array of many characters, and we need to compare them differently. Luckily, the string library has a strcmp function which compares strings for us and returns 0 if they\u2019re the same, so we can use that. Now lets implement a phone book with the same ideas: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <stdio.h> #include <string.h> int main ( void ) { string names [ 4 ] = { \"EMMA\" , \"RODRIGO\" , \"BRIAN\" , \"DAVID\" }; string numbers [ 4 ] = { \"617\u2013555\u20130100\" , \"617\u2013555\u20130101\" , \"617\u2013555\u20130102\" , \"617\u2013555\u20130103\" }; for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( names [ i ], \"EMMA\" ) == 0 ) // emma's phone number is what we're looking for { printf ( \"Found %s \\n \" , numbers [ i ]); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } Now, if the name at a certain index in the names array matches who we\u2019re looking for, we\u2019ll return the phone number in the numbers array, at the same index. But that means we need to particularly careful to make sure that each number corresponds to the name at each index, especially if we add or remove names and numbers. Let's improve the above code using our own custom data type!","title":"Linear Search"},{"location":"c-algorithms/#structs","text":"We can make our own custom data types called structs : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include <cs50.h> #include <stdio.h> #include <string.h> typedef struct { string name ; string number ; } person ; // we are encapsulating both the strings name and number inside our struct \"person\" int main ( void ) { person people [ 4 ]; people [ 0 ]. name = \"EMMA\" ; people [ 0 ]. number = \"617\u2013555\u20130100\" ; people [ 1 ]. name = \"RODRIGO\" ; people [ 1 ]. number = \"617\u2013555\u20130101\" ; people [ 2 ]. name = \"BRIAN\" ; people [ 2 ]. number = \"617\u2013555\u20130102\" ; people [ 3 ]. name = \"DAVID\" ; people [ 3 ]. number = \"617\u2013555\u20130103\" ; // Search for EMMA for ( int i = 0 ; i < 4 ; i ++ ) { if ( strcmp ( people [ i ]. name , \"EMMA\" ) == 0 ) { printf ( \"Found %s \\n \" , people [ i ]. number ); return 0 ; } } printf ( \"Not found \\n \" ); return 1 ; } We can think of structs as containers, inside of which are multiple other data types. Here, we create our own type with a struct called person , which will have a string called name and a string called number . Then, we can create an array of these struct types and initialize the values inside each of them, using a new syntax, . , to access the properties of each person . In our loop, we can now be more certain that the number corresponds to the name since they are from the same person element.","title":"Structs"},{"location":"c-algorithms/#sorting","text":"The process of Sorting can be explained as a technique of rearranging the elements in any particular order, which can be set ready for further processing by the program logic. In C, there are multiple sorting algorithms available, which can be incorporated inside the code.","title":"Sorting"},{"location":"c-algorithms/#bubble-sort","text":"In bubble stort, the idea of the algorithm is to move higher valued elements generally towards the right and lower value elements generally towards the left. Let's take 8 random numbers ( 6 , 3 , 8 , 5 , 2 , 7 , 4 , 1 ) and try to sort them in C. First, we can look at the first two numbers and swap them so they are in order: 6 3 8 5 2 7 4 1 3 6 8 5 2 7 4 1 The next pair, 6 and 8 , are in order, so we don\u2019t need to swap them. The next pair, 8 and 5 , need to be swapped: 3 6 8 5 2 7 4 1 3 6 5 8 2 7 4 1 We continue until we reach the end of the list: 3 6 5 8 2 7 4 1 3 6 5 2 8 7 4 1 3 6 5 2 7 8 4 1 3 6 5 2 7 4 8 1 3 6 5 2 7 4 1 8 Our list isn\u2019t sorted yet, but we\u2019re slightly closer to the solution because the biggest value, 8 , has been shifted all the way to the right. We repeat this with another pass through the list, over and over, until it is sorted correctly. The pseudocode for this might look like: Repeat n\u20131 times For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Since we are comparing the i'th and i+1'th element, we only need to go up to n \u2013 2 for i . Then, we swap the two elements if they\u2019re out of order. And we can stop after we\u2019ve made n \u2013 1 passes, since we know the largest n \u20131 elements will have bubbled to the right. We have n \u2013 2 steps for the inner loop, and n \u2013 1 loops, so we get n 2 \u2013 3 n + 2 steps total. But the largest factor, or dominant term, is n 2 , as n gets larger and larger, so we can say that bubble sort is O ( n 2 ). Worst-case scenario : The array is in rever order; we have to \"bubble\" each of the n elements all the way across the array, and since we can only fully bubble one element into position per pass, we must do this n times. Best-case scenario : The array is already perfectly sorted, and we make no swaps on the first pass. We\u2019ve seen running times like the following, and so even though binary search is much faster than linear search, it might not be worth the one\u2013time cost of sorting the list first, unless we do lots of searches over time: O( n 2 ) (bubble sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) And \u03a9 for bubble sort is still n 2 , since we still check each pair of elements for n \u2013 1 passes.","title":"Bubble Sort"},{"location":"c-algorithms/#selection-sort","text":"In selection sort, the idea of the algorithm is to find the smallest unsorted element and add it to the end of the sorted list. This basically builds a sorted list, one element at a time. We can take another approach with the same set of numbers: 6 3 8 5 2 7 4 1 First, we\u2019ll look at each number, and remember the smallest one we\u2019ve seen. Then, we can swap it with the first number in our list, since we know it\u2019s the smallest: 6 3 8 5 2 7 4 1 1 3 8 5 2 7 4 6 Now we know at least the first element of our list is in the right place, so we can look for the smallest element among the rest, and swap it with the next unsorted element (now the second element): 1 3 8 5 2 7 4 6 1 2 8 5 3 7 4 6 We can repeat this over and over, until we have a sorted list. The pseudocode for this might look like: For i from 0 to n\u20131 Find smallest item between i'th item and last item Swap smallest item with i'th item With big O notation, we still have running time of O ( n 2 ), since we were looking at roughly all n elements to find the smallest, and making n passes to sort all the elements. Worst-case scenario : We have to iterate over each of the n elements of the array (to find the smallest unsorted element) and we must repeat this process n times, since only one element gets sorted on each pass. Best-case scenario : Exactly the same! There's no way to gurantee this array is sorted until we go through this process for all the elements. So it turns out that selection sort is fundamentally about the same as bubble sort in running time: O( n 2 ) (bubble sort, selection sort) O( n log n ) O( n ) (linear search) O(log n ) (binary search) O(1) The best case, \u03a9, is also n 2 . We can go back to bubble sort and change its algorithm to be something like this, which will allow us to stop early if all the elements are sorted: Repeat until no swaps For i from 0 to n\u20132 If i'th and i+1'th elements out of order Swap them Now, we only need to look at each element once, so the best case is now \u03a9( n ): \u03a9(n 2 ) (selection sort) \u03a9( n log n ) \u03a9( n ) (bubble sort) \u03a9(log n ) \u03a9(1) (linear search, binary search)","title":"Selection Sort"},{"location":"c-algorithms/#insertion-sort","text":"In insertion sort, the idea of the algorithm is to build your sorted array in place, shifting elements out of the way if necessary to make room as you go. This is different to bubble sort and selection sort, where we slide actually slide elements out of the way while sorting. In pseudo code: Call the first element of the array \"sorted\". Repeat until all elements are sorted: Look at the next unsorted element. Insert into the \"sorted\" portion by shifting the requisite number of elements. Worst-case scenario : The array is in reverse order; we have to shift each of the n elements n positions each time we make an insertion. Best-case scenario : The array is already perfectly sorted, and we simply keep moving the line between \"unsorted\" and \"sorted\" as we examine each element. Insertion sort can be seen as: O( n 2 ) and \u03a9( n ). We can use a visualization tool, found here , with animations for how the elements move within arrays for both bubble sort and insertion sort.","title":"Insertion Sort"},{"location":"c-algorithms/#recursion","text":"Recall that in week 0, we had pseudocode for finding a name in a phone book, where we had lines telling us to \u201cgo back\u201d and repeat some steps: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 Open to middle of left half of book 8 **Go back to line 3** 9 Else if Smith is later in book 10 Open to middle of right half of book 11 **Go back to line 3** 12 Else 13 Quit We could instead just repeat our entire algorithm on the half of the book we have left: 1 Pick up phone book 2 Open to middle of phone book 3 Look at page 4 If Smith is on page 5 Call Mike 6 Else if Smith is earlier in book 7 **Search left half of book** 8 Else if Smith is later in book 9 **Search right half of book** 10 Else 11 Quit This seems like a cyclical process that will never end, but we\u2019re actually dividing the problem in half each time, and stopping once there\u2019s no more book left. Recursion occurs when a function or algorithm refers to itself (references its own name in the code), as in the new pseudocode above. Let's try to visualize this with simple code. The factorial function ( n !) is defined over all positive integers. n ! equals all of the positive integers less than or equal to n , multiplied together. Thinking in terms programming, we'll define the mathematical function n ! as fact(n) . fact(1) = 1 fact(2) = 2 * 1 fact(3) = 3 * 2 * 1 fact(4) = 4 * 3 * 2 * 1 ... This can also be seen as: fact(1) = 1 fact(2) = 2 * fact(1) fact(3) = 3 * fact(2) fact(4) = 4 * fact(3) ... This can be seen as fact(n) = n * fact(n-1) . This forms the basis for a recusive definition of the factorial function. Every recursive function has two cases that could apply, given any input: The base case , which when triggered will terminate the recursive process. The recursive case , which is where the recursion will actually occur. We can see this in the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 //recursive version int fact ( int n ) { if ( n == 1 ) // base case { return 1 ; } else // recursive case { return n * fact ( n - 1 ); } } In general, but not always, recursive functions replace loops in non-recursive functions: Below is the iterative version of the same code above (notice how much simpler the recursive version is). 1 2 3 4 5 6 7 8 9 10 11 //iterative version int fact2 ( int n ) { int product = 1 ; while w ( n > 0 ) { product *= n ; n -- ; } return product ; } In week 1, we implemented a \u201cpyramid\u201d of blocks in the following shape : # ## ### #### This was the code we created for that problem set: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // Draw pyramid of height h for ( int i = 1 ; i <= h ; i ++ ) { for ( int j = 1 ; j <= i ; j ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } } Here, we use for loops to print each block in each row. But notice that a pyramid of height 4 is actually a pyramid of height 3, with an extra row of 4 blocks added on. And a pyramid of height 3 is a pyramid of height 2, with an extra row of 3 blocks. A pyramid of height 2 is a pyramid of height 1, with an extra row of 2 blocks. And finally, a pyramid of height 1 is just a pyramid of height 0, or nothing, with another row of a single block added on. With this idea in mind, we can write: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include <cs50.h> #include <stdio.h> void draw ( int h ); int main ( void ) { // Get height of pyramid int height = get_int ( \"Height: \" ); // Draw pyramid draw ( height ); } void draw ( int h ) { // If nothing to draw if ( h == 0 ) { return ; } // Draw pyramid of height h - 1 draw ( h - 1 ); // Notice how we are referring to itself (draw) within the code // Draw one more row of width h for ( int i = 0 ; i < h ; i ++ ) { printf ( \"#\" ); } printf ( \" \\n \" ); } Now, our draw function first calls itself recursively , drawing a pyramid of height h - 1 . But even before that, we need to stop if h is 0, since there won\u2019t be anything left to drawn. After, we draw the next row, or a row of width h .","title":"Recursion"},{"location":"c-algorithms/#merge-sort","text":"In merge sort, the idea of the algorithm is to sort smaller arrays and then combine those arrays together (merge them) in sorted order. We can take the idea of recusion to sorting, with another algorithm called merge sort. The pseudocode might look like: If only one item Return Else Sort left half of items (assuming n > 1) Sort right half of items (assuming n > 1) Merge sorted halves We will use an unsorted list to demonstrate merge sorting: 7 4 5 2 6 3 8 1 First, we'll sort the left half (the first four elements): 7 4 5 2 | 6 3 8 1 - - - - Well, to sort that, we need to sort the left half of the left half first: 7 4 | 5 2 | 6 3 8 1 - - Now, we have just one item, 7 , in the left half, and one item, 4 , in the right half. So we\u2019ll merge that together, by taking the smallest item from each list first: - - | 5 2 | 6 3 8 1 4 7 And now we go back to the right half of the left half, and sort it: - - | - - | 6 3 8 1 4 7 2 5 Now, both halves of the left half are sorted, so we can merge the two of them together. We look at the start of each list, and take 2 since it\u2019s smaller than 4 . Then, we take 4 , since it\u2019s now the smallest item at the front of both lists. Then, we take 5 , and finally, 7 , to get: - - - - | 6 3 8 1 - - - - 2 4 5 7 Next, we do the same thing for the right half of numbers and end up with: - - - - | - - - - - - - - - - - - 2 4 5 7 1 3 6 8 And finally, we can merge both halves of the whole list, following the same steps as before. Notice that we don\u2019t need to check all the elements of each half to find the smallest, since we know that each half is already sorted. Instead, we just take the smallest element of the two at the start of each half. It took a lot of steps, but it actually took fewer steps than the other algorithms we\u2019ve seen so far. We broke our list in half each time, until we were \u201csorting\u201d eight lists with one element each. Since our algorithm divided the problem in half each time, its running time is logarithmic with O(log n). And after we sorted each half (or half of a half), we needed to merge together all the elements, with n steps since we had to look at each element once. Worst-case scenario : We have to split n elements up and then recombine them, effectively doubling the sorted subarrays as we build them. (Combining sorted 1-element arrays into 2-element arrays, combining soorted 2-element arrays into 4-element arrays...) - O ( n log n ). Best-case scenario : The array is already perfectly sorted. But we still have to split and recombine it back together with this algorithm. - \u03a9( n log n ). So our total running time is O ( n log n ): O( n 2 ) (bubble sort, selection sort) O( n log n ) (merge search) O( n ) (linear search) O(log n ) (binary search) O(1) To see this in real time, watch this video to see multiple sorting algorithms running at the same time.","title":"Merge Sort"},{"location":"c-algorithms/#algorithms-summary","text":"Algorithm Name Basic Concept O \u03a9 Selection Sort Find the smallest unsorted element in an array and swap it with the first unsorted element of that array. n 2 n 2 Bubble Sort Swap adjacent pairs of elements if they are out of order, effectively \"bubbling\" larger elements to the right and smaller ones to the left. n 2 n Insertion Sort Proceed through the array from left-to-right, shifting elements as necessary to insert each element into its correct place. n 2 n Merge Sort Split the full array into subarrays, then merge those subarrays back together in the correct order. n log n n log n Linear Search Iterate across the array from left-to-right, trying to find the target element. n 1 Binary Search Given a sorted array, divide and conquer by systematically eliminating half of the remaining elements in the search for the target element. log n 1","title":"Algorithms Summary"},{"location":"c-algorithms/#algorithm-problems","text":"To see the problem sets for the covered algorithms, please click here .","title":"Algorithm Problems"},{"location":"c-arrays/","text":"Arrays What are Arrays? Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you. Array Declarations \u2003\u2003 type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages. Basic Array Program Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average). Other Array Tips Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything. Reading Levels Program According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); } Caesar's Cipher We will now create a program that will take text and run it through Caesar's encryption method. Supposedly, Caesar (yes, that Caesar) used to \u201cencrypt\u201d (i.e., conceal in a reversible way) confidential messages by shifting each letter therein by some number of places. For instance, he might write A as B, B as C, C as D, \u2026, and, wrapping around alphabetically, Z as A. And so, to say HELLO to someone, Caesar might write IFMMP. Upon receiving such messages from Caesar, recipients would have to \u201cdecrypt\u201d them by shifting letters in the opposite direction by the same number of places. The secrecy of this \u201ccryptosystem\u201d relied on only Caesar and the recipients knowing a secret, the number of places by which Caesar had shifted his letters (e.g., 1). Not particularly secure by modern standards, but, hey, if you\u2019re perhaps the first in the world to do it, pretty secure! Note Unencrypted text is generally called plaintext . Encrypted text is generally called ciphertext . And the secret used is called a key . To be clear, then, here\u2019s how encrypting HELLO with a key of 1 yields IFMMP : plaintext H E L L O + key 1 1 1 1 1 = ciphertext I F M M P More formally, Caesar\u2019s algorithm (i.e., cipher) encrypts messages by \u201crotating\u201d each letter by k positions. More formally, if p is some plaintext (i.e., an unencrypted message), p i is the i th character in p , and k is a secret key (i.e., a non-negative integer), then each letter, c i , in the ciphertext, c , is computed as: c i = (p i + k) % 26 wherein % 26 here means \u201cremainder when dividing by 26.\u201d This formula perhaps makes the cipher seem more complicated than it is, but it\u2019s really just a concise way of expressing the algorithm precisely. Indeed, for the sake of discussion, think of A (or a) as 0, B (or b) as 1, \u2026, H (or h) as 7, I (or i) as 8, \u2026, and Z (or z) as 25. Suppose that Caesar just wants to say Hi to someone confidentially using, this time, a key, k , of 3. And so his plaintext, p , is Hi, in which case his plaintext\u2019s first character, p 0 , is H (aka 7), and his plaintext\u2019s second character, p 1 , is i (aka 8). His ciphertext\u2019s first character, c 0 , is thus K, and his ciphertext\u2019s second character, c 1 , is thus L. Can you see why? Here are a few examples of how the program might work. For example, if the user inputs a key of 1 and a plaintext of HELLO : $ ./caesar 1 plaintext: HELLO ciphertext: IFMMP Here\u2019s how the program might work if the user provides a key of 13 and a plaintext of hello, world : $ ./caesar 13 plaintext: hello, world ciphertext: uryyb, jbeyq Now let's get coding! We need our program to do the following: Get Key (the amount to shift the text by) Get plaintext Encipher Print ciphertext Note We will preserve case for letters (Keep capital letters capital, and lowercase lowercase). We will also wrap the alphabet (If we go beyond the boundaries of the alphabet, it will just start over). Let's walkthrough each piece of the program. Get the Key We will be taking the key as a command line argument : $ ./caesar 3 Remember that in C our main function can take arguments using the following: int main ( int argc , string argv []) { // code here } Getting the Key Ensure single command-line argument (print error message if command-line argument is out of bounds) Make sure argument contains only digit characters Convert argument to an integer We will also need to convert the string from the command line argument into a number using the atoi function, declared in <stdlib.h> . Getting the Plaintext We will simply use the get_string function to get user input for the plaintext. Encipher the Plaintext If it's alphabetic, shift the plaintext character by key, preserving the case. If it's not alphabetic, leave the character as-is. We can use the following functions to help us identify character type: isalpha , isupper , and islower . These functions will return a boolean value ( true or false ). Here is the correct program: #include <stdio.h> #include <cs50.h> #include <stdlib.h> #include <string.h> #include <ctype.h> bool check_key ( string s ); int main ( int argc , string argv []) //argc takes in the number of arguments and argv creates an array for the arguments themselves. { if ( argc != 2 || ! check_key ( argv [ 1 ])) // checking if the number of arguments is not 2 and if the key is valid { printf ( \"Usage: ./caesar key\" ); // if the input is not valid, it will print an error message with the correct way to enter return 1 ; } int key = atoi ( argv [ 1 ]); // converts from ASCII to integer string plaintext = get_string ( \"plaintext: \" ); printf ( \"ciphertext: \" ); for ( int i = 0 , len = strlen ( plaintext ); i < len ; i ++ ) { char c = plaintext [ i ]; if ( isalpha ( c )) { char m = 'A' ; if ( islower ( c )) m = 'a' ; printf ( \"%c\" , ( c - m + key ) % 26 + m ); // inputs the plaintext into Caesar's cipher } else printf ( \"%c\" , c ); // if the character is not alphabetic, it will print it as is } printf ( \" \\n \" ); } bool check_key ( string s ) // this string checks to see if the key is valid { for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) if ( ! isdigit ( s [ i ])) // if its not a digit, return false return false ; return true ; }","title":"Arrays"},{"location":"c-arrays/#arrays","text":"","title":"Arrays"},{"location":"c-arrays/#what-are-arrays","text":"Arrays are a fundamental data structure, and they are extremely useful! We use arrays to hold values of the same type at contiguous memory locations (A way to group together data types (integers, characters, floats) in memory really close together without giving each one their own name). A good analogy to use for arrays is a post office: Arrays Post Office Boxes An array is a block of contiguous space in memory... A mail bank is a large space o the wall of the post office... ...which has been partitioned into small, identically-sized blocks of space called elements ... ...which has been partitioned into small, identically-sized blocks of space called post office boxes ... ...each of which can store a certain amount of data ... ...each of which can hold a certain amount of mail ... ...all of the same data type such as int or char ... ...all of a familiar type such as letters or small packages ... ...and which can be accessed directly by an index . ...and which can be accessed directly by a mailbox number . In C, the elements of an array are indexed starting from 0. If an array consists of n elements, the first element is located at index 0. The last element is located at ( n -1). For example, if an array has 50 elements, the first is located at index 0 and the last is located at index 49). C is very lenient with arrays when compiled, which can lead to unforseen errors when the program is run. \"Segmentation Faults\" are common if you ask the program to access memory outside the bounds of what you asked the program to give you.","title":"What are Arrays?"},{"location":"c-arrays/#array-declarations","text":"type name [ size ]; The type is what kind of variable (data type) each element of the array will be. The name is what you want to call your array. The size is how many elements you would like your array to contain. Examples: \u2003\u2003 int data [ 100 ]; -> This array, named data, will store 100 integers. \u2003\u2003 float numbers [ 5 ]; -> This array, named numbers, will store 5 floating-point values. When declaring and initializing an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values. \u2003\u2003 Instantiation syntax \u2003\u2003 bool truthtable [ 3 ] = { false , true , true }; -> if the [ ] is left blank, C will automatically create an array for the number of items in the { } . \u2003\u2003 Individual element syntax \u2003\u2003 bool truthtable [ 3 ]; \u2003\u2003 truthtable [ 0 ] = false ; \u2003\u2003 truthtable [ 1 ] = true ; \u2003\u2003 truthtable [ 2 ] = true ; Both of these arrays will have the same output. Arrays are not restricted to a single dimension. You can have as many size specifiers as you wish. For example: \u2003\u2003 bool battleship [ 10 ][ 10 ]; You can choose to think of this as either a 10x10 grid of cells, but it's really just a 100-element one-dimensional array. Multi-dimensional arrays are great abstractions to help visualize game boards (such as Battleship above) or other complex representations. Important Note While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables. We cannot, for instance assign one array to another using the assignment operator. Instead, we must use a loop to copy over the elements one at a time. For example, the following code would not work: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; bar = foo ; In the above code we are attempting to copy foo into bar , but this would not work correctly. We must use a loop to copy the elements of foo into bar as follows: int foo [ 5 ] = { 1 , 2 , 3 , 4 , 5 }; int bar [ 5 ]; for ( int j = 0 ; j < 5 ; j ++ ) { bar [ j ] = foo [ j ]; } The simple bar = foo; does not work in C, but a simple element = element does work in many more modern programming languages.","title":"Array Declarations"},{"location":"c-arrays/#basic-array-program","text":"Lets make our first program using an array. Let's say we want to create a program that prints out the average scores for a quiz. We could have the following code that works perfectly: #include <stdio.h> #include <cs50.h> int main ( void ) { int score1 = 73 ; int score2 = 77 ; int score3 = 36 ; printf ( \"The average score was %i \\n \" , ( score1 + score2 + score3 ) / 3 ); } Now lets convert the above code to use an array: #include <stdio.h> #include <cs50.h> int main ( void ) { int scores [ 3 ]; scores [ 0 ] = 73 ; //(note how we started counting at 0) scores [ 1 ] = 77 ; scores [ 2 ] = 36 ; printf ( \"The average score was %i \\n \" , ( scores [ 0 ] + scores [ 1 ] + scores [ 2 ]) / 3 ); } Now lets make this program more intuitive and ask for user input. Let's also make it so it is not constrained to just 3 scores. #include <stdio.h> #include <cs50.h> float average ( int length , int array []); int main ( void ) { int n = get_int ( \"Number of scores: \" ); int scores [ n ]; for ( int i = 0 ; i < n ; i ++ ) { scores [ i ] = get_int ( \"Score %i: \" , i + 1 ); //this will ask the user for input of Score 1, Score 2, Score 3, etc. } printf ( \"The average score was %.2f \\n \" , average ( n , scores )); } float average ( int length , int array []) { int sum = 0 ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + array [ i ]; } return ( float ) sum / ( float ) length ; } This should now allow a user to input the number of scores they want to be averaged and the program will prompt the user for each score. After the scores have been inserted, the average will be displayed (with a decimal point because we chose to use float for the average).","title":"Basic Array Program"},{"location":"c-arrays/#other-array-tips","text":"Unlike most variables in C, arrays are not passed by value. Arrays are passed by reference. Instead of making an actual copy, arrays trust that functions will not break anything.","title":"Other Array Tips"},{"location":"c-arrays/#reading-levels-program","text":"According to Scholastic, E.B. White\u2019s \u201cCharlotte\u2019s Web\u201d is between a second and fourth grade reading level, and Lois Lowry\u2019s \u201cThe Giver\u201d is between an eighth grade reading level and a twelfth grade reading level. What does it mean, though, for a book to be at a \u201cfourth grade reading level\u201d? Well, in many cases, a human expert might read a book and make a decision on the grade for which they think the book is most appropriate. But you could also imagine an algorithm attempting to figure out what the reading level of a text is. So what sorts of traits are characteristic of higher reading levels? Well, longer words probably correlate with higher reading levels. Likewise, longer sentences probably correlate with higher reading levels, too. A number of \u201creadability tests\u201d have been developed over the years, to give a formulaic process for computing the reading level of a text. One such readability test is the Coleman-Liau index. The Coleman-Liau index of a text is designed to output what (U.S.) grade level is needed to understand the text. The formula is: index = 0.0588 * L - 0.296 * S - 15.8 Here, L is the average number of letters per 100 words in the text, and S is the average number of sentences per 100 words in the text. Let\u2019s write a program called readability that takes a text and determines its reading level. For example, if user types in a line from Dr. Seuss: $ ./readability Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 The text the user inputted has 65 letters, 4 sentences, and 14 words. 65 letters per 14 words is an average of about 464.29 letters per 100 words. And 4 sentences per 14 words is an average of about 28.57 sentences per 100 words. Plugged into the Coleman-Liau formula, and rounded to the nearest whole number, we get an answer of 3: so this passage is at a third grade reading level. $ ./readability Text: Harry Potter was a highly unusual boy in many ways. For one thing, he hated the summer holidays more than any other time of year. For another, he really wanted to do his homework, but was forced to do it in secret, in the dead of the night. And he also happened to be a wizard. Grade 5 This text has 214 letters, 4 sentences, and 56 words. That comes out to about 382.14 letters per 100 words, and 7.14 sentences per 100 words. Plugged into the Coleman-Liau formula, we get a fifth grade reading level. As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. $ ./readability Text: As the average number of letters and words per sentence increases, the Coleman-Liau index gives the text a higher reading level. If you were to take this paragraph, for instance, which has longer words and sentences than either of the prior two examples, the formula would give the text an eleventh grade reading level. Grade 11 For this program we need to start with counting the letters, words, and sentences there are in the submitted text. Next, we will plug those results into the Coleman-Liau index, mentioned above, index = 0.0588 * L - 0.296 * S - 15.8 . Finally, we will take the result from the Coleman-Liau index and display the correct (U.S.) grade level. Walkthrough First, we will look at the letters in the submitted text. We will need to count the number of both uppercase and lowercase letters in the text. We will also need to ignore the spaces and punctuation. We will need to look at each letter in the submitted text as it's own space as follows: 1 2 3 4 5 - - 6 7 8 9 10 - H e l l o , w o l r d ! We will utilize the library #include <ctype.h> to help differentiate characters from each other. We will then need to calculate the number of words in a sentence. We will do this by thinking that any sequence of characters separated by one or more spaces is a word. This would look as follows: 1 2 H e l l o , w o l r d ! Finally, we will look at sentences. For this problem, any period, exclamation point, or question mark will indicate a sentence. This may no be true in some instances (Mr. or Mrs.), but should work in most cases. After these steps, we should have an accurate count of letters , words , and sentences . We should then run these numbers through the Coleman-Liau index. The formula should give out a real number, but we should round to the nearest whole number ( int ). Output should be \"Grade #\", where # is the grade level. If the output is less than 1, we will output \"Before Grade 1\" and if it is above 16, we will output \"Grade 16+\". Let's begin programming! #include <stdio.h> #include <cs50.h> #include <math.h> #include <ctype.h> #include <string.h> int main ( void ) { string s = get_string ( \"Text: \" ); int words , sentences , letters ; words = sentences = letters = 0 ; // setting word, sentences, and letter count to 0 for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) { if ( isalpha ( s [ i ])) // checks to see if i is an alphanumeric character letters ++ ; // if it is an alphanumeric character, letters increases by 1 if (( i == 0 && s [ i ] != ' ' ) || ( i != len - 1 && s [ i ] == ' ' && s [ i + 1 ] != ' ' )) // checks to see if there are any spaces between groups of letters words ++ ; // if there are spaces between groups of letters, words increases by 1 if ( s [ i ] == '.' || s [ i ] == '!' || s [ i ] == '?' ) // checks to see if there is a ., !, or ? sentences ++ ; // if there is a ., !, or ?, it increases by 1 } float L = (( float ) letters / ( float ) words ) * 100 ; // converts the number of letters and words to float, then divides them by each other and multiplies the result by 100 float S = (( float ) sentences / ( float ) words ) * 100 ; // converts the number of sentences and words to float, then divides them by each other and multiplies the result by 100 int index = round ( 0.0588 * L - 0.296 * S - 15.8 ); // the float L and S are then ran through the Coleman-Liau index. if ( index < 1 ) // if the index (Coleman-Liau index) is less than 1 printf ( \"Before Grade 1 \\n \" ); else if ( index < 16 ) // if the index is less than 16 printf ( \"Grade %i \\n \" , index ); else // if it is >= 16 printf ( \"Grade 16+ \\n \" ); }","title":"Reading Levels Program"},{"location":"c-arrays/#caesars-cipher","text":"We will now create a program that will take text and run it through Caesar's encryption method. Supposedly, Caesar (yes, that Caesar) used to \u201cencrypt\u201d (i.e., conceal in a reversible way) confidential messages by shifting each letter therein by some number of places. For instance, he might write A as B, B as C, C as D, \u2026, and, wrapping around alphabetically, Z as A. And so, to say HELLO to someone, Caesar might write IFMMP. Upon receiving such messages from Caesar, recipients would have to \u201cdecrypt\u201d them by shifting letters in the opposite direction by the same number of places. The secrecy of this \u201ccryptosystem\u201d relied on only Caesar and the recipients knowing a secret, the number of places by which Caesar had shifted his letters (e.g., 1). Not particularly secure by modern standards, but, hey, if you\u2019re perhaps the first in the world to do it, pretty secure! Note Unencrypted text is generally called plaintext . Encrypted text is generally called ciphertext . And the secret used is called a key . To be clear, then, here\u2019s how encrypting HELLO with a key of 1 yields IFMMP : plaintext H E L L O + key 1 1 1 1 1 = ciphertext I F M M P More formally, Caesar\u2019s algorithm (i.e., cipher) encrypts messages by \u201crotating\u201d each letter by k positions. More formally, if p is some plaintext (i.e., an unencrypted message), p i is the i th character in p , and k is a secret key (i.e., a non-negative integer), then each letter, c i , in the ciphertext, c , is computed as: c i = (p i + k) % 26 wherein % 26 here means \u201cremainder when dividing by 26.\u201d This formula perhaps makes the cipher seem more complicated than it is, but it\u2019s really just a concise way of expressing the algorithm precisely. Indeed, for the sake of discussion, think of A (or a) as 0, B (or b) as 1, \u2026, H (or h) as 7, I (or i) as 8, \u2026, and Z (or z) as 25. Suppose that Caesar just wants to say Hi to someone confidentially using, this time, a key, k , of 3. And so his plaintext, p , is Hi, in which case his plaintext\u2019s first character, p 0 , is H (aka 7), and his plaintext\u2019s second character, p 1 , is i (aka 8). His ciphertext\u2019s first character, c 0 , is thus K, and his ciphertext\u2019s second character, c 1 , is thus L. Can you see why? Here are a few examples of how the program might work. For example, if the user inputs a key of 1 and a plaintext of HELLO : $ ./caesar 1 plaintext: HELLO ciphertext: IFMMP Here\u2019s how the program might work if the user provides a key of 13 and a plaintext of hello, world : $ ./caesar 13 plaintext: hello, world ciphertext: uryyb, jbeyq Now let's get coding! We need our program to do the following: Get Key (the amount to shift the text by) Get plaintext Encipher Print ciphertext Note We will preserve case for letters (Keep capital letters capital, and lowercase lowercase). We will also wrap the alphabet (If we go beyond the boundaries of the alphabet, it will just start over). Let's walkthrough each piece of the program. Get the Key We will be taking the key as a command line argument : $ ./caesar 3 Remember that in C our main function can take arguments using the following: int main ( int argc , string argv []) { // code here } Getting the Key Ensure single command-line argument (print error message if command-line argument is out of bounds) Make sure argument contains only digit characters Convert argument to an integer We will also need to convert the string from the command line argument into a number using the atoi function, declared in <stdlib.h> . Getting the Plaintext We will simply use the get_string function to get user input for the plaintext. Encipher the Plaintext If it's alphabetic, shift the plaintext character by key, preserving the case. If it's not alphabetic, leave the character as-is. We can use the following functions to help us identify character type: isalpha , isupper , and islower . These functions will return a boolean value ( true or false ). Here is the correct program: #include <stdio.h> #include <cs50.h> #include <stdlib.h> #include <string.h> #include <ctype.h> bool check_key ( string s ); int main ( int argc , string argv []) //argc takes in the number of arguments and argv creates an array for the arguments themselves. { if ( argc != 2 || ! check_key ( argv [ 1 ])) // checking if the number of arguments is not 2 and if the key is valid { printf ( \"Usage: ./caesar key\" ); // if the input is not valid, it will print an error message with the correct way to enter return 1 ; } int key = atoi ( argv [ 1 ]); // converts from ASCII to integer string plaintext = get_string ( \"plaintext: \" ); printf ( \"ciphertext: \" ); for ( int i = 0 , len = strlen ( plaintext ); i < len ; i ++ ) { char c = plaintext [ i ]; if ( isalpha ( c )) { char m = 'A' ; if ( islower ( c )) m = 'a' ; printf ( \"%c\" , ( c - m + key ) % 26 + m ); // inputs the plaintext into Caesar's cipher } else printf ( \"%c\" , c ); // if the character is not alphabetic, it will print it as is } printf ( \" \\n \" ); } bool check_key ( string s ) // this string checks to see if the key is valid { for ( int i = 0 , len = strlen ( s ); i < len ; i ++ ) if ( ! isdigit ( s [ i ])) // if its not a digit, return false return false ; return true ; }","title":"Caesar's Cipher"},{"location":"c-cl-arguments/","text":"Command Line Arugments Overview Command Line Arguments So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc -1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-cl-arguments/#command-line-arugments-overview","text":"","title":"Command Line Arugments Overview"},{"location":"c-cl-arguments/#command-line-arguments","text":"So far, all of our programs have begun pretty much the same way: int main ( void ) { Since we've been collecting user input through in-program prompts, we haven't needed to modify this declaration of main . If we want the user to provide data to our program before the program starts running, we need a new form. To collect so called command-line arguments from the user, declare main as: int main ( int argc , string argv []) // the first parameter (argument/input) is an integer argc and the second is an array of strings. { These two special arguments enable you to know what data the user provided at the command line and how much data they provided. argc (argument count) This integer-type variable will store the number of command-line arguments the user typed when the program was executed. command argc ./greedy 1 ./greedy 1024 cs50 3 (greedy is the name of the program in the above example) argv (argument vector) This array of strings stores, one string per element, the actual text the user typed at the command-line when the program was executed. The first element of argv is always found at argv [ 0 ] (first index of the argv array). The last element of argv is always found at argv [ argc -1 ] (this is because the number of elements that exist in the array are argc number of elements). Let's assume the user executes the greedy program as follows: ./greedy 1024 cs50 argv indices argv contents argv [ 0 ] \"./greedy\" argv [ 1 ] \"1024\" (stored as a string NOT an integer) argv [ 2 ] \"cs50\" argv [ 3 ] ??? (often leads to segmentation fault)","title":"Command Line Arguments"},{"location":"c-data-structures-problems/","text":"Data Structures Problem Speller We are going to implement a program that spell-checks a file, like below, using a hash table. $ ./speller texts/lalaland.txt MISSPELLED WORDS [...] AHHHHHHHHHHHHHHHHHHHHHHHHHHHT [...] Shangri [...] fianc [...] Sebastian's [...] WORDS MISSPELLED: WORDS IN DICTIONARY: WORDS IN TEXT: TIME IN load: TIME IN check: TIME IN size: TIME IN unload: TIME IN TOTAL: To download the prerequisite files, click here . This should give you the following files: dictionaries/ dictionary.c dictionary.h keys/ Makefile speller.c texts/ Understanding Theoretically, on input of size n , an algorithm with a running time of n is \u201casymptotically equivalent,\u201d in terms of O , to an algorithm with a running time of 2 n . Indeed, when describing the running time of an algorithm, we typically focus on the dominant (i.e., most impactful) term (i.e., n in this case, since n could be much larger than 2). In the real world, though, the fact of the matter is that 2 n feels twice as slow as n . The challenge ahead is to implement the fastest spell checker we can! By \u201cfastest,\u201d though, we\u2019re talking actual \u201cwall-clock,\u201d not asymptotic, time. In speller.c , we\u2019ve put together a program that\u2019s designed to spell-check a file after loading a dictionary of words from disk into memory. That dictionary, meanwhile, is implemented in a file called dictionary.c . (It could just be implemented in speller.c , but as programs get more complex, it\u2019s often convenient to break them into multiple files.) The prototypes for the functions therein, meanwhile, are defined not in dictionary.c itself but in dictionary.h instead. That way, both speller.c and dictionary.c can #include the file. Unfortunately, we didn\u2019t quite get around to implementing the loading part. Or the checking part. Both (and a bit more) we leave to you! But first, a tour. dictionary.h Open up dictionary.h , and you\u2019ll see some new syntax, including a few lines that mention DICTIONARY_H . No need to worry about those, but, if curious, those lines just ensure that, even though dictionary.c and speller.c (which you\u2019ll see in a moment) #include this file, clang will only compile it once. Next notice how we #include a file called stdbool.h . That\u2019s the file in which bool itself is defined. You\u2019ve not needed it before, since the CS50 Library used to #include that for you. Also notice our use of #define , a \u201cpreprocessor directive\u201d that defines a \u201cconstant\u201d called LENGTH that has a value of 45 . It\u2019s a constant in the sense that you can\u2019t (accidentally) change it in your own code. In fact, clang will replace any mentions of LENGTH in your own code with, literally, 45 . In other words, it\u2019s not a variable, just a find-and-replace trick. Finally, notice the prototypes for five functions: check , hash , load , size , and unload . Notice how three of those take a pointer as an argument, per the * : bool check ( const char * word ); unsigned int hash ( const char * word ); bool load ( const char * dictionary ); Recall that char * is what we used to call string . So those three prototypes are essentially just: bool check ( const string word ); unsigned int hash ( const string word ); bool load ( const string dictionary ); And const , meanwhile, just says that those strings, when passed in as arguments, must remain constant; you won\u2019t be able to change them, accidentally or otherwise! dictionary.c Now open up dictionary.c . Notice how, atop the file, we\u2019ve defined a struct called node that represents a node in a hash table. And we\u2019ve declared a global pointer array, table , which will (soon) represent the hash table you will use to keep track of words in the dictionary. The array contains N node pointers, and we\u2019ve set N equal to 1 for now, meaning this hash table has just 1 bucket right now. You\u2019ll likely want to increase the number of buckets, as by changing N , to something larger! Next, notice that we\u2019ve implemented load , hash , check , size , and unload , but only barely, just enough for the code to compile. Your job, ultimately, is to re-implement those functions as cleverly as possible so that this spell checker works as advertised. And fast! speller.c Okay, next open up speller.c and spend some time looking over the code and comments therein. You won\u2019t need to change anything in this file, and you don\u2019t need to understand its entirety, but do try to get a sense of its functionality nonetheless. Notice how, by way of a function called getrusage , we\u2019ll be \u201cbenchmarking\u201d (i.e., timing the execution of) your implementations of check , load , size , and unload . Also notice how we go about passing check , word by word, the contents of some file to be spell-checked. Ultimately, we report each misspelling in that file along with a bunch of statistics. Notice, incidentally, that we have defined the usage of speller to be Usage: speller [dictionary] text where dictionary is assumed to be a file containing a list of lowercase words, one per line, and text is a file to be spell-checked. As the brackets suggest, provision of dictionary is optional; if this argument is omitted, speller will use dictionaries/large by default. In other words, running $ ./speller text will be equivalent to running $ ./speller dictionaries/large text where text is the file you wish to spell-check. Suffice it to say, the former is easier to type! (Of course, speller will not be able to load any dictionaries until you implement load in dictionary.c ! Until then, you\u2019ll see Could not load .) Within the default dictionary, mind you, are 143,091 words, all of which must be loaded into memory! In fact, take a peek at that file to get a sense of its structure and size. Notice that every word in that file appears in lowercase (even, for simplicity, proper nouns and acronyms). From top to bottom, the file is sorted lexicographically, with only one word per line (each of which ends with \\n ). No word is longer than 45 characters, and no word appears more than once. During development, you may find it helpful to provide speller with a dictionary of your own that contains far fewer words, lest you struggle to debug an otherwise enormous structure in memory. In dictionaries/small is one such dictionary. To use it, execute $ ./speller dictionaries/small text where text is the file you wish to spell-check. Don\u2019t move on until you\u2019re sure you understand how speller itself works! Odds are, you didn\u2019t spend enough time looking over speller.c . Go back one square and walk yourself through it again! texts/ So that you can test your implementation of speller , we\u2019ve also provided you with a whole bunch of texts, among them the script from La La Land, the text of the Affordable Care Act, three million bytes from Tolstoy, some excerpts from The Federalist Papers and Shakespeare, the entirety of the King James V Bible and the Koran, and more. So that you know what to expect, open and skim each of those files, all of which are in a directory called texts within your pset5 directory. Now, as you should know from having read over speller.c carefully, the output of speller , if executed with, say, $ ./speller texts/lalaland.txt will eventually resemble the below. For now, try the staff\u2019s solution (using the default dictionary) by executing $ ~cs50/2019/fall/pset5/speller texts/lalaland.txt Below\u2019s some of the output you\u2019ll see. For information\u2019s sake, we\u2019ve excerpted some examples of \u201cmisspellings.\u201d And lest we spoil the fun, we\u2019ve omitted our own statistics for now. MISSPELLED WORDS [...] AHHHHHHHHHHHHHHHHHHHHHHHHHHHT [...] Shangri [...] fianc [...] Sebastian's [...] WORDS MISSPELLED: WORDS IN DICTIONARY: WORDS IN TEXT: TIME IN load: TIME IN check: TIME IN size: TIME IN unload: TIME IN TOTAL: TIME IN load represents the number of seconds that speller spends executing your implementation of load . TIME IN check represents the number of seconds that speller spends, in total, executing your implementation of check . TIME IN size represents the number of seconds that speller spends executing your implementation of size . TIME IN unload represents the number of seconds that speller spends executing your implementation of unload . TIME IN TOTAL is the sum of those four measurements. Note that these times may vary somewhat across executions of speller , depending on what else CS50 IDE is doing, even if you don\u2019t change your code. Incidentally, to be clear, by \u201cmisspelled\u201d we simply mean that some word is not in the dictionary provided. Makefile And, lastly, recall that make automates compilation of your code so that you don\u2019t have to execute clang manually along with a whole bunch of switches. However, as your programs grow in size, make won\u2019t be able to infer from context anymore how to compile your code; you\u2019ll need to start telling make how to compile your program, particularly when they involve multiple source (i.e., .c ) files, as in the case of this problem. And so we\u2019ll utilize a Makefile , a configuration file that tells make exactly what to do. Open up Makefile , and you should see four lines: The first line tells make to execute the subsequent lines whenever you yourself execute make speller (or just make ). The second line tells make how to compile speller.c into machine code (i.e., speller.o ). The third line tells make how to compile dictionary.c into machine code (i.e., dictionary.o ). The fourth line tells make to link speller.o and dictionary.o in a file called speller . Be sure to compile speller by executing make speller (or just make ). Executing make dictionary won\u2019t work! Getting started Alright, the challenge now before you is to implement, in order, load , hash , size , check , and unload as efficiently as possible using a hash table in such a way that TIME IN load , TIME IN check , TIME IN size , and TIME IN unload are all minimized. To be sure, it\u2019s not obvious what it even means to be minimized, inasmuch as these benchmarks will certainly vary as you feed speller different values for dictionary and for text . But therein lies the challenge, if not the fun, of this problem. This problem is your chance to design. Although we invite you to minimize space, your ultimate enemy is time. But before you dive in, some specifications from us. You may not alter speller.c or Makefile . You may alter dictionary.c (and, in fact, must in order to complete the implementations of load , hash , size , check , and unload ), but you may not alter the declarations (i.e., prototypes) of load , hash , size , check , or unload . You may, though, add new functions and (local or global) variables to dictionary.c . You may change the value of N in dictionary.c , so that your hash table can have more buckets. You may alter dictionary.h , but you may not alter the declarations of load , hash , size , check , or unload . Your implementation of check must be case-insensitive. In other words, if foo is in dictionary, then check should return true given any capitalization thereof; none of foo , foO , fOo , fOO , fOO , Foo , FoO , FOo , and FOO should be considered misspelled. Capitalization aside, your implementation of check should only return true for words actually in dictionary . Beware hard-coding common words (e.g., the ), lest we pass your implementation a dictionary without those same words. Moreover, the only possessives allowed are those actually in dictionary . In other words, even if foo is in dictionary , check should return false given foo 's if foo 's is not also in dictionary . You may assume that any dictionary passed to your program will be structured exactly like ours, alphabetically sorted from top to bottom with one word per line, each of which ends with \\n . You may also assume that dictionary will contain at least one word, that no word will be longer than LENGTH (a constant defined in dictionary.h ) characters, that no word will appear more than once, that each word will contain only lowercase alphabetical characters and possibly apostrophes, and that no word will start with an apostrophe. You may assume that check will only be passed words that contain (uppercase or lowercase) alphabetical characters and possibly apostrophes. Your spell checker may only take text and, optionally, dictionary as input. Although you might be inclined (particularly if among those more comfortable) to \u201cpre-process\u201d our default dictionary in order to derive an \u201cideal hash function\u201d for it, you may not save the output of any such pre-processing to disk in order to load it back into memory on subsequent runs of your spell checker in order to gain an advantage. Your spell checker must not leak any memory. Be sure to check for leaks with valgrind . You may search for (good) hash functions online, so long as you cite the origin of any hash function you integrate into your own code. Now let's implement load, hash, size, check, and unload! Solution Speller Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // Implements a dictionary's functionality #include <stdbool.h> #include \"ctype.h\" #include \"stdio.h\" #include \"string.h\" #include \"strings.h\" #include \"stdlib.h\" #include \"cs50.h\" #include \"dictionary.h\" // Represents a node in a hash table typedef struct node { char word [ LENGTH + 1 ]; struct node * next ; } node ; // Number of buckets in hash table const unsigned int N = 25 ; //index for int N for A-Z int total_words = 0 ; //counts the total words from dictionary bool is_loaded = false ; //makes sure that dictionary loads // Hash table node * table [ N ]; // Returns true if word is in dictionary else false bool check ( const char * word ) { int i = hash ( word ); if ( table [ i ] == NULL ) { return false ; } for ( node * cursor = table [ i ]; cursor != NULL ; cursor = cursor -> next ) { if ( strcasecmp ( word , cursor -> word ) == 0 ) //compare strings { return true ; } } return false ; } // Hashes word to a number unsigned int hash ( const char * word ) //create hash code using firt letter { char x ; x = tolower ( word [ 0 ]); int hash = x ; hash = hash - 97 ; return hash ; } // Loads dictionary into memory, returning true if successful else false bool load ( const char * dictionary ) { FILE * d = fopen ( dictionary , \"r\" ); if ( d == NULL ) //check if file opened or not { printf ( \"File not found \\n \" ); return false ; } for ( int k = 0 ; k < N ; k ++ ) { table [ k ] = NULL ; //set all pointers in hash table to NULL } char new_word [ LENGTH + 1 ]; while ( fscanf ( d , \"%s\" , new_word ) != EOF ) { node * new_node = malloc ( sizeof ( node )); if ( new_node == NULL ) { return false ; } int i = hash ( new_word ); strcpy ( new_node -> word , new_word ); if ( table [ i ] == NULL ) { new_node -> next = NULL ; table [ i ] = new_node ; total_words ++ ; } else { new_node -> next = table [ i ]; table [ i ] = new_node ; total_words ++ ; } } fclose ( d ); is_loaded = true ; return true ; } // Returns number of words in dictionary if loaded else 0 if not yet loaded unsigned int size ( void ) { if ( is_loaded == true ) { return total_words ; } else { return 0 ; } } // Unloads dictionary from memory, returning true if successful else false bool unload ( void ) { for ( int i = 0 ; i <= N ; i ++ ) { if ( table [ i ] != NULL ) { node * p = table [ i ]; while ( p != NULL ) { node * q = p ; p = p -> next ; free ( q ); } } } return true ; }","title":"Data Structures Problem"},{"location":"c-data-structures-problems/#data-structures-problem","text":"","title":"Data Structures Problem"},{"location":"c-data-structures-problems/#speller","text":"We are going to implement a program that spell-checks a file, like below, using a hash table. $ ./speller texts/lalaland.txt MISSPELLED WORDS [...] AHHHHHHHHHHHHHHHHHHHHHHHHHHHT [...] Shangri [...] fianc [...] Sebastian's [...] WORDS MISSPELLED: WORDS IN DICTIONARY: WORDS IN TEXT: TIME IN load: TIME IN check: TIME IN size: TIME IN unload: TIME IN TOTAL: To download the prerequisite files, click here . This should give you the following files: dictionaries/ dictionary.c dictionary.h keys/ Makefile speller.c texts/","title":"Speller"},{"location":"c-data-structures-problems/#understanding","text":"Theoretically, on input of size n , an algorithm with a running time of n is \u201casymptotically equivalent,\u201d in terms of O , to an algorithm with a running time of 2 n . Indeed, when describing the running time of an algorithm, we typically focus on the dominant (i.e., most impactful) term (i.e., n in this case, since n could be much larger than 2). In the real world, though, the fact of the matter is that 2 n feels twice as slow as n . The challenge ahead is to implement the fastest spell checker we can! By \u201cfastest,\u201d though, we\u2019re talking actual \u201cwall-clock,\u201d not asymptotic, time. In speller.c , we\u2019ve put together a program that\u2019s designed to spell-check a file after loading a dictionary of words from disk into memory. That dictionary, meanwhile, is implemented in a file called dictionary.c . (It could just be implemented in speller.c , but as programs get more complex, it\u2019s often convenient to break them into multiple files.) The prototypes for the functions therein, meanwhile, are defined not in dictionary.c itself but in dictionary.h instead. That way, both speller.c and dictionary.c can #include the file. Unfortunately, we didn\u2019t quite get around to implementing the loading part. Or the checking part. Both (and a bit more) we leave to you! But first, a tour.","title":"Understanding"},{"location":"c-data-structures-problems/#dictionaryh","text":"Open up dictionary.h , and you\u2019ll see some new syntax, including a few lines that mention DICTIONARY_H . No need to worry about those, but, if curious, those lines just ensure that, even though dictionary.c and speller.c (which you\u2019ll see in a moment) #include this file, clang will only compile it once. Next notice how we #include a file called stdbool.h . That\u2019s the file in which bool itself is defined. You\u2019ve not needed it before, since the CS50 Library used to #include that for you. Also notice our use of #define , a \u201cpreprocessor directive\u201d that defines a \u201cconstant\u201d called LENGTH that has a value of 45 . It\u2019s a constant in the sense that you can\u2019t (accidentally) change it in your own code. In fact, clang will replace any mentions of LENGTH in your own code with, literally, 45 . In other words, it\u2019s not a variable, just a find-and-replace trick. Finally, notice the prototypes for five functions: check , hash , load , size , and unload . Notice how three of those take a pointer as an argument, per the * : bool check ( const char * word ); unsigned int hash ( const char * word ); bool load ( const char * dictionary ); Recall that char * is what we used to call string . So those three prototypes are essentially just: bool check ( const string word ); unsigned int hash ( const string word ); bool load ( const string dictionary ); And const , meanwhile, just says that those strings, when passed in as arguments, must remain constant; you won\u2019t be able to change them, accidentally or otherwise!","title":"dictionary.h"},{"location":"c-data-structures-problems/#dictionaryc","text":"Now open up dictionary.c . Notice how, atop the file, we\u2019ve defined a struct called node that represents a node in a hash table. And we\u2019ve declared a global pointer array, table , which will (soon) represent the hash table you will use to keep track of words in the dictionary. The array contains N node pointers, and we\u2019ve set N equal to 1 for now, meaning this hash table has just 1 bucket right now. You\u2019ll likely want to increase the number of buckets, as by changing N , to something larger! Next, notice that we\u2019ve implemented load , hash , check , size , and unload , but only barely, just enough for the code to compile. Your job, ultimately, is to re-implement those functions as cleverly as possible so that this spell checker works as advertised. And fast!","title":"dictionary.c"},{"location":"c-data-structures-problems/#spellerc","text":"Okay, next open up speller.c and spend some time looking over the code and comments therein. You won\u2019t need to change anything in this file, and you don\u2019t need to understand its entirety, but do try to get a sense of its functionality nonetheless. Notice how, by way of a function called getrusage , we\u2019ll be \u201cbenchmarking\u201d (i.e., timing the execution of) your implementations of check , load , size , and unload . Also notice how we go about passing check , word by word, the contents of some file to be spell-checked. Ultimately, we report each misspelling in that file along with a bunch of statistics. Notice, incidentally, that we have defined the usage of speller to be Usage: speller [dictionary] text where dictionary is assumed to be a file containing a list of lowercase words, one per line, and text is a file to be spell-checked. As the brackets suggest, provision of dictionary is optional; if this argument is omitted, speller will use dictionaries/large by default. In other words, running $ ./speller text will be equivalent to running $ ./speller dictionaries/large text where text is the file you wish to spell-check. Suffice it to say, the former is easier to type! (Of course, speller will not be able to load any dictionaries until you implement load in dictionary.c ! Until then, you\u2019ll see Could not load .) Within the default dictionary, mind you, are 143,091 words, all of which must be loaded into memory! In fact, take a peek at that file to get a sense of its structure and size. Notice that every word in that file appears in lowercase (even, for simplicity, proper nouns and acronyms). From top to bottom, the file is sorted lexicographically, with only one word per line (each of which ends with \\n ). No word is longer than 45 characters, and no word appears more than once. During development, you may find it helpful to provide speller with a dictionary of your own that contains far fewer words, lest you struggle to debug an otherwise enormous structure in memory. In dictionaries/small is one such dictionary. To use it, execute $ ./speller dictionaries/small text where text is the file you wish to spell-check. Don\u2019t move on until you\u2019re sure you understand how speller itself works! Odds are, you didn\u2019t spend enough time looking over speller.c . Go back one square and walk yourself through it again!","title":"speller.c"},{"location":"c-data-structures-problems/#texts","text":"So that you can test your implementation of speller , we\u2019ve also provided you with a whole bunch of texts, among them the script from La La Land, the text of the Affordable Care Act, three million bytes from Tolstoy, some excerpts from The Federalist Papers and Shakespeare, the entirety of the King James V Bible and the Koran, and more. So that you know what to expect, open and skim each of those files, all of which are in a directory called texts within your pset5 directory. Now, as you should know from having read over speller.c carefully, the output of speller , if executed with, say, $ ./speller texts/lalaland.txt will eventually resemble the below. For now, try the staff\u2019s solution (using the default dictionary) by executing $ ~cs50/2019/fall/pset5/speller texts/lalaland.txt Below\u2019s some of the output you\u2019ll see. For information\u2019s sake, we\u2019ve excerpted some examples of \u201cmisspellings.\u201d And lest we spoil the fun, we\u2019ve omitted our own statistics for now. MISSPELLED WORDS [...] AHHHHHHHHHHHHHHHHHHHHHHHHHHHT [...] Shangri [...] fianc [...] Sebastian's [...] WORDS MISSPELLED: WORDS IN DICTIONARY: WORDS IN TEXT: TIME IN load: TIME IN check: TIME IN size: TIME IN unload: TIME IN TOTAL: TIME IN load represents the number of seconds that speller spends executing your implementation of load . TIME IN check represents the number of seconds that speller spends, in total, executing your implementation of check . TIME IN size represents the number of seconds that speller spends executing your implementation of size . TIME IN unload represents the number of seconds that speller spends executing your implementation of unload . TIME IN TOTAL is the sum of those four measurements. Note that these times may vary somewhat across executions of speller , depending on what else CS50 IDE is doing, even if you don\u2019t change your code. Incidentally, to be clear, by \u201cmisspelled\u201d we simply mean that some word is not in the dictionary provided.","title":"texts/"},{"location":"c-data-structures-problems/#makefile","text":"And, lastly, recall that make automates compilation of your code so that you don\u2019t have to execute clang manually along with a whole bunch of switches. However, as your programs grow in size, make won\u2019t be able to infer from context anymore how to compile your code; you\u2019ll need to start telling make how to compile your program, particularly when they involve multiple source (i.e., .c ) files, as in the case of this problem. And so we\u2019ll utilize a Makefile , a configuration file that tells make exactly what to do. Open up Makefile , and you should see four lines: The first line tells make to execute the subsequent lines whenever you yourself execute make speller (or just make ). The second line tells make how to compile speller.c into machine code (i.e., speller.o ). The third line tells make how to compile dictionary.c into machine code (i.e., dictionary.o ). The fourth line tells make to link speller.o and dictionary.o in a file called speller . Be sure to compile speller by executing make speller (or just make ). Executing make dictionary won\u2019t work!","title":"Makefile"},{"location":"c-data-structures-problems/#getting-started","text":"Alright, the challenge now before you is to implement, in order, load , hash , size , check , and unload as efficiently as possible using a hash table in such a way that TIME IN load , TIME IN check , TIME IN size , and TIME IN unload are all minimized. To be sure, it\u2019s not obvious what it even means to be minimized, inasmuch as these benchmarks will certainly vary as you feed speller different values for dictionary and for text . But therein lies the challenge, if not the fun, of this problem. This problem is your chance to design. Although we invite you to minimize space, your ultimate enemy is time. But before you dive in, some specifications from us. You may not alter speller.c or Makefile . You may alter dictionary.c (and, in fact, must in order to complete the implementations of load , hash , size , check , and unload ), but you may not alter the declarations (i.e., prototypes) of load , hash , size , check , or unload . You may, though, add new functions and (local or global) variables to dictionary.c . You may change the value of N in dictionary.c , so that your hash table can have more buckets. You may alter dictionary.h , but you may not alter the declarations of load , hash , size , check , or unload . Your implementation of check must be case-insensitive. In other words, if foo is in dictionary, then check should return true given any capitalization thereof; none of foo , foO , fOo , fOO , fOO , Foo , FoO , FOo , and FOO should be considered misspelled. Capitalization aside, your implementation of check should only return true for words actually in dictionary . Beware hard-coding common words (e.g., the ), lest we pass your implementation a dictionary without those same words. Moreover, the only possessives allowed are those actually in dictionary . In other words, even if foo is in dictionary , check should return false given foo 's if foo 's is not also in dictionary . You may assume that any dictionary passed to your program will be structured exactly like ours, alphabetically sorted from top to bottom with one word per line, each of which ends with \\n . You may also assume that dictionary will contain at least one word, that no word will be longer than LENGTH (a constant defined in dictionary.h ) characters, that no word will appear more than once, that each word will contain only lowercase alphabetical characters and possibly apostrophes, and that no word will start with an apostrophe. You may assume that check will only be passed words that contain (uppercase or lowercase) alphabetical characters and possibly apostrophes. Your spell checker may only take text and, optionally, dictionary as input. Although you might be inclined (particularly if among those more comfortable) to \u201cpre-process\u201d our default dictionary in order to derive an \u201cideal hash function\u201d for it, you may not save the output of any such pre-processing to disk in order to load it back into memory on subsequent runs of your spell checker in order to gain an advantage. Your spell checker must not leak any memory. Be sure to check for leaks with valgrind . You may search for (good) hash functions online, so long as you cite the origin of any hash function you integrate into your own code. Now let's implement load, hash, size, check, and unload!","title":"Getting started"},{"location":"c-data-structures-problems/#solution","text":"Speller Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // Implements a dictionary's functionality #include <stdbool.h> #include \"ctype.h\" #include \"stdio.h\" #include \"string.h\" #include \"strings.h\" #include \"stdlib.h\" #include \"cs50.h\" #include \"dictionary.h\" // Represents a node in a hash table typedef struct node { char word [ LENGTH + 1 ]; struct node * next ; } node ; // Number of buckets in hash table const unsigned int N = 25 ; //index for int N for A-Z int total_words = 0 ; //counts the total words from dictionary bool is_loaded = false ; //makes sure that dictionary loads // Hash table node * table [ N ]; // Returns true if word is in dictionary else false bool check ( const char * word ) { int i = hash ( word ); if ( table [ i ] == NULL ) { return false ; } for ( node * cursor = table [ i ]; cursor != NULL ; cursor = cursor -> next ) { if ( strcasecmp ( word , cursor -> word ) == 0 ) //compare strings { return true ; } } return false ; } // Hashes word to a number unsigned int hash ( const char * word ) //create hash code using firt letter { char x ; x = tolower ( word [ 0 ]); int hash = x ; hash = hash - 97 ; return hash ; } // Loads dictionary into memory, returning true if successful else false bool load ( const char * dictionary ) { FILE * d = fopen ( dictionary , \"r\" ); if ( d == NULL ) //check if file opened or not { printf ( \"File not found \\n \" ); return false ; } for ( int k = 0 ; k < N ; k ++ ) { table [ k ] = NULL ; //set all pointers in hash table to NULL } char new_word [ LENGTH + 1 ]; while ( fscanf ( d , \"%s\" , new_word ) != EOF ) { node * new_node = malloc ( sizeof ( node )); if ( new_node == NULL ) { return false ; } int i = hash ( new_word ); strcpy ( new_node -> word , new_word ); if ( table [ i ] == NULL ) { new_node -> next = NULL ; table [ i ] = new_node ; total_words ++ ; } else { new_node -> next = table [ i ]; table [ i ] = new_node ; total_words ++ ; } } fclose ( d ); is_loaded = true ; return true ; } // Returns number of words in dictionary if loaded else 0 if not yet loaded unsigned int size ( void ) { if ( is_loaded == true ) { return total_words ; } else { return 0 ; } } // Unloads dictionary from memory, returning true if successful else false bool unload ( void ) { for ( int i = 0 ; i <= N ; i ++ ) { if ( table [ i ] != NULL ) { node * p = table [ i ]; while ( p != NULL ) { node * q = p ; p = p -> next ; free ( q ); } } } return true ; }","title":"Solution"},{"location":"c-data-structures/","text":"Data Structures Data Structures Summary By this point we've now examined four different ways to store sets of data: Arrays Linked lists Hash tables Tries There are even some variations on these (trees and heaps, quite similar to tries, stacks and queues quite similar to arrays or linked lists, etc.) but this will generally cover most of what we're looking at in C. Arrays Insertion is bad - lots of shifting to fit an element in the middle. Deletion is bad - lots of shifting after removing an element. Lookup is great - random access, constant time. Relatively easy to sort. Relatively small size-wise. Stuck with a fixed size, no flexibility. Linked lists Insertion is easy - just tack onto the front. Deletion is easy - once you find the element. Lookup is bad - have to rely on linear search. Relatively difficult to sort - unless you're willing to compromise on super-fast insertion and instead sort as you construct. Relatively small size-wise (not as small as arrays). Hash tables Insertion is a two-step process - hash, then add. Deletion is easy - once you find the element. Lookup is on average better than with linked lists because you have the benefit of real-world constant factor. Not an ideal data structure if sorting is the goal - just use an array. Can run the gamut on size. Tries Insertion is complex - a lot of dynamic memory allocation, but gets easier as you go. Deletion is easy - just free a node. Lookup is fast - not quite as fast as an array, but almost. Already sorted - sorts as you build in almost all situations. Rapidly becomes huge, even with very little data present, not great if space is at a premium. Pointers In the memory notes, we learned about pointers, malloc , and other useful tools for working with memory. Let's review the following snipped of code: 1 2 3 4 5 6 7 8 9 10 int main ( void ) { int * x ; int * y ; x = malloc ( sizeof ( int )); * x = 42 ; * y = 13 ; } Here, the first two lines of code in our main function are declaring two pointers, x and y . Then, we allocate enough memory for an int with malloc , and stores the address returned by malloc into x . With *x = 42; , we got to the address pointed to by x , and stores the value of 42 into that location. The final line, though, is buggy since we don't know what the value of y is, since we never set a value for it. Instead , we can write: y = x ; * y = 13 ; For a more fun way to understand the above, take a look at the short clip, Pointer Fun with Blinky . Resizing arrays In the arrays notes, we learned about arrays, where we could store the same kind of value in a list side-by-side. But we need to declare the size of arrays when we create them, and when we want to increase the size of the array, the memory surrounding it might be taken up by some other data. One solution might be to allocate more memory in a larger area that's free, and move our array there, where it has more space. This sounds like it could work, but we'll need to copy our array, which becomes an operation with running time of O(n) , since we need to copy each of n elements in an array. We might write a program like the following, to do this in code: copy array code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <stdio.h> #include <stdlib.h> int main ( void ) { // Here, we allocate enough memory to fit three integers, and our variable // list will point to the first integer. int * list = malloc ( 3 * sizeof ( int )); // We should check that we allocated memory correctly, since malloc might // fail to get us enough free memory. if ( list == NULL ) { return 1 ; } // With this syntax, the compiler will do pointer arithmetic for us, and // calculate the byte in memory that list[0], list[1], and list[2] maps to, // since integers are 4 bytes large. list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Now, if we want to resize our array to fit 4 integers, we'll try to allocate // enough memory for them, and temporarily use tmp to point to the first: int * tmp = malloc ( 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, we copy integers from the old array into the new array ... for ( int i = 0 ; i < 3 ; i ++ ) { tmp [ i ] = list [ i ]; } // ... and add the fourth integer: tmp [ 3 ] = 4 ; // We should free the original memory for list, which is why we need a // temporary variable to point to the new array ... free ( list ); // ... and now we can set our list variable to point to the new array that // tmp points to: list = tmp ; // Now, we can print the new array: for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } // And finally, free the memory for the new array. free ( list ); } It turns out that there\u2019s actually a helpful function, realloc , which will reallocate some memory: realloc example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <stdlib.h> int main ( void ) { int * list = malloc ( 3 * sizeof ( int )); if ( list == NULL ) { return 1 ; } list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Here, we give realloc our original array that list points to, and it will // return a new address for a new array, with the old data copied over: int * tmp = realloc ( list , 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, all we need to do is remember the location of the new array: list = tmp ; list [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } free ( list ); } Data Structures Data structures are programming constructs that allow us to store information in different layouts in our computer\u2019s memory. To build a data structure, we\u2019ll need some tools we\u2019ve seen: struct to create custom data types . to access properties in structure * to go to an address in memory pointed to by a pointer Linked Lists So far, we've only had one kind of data structure for representing collections of like values - struct - which give us \"containers\" for holding variables of different types, typically. Arrays are great for element lookup, but unless we want to insert at the very end of an array, inserting elements is quite costly. Arrays also suffer from great inflexibility - what happens if we need a larger array than we thought? Through clever use of pointers, dynamic memory allocation and struct s, we can put the pieces together to develop a new kind of data structure that gives us the ability to grow and shrink a collection of like values to fit our needs. We call this combination of elements, when used in this way, a linked list . A linked list node is a special kind of struct with two members: Data of some type ( int , char , float ...) A pointer to another node of the same type In this way, a set of nodes together can be thought of as forming a chain of elements that we can follow from beginning to end. With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory: This is different than an array since our values are no longer next to one another in memory. This uses two chunks of memory, where the second chunk is used to point at the next chunk of memory. By the way, NUL refers to \\0 , a character that ends a string, and NULL refers to an address of all zeros, or a null pointer that we can think of as pointing nowhere. These chunks are linked by the pointers in the second chunk of memory. In order to work with linked lists effectively, there are a number of operations that we need to understand: Create a linked list when it doesn't already exist . Search through a linked list to find an element . Insert a new node into the linked list . Delete a single element from a linked list . Delete an entire linked list . Create a linked list sllnode * create ( VALUE val ); // ssl stands for \"single-linked list\" in the following code Steps involved: Dynamically allocate space for a new sllnode . Check to make sure we didn't run out of memory. Initialize the node's val field. Initialize the node's next field. Return a pointer to the newly created sllnode . Search through a linked list to find an element bool find ( sllnode * head , VALUE val ); Steps involved: Create a traversal pointer pointing to the list's head. If the current node's val field is what we're looking for, report success. If not, set the traversal point to the next pointer in the list and go back to step 2 (above). If you've reached the end of the list, report failure. Insert a new node into the linked list sllnode * insert ( sllnode * head , VALUE val ); Steps involved: Dynamically allocate space for a new sllnode . Check to make sure we didn't run out of memory. Populate and insert the node at the beginning of the linked list. Return a pointer to the new head of the linked list. Delete a single element from a linked list Deleting a single element from a singley-linked list can be a little tricky because it can cause different problems. There are solutions for this in doubley-linked lists. Delete an entire linked list void destroy ( sllnode * head ); Steps involved: If you've reached a null pointer, stop. Delete the rest of the list. Free the current node. Additional linked list notes Unlike with arrays, we no longer randomly access elements in a linked list. For example, we can no longer access the 5 th element of the list by calculating where it is, in constant time. (Since we know arrays store elements back-to-back, we can add 1, or 4, or the size of our element, to calculate addresses.) Instead, we have to follow each element\u2019s pointer, one at a time. And we need to allocate twice as much memory as we needed before for each element. In code, we might create our own struct called node (like a node from a graph in mathematics), and we need to store both an int and a pointer to the next node called next . 1 2 3 4 5 6 typedef struct node { int number ; struct node * next ; } node ; // this is the nickname for struct node We start this struct with typedef struct node so that we can refer to a node inside our struct. We can build a linked list in code starting with our struct. First, we'll want to remember an empty list, so we can use the null pointer: node *list = NULL; . To add an element, first we'll need to allocate some memory for a node, and set its values: 1 2 3 4 5 6 7 8 9 10 11 12 node * n = malloc ( sizeof ( node )); // We want to make sure malloc succeeded in getting memory for us: if ( n != NULL ) { // This (->) is equivalent to (*n).number, where we first go to the node pointed // to by n, and then set the number property. In C, we can also use this // arrow notation: n -> number = 2 ; // Then we need to store a pointer to the next node in our list, but the // new node won't point to anything (for now): n -> next = NULL ; } Now our list can point to this node: list = n; : To add to our lsit, we'll create a new node the same way, perhaps with the value 4. But now we need to update the pointer in our first node to point to it. since our list pointer points only to the first node (and we can't be sure that the list only has one node), we need to \"follow the breadcrumbs\" and follow each node's next pointer: 1 2 3 4 5 6 7 8 9 10 // Create temporary pointer to what list is pointing to node * tmp = list ; // As long as the node has a next pointer ... while ( tmp -> next != NULL ) { // ... set the temporary to the next node tmp = tmp -> next ; } // Now, tmp points to the last node in our list, and we can update its next // pointer to point to our new node. If we want to insert a node to the front of our linked list, we would need to carefully update our node to point to the one following it, before updating the list. Otherwise, we'll lose the rest of our list: 1 2 3 4 5 // Here, we're inserting a node into the front of the list, so we want its // next pointer to point to the original list, before pointing the list to // n: n -> next = list ; list = n ; And to insert a node in the middle of our list, we can go through the list, following each element one at a time, comparing its values, and changing the next pointers carefully as well. We can combine all of our snippets of code into a complete program: node example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include <stdio.h> #include <stdlib.h> // Represents a node typedef struct node { int number ; struct node * next ; } node ; int main ( void ) { // List of size 0, initially not pointing to anything node * list = NULL ; // Add number to list node * n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 1 ; n -> next = NULL ; // We create our first node, store the value 1 in it, and leave the next // pointer to point to nothing. Then, our list variable can point to it. list = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 2 ; n -> next = NULL ; // Now, we go our first node that list points to, and sets the next pointer // on it to point to our new node, adding it to the end of the list: list -> next = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 3 ; n -> next = NULL ; // We can follow multiple nodes with this syntax, using the next pointer // over and over, to add our third new node to the end of the list: list -> next -> next = n ; // Normally, though, we would want a loop and a temporary variable to add // a new node to our list. // Print list // Here we can iterate over all the nodes in our list with a temporary // variable. First, we have a temporary pointer, tmp, that points to the // list. Then, our condition for continuing is that tmp is not NULL, and // finally, we update tmp to the next pointer of itself. for ( node * tmp = list ; tmp != NULL ; tmp = tmp -> next ) { // Within the node, we'll just print the number stored: printf ( \"%i \\n \" , tmp -> number ); } // Free list // Since we're freeing each node as we go along, we'll use a while loop // and follow each node's next pointer before freeing it, but we'll see // this in more detail in Problem Set 5. while ( list != NULL ) { node * tmp = list -> next ; free ( list ); list = tmp ; } } Hash Table Hash tables combine the random access ability of an array with the dynamism of a linked list. This means (assuming we define our hash table well): Insetion can start to tend toward \u0398(1) Deletion can start to tend toward \u0398(1) Lookup can start to tend toward \u0398(1) \u0398 above stands for the average case. We're gaining the advantages of both types of data structure (arrays & linked lists), while mitigating the disadvantages. To get this performance upgrade, we create a new structure whereby when we insert data into the structure, the data itself gives us a clue about where we will find the data, should we need to look it up later. A hash table amounts to a combination of two things: First, a hash function , which returns a nonnegative integer value called a hash code . Second, an array capable of storing data of the type we wish to place into the data structure. The idea is that we run our data through the hash function, and then store the data in the element of the array represented by the returned hash code. We can implement this in a hash table with an array of 26 pointers, each of which points to a linked list for a letter of the alphabet: Since we have random access with arrays, we can add elements quickly, and also index quickly into a bucket. A bucket might have might have multiple matching values, so we'll use a linked list to store all of them horizontally. (We call this a collision, when two values match in the same way.) This is called a hash table because we use a hash function, which takes some input and maps it to a bucket it should go in. In our example, the hash function is just at the first letter of the name, so it might return 0 for \"Albus\" and 25 for \"Zacharias\". But in the worst case, all the names might start with the same letter, so we might end up with the equivalent of a single linked list again. We might look at the first two letters, and allocate enough buckets for 26x26 possible hashed values, or even the first three letters, and now we\u2019ll need 26x26x26 buckets. But we could still have a worst case where all our values start with the same three characters, so the running time for search is O ( n ). In practice, though, we can get closer to O (1) if we have about as many buckets as possible values, especially if we have an ideal hash function, where we can sort our inputs into unique buckets. Tries We can use another data structure called a trie (prounounced like \"try\", and is short for \"retrieval\"): Tries combine structures and poiinters together to store data in an interesting way. The data to be searched for in the trie is now a roadmap. If you can follow the map from beginning to end, the data exists in the trie, if you can't, it does not exist in the trie. Unlike with a hash table, there are no collisions, and no two pieces of data (unless they are identical) have the same path. Imagine we want to store a dictionary of words efficiently, and be able to access each one in constant time. A trie is like a tree, but each node is an array. Each array will have each letter, A-Z, stored. For each word, the first letter will point to an array, where the next valid letter will point to another array, and so on, until we reach something indicating the end of a valid word. If our word isn\u2019t in the trie, then one of the arrays won\u2019t have a pointer or terminating character for our word. Now, even if our data structure has lots of words, the lookup time will be just the length of the word we\u2019re looking for, and this might be a fixed maximum so we have O (1) for searching and insertion. The cost for this, though, is 26 times as much memory as we need for each character. More data structures A tree is another data structure where each node points to two other nodes, one to the left (with a smaller value) and one to the right (with a larger value): Notice that there are now two dimensions to this data structure, where some nodes are on different \"levels\" than others. We can imagine implementing this with a more complex version of a node in a linked list, where each node has not one but two pointers, one to the value in the \"middle of the left half\" and one to the value in the \"middle of the right half\". Note: all elements to the left of the node are smaller and all elements to the right are greater. This is called a binary search tree because each node has at most two children, or nodes it is pointing to, and a search tree because it's sorted in a way that allows us to search correctly. And like a linked list, we'll want to keep a pointer to just the beginning of the list, but in this case we want to point to the root, or top center node of the tree (the 4 in the image above). Now, we can easily do binary search, and since each node is pointing to another, we can also insert nodes into the tree without moving all of them around as we would have to do with an array. Recursively searching this tree would look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 typedef struct node { int number ; struct node * left ; struct node * right ; } node ; // Here, *tree is a pointer to the root of our tree. bool search ( node * tree ) { // We need a base case, if the current tree (or part of the tree) is NULL, // to return false: if ( tree == NULL ) { return false ; } // Now, depending on if the number in the current node is bigger or smaller, // we can just look at the left or right side of the tree: else if ( 50 < tree -> number ) { return search ( tree -> left ); } else if ( 50 > tree -> number ) { return search ( tree -> right ); } // Otherwise, the number must be equal to what we're looking for: else { return true ; } } The running time of searching a tree is O (log n ) and inserting nodes while keeping the tree balances is also O (log n ). By spending a bit more memory and time to maintain the tree, we've now gained faster searching compared to a plain linked list. There are even higher-level constructs, abstract data structures , where we use our building blocks of arrays, linked lists, hash tables, and tries to implement a solution to some problem. For example, one abstract data structure is a queue , where we want to be able to add values and remove values in a first-in-first-out (FIFO) way. To add a value we might enqueue it, and to remove a value we would dequeue it. And we can implement this with an array that we resize as we add items, or a linked list where we append values to the end. An \u201copposite\u201d data structure would be a stack , where items most recently added (pushed) are removed (popped) first, in a last-in-first-out (LIFO) way. Our email inbox is a stack, where our most recent emails are at the top. Another example is a dictionary , where we can map keys to values, or strings to values, and we can implement one with a hash table where a word comes with some other information (like its definition or meaning).","title":"Data Structures Overview"},{"location":"c-data-structures/#data-structures","text":"","title":"Data Structures"},{"location":"c-data-structures/#data-structures-summary","text":"By this point we've now examined four different ways to store sets of data: Arrays Linked lists Hash tables Tries There are even some variations on these (trees and heaps, quite similar to tries, stacks and queues quite similar to arrays or linked lists, etc.) but this will generally cover most of what we're looking at in C.","title":"Data Structures Summary"},{"location":"c-data-structures/#arrays","text":"Insertion is bad - lots of shifting to fit an element in the middle. Deletion is bad - lots of shifting after removing an element. Lookup is great - random access, constant time. Relatively easy to sort. Relatively small size-wise. Stuck with a fixed size, no flexibility.","title":"Arrays"},{"location":"c-data-structures/#linked-lists","text":"Insertion is easy - just tack onto the front. Deletion is easy - once you find the element. Lookup is bad - have to rely on linear search. Relatively difficult to sort - unless you're willing to compromise on super-fast insertion and instead sort as you construct. Relatively small size-wise (not as small as arrays).","title":"Linked lists"},{"location":"c-data-structures/#hash-tables","text":"Insertion is a two-step process - hash, then add. Deletion is easy - once you find the element. Lookup is on average better than with linked lists because you have the benefit of real-world constant factor. Not an ideal data structure if sorting is the goal - just use an array. Can run the gamut on size.","title":"Hash tables"},{"location":"c-data-structures/#tries","text":"Insertion is complex - a lot of dynamic memory allocation, but gets easier as you go. Deletion is easy - just free a node. Lookup is fast - not quite as fast as an array, but almost. Already sorted - sorts as you build in almost all situations. Rapidly becomes huge, even with very little data present, not great if space is at a premium.","title":"Tries"},{"location":"c-data-structures/#pointers","text":"In the memory notes, we learned about pointers, malloc , and other useful tools for working with memory. Let's review the following snipped of code: 1 2 3 4 5 6 7 8 9 10 int main ( void ) { int * x ; int * y ; x = malloc ( sizeof ( int )); * x = 42 ; * y = 13 ; } Here, the first two lines of code in our main function are declaring two pointers, x and y . Then, we allocate enough memory for an int with malloc , and stores the address returned by malloc into x . With *x = 42; , we got to the address pointed to by x , and stores the value of 42 into that location. The final line, though, is buggy since we don't know what the value of y is, since we never set a value for it. Instead , we can write: y = x ; * y = 13 ; For a more fun way to understand the above, take a look at the short clip, Pointer Fun with Blinky .","title":"Pointers"},{"location":"c-data-structures/#resizing-arrays","text":"In the arrays notes, we learned about arrays, where we could store the same kind of value in a list side-by-side. But we need to declare the size of arrays when we create them, and when we want to increase the size of the array, the memory surrounding it might be taken up by some other data. One solution might be to allocate more memory in a larger area that's free, and move our array there, where it has more space. This sounds like it could work, but we'll need to copy our array, which becomes an operation with running time of O(n) , since we need to copy each of n elements in an array. We might write a program like the following, to do this in code: copy array code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include <stdio.h> #include <stdlib.h> int main ( void ) { // Here, we allocate enough memory to fit three integers, and our variable // list will point to the first integer. int * list = malloc ( 3 * sizeof ( int )); // We should check that we allocated memory correctly, since malloc might // fail to get us enough free memory. if ( list == NULL ) { return 1 ; } // With this syntax, the compiler will do pointer arithmetic for us, and // calculate the byte in memory that list[0], list[1], and list[2] maps to, // since integers are 4 bytes large. list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Now, if we want to resize our array to fit 4 integers, we'll try to allocate // enough memory for them, and temporarily use tmp to point to the first: int * tmp = malloc ( 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, we copy integers from the old array into the new array ... for ( int i = 0 ; i < 3 ; i ++ ) { tmp [ i ] = list [ i ]; } // ... and add the fourth integer: tmp [ 3 ] = 4 ; // We should free the original memory for list, which is why we need a // temporary variable to point to the new array ... free ( list ); // ... and now we can set our list variable to point to the new array that // tmp points to: list = tmp ; // Now, we can print the new array: for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } // And finally, free the memory for the new array. free ( list ); } It turns out that there\u2019s actually a helpful function, realloc , which will reallocate some memory: realloc example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> #include <stdlib.h> int main ( void ) { int * list = malloc ( 3 * sizeof ( int )); if ( list == NULL ) { return 1 ; } list [ 0 ] = 1 ; list [ 1 ] = 2 ; list [ 2 ] = 3 ; // Here, we give realloc our original array that list points to, and it will // return a new address for a new array, with the old data copied over: int * tmp = realloc ( list , 4 * sizeof ( int )); if ( tmp == NULL ) { return 1 ; } // Now, all we need to do is remember the location of the new array: list = tmp ; list [ 3 ] = 4 ; for ( int i = 0 ; i < 4 ; i ++ ) { printf ( \"%i \\n \" , list [ i ]); } free ( list ); }","title":"Resizing arrays"},{"location":"c-data-structures/#data-structures_1","text":"Data structures are programming constructs that allow us to store information in different layouts in our computer\u2019s memory. To build a data structure, we\u2019ll need some tools we\u2019ve seen: struct to create custom data types . to access properties in structure * to go to an address in memory pointed to by a pointer","title":"Data Structures"},{"location":"c-data-structures/#linked-lists_1","text":"So far, we've only had one kind of data structure for representing collections of like values - struct - which give us \"containers\" for holding variables of different types, typically. Arrays are great for element lookup, but unless we want to insert at the very end of an array, inserting elements is quite costly. Arrays also suffer from great inflexibility - what happens if we need a larger array than we thought? Through clever use of pointers, dynamic memory allocation and struct s, we can put the pieces together to develop a new kind of data structure that gives us the ability to grow and shrink a collection of like values to fit our needs. We call this combination of elements, when used in this way, a linked list . A linked list node is a special kind of struct with two members: Data of some type ( int , char , float ...) A pointer to another node of the same type In this way, a set of nodes together can be thought of as forming a chain of elements that we can follow from beginning to end. With a linked list, we can store a list of values that can easily be grown by storing values in different parts of memory: This is different than an array since our values are no longer next to one another in memory. This uses two chunks of memory, where the second chunk is used to point at the next chunk of memory. By the way, NUL refers to \\0 , a character that ends a string, and NULL refers to an address of all zeros, or a null pointer that we can think of as pointing nowhere. These chunks are linked by the pointers in the second chunk of memory. In order to work with linked lists effectively, there are a number of operations that we need to understand: Create a linked list when it doesn't already exist . Search through a linked list to find an element . Insert a new node into the linked list . Delete a single element from a linked list . Delete an entire linked list .","title":"Linked Lists"},{"location":"c-data-structures/#create-a-linked-list","text":"sllnode * create ( VALUE val ); // ssl stands for \"single-linked list\" in the following code Steps involved: Dynamically allocate space for a new sllnode . Check to make sure we didn't run out of memory. Initialize the node's val field. Initialize the node's next field. Return a pointer to the newly created sllnode .","title":"Create a linked list"},{"location":"c-data-structures/#search-through-a-linked-list-to-find-an-element","text":"bool find ( sllnode * head , VALUE val ); Steps involved: Create a traversal pointer pointing to the list's head. If the current node's val field is what we're looking for, report success. If not, set the traversal point to the next pointer in the list and go back to step 2 (above). If you've reached the end of the list, report failure.","title":"Search through a linked list to find an element"},{"location":"c-data-structures/#insert-a-new-node-into-the-linked-list","text":"sllnode * insert ( sllnode * head , VALUE val ); Steps involved: Dynamically allocate space for a new sllnode . Check to make sure we didn't run out of memory. Populate and insert the node at the beginning of the linked list. Return a pointer to the new head of the linked list.","title":"Insert a new node into the linked list"},{"location":"c-data-structures/#delete-a-single-element-from-a-linked-list","text":"Deleting a single element from a singley-linked list can be a little tricky because it can cause different problems. There are solutions for this in doubley-linked lists.","title":"Delete a single element from a linked list"},{"location":"c-data-structures/#delete-an-entire-linked-list","text":"void destroy ( sllnode * head ); Steps involved: If you've reached a null pointer, stop. Delete the rest of the list. Free the current node.","title":"Delete an entire linked list"},{"location":"c-data-structures/#additional-linked-list-notes","text":"Unlike with arrays, we no longer randomly access elements in a linked list. For example, we can no longer access the 5 th element of the list by calculating where it is, in constant time. (Since we know arrays store elements back-to-back, we can add 1, or 4, or the size of our element, to calculate addresses.) Instead, we have to follow each element\u2019s pointer, one at a time. And we need to allocate twice as much memory as we needed before for each element. In code, we might create our own struct called node (like a node from a graph in mathematics), and we need to store both an int and a pointer to the next node called next . 1 2 3 4 5 6 typedef struct node { int number ; struct node * next ; } node ; // this is the nickname for struct node We start this struct with typedef struct node so that we can refer to a node inside our struct. We can build a linked list in code starting with our struct. First, we'll want to remember an empty list, so we can use the null pointer: node *list = NULL; . To add an element, first we'll need to allocate some memory for a node, and set its values: 1 2 3 4 5 6 7 8 9 10 11 12 node * n = malloc ( sizeof ( node )); // We want to make sure malloc succeeded in getting memory for us: if ( n != NULL ) { // This (->) is equivalent to (*n).number, where we first go to the node pointed // to by n, and then set the number property. In C, we can also use this // arrow notation: n -> number = 2 ; // Then we need to store a pointer to the next node in our list, but the // new node won't point to anything (for now): n -> next = NULL ; } Now our list can point to this node: list = n; : To add to our lsit, we'll create a new node the same way, perhaps with the value 4. But now we need to update the pointer in our first node to point to it. since our list pointer points only to the first node (and we can't be sure that the list only has one node), we need to \"follow the breadcrumbs\" and follow each node's next pointer: 1 2 3 4 5 6 7 8 9 10 // Create temporary pointer to what list is pointing to node * tmp = list ; // As long as the node has a next pointer ... while ( tmp -> next != NULL ) { // ... set the temporary to the next node tmp = tmp -> next ; } // Now, tmp points to the last node in our list, and we can update its next // pointer to point to our new node. If we want to insert a node to the front of our linked list, we would need to carefully update our node to point to the one following it, before updating the list. Otherwise, we'll lose the rest of our list: 1 2 3 4 5 // Here, we're inserting a node into the front of the list, so we want its // next pointer to point to the original list, before pointing the list to // n: n -> next = list ; list = n ; And to insert a node in the middle of our list, we can go through the list, following each element one at a time, comparing its values, and changing the next pointers carefully as well. We can combine all of our snippets of code into a complete program: node example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #include <stdio.h> #include <stdlib.h> // Represents a node typedef struct node { int number ; struct node * next ; } node ; int main ( void ) { // List of size 0, initially not pointing to anything node * list = NULL ; // Add number to list node * n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 1 ; n -> next = NULL ; // We create our first node, store the value 1 in it, and leave the next // pointer to point to nothing. Then, our list variable can point to it. list = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 2 ; n -> next = NULL ; // Now, we go our first node that list points to, and sets the next pointer // on it to point to our new node, adding it to the end of the list: list -> next = n ; // Add number to list n = malloc ( sizeof ( node )); if ( n == NULL ) { return 1 ; } n -> number = 3 ; n -> next = NULL ; // We can follow multiple nodes with this syntax, using the next pointer // over and over, to add our third new node to the end of the list: list -> next -> next = n ; // Normally, though, we would want a loop and a temporary variable to add // a new node to our list. // Print list // Here we can iterate over all the nodes in our list with a temporary // variable. First, we have a temporary pointer, tmp, that points to the // list. Then, our condition for continuing is that tmp is not NULL, and // finally, we update tmp to the next pointer of itself. for ( node * tmp = list ; tmp != NULL ; tmp = tmp -> next ) { // Within the node, we'll just print the number stored: printf ( \"%i \\n \" , tmp -> number ); } // Free list // Since we're freeing each node as we go along, we'll use a while loop // and follow each node's next pointer before freeing it, but we'll see // this in more detail in Problem Set 5. while ( list != NULL ) { node * tmp = list -> next ; free ( list ); list = tmp ; } }","title":"Additional linked list notes"},{"location":"c-data-structures/#hash-table","text":"Hash tables combine the random access ability of an array with the dynamism of a linked list. This means (assuming we define our hash table well): Insetion can start to tend toward \u0398(1) Deletion can start to tend toward \u0398(1) Lookup can start to tend toward \u0398(1) \u0398 above stands for the average case. We're gaining the advantages of both types of data structure (arrays & linked lists), while mitigating the disadvantages. To get this performance upgrade, we create a new structure whereby when we insert data into the structure, the data itself gives us a clue about where we will find the data, should we need to look it up later. A hash table amounts to a combination of two things: First, a hash function , which returns a nonnegative integer value called a hash code . Second, an array capable of storing data of the type we wish to place into the data structure. The idea is that we run our data through the hash function, and then store the data in the element of the array represented by the returned hash code. We can implement this in a hash table with an array of 26 pointers, each of which points to a linked list for a letter of the alphabet: Since we have random access with arrays, we can add elements quickly, and also index quickly into a bucket. A bucket might have might have multiple matching values, so we'll use a linked list to store all of them horizontally. (We call this a collision, when two values match in the same way.) This is called a hash table because we use a hash function, which takes some input and maps it to a bucket it should go in. In our example, the hash function is just at the first letter of the name, so it might return 0 for \"Albus\" and 25 for \"Zacharias\". But in the worst case, all the names might start with the same letter, so we might end up with the equivalent of a single linked list again. We might look at the first two letters, and allocate enough buckets for 26x26 possible hashed values, or even the first three letters, and now we\u2019ll need 26x26x26 buckets. But we could still have a worst case where all our values start with the same three characters, so the running time for search is O ( n ). In practice, though, we can get closer to O (1) if we have about as many buckets as possible values, especially if we have an ideal hash function, where we can sort our inputs into unique buckets.","title":"Hash Table"},{"location":"c-data-structures/#tries_1","text":"We can use another data structure called a trie (prounounced like \"try\", and is short for \"retrieval\"): Tries combine structures and poiinters together to store data in an interesting way. The data to be searched for in the trie is now a roadmap. If you can follow the map from beginning to end, the data exists in the trie, if you can't, it does not exist in the trie. Unlike with a hash table, there are no collisions, and no two pieces of data (unless they are identical) have the same path. Imagine we want to store a dictionary of words efficiently, and be able to access each one in constant time. A trie is like a tree, but each node is an array. Each array will have each letter, A-Z, stored. For each word, the first letter will point to an array, where the next valid letter will point to another array, and so on, until we reach something indicating the end of a valid word. If our word isn\u2019t in the trie, then one of the arrays won\u2019t have a pointer or terminating character for our word. Now, even if our data structure has lots of words, the lookup time will be just the length of the word we\u2019re looking for, and this might be a fixed maximum so we have O (1) for searching and insertion. The cost for this, though, is 26 times as much memory as we need for each character.","title":"Tries"},{"location":"c-data-structures/#more-data-structures","text":"A tree is another data structure where each node points to two other nodes, one to the left (with a smaller value) and one to the right (with a larger value): Notice that there are now two dimensions to this data structure, where some nodes are on different \"levels\" than others. We can imagine implementing this with a more complex version of a node in a linked list, where each node has not one but two pointers, one to the value in the \"middle of the left half\" and one to the value in the \"middle of the right half\". Note: all elements to the left of the node are smaller and all elements to the right are greater. This is called a binary search tree because each node has at most two children, or nodes it is pointing to, and a search tree because it's sorted in a way that allows us to search correctly. And like a linked list, we'll want to keep a pointer to just the beginning of the list, but in this case we want to point to the root, or top center node of the tree (the 4 in the image above). Now, we can easily do binary search, and since each node is pointing to another, we can also insert nodes into the tree without moving all of them around as we would have to do with an array. Recursively searching this tree would look something like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 typedef struct node { int number ; struct node * left ; struct node * right ; } node ; // Here, *tree is a pointer to the root of our tree. bool search ( node * tree ) { // We need a base case, if the current tree (or part of the tree) is NULL, // to return false: if ( tree == NULL ) { return false ; } // Now, depending on if the number in the current node is bigger or smaller, // we can just look at the left or right side of the tree: else if ( 50 < tree -> number ) { return search ( tree -> left ); } else if ( 50 > tree -> number ) { return search ( tree -> right ); } // Otherwise, the number must be equal to what we're looking for: else { return true ; } } The running time of searching a tree is O (log n ) and inserting nodes while keeping the tree balances is also O (log n ). By spending a bit more memory and time to maintain the tree, we've now gained faster searching compared to a plain linked list. There are even higher-level constructs, abstract data structures , where we use our building blocks of arrays, linked lists, hash tables, and tries to implement a solution to some problem. For example, one abstract data structure is a queue , where we want to be able to add values and remove values in a first-in-first-out (FIFO) way. To add a value we might enqueue it, and to remove a value we would dequeue it. And we can implement this with an array that we resize as we add items, or a linked list where we append values to the end. An \u201copposite\u201d data structure would be a stack , where items most recently added (pushed) are removed (popped) first, in a last-in-first-out (LIFO) way. Our email inbox is a stack, where our most recent emails are at the top. Another example is a dictionary , where we can map keys to values, or strings to values, and we can implement one with a hash table where a word comes with some other information (like its definition or meaning).","title":"More data structures"},{"location":"c-functions/","text":"Functions What are functions? C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented. Why us functions? Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need! Function Declarations The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number. Function Definitions The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back } Function Calls To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; } Function Miscellany Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type. Practice Problem We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Functions"},{"location":"c-functions/#functions","text":"","title":"Functions"},{"location":"c-functions/#what-are-functions","text":"C and nearly all languages developed since allow us to write functions, sometimes also known as procedures, methods, or subroutines. A function is a black box with a set of 0+ inputs and 1 output. For example: add ( a , b , c ) // or mult ( a , b ) The add function takes the input from a , b , c and will have a single output. The mult function takes the input from a , b and will have a single output. Why call it a black box ? If we aren't writing the functions ourselves, we don't need to know the underlying implementation. mult ( a , b ) : can be implemented in many different ways, including: output a * b Or set counter to 0 repeat b times (ex. 3) add a to counter (ex. 5) output counter (counter will add 3 five times with the same output as a * b) That's part of the contract of using functions. The behavior is typically predictable based on the name. That's why most functions have clear, obvious(ish) names, and are well-documented.","title":"What are functions?"},{"location":"c-functions/#why-us-functions","text":"Organization Functions help break up a complicated problem into more manageable subparts. Simplification Smaller components tend to be easier to design, implement, and debug. Reusability Functions can be recycled; you only need to write them once, but can use them as often as you need!","title":"Why us functions?"},{"location":"c-functions/#function-declarations","text":"The first step to creating a function is to declare it. This gives the compiler a heads-up that a user-written function appears in the code. Function declarations should always go atop your code, before you begin writing the main () . There is a standard form that every function declaration follows: return - type name ( argument - list ); The return - type is what kind of variable the function will output. The name is what you want to call your function. The argument - list is the comma-separated set of inputs to your function, each of which has a type and a name. Here is an example of a function declaration for a function that would add two integers together: int add_two_ints ( int a , int b ); The sum of the two integers is going to be an integer as well. Given what this function does, make sure to give it an appropriate name (like add_two_ints ). There are two inputs to this function (each of which is an integer), and we need to give a name to each of them for purposes of the function. There's nothing important about these inputs as far as we know, so giving them a simple name is okay ( a and b ). Another example for floating point numbers could be: float mult_two_floats ( float x , float y ); The product of two floating point numbers is also a floating point number.","title":"Function Declarations"},{"location":"c-functions/#function-definitions","text":"The second step to creating a function is to define it. This allows for predictable behavior when the function is called with inputs. Let's try to define the mult_two_floats from above. float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { float product = x * y ; return product ; } Or more simply: float mult_two_floats ( float x , float y ); float mult_two_floats ( float x , float y ) { return x * y ; } Now lets define add_two_ints () from earlier: int add_two_ints ( int a , int b ); int add_two_ints ( int a , int b ) { int sum ; //declare variable sum = a + b ; //calculate the sume retruen sum ; //give result back }","title":"Function Definitions"},{"location":"c-functions/#function-calls","text":"To call a function, simply pass it appropriate arguments and assign its return value to something of the correct type. Here is an example with a file called adder.c : // includes #include <cs50.h> #include <stdio.h> // declare function prototype int add_two_ints ( int a , int b ); int main ( void ) { // ask user for input int x = get_int ( \"Give me an integer: \" ); int y = get_int ( \"Give me another integer: \" ); // add the two numbers together via a function call int z = add_two_ints ( x , y ); // output the result printf ( \"The sum of %i and %i is %i! \\n \" , x , y , z ); } int add_two_ints ( int a , int b ) { int sum = a + b ; return sum ; }","title":"Function Calls"},{"location":"c-functions/#function-miscellany","text":"Recall from our discussion of data types that functions can sometimes take no inputs. In that case, we declare the function as having a void argument list. An example of this would be int main ( void ) . Recall also that functions sometimes do not have an output. In that case, we declare the function as having a void return type.","title":"Function Miscellany"},{"location":"c-functions/#practice-problem","text":"We will declare and write a function called valid_triangle that takes three real numbers representing the lengths of the three sides of a triangle as its arguments, and outputs either true or false , depending on whether those three lengths are capable of making a triangle. Note the following rules about triangles: A triangle may only have sides with positive length. The sum of the lengths of any two sides of the triangle must be greater than the length of the third side. bool valid_triangle ( float x , float y , float z ); bool valid_triangle ( float x , float y , float z ) { //check for all positive sizes if ( x <= 0 || y <= 0 || z <= 0 ) { return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { return false ; } //if both checks pass, we output true! return true ; } Now lets make one that takes in user input for fun! #include <cs50.h> #include <stdio.h> int main ( void ) { bool valid_triangle (); float x = get_float ( \"Give me the size of the first side of the triangle: \" ); float y = get_float ( \"Give me the size of the second size of the triangle: \" ); float z = get_float ( \"Give me the size of the third side of the triange: \" ); //check that all floats are positive if ( x <= 0 || y <= 0 || z <= 0 ) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //check that the sum of any two sides is greater than the third if (( x + y <= z ) || ( x + z <= y ) || ( y + z <= x )) { printf ( \"Not a valid triangle. \\n \" ); return false ; } //if both checks pass, we output true! printf ( \"That is a valid triangle! \\n \" ); return true ; }","title":"Practice Problem"},{"location":"c-memory-problems/","text":"Memory Problems Filter Implement a program that applies filters to BMPs, per the below: $ ./filter -r image.bmp reflected.bmp Background Perhaps the simplest way to represent an image is with a grid of pixels (i.e., dots), each of which can be of a different color. For black-and-white images, we thus need 1 bit per pixel, as 0 could represent black and 1 could represent white, as in the below. In this sense, then, is an image just a bitmap (i.e., a map of bits). For more colorful images, you simply need more bits per pixel. A file format (like BMP , JPEG , or PNG ) that supports \u201c24-bit color\u201d uses 24 bits per pixel. (BMP actually supports 1-, 4-, 8-, 16-, 24-, and 32-bit color.) A 24-bit BMP uses 8 bits to signify the amount of red in a pixel\u2019s color, 8 bits to signify the amount of green in a pixel\u2019s color, and 8 bits to signify the amount of blue in a pixel\u2019s color. If you\u2019ve ever heard of RGB color, well, there you have it: red, green, blue. If the R, G, and B values of some pixel in a BMP are, say, 0xff , 0x00 , and 0x00 in hexadecimal, that pixel is purely red, as 0xff (otherwise known as 255 in decimal) implies \u201ca lot of red,\u201d while 0x00 and 0x00 imply \u201cno green\u201d and \u201cno blue,\u201d respectively. A Bit(map) More Technical Recall that a file is just a sequence of bits, arranged in some fashion. A 24-bit BMP file, then, is essentially just a sequence of bits, (almost) every 24 of which happen to represent some pixel\u2019s color. But a BMP file also contains some \u201cmetadata,\u201d information like an image\u2019s height and width. That metadata is stored at the beginning of the file in the form of two data structures generally referred to as \u201cheaders,\u201d not to be confused with C\u2019s header files. (Incidentally, these headers have evolved over time. This problem uses the latest version of Microsoft\u2019s BMP format, 4.0, which debuted with Windows 95.) The first of these headers, called BITMAPFILEHEADER , is 14 bytes long. (Recall that 1 byte equals 8 bits.) The second of these headers, called BITMAPINFOHEADER , is 40 bytes long. Immediately following these headers is the actual bitmap: an array of bytes, triples of which represent a pixel\u2019s color. However, BMP stores these triples backwards (i.e., as BGR), with 8 bits for blue, followed by 8 bits for green, followed by 8 bits for red. (Some BMPs also store the entire bitmap backwards, with an image\u2019s top row at the end of the BMP file. But we\u2019ve stored this problem set\u2019s BMPs as described herein, with each bitmap\u2019s top row first and bottom row last.) In other words, were we to convert the 1-bit smiley above to a 24-bit smiley, substituting red for black, a 24-bit BMP would store this bitmap as follows, where 0000ff signifies red and ffffff signifies white; we\u2019ve highlighted in red all instances of 0000ff . Because we\u2019ve presented these bits from left to right, top to bottom, in 8 columns, you can actually see the red smiley if you take a step back. To be clear, recall that a hexadecimal digit represents 4 bits. Accordingly, ffffff in hexadecimal actually signifies 111111111111111111111111 in binary. Notice that you could represent a bitmap as a 2-dimensional array of pixels: where the image is an array of rows, each row is an array of pixels. Indeed, that\u2019s how we\u2019ve chosen to represent bitmap images in this problem. Image Filtering What does it even mean to filter an image? You can think of filtering an image as taking the pixels of some original image, and modifying each pixel in such a way that a particular effect is apparent in the resulting image. Grayscale One common filter is the \u201cgrayscale\u201d filter, where we take an image and want to convert it to black-and-white. How does that work? Recall that if the red, green, and blue values are all set to 0x00 (hexadecimal for 0 ), then the pixel is black. And if all values are set to 0xff (hexadecimal for 255 ), then the pixel is white. So long as the red, green, and blue values are all equal, the result will be varying shades of gray along the black-white spectrum, with higher values meaning lighter shades (closer to white) and lower values meaning darker shades (closer to black). So to convert a pixel to grayscale, we just need to make sure the red, green, and blue values are all the same value. But how do we know what value to make them? Well, it\u2019s probably reasonable to expect that if the original red, green, and blue values were all pretty high, then the new value should also be pretty high. And if the original values were all low, then the new value should also be low. In fact, to ensure each pixel of the new image still has the same general brightness or darkness as the old image, we can take the average of the red, green, and blue values to determine what shade of grey to make the new pixel. If you apply that to each pixel in the image, the result will be an image converted to grayscale. Sepia Most image editing programs support a \u201csepia\u201d filter, which gives images an old-timey feel by making the whole image look a bit reddish-brown. An image can be converted to sepia by taking each pixel, and computing new red, green, and blue values based on the original values of the three. There are a number of algorithms for converting an image to sepia, but for this problem, we\u2019ll ask you to use the following algorithm. For each pixel, the sepia color values should be calculated based on the original color values per the below. sepiaRed = .393 * originalRed + .769 * originalGreen + .189 * originalBlue sepiaGreen = .349 * originalRed + .686 * originalGreen + .168 * originalBlue sepiaBlue = .272 * originalRed + .534 * originalGreen + .131 * originalBlue Of course, the result of each of these formulas may not be an integer, but each value could be rounded to the nearest integer. It\u2019s also possible that the result of the formula is a number greater than 255, the maximum value for an 8-bit color value. In that case, the red, green, and blue values should be capped at 255. As a result, we can guarantee that the resulting red, green, and blue values will be whole numbers between 0 and 255, inclusive. Reflection Some filters might also move pixels around. Reflecting an image, for example, is a filter where the resulting image is what you would get by placing the original image in front of a mirror. So any pixels on the left side of the image should end up on the right, and vice versa. Note that all of the original pixels of the original image will still be present in the reflected image, it\u2019s just that those pixels may have rearranged to be in a different place in the image. Blur There are a number of ways to create the effect of blurring or softening an image. For this problem, we\u2019ll use the \u201cbox blur,\u201d which works by taking each pixel and, for each color value, giving it a new value by averaging the color values of neighboring pixels. Consider the following grid of pixels, where we\u2019ve numbered each pixel. The new value of each pixel would be the average of the values of all of the pixels that are within 1 row and column of the original pixel (forming a 3x3 box). For example, each of the color values for pixel 6 would be obtained by averaging the original color values of pixels 1, 2, 3, 5, 6, 7, 9, 10, and 11 (note that pixel 6 itself is included in the average). Likewise, the color values for pixel 11 would be be obtained by averaging the color values of pixels 6, 7, 8, 10, 11, 12, 14, 15 and 16. For a pixel along the edge or corner, like pixel 15, we would still look for all pixels within 1 row and column: in this case, pixels 10, 11, 12, 14, 15, and 16. Problem Solving Get the files for the filter HERE . Now let's look at the files provided to help break understand what is inside. bmp.h bmp.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // BMP-related data types based on Microsoft's own #include <stdint.h> /** * Common Data Types * * The data types in this section are essentially aliases for C/C++ * primitive data types. * * Adapted from http://msdn.microsoft.com/en-us/library/cc230309.aspx. * See http://en.wikipedia.org/wiki/Stdint.h for more on stdint.h. */ typedef uint8_t BYTE ; typedef uint32_t DWORD ; typedef int32_t LONG ; typedef uint16_t WORD ; /** * BITMAPFILEHEADER * * The BITMAPFILEHEADER structure contains information about the type, size, * and layout of a file that contains a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183374(VS.85).aspx. */ typedef struct { WORD bfType ; DWORD bfSize ; WORD bfReserved1 ; WORD bfReserved2 ; DWORD bfOffBits ; } __attribute__ (( __packed__ )) BITMAPFILEHEADER ; /** * BITMAPINFOHEADER * * The BITMAPINFOHEADER structure contains information about the * dimensions and color format of a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183376(VS.85).aspx. */ typedef struct { DWORD biSize ; LONG biWidth ; LONG biHeight ; WORD biPlanes ; WORD biBitCount ; DWORD biCompression ; DWORD biSizeImage ; LONG biXPelsPerMeter ; LONG biYPelsPerMeter ; DWORD biClrUsed ; DWORD biClrImportant ; } __attribute__ (( __packed__ )) BITMAPINFOHEADER ; /** * RGBTRIPLE * * This structure describes a color consisting of relative intensities of * red, green, and blue. * * Adapted from http://msdn.microsoft.com/en-us/library/aa922590.aspx. */ typedef struct { BYTE rgbtBlue ; BYTE rgbtGreen ; BYTE rgbtRed ; } __attribute__ (( __packed__ )) RGBTRIPLE ; You\u2019ll see definitions of the headers we\u2019ve mentioned ( BITMAPINFOHEADER and BITMAPFILEHEADER ). In addition, that file defines BYTE , DWORD , LONG , and WORD , data types normally found in the world of Windows programming. Notice how they\u2019re just aliases for primitives with which you are (hopefully) already familiar. It appears that BITMAPFILEHEADER and BITMAPINFOHEADER make use of these types. Perhaps most importantly, this file also defines a struct called RGBTRIPLE that, quite simply, \u201cencapsulates\u201d three bytes: one blue, one green, and one red (the order, recall, in which we expect to find RGB triples actually on disk). Why are these struct s useful? Well, recall that a file is just a sequence of bytes (or, ultimately, bits) on disk. But those bytes are generally ordered in such a way that the first few represent something, the next few represent something else, and so on. \u201cFile formats\u201d exist because the world has standardized what bytes mean what. Now, we could just read a file from disk into RAM as one big array of bytes. And we could just remember that the byte at array[i] represents one thing, while the byte at array[j] represents another. But why not give some of those bytes names so that we can retrieve them from memory more easily? That\u2019s precisely what the structs in bmp.h allow us to do. Rather than think of some file as one long sequence of bytes, we can instead think of it as a sequence of struct s. filter.c filter.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include <getopt.h> #include <stdio.h> #include <stdlib.h> #include \"helpers.h\" int main ( int argc , char * argv []) { // Define allowable filters char * filters = \"bgrs\" ; // Get filter flag and check validity char filter = getopt ( argc , argv , filters ); if ( filter == '?' ) { fprintf ( stderr , \"Invalid filter. \\n \" ); return 1 ; } // Ensure only one filter if ( getopt ( argc , argv , filters ) != -1 ) { fprintf ( stderr , \"Only one filter allowed. \\n \" ); return 2 ; } // Ensure proper usage if ( argc != optind + 2 ) { fprintf ( stderr , \"Usage: filter [flag] infile outfile \\n \" ); return 3 ; } // Remember filenames char * infile = argv [ optind ]; char * outfile = argv [ optind + 1 ]; // Open input file FILE * inptr = fopen ( infile , \"r\" ); if ( inptr == NULL ) { fprintf ( stderr , \"Could not open %s. \\n \" , infile ); return 4 ; } // Open output file FILE * outptr = fopen ( outfile , \"w\" ); if ( outptr == NULL ) { fclose ( inptr ); fprintf ( stderr , \"Could not create %s. \\n \" , outfile ); return 5 ; } // Read infile's BITMAPFILEHEADER BITMAPFILEHEADER bf ; fread ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , inptr ); // Read infile's BITMAPINFOHEADER BITMAPINFOHEADER bi ; fread ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , inptr ); // Ensure infile is (likely) a 24-bit uncompressed BMP 4.0 if ( bf . bfType != 0x4d42 || bf . bfOffBits != 54 || bi . biSize != 40 || bi . biBitCount != 24 || bi . biCompression != 0 ) { fclose ( outptr ); fclose ( inptr ); fprintf ( stderr , \"Unsupported file format. \\n \" ); return 6 ; } int height = abs ( bi . biHeight ); int width = bi . biWidth ; // Allocate memory for image RGBTRIPLE ( * image )[ width ] = calloc ( height , width * sizeof ( RGBTRIPLE )); if ( image == NULL ) { fprintf ( stderr , \"Not enough memory to store image. \\n \" ); fclose ( outptr ); fclose ( inptr ); return 7 ; } // Determine padding for scanlines int padding = ( 4 - ( width * sizeof ( RGBTRIPLE )) % 4 ) % 4 ; // Iterate over infile's scanlines for ( int i = 0 ; i < height ; i ++ ) { // Read row into pixel array fread ( image [ i ], sizeof ( RGBTRIPLE ), width , inptr ); // Skip over padding fseek ( inptr , padding , SEEK_CUR ); } // Filter image switch ( filter ) { // Blur case 'b' : blur ( height , width , image ); break ; // Grayscale case 'g' : grayscale ( height , width , image ); break ; // Reflection case 'r' : reflect ( height , width , image ); break ; // Sepia case 's' : sepia ( height , width , image ); break ; } // Write outfile's BITMAPFILEHEADER fwrite ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , outptr ); // Write outfile's BITMAPINFOHEADER fwrite ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , outptr ); // Write new pixels to outfile for ( int i = 0 ; i < height ; i ++ ) { // Write row to outfile fwrite ( image [ i ], sizeof ( RGBTRIPLE ), width , outptr ); // Write padding at end of row for ( int k = 0 ; k < padding ; k ++ ) { fputc ( 0x00 , outptr ); } } // Free memory for image free ( image ); // Close infile fclose ( inptr ); // Close outfile fclose ( outptr ); return 0 ; } First, notice the definition of filters on line 11. That string tells the program what the allowable command-line arguments to the program are: b , g , r , and s . Each of them specifies a different filter that we might apply to our images: blur, grayscale, reflection, and sepia. The next several lines open up an image file, make sure it\u2019s indeed a BMP file, and read all of the pixel information into a 2D array called image . Scroll down to the switch statement that begins on line 102. Notice that, depending on what filter we\u2019ve chosen, a different function is called: if the user chooses filter b , the program calls the blur function; if g , then grayscale is called; if r , then reflect is called; and if s , then sepia is called. Notice, too, that each of these functions take as arguments the height of the image, the width of the image, and the 2D array of pixels. The remaining lines of the program take the resulting image and write them out to a new image file. helpers.h helpers.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \"bmp.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]); This file is quite short, and just provides the function prototypes for the functions you saw earlier. Here, take note of the fact that each function takes a 2D array called image as an argument, where image is an array of height many rows, and each row is itself another array of width many GBTRIPLE s. So if image represents the whole picture, then image[0] represents the first row, and image[0][0] represents the pixel in the upper-left corner of the image. helpers.c helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \"helpers.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } Now, open up helpers.c. Here\u2019s where the implementation of the functions declared in helpers.h belong. But note that, right now, the implementations are missing! We will come back to this later. Makefile filter: clang -fsanitize=signed-integer-overflow -fsanitize=undefined -ggdb3 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -o filter filter.c helpers.c Finally, let\u2019s look at Makefile . This file specifies what should happen when we run a terminal command like make filter . Whereas programs you may have written before were confined to just one file, filter seems to use multiple files: filter.c , bmp.h , helpers.h , and helpers.c . So we\u2019ll need to tell make how to compile this file. Try compiling filter for yourself by going to your terminal and running $ make filter Then, you can run the program by running: $ ./filter -g images/yard.bmp out.bmp which takes the image at images/yard.bmp , and generates a new image called out.bmp after running the pixels through the grayscale function. grayscale doesn\u2019t do anything just yet, though, so the output image should look the same as the original yard. Code and Solution Here are our goals for the filter program: The function grayscale should take an image and turn it into a black-and-white version of the same image. The function sepia should take an image and turn it into a sepia version of the same image. The reflect function should take an image and reflect it horizontally. Finally, the blur function should take an image and turn it into a box-blurred version of the same image. Let's look at helpers.c and add some code: helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \"helpers.h\" #include \"math.h\" #include \"cs50.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int average = round (( pixel . rgbtRed + pixel . rgbtBlue + pixel . rgbtGreen ) / 3.0 ); image [ i ][ j ]. rgbtRed = image [ i ][ j ]. rgbtGreen = image [ i ][ j ]. rgbtBlue = average ; } } } // Convert image to sepia using formula given int capacity ( int value ) { return value > 255 ? 255 : value ; } void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int originalRed = pixel . rgbtRed ; int originalBlue = pixel . rgbtBlue ; int originalGreen = pixel . rgbtGreen ; image [ i ][ j ]. rgbtRed = capacity ( round ( 0.393 * originalRed + 0.769 * originalGreen + 0.189 * originalBlue )); image [ i ][ j ]. rgbtGreen = capacity ( round ( 0.349 * originalRed + 0.686 * originalGreen + 0.168 * originalBlue )); image [ i ][ j ]. rgbtBlue = capacity ( round ( 0.272 * originalRed + 0.534 * originalGreen + 0.131 * originalBlue )); } } } // Reflect image horizontally void swap ( RGBTRIPLE * pixel1 , RGBTRIPLE * pixel2 ) { RGBTRIPLE temp = * pixel1 ; * pixel1 = * pixel2 ; * pixel2 = temp ; } void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width / 2 ; j ++ ) { swap ( & image [ i ][ j ], & image [ i ][ width - 1 - i ]); } } } // Blur image bool is_valid ( int i , int j , int height , int width ) { return i >= 0 && i < height && j >= 0 && j < width ; } RGBTRIPLE get_blur ( int i , int j , int height , int width , RGBTRIPLE image [ height ][ width ]) { int redValue , blueValue , greenValue ; redValue = blueValue = greenValue = 0 ; int num_valid_pixels = 0 ; for ( int di = -1 ; di <= 1 ; di ++ ) // di stand for change in i { for ( int dj = -1 ; dj <= 1 ; dj ++ ) { int new_i = i + di ; int new_j = j + dj ; if ( is_valid ( new_i , new_j , height , width )) { num_valid_pixels ++ ; redValue += image [ new_i ][ new_j ]. rgbtRed ; blueValue += image [ new_i ][ new_j ]. rgbtBlue ; greenValue += image [ new_i ][ new_j ]. rgbtGreen ; } } } RGBTRIPLE blurred_pix ; blurred_pix . rgbtRed = round (( float ) redValue / num_valid_pixels ); blurred_pix . rgbtGreen = round (( float ) greenValue / num_valid_pixels ); blurred_pix . rgbtBlue = round (( float ) blueValue / num_valid_pixels ); return blurred_pix ; } void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { RGBTRIPLE blur_image [ height ][ width ]; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { blur_image [ i ][ j ] = get_blur ( i , j , height , width , image ); } } for ( int i = 0 ; i < height ; i ++ ) for ( int j = 0 ; j < width ; j ++ ) image [ i ][ j ] = blur_image [ i ][ j ]; } Recover Implement a program that recovers JPEGs from a forensic image, per the below. $ ./recover card.raw Background Sometimes, after taking an image, we may delete them by accident. Thankfully, in the computer world, \u201cdeleted\u201d tends not to mean \u201cdeleted\u201d so much as \u201cforgotten.\u201d Even though the camera insists that the card is now blank, we\u2019re pretty sure that\u2019s not quite true. Even though JPEGs are more complicated than BMPs, JPEGs have \u201csignatures,\u201d patterns of bytes that can distinguish them from other file formats. Specifically, the first three bytes of JPEGs are: 0xff 0xd8 0xff from first byte to third byte, left to right. The fourth byte, meanwhile, is either 0xe0 , 0xe1 , 0xe2 , 0xe3 , 0xe4 , 0xe5 , 0xe6 , 0xe7 , 0xe8 , 0xe9 , 0xea , 0xeb , 0xec , 0xed , 0xee , or 0xef . Put another way, the fourth byte\u2019s first four bits are 1110 . Odds are, if you find this pattern of four bytes on media known to store photos (e.g., my memory card), they demarcate the start of a JPEG. To be fair, you might encounter these patterns on some disk purely by chance, so data recovery isn\u2019t an exact science. Fortunately, digital cameras tend to store photographs contiguously on memory cards, whereby each photo is stored immediately after the previously taken photo. Accordingly, the start of a JPEG usually demarks the end of another. However, digital cameras often initialize cards with a FAT file system whose \u201cblock size\u201d is 512 bytes (B). The implication is that these cameras only write to those cards in units of 512 B. A photo that\u2019s 1 MB (i.e., 1,048,576 B) thus takes up 1048576 \u00f7 512 = 2048 \u201cblocks\u201d on a memory card. But so does a photo that\u2019s, say, one byte smaller (i.e., 1,048,575 B)! The wasted space on disk is called \u201cslack space.\u201d Forensic investigators often look at slack space for remnants of suspicious data. The implication of all these details is that you, the investigator, can probably write a program that iterates over a copy of my memory card, looking for JPEGs\u2019 signatures. Each time you find a signature, you can open a new file for writing and start filling that file with bytes from my memory card, closing that file only once you encounter another signature. Moreover, rather than read my memory card\u2019s bytes one at a time, you can read 512 of them at a time into a buffer for efficiency\u2019s sake. Thanks to FAT, you can trust that JPEGs\u2019 signatures will be \u201cblock-aligned.\u201d That is, you need only look for those signatures in a block\u2019s first four bytes. Realize, of course, that JPEGs can span contiguous blocks. Otherwise, no JPEG could be larger than 512 B. But the last byte of a JPEG might not fall at the very end of a block. Recall the possibility of slack space. But not to worry. Because this memory card was brand-new when I started snapping photos, odds are it\u2019d been \u201czeroed\u201d (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. It\u2019s okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable. Now, I only have one memory card, but there are a lot of you! And so I\u2019ve gone ahead and created a \u201cforensic image\u201d of the card, storing its contents, byte after byte, in a file called card.raw . So that you don\u2019t waste time iterating over millions of 0s unnecessarily, I\u2019ve only imaged the first few megabytes of the memory card. But you should ultimately find that the image contains 50 JPEGs. Problem Solving Get the files for the recovery problem HERE . Let's take a look at the code provided in the .zip: recover.c code 1 2 3 4 5 6 7 #include <stdio.h> #include <stdlib.h> int main ( int argc , char * argv []) { } The above code is basically bare of anything, which means we should break down what we need to do: Tasks Open memory card Look for beginning of a JPEG Open a new JPEG file Write 512 bytes until a new JPEG is found Stop at the end of the file Let's look at some things we can do for each step: Open memory card We can take advantage of the fopen() function to open the memory card: FILE * f = fopen ( filename , \"r\" ); Here inside the fopen(); the filename is the name of the file you are trying to open and the \"r\" means you want to read the files. Look for beginning of a JPEG As mentioned previously, each JPEG file starts with a distinct header, meaning that first byte is always 0xff , the second byte is always 0xd8 , the third byte is always 0xff , and the fourth byte can vary a little bit, but always start with 0xe . Luckily for us, each JPEG is stored back-to-back in this problem file. We can utilize the fread() function to look for JPEGs. fread ( data , size , number , inptr ); The above code can be broken down as: data : pointer to where to store data you're reading. size : size of each element to read. number : number of elements to read. inptr : FILE * to read from. For example, we can check to see if the first byte of an array, for example called buffer , contains 0xff : buffer [ 0 ] == 0xff buffer [ 1 ] == 0xd8 buffer [ 2 ] == 0xff buffer[3] is a little bit more confusing because it can vary. We could use a boolean expression here to check all the different variations to start: buffer [ 3 ] == 0xe0 || buffer [ 3 ] == 0xe1 || buffer [ 3 ] == 0xe2 ... But having to write out all 16 variations could become tedious. For a shortcut, we could use bitwise arithmatic: ( buffer [ 3 ] & 0xf0 ) == 0xe0 This is going to say to look at the first 4 bits of this 8 bit byte, and set the remaining 4 bytes to zero. This clears out the last 4 bits and compares the results. Open a new JPEG file After we find a JPEG, we need to make a new JPEG file. To begin we need to have filenames set as ###.jpg , starting at 000.jpg . This will help us keep track of the number of JPEGs found. We can utilize the sprintf() function here, where instead of printing to the terminal, it prints to a string . For example, we could use the following code: sprintf ( filename , \"%03i.jpg\" , 2 ); %03i.jpg simply means to print an integer with 3 digits. Next, to create the new file, we can use the fopen() function again: FILE * img = fopen ( filename , \"w\" ); Notice the \"w\" , which stands for write. To begin writing the new file, we can use the fwrite function: fwrite ( data , size , number , outptr ); The above code can be broken down as: data : pointer to bytes that will be written to file. size : size of each element to write. number : number of elements to write. outptr : FILE * to write to. Returns number of items of size size were read. Pseudocode Open memory card Repeat until end of card: Read 512 bytes into a buffer If start of new JPEG If first JPEG ... Else ... Else If already found JPEG Solution recover.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <stdio.h> #include <stdlib.h> #include <cs50.h> #include <stdint.h> typedef uint8_t BYTE ; //defining BYTE as a byte (unsigned integer of length = 8 bits) #define BLOCK_SIZE 512 // setting BLOCK_SIZE to 512 bytes #define FILE_NAME_SIZE 8 bool start_jpeg ( BYTE buffer []); int main ( int argc , char * argv []) { if ( argc != 2 ) { printf ( \"Usage: ./recover image \\n \" ); return 1 ; } FILE * infile = fopen ( argv [ 1 ], \"r\" ) if ( infile == NULL ) { printf ( \"File not found \\n \" ); return 1 ; } BYTE buffer [ BLOCK_SIZE ]; int file_index = 0 ; bool first_jpeg = false ; FILE * outfile ; while ( fread ( buffer , BLOCK_SIZE , 1 , infile )) { if ( start_jpeg ( buffer )) { if ( ! first_jpeg ) first_jpeg = true ; else fclose ( outfile ); char filename ( FILE_NAME_SIZE ); sprintf ( filename , \"%03i.jpg\" , file_index ++ ); outfile = fopen ( filename , \"w\" ); if ( outfile == NULL ) return 1 ; fwrite ( buffer , BLOCK_SIZE , 1 , outfile ); } else if ( first_jpeg ) { fwrite ( buffer , BLOCK_SIZE , 1 , outfile ) } } fclose ( outfile ); fclose ( infile ); } bool start_jpeg ( BYTE buffer []) { return buffer [ 0 ] == 0xff && buffer [ 1 ] == 0xd8 && buffer [ 2 ] == 0xff && ( buffer [ 3 ] & 0xf0 ) == 0xe0 ; }","title":"Memory Problems"},{"location":"c-memory-problems/#memory-problems","text":"","title":"Memory Problems"},{"location":"c-memory-problems/#filter","text":"Implement a program that applies filters to BMPs, per the below: $ ./filter -r image.bmp reflected.bmp","title":"Filter"},{"location":"c-memory-problems/#background","text":"Perhaps the simplest way to represent an image is with a grid of pixels (i.e., dots), each of which can be of a different color. For black-and-white images, we thus need 1 bit per pixel, as 0 could represent black and 1 could represent white, as in the below. In this sense, then, is an image just a bitmap (i.e., a map of bits). For more colorful images, you simply need more bits per pixel. A file format (like BMP , JPEG , or PNG ) that supports \u201c24-bit color\u201d uses 24 bits per pixel. (BMP actually supports 1-, 4-, 8-, 16-, 24-, and 32-bit color.) A 24-bit BMP uses 8 bits to signify the amount of red in a pixel\u2019s color, 8 bits to signify the amount of green in a pixel\u2019s color, and 8 bits to signify the amount of blue in a pixel\u2019s color. If you\u2019ve ever heard of RGB color, well, there you have it: red, green, blue. If the R, G, and B values of some pixel in a BMP are, say, 0xff , 0x00 , and 0x00 in hexadecimal, that pixel is purely red, as 0xff (otherwise known as 255 in decimal) implies \u201ca lot of red,\u201d while 0x00 and 0x00 imply \u201cno green\u201d and \u201cno blue,\u201d respectively.","title":"Background"},{"location":"c-memory-problems/#a-bitmap-more-technical","text":"Recall that a file is just a sequence of bits, arranged in some fashion. A 24-bit BMP file, then, is essentially just a sequence of bits, (almost) every 24 of which happen to represent some pixel\u2019s color. But a BMP file also contains some \u201cmetadata,\u201d information like an image\u2019s height and width. That metadata is stored at the beginning of the file in the form of two data structures generally referred to as \u201cheaders,\u201d not to be confused with C\u2019s header files. (Incidentally, these headers have evolved over time. This problem uses the latest version of Microsoft\u2019s BMP format, 4.0, which debuted with Windows 95.) The first of these headers, called BITMAPFILEHEADER , is 14 bytes long. (Recall that 1 byte equals 8 bits.) The second of these headers, called BITMAPINFOHEADER , is 40 bytes long. Immediately following these headers is the actual bitmap: an array of bytes, triples of which represent a pixel\u2019s color. However, BMP stores these triples backwards (i.e., as BGR), with 8 bits for blue, followed by 8 bits for green, followed by 8 bits for red. (Some BMPs also store the entire bitmap backwards, with an image\u2019s top row at the end of the BMP file. But we\u2019ve stored this problem set\u2019s BMPs as described herein, with each bitmap\u2019s top row first and bottom row last.) In other words, were we to convert the 1-bit smiley above to a 24-bit smiley, substituting red for black, a 24-bit BMP would store this bitmap as follows, where 0000ff signifies red and ffffff signifies white; we\u2019ve highlighted in red all instances of 0000ff . Because we\u2019ve presented these bits from left to right, top to bottom, in 8 columns, you can actually see the red smiley if you take a step back. To be clear, recall that a hexadecimal digit represents 4 bits. Accordingly, ffffff in hexadecimal actually signifies 111111111111111111111111 in binary. Notice that you could represent a bitmap as a 2-dimensional array of pixels: where the image is an array of rows, each row is an array of pixels. Indeed, that\u2019s how we\u2019ve chosen to represent bitmap images in this problem.","title":"A Bit(map) More Technical"},{"location":"c-memory-problems/#image-filtering","text":"What does it even mean to filter an image? You can think of filtering an image as taking the pixels of some original image, and modifying each pixel in such a way that a particular effect is apparent in the resulting image. Grayscale One common filter is the \u201cgrayscale\u201d filter, where we take an image and want to convert it to black-and-white. How does that work? Recall that if the red, green, and blue values are all set to 0x00 (hexadecimal for 0 ), then the pixel is black. And if all values are set to 0xff (hexadecimal for 255 ), then the pixel is white. So long as the red, green, and blue values are all equal, the result will be varying shades of gray along the black-white spectrum, with higher values meaning lighter shades (closer to white) and lower values meaning darker shades (closer to black). So to convert a pixel to grayscale, we just need to make sure the red, green, and blue values are all the same value. But how do we know what value to make them? Well, it\u2019s probably reasonable to expect that if the original red, green, and blue values were all pretty high, then the new value should also be pretty high. And if the original values were all low, then the new value should also be low. In fact, to ensure each pixel of the new image still has the same general brightness or darkness as the old image, we can take the average of the red, green, and blue values to determine what shade of grey to make the new pixel. If you apply that to each pixel in the image, the result will be an image converted to grayscale. Sepia Most image editing programs support a \u201csepia\u201d filter, which gives images an old-timey feel by making the whole image look a bit reddish-brown. An image can be converted to sepia by taking each pixel, and computing new red, green, and blue values based on the original values of the three. There are a number of algorithms for converting an image to sepia, but for this problem, we\u2019ll ask you to use the following algorithm. For each pixel, the sepia color values should be calculated based on the original color values per the below. sepiaRed = .393 * originalRed + .769 * originalGreen + .189 * originalBlue sepiaGreen = .349 * originalRed + .686 * originalGreen + .168 * originalBlue sepiaBlue = .272 * originalRed + .534 * originalGreen + .131 * originalBlue Of course, the result of each of these formulas may not be an integer, but each value could be rounded to the nearest integer. It\u2019s also possible that the result of the formula is a number greater than 255, the maximum value for an 8-bit color value. In that case, the red, green, and blue values should be capped at 255. As a result, we can guarantee that the resulting red, green, and blue values will be whole numbers between 0 and 255, inclusive. Reflection Some filters might also move pixels around. Reflecting an image, for example, is a filter where the resulting image is what you would get by placing the original image in front of a mirror. So any pixels on the left side of the image should end up on the right, and vice versa. Note that all of the original pixels of the original image will still be present in the reflected image, it\u2019s just that those pixels may have rearranged to be in a different place in the image. Blur There are a number of ways to create the effect of blurring or softening an image. For this problem, we\u2019ll use the \u201cbox blur,\u201d which works by taking each pixel and, for each color value, giving it a new value by averaging the color values of neighboring pixels. Consider the following grid of pixels, where we\u2019ve numbered each pixel. The new value of each pixel would be the average of the values of all of the pixels that are within 1 row and column of the original pixel (forming a 3x3 box). For example, each of the color values for pixel 6 would be obtained by averaging the original color values of pixels 1, 2, 3, 5, 6, 7, 9, 10, and 11 (note that pixel 6 itself is included in the average). Likewise, the color values for pixel 11 would be be obtained by averaging the color values of pixels 6, 7, 8, 10, 11, 12, 14, 15 and 16. For a pixel along the edge or corner, like pixel 15, we would still look for all pixels within 1 row and column: in this case, pixels 10, 11, 12, 14, 15, and 16.","title":"Image Filtering"},{"location":"c-memory-problems/#problem-solving","text":"Get the files for the filter HERE . Now let's look at the files provided to help break understand what is inside. bmp.h bmp.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // BMP-related data types based on Microsoft's own #include <stdint.h> /** * Common Data Types * * The data types in this section are essentially aliases for C/C++ * primitive data types. * * Adapted from http://msdn.microsoft.com/en-us/library/cc230309.aspx. * See http://en.wikipedia.org/wiki/Stdint.h for more on stdint.h. */ typedef uint8_t BYTE ; typedef uint32_t DWORD ; typedef int32_t LONG ; typedef uint16_t WORD ; /** * BITMAPFILEHEADER * * The BITMAPFILEHEADER structure contains information about the type, size, * and layout of a file that contains a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183374(VS.85).aspx. */ typedef struct { WORD bfType ; DWORD bfSize ; WORD bfReserved1 ; WORD bfReserved2 ; DWORD bfOffBits ; } __attribute__ (( __packed__ )) BITMAPFILEHEADER ; /** * BITMAPINFOHEADER * * The BITMAPINFOHEADER structure contains information about the * dimensions and color format of a DIB [device-independent bitmap]. * * Adapted from http://msdn.microsoft.com/en-us/library/dd183376(VS.85).aspx. */ typedef struct { DWORD biSize ; LONG biWidth ; LONG biHeight ; WORD biPlanes ; WORD biBitCount ; DWORD biCompression ; DWORD biSizeImage ; LONG biXPelsPerMeter ; LONG biYPelsPerMeter ; DWORD biClrUsed ; DWORD biClrImportant ; } __attribute__ (( __packed__ )) BITMAPINFOHEADER ; /** * RGBTRIPLE * * This structure describes a color consisting of relative intensities of * red, green, and blue. * * Adapted from http://msdn.microsoft.com/en-us/library/aa922590.aspx. */ typedef struct { BYTE rgbtBlue ; BYTE rgbtGreen ; BYTE rgbtRed ; } __attribute__ (( __packed__ )) RGBTRIPLE ; You\u2019ll see definitions of the headers we\u2019ve mentioned ( BITMAPINFOHEADER and BITMAPFILEHEADER ). In addition, that file defines BYTE , DWORD , LONG , and WORD , data types normally found in the world of Windows programming. Notice how they\u2019re just aliases for primitives with which you are (hopefully) already familiar. It appears that BITMAPFILEHEADER and BITMAPINFOHEADER make use of these types. Perhaps most importantly, this file also defines a struct called RGBTRIPLE that, quite simply, \u201cencapsulates\u201d three bytes: one blue, one green, and one red (the order, recall, in which we expect to find RGB triples actually on disk). Why are these struct s useful? Well, recall that a file is just a sequence of bytes (or, ultimately, bits) on disk. But those bytes are generally ordered in such a way that the first few represent something, the next few represent something else, and so on. \u201cFile formats\u201d exist because the world has standardized what bytes mean what. Now, we could just read a file from disk into RAM as one big array of bytes. And we could just remember that the byte at array[i] represents one thing, while the byte at array[j] represents another. But why not give some of those bytes names so that we can retrieve them from memory more easily? That\u2019s precisely what the structs in bmp.h allow us to do. Rather than think of some file as one long sequence of bytes, we can instead think of it as a sequence of struct s. filter.c filter.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 #include <getopt.h> #include <stdio.h> #include <stdlib.h> #include \"helpers.h\" int main ( int argc , char * argv []) { // Define allowable filters char * filters = \"bgrs\" ; // Get filter flag and check validity char filter = getopt ( argc , argv , filters ); if ( filter == '?' ) { fprintf ( stderr , \"Invalid filter. \\n \" ); return 1 ; } // Ensure only one filter if ( getopt ( argc , argv , filters ) != -1 ) { fprintf ( stderr , \"Only one filter allowed. \\n \" ); return 2 ; } // Ensure proper usage if ( argc != optind + 2 ) { fprintf ( stderr , \"Usage: filter [flag] infile outfile \\n \" ); return 3 ; } // Remember filenames char * infile = argv [ optind ]; char * outfile = argv [ optind + 1 ]; // Open input file FILE * inptr = fopen ( infile , \"r\" ); if ( inptr == NULL ) { fprintf ( stderr , \"Could not open %s. \\n \" , infile ); return 4 ; } // Open output file FILE * outptr = fopen ( outfile , \"w\" ); if ( outptr == NULL ) { fclose ( inptr ); fprintf ( stderr , \"Could not create %s. \\n \" , outfile ); return 5 ; } // Read infile's BITMAPFILEHEADER BITMAPFILEHEADER bf ; fread ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , inptr ); // Read infile's BITMAPINFOHEADER BITMAPINFOHEADER bi ; fread ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , inptr ); // Ensure infile is (likely) a 24-bit uncompressed BMP 4.0 if ( bf . bfType != 0x4d42 || bf . bfOffBits != 54 || bi . biSize != 40 || bi . biBitCount != 24 || bi . biCompression != 0 ) { fclose ( outptr ); fclose ( inptr ); fprintf ( stderr , \"Unsupported file format. \\n \" ); return 6 ; } int height = abs ( bi . biHeight ); int width = bi . biWidth ; // Allocate memory for image RGBTRIPLE ( * image )[ width ] = calloc ( height , width * sizeof ( RGBTRIPLE )); if ( image == NULL ) { fprintf ( stderr , \"Not enough memory to store image. \\n \" ); fclose ( outptr ); fclose ( inptr ); return 7 ; } // Determine padding for scanlines int padding = ( 4 - ( width * sizeof ( RGBTRIPLE )) % 4 ) % 4 ; // Iterate over infile's scanlines for ( int i = 0 ; i < height ; i ++ ) { // Read row into pixel array fread ( image [ i ], sizeof ( RGBTRIPLE ), width , inptr ); // Skip over padding fseek ( inptr , padding , SEEK_CUR ); } // Filter image switch ( filter ) { // Blur case 'b' : blur ( height , width , image ); break ; // Grayscale case 'g' : grayscale ( height , width , image ); break ; // Reflection case 'r' : reflect ( height , width , image ); break ; // Sepia case 's' : sepia ( height , width , image ); break ; } // Write outfile's BITMAPFILEHEADER fwrite ( & bf , sizeof ( BITMAPFILEHEADER ), 1 , outptr ); // Write outfile's BITMAPINFOHEADER fwrite ( & bi , sizeof ( BITMAPINFOHEADER ), 1 , outptr ); // Write new pixels to outfile for ( int i = 0 ; i < height ; i ++ ) { // Write row to outfile fwrite ( image [ i ], sizeof ( RGBTRIPLE ), width , outptr ); // Write padding at end of row for ( int k = 0 ; k < padding ; k ++ ) { fputc ( 0x00 , outptr ); } } // Free memory for image free ( image ); // Close infile fclose ( inptr ); // Close outfile fclose ( outptr ); return 0 ; } First, notice the definition of filters on line 11. That string tells the program what the allowable command-line arguments to the program are: b , g , r , and s . Each of them specifies a different filter that we might apply to our images: blur, grayscale, reflection, and sepia. The next several lines open up an image file, make sure it\u2019s indeed a BMP file, and read all of the pixel information into a 2D array called image . Scroll down to the switch statement that begins on line 102. Notice that, depending on what filter we\u2019ve chosen, a different function is called: if the user chooses filter b , the program calls the blur function; if g , then grayscale is called; if r , then reflect is called; and if s , then sepia is called. Notice, too, that each of these functions take as arguments the height of the image, the width of the image, and the 2D array of pixels. The remaining lines of the program take the resulting image and write them out to a new image file. helpers.h helpers.h code 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \"bmp.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]); // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]); This file is quite short, and just provides the function prototypes for the functions you saw earlier. Here, take note of the fact that each function takes a 2D array called image as an argument, where image is an array of height many rows, and each row is itself another array of width many GBTRIPLE s. So if image represents the whole picture, then image[0] represents the first row, and image[0][0] represents the pixel in the upper-left corner of the image. helpers.c helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \"helpers.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Convert image to sepia void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Reflect image horizontally void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } // Blur image void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { return ; } Now, open up helpers.c. Here\u2019s where the implementation of the functions declared in helpers.h belong. But note that, right now, the implementations are missing! We will come back to this later. Makefile filter: clang -fsanitize=signed-integer-overflow -fsanitize=undefined -ggdb3 -O0 -Qunused-arguments -std=c11 -Wall -Werror -Wextra -Wno-sign-compare -Wno-unused-parameter -Wno-unused-variable -Wshadow -o filter filter.c helpers.c Finally, let\u2019s look at Makefile . This file specifies what should happen when we run a terminal command like make filter . Whereas programs you may have written before were confined to just one file, filter seems to use multiple files: filter.c , bmp.h , helpers.h , and helpers.c . So we\u2019ll need to tell make how to compile this file. Try compiling filter for yourself by going to your terminal and running $ make filter Then, you can run the program by running: $ ./filter -g images/yard.bmp out.bmp which takes the image at images/yard.bmp , and generates a new image called out.bmp after running the pixels through the grayscale function. grayscale doesn\u2019t do anything just yet, though, so the output image should look the same as the original yard.","title":"Problem Solving"},{"location":"c-memory-problems/#code-and-solution","text":"Here are our goals for the filter program: The function grayscale should take an image and turn it into a black-and-white version of the same image. The function sepia should take an image and turn it into a sepia version of the same image. The reflect function should take an image and reflect it horizontally. Finally, the blur function should take an image and turn it into a box-blurred version of the same image. Let's look at helpers.c and add some code: helpers.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include \"helpers.h\" #include \"math.h\" #include \"cs50.h\" // Convert image to grayscale void grayscale ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int average = round (( pixel . rgbtRed + pixel . rgbtBlue + pixel . rgbtGreen ) / 3.0 ); image [ i ][ j ]. rgbtRed = image [ i ][ j ]. rgbtGreen = image [ i ][ j ]. rgbtBlue = average ; } } } // Convert image to sepia using formula given int capacity ( int value ) { return value > 255 ? 255 : value ; } void sepia ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < height ; j ++ ) { RGBTRIPLE pixel = image [ i ][ j ]; int originalRed = pixel . rgbtRed ; int originalBlue = pixel . rgbtBlue ; int originalGreen = pixel . rgbtGreen ; image [ i ][ j ]. rgbtRed = capacity ( round ( 0.393 * originalRed + 0.769 * originalGreen + 0.189 * originalBlue )); image [ i ][ j ]. rgbtGreen = capacity ( round ( 0.349 * originalRed + 0.686 * originalGreen + 0.168 * originalBlue )); image [ i ][ j ]. rgbtBlue = capacity ( round ( 0.272 * originalRed + 0.534 * originalGreen + 0.131 * originalBlue )); } } } // Reflect image horizontally void swap ( RGBTRIPLE * pixel1 , RGBTRIPLE * pixel2 ) { RGBTRIPLE temp = * pixel1 ; * pixel1 = * pixel2 ; * pixel2 = temp ; } void reflect ( int height , int width , RGBTRIPLE image [ height ][ width ]) { for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width / 2 ; j ++ ) { swap ( & image [ i ][ j ], & image [ i ][ width - 1 - i ]); } } } // Blur image bool is_valid ( int i , int j , int height , int width ) { return i >= 0 && i < height && j >= 0 && j < width ; } RGBTRIPLE get_blur ( int i , int j , int height , int width , RGBTRIPLE image [ height ][ width ]) { int redValue , blueValue , greenValue ; redValue = blueValue = greenValue = 0 ; int num_valid_pixels = 0 ; for ( int di = -1 ; di <= 1 ; di ++ ) // di stand for change in i { for ( int dj = -1 ; dj <= 1 ; dj ++ ) { int new_i = i + di ; int new_j = j + dj ; if ( is_valid ( new_i , new_j , height , width )) { num_valid_pixels ++ ; redValue += image [ new_i ][ new_j ]. rgbtRed ; blueValue += image [ new_i ][ new_j ]. rgbtBlue ; greenValue += image [ new_i ][ new_j ]. rgbtGreen ; } } } RGBTRIPLE blurred_pix ; blurred_pix . rgbtRed = round (( float ) redValue / num_valid_pixels ); blurred_pix . rgbtGreen = round (( float ) greenValue / num_valid_pixels ); blurred_pix . rgbtBlue = round (( float ) blueValue / num_valid_pixels ); return blurred_pix ; } void blur ( int height , int width , RGBTRIPLE image [ height ][ width ]) { RGBTRIPLE blur_image [ height ][ width ]; for ( int i = 0 ; i < height ; i ++ ) { for ( int j = 0 ; j < width ; j ++ ) { blur_image [ i ][ j ] = get_blur ( i , j , height , width , image ); } } for ( int i = 0 ; i < height ; i ++ ) for ( int j = 0 ; j < width ; j ++ ) image [ i ][ j ] = blur_image [ i ][ j ]; }","title":"Code and Solution"},{"location":"c-memory-problems/#recover","text":"Implement a program that recovers JPEGs from a forensic image, per the below. $ ./recover card.raw","title":"Recover"},{"location":"c-memory-problems/#background_1","text":"Sometimes, after taking an image, we may delete them by accident. Thankfully, in the computer world, \u201cdeleted\u201d tends not to mean \u201cdeleted\u201d so much as \u201cforgotten.\u201d Even though the camera insists that the card is now blank, we\u2019re pretty sure that\u2019s not quite true. Even though JPEGs are more complicated than BMPs, JPEGs have \u201csignatures,\u201d patterns of bytes that can distinguish them from other file formats. Specifically, the first three bytes of JPEGs are: 0xff 0xd8 0xff from first byte to third byte, left to right. The fourth byte, meanwhile, is either 0xe0 , 0xe1 , 0xe2 , 0xe3 , 0xe4 , 0xe5 , 0xe6 , 0xe7 , 0xe8 , 0xe9 , 0xea , 0xeb , 0xec , 0xed , 0xee , or 0xef . Put another way, the fourth byte\u2019s first four bits are 1110 . Odds are, if you find this pattern of four bytes on media known to store photos (e.g., my memory card), they demarcate the start of a JPEG. To be fair, you might encounter these patterns on some disk purely by chance, so data recovery isn\u2019t an exact science. Fortunately, digital cameras tend to store photographs contiguously on memory cards, whereby each photo is stored immediately after the previously taken photo. Accordingly, the start of a JPEG usually demarks the end of another. However, digital cameras often initialize cards with a FAT file system whose \u201cblock size\u201d is 512 bytes (B). The implication is that these cameras only write to those cards in units of 512 B. A photo that\u2019s 1 MB (i.e., 1,048,576 B) thus takes up 1048576 \u00f7 512 = 2048 \u201cblocks\u201d on a memory card. But so does a photo that\u2019s, say, one byte smaller (i.e., 1,048,575 B)! The wasted space on disk is called \u201cslack space.\u201d Forensic investigators often look at slack space for remnants of suspicious data. The implication of all these details is that you, the investigator, can probably write a program that iterates over a copy of my memory card, looking for JPEGs\u2019 signatures. Each time you find a signature, you can open a new file for writing and start filling that file with bytes from my memory card, closing that file only once you encounter another signature. Moreover, rather than read my memory card\u2019s bytes one at a time, you can read 512 of them at a time into a buffer for efficiency\u2019s sake. Thanks to FAT, you can trust that JPEGs\u2019 signatures will be \u201cblock-aligned.\u201d That is, you need only look for those signatures in a block\u2019s first four bytes. Realize, of course, that JPEGs can span contiguous blocks. Otherwise, no JPEG could be larger than 512 B. But the last byte of a JPEG might not fall at the very end of a block. Recall the possibility of slack space. But not to worry. Because this memory card was brand-new when I started snapping photos, odds are it\u2019d been \u201czeroed\u201d (i.e., filled with 0s) by the manufacturer, in which case any slack space will be filled with 0s. It\u2019s okay if those trailing 0s end up in the JPEGs you recover; they should still be viewable. Now, I only have one memory card, but there are a lot of you! And so I\u2019ve gone ahead and created a \u201cforensic image\u201d of the card, storing its contents, byte after byte, in a file called card.raw . So that you don\u2019t waste time iterating over millions of 0s unnecessarily, I\u2019ve only imaged the first few megabytes of the memory card. But you should ultimately find that the image contains 50 JPEGs.","title":"Background"},{"location":"c-memory-problems/#problem-solving_1","text":"Get the files for the recovery problem HERE . Let's take a look at the code provided in the .zip: recover.c code 1 2 3 4 5 6 7 #include <stdio.h> #include <stdlib.h> int main ( int argc , char * argv []) { } The above code is basically bare of anything, which means we should break down what we need to do: Tasks Open memory card Look for beginning of a JPEG Open a new JPEG file Write 512 bytes until a new JPEG is found Stop at the end of the file Let's look at some things we can do for each step: Open memory card We can take advantage of the fopen() function to open the memory card: FILE * f = fopen ( filename , \"r\" ); Here inside the fopen(); the filename is the name of the file you are trying to open and the \"r\" means you want to read the files. Look for beginning of a JPEG As mentioned previously, each JPEG file starts with a distinct header, meaning that first byte is always 0xff , the second byte is always 0xd8 , the third byte is always 0xff , and the fourth byte can vary a little bit, but always start with 0xe . Luckily for us, each JPEG is stored back-to-back in this problem file. We can utilize the fread() function to look for JPEGs. fread ( data , size , number , inptr ); The above code can be broken down as: data : pointer to where to store data you're reading. size : size of each element to read. number : number of elements to read. inptr : FILE * to read from. For example, we can check to see if the first byte of an array, for example called buffer , contains 0xff : buffer [ 0 ] == 0xff buffer [ 1 ] == 0xd8 buffer [ 2 ] == 0xff buffer[3] is a little bit more confusing because it can vary. We could use a boolean expression here to check all the different variations to start: buffer [ 3 ] == 0xe0 || buffer [ 3 ] == 0xe1 || buffer [ 3 ] == 0xe2 ... But having to write out all 16 variations could become tedious. For a shortcut, we could use bitwise arithmatic: ( buffer [ 3 ] & 0xf0 ) == 0xe0 This is going to say to look at the first 4 bits of this 8 bit byte, and set the remaining 4 bytes to zero. This clears out the last 4 bits and compares the results. Open a new JPEG file After we find a JPEG, we need to make a new JPEG file. To begin we need to have filenames set as ###.jpg , starting at 000.jpg . This will help us keep track of the number of JPEGs found. We can utilize the sprintf() function here, where instead of printing to the terminal, it prints to a string . For example, we could use the following code: sprintf ( filename , \"%03i.jpg\" , 2 ); %03i.jpg simply means to print an integer with 3 digits. Next, to create the new file, we can use the fopen() function again: FILE * img = fopen ( filename , \"w\" ); Notice the \"w\" , which stands for write. To begin writing the new file, we can use the fwrite function: fwrite ( data , size , number , outptr ); The above code can be broken down as: data : pointer to bytes that will be written to file. size : size of each element to write. number : number of elements to write. outptr : FILE * to write to. Returns number of items of size size were read. Pseudocode Open memory card Repeat until end of card: Read 512 bytes into a buffer If start of new JPEG If first JPEG ... Else ... Else If already found JPEG","title":"Problem Solving"},{"location":"c-memory-problems/#solution","text":"recover.c code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include <stdio.h> #include <stdlib.h> #include <cs50.h> #include <stdint.h> typedef uint8_t BYTE ; //defining BYTE as a byte (unsigned integer of length = 8 bits) #define BLOCK_SIZE 512 // setting BLOCK_SIZE to 512 bytes #define FILE_NAME_SIZE 8 bool start_jpeg ( BYTE buffer []); int main ( int argc , char * argv []) { if ( argc != 2 ) { printf ( \"Usage: ./recover image \\n \" ); return 1 ; } FILE * infile = fopen ( argv [ 1 ], \"r\" ) if ( infile == NULL ) { printf ( \"File not found \\n \" ); return 1 ; } BYTE buffer [ BLOCK_SIZE ]; int file_index = 0 ; bool first_jpeg = false ; FILE * outfile ; while ( fread ( buffer , BLOCK_SIZE , 1 , infile )) { if ( start_jpeg ( buffer )) { if ( ! first_jpeg ) first_jpeg = true ; else fclose ( outfile ); char filename ( FILE_NAME_SIZE ); sprintf ( filename , \"%03i.jpg\" , file_index ++ ); outfile = fopen ( filename , \"w\" ); if ( outfile == NULL ) return 1 ; fwrite ( buffer , BLOCK_SIZE , 1 , outfile ); } else if ( first_jpeg ) { fwrite ( buffer , BLOCK_SIZE , 1 , outfile ) } } fclose ( outfile ); fclose ( infile ); } bool start_jpeg ( BYTE buffer []) { return buffer [ 0 ] == 0xff && buffer [ 1 ] == 0xd8 && buffer [ 2 ] == 0xff && ( buffer [ 3 ] & 0xf0 ) == 0xe0 ; }","title":"Solution"},{"location":"c-memory/","text":"Memory In previous weeks, we have discussed binary. We have also covered how each byte has an address, or identifier, so we can refer to where our variables are actually stored. It turns out, by convention, the addresses for memory use the counting system hexadecimal , where there are 16 digits (0-9 and A-F). In binary ( base-2 ), each digit stood for a power of 2: 128 64 32 16 8 4 2 1 1 1 1 1 1 1 1 1 With 8 bits, we can count up to 255. Hexadecimal ( base-16 ) is a much more concise way to express the data on a computer's system. Hexadecimal is displayed as follows: 0 1 2 3 4 5 6 7 8 9 A B C D E F . Just like binary has place values (1, 2, 4, 8...) and decimal has place values (1, 10, 100, 1000...), hexadecimal does too. Hexadecimal's place values are by the power of 16. For example, if we were to look at the hex number 0x397, it would be as follows: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x 3 9 7 So the above number would be (3 x 256) + (9 x 16) + 7 = 919. Another example that uses alphanumeric hex characters: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x A D C This would look like (10 x 256) + (13 x 16) + 12 = 2780 in decimal form. Here, the F is a value of 15 in decimal, and each place is a power of 16, so the first F is 16^1 * 15 = 240, plus the second F with the value of 16^0 * 15 = 15, for a total of 255. Here is a quick chart to compare decimal, hexadecimal, and binary: The RGB color system also conventionally uses hexadecimal to describe the amount of each color. For example, 000000 in hexadecimal means 0 of each red, green, and blue, for a color of black. And FF0000 would be 255, or the highest possible, amount of red. With different values for each color, we can represent millions of different colors. In writing, we can also indicate a value is in hexadecimal by prefixing it with 0x , as in 0x10 , where the value is equal to 16 in decimal, as opposed to 10. 0x means nothing to a computer, this is simply to help humans see when hexadecimal will be used. Pointers Pointers provide an alternative way to pass data between functions. Up until this point we have passed all data by value, which means we have only passed a copy of that data. If we use pointers instead, we have the power to pass the actual variable itself. That means that if a change is made in one function, it can impact what happens in other functions. Let's create a small program that prints out a value of n : 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , n ); } In our computer's memory, there are now 4 bytes somewhere that have the binary value of 50, labeled n . The bytes for the variable n will start at a unique address and may look something like 0x12345678 . In C, we can actually see the address with the & operator, which means \"get the address of this variable\": 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%p \\n \" , & n ); // notice the %p and & here } When this program was run, I received the result 0x7ffe5878a42c . The address of a variable is called a pointer , which we can think of as a value that \"points\" to a location in the memory. The * operator lets us \"go to\" the location that a pointer is point to. For example, we can print *&n , where we \"go to\" the address of n and print out the value of n , 50 . The * is known as the deference operator . It \"goes to the reference\" and access that data at that location, allowing you to manipulate it at will. 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , *& n ); // notice the *&n here } We also have to use the * operator (in an unfortunately confusing way) to declare a variable that we want to be a pointer: 1 2 3 4 5 6 7 8 #include <stdio.h> int main ( void ) { int n = 50 ; int * p = & n ; // declaring the pointer variable printf ( \"%p \\n \" , p ); } Here, we use int *p to declare a variable, p , that has the type of * , a pointer, to a value of type int , an integer. Then, we can print its value (something like 0x12345678 ), or print the value at its location with printf(\"%i\\n\", *p); . In our computer\u2019s memory, the variables might look like this (each square representing a byte of memory): We have a pointer, p , with the address of some variable. We can abstract away the actual value of the addresses now, since they\u2019ll be different as we declare variables in our programs, and simply think of p as \u201cpointing at\u201d some value: An easier way to look at this is if we have a mailbox labeled \"123\", with the number \"50\" inside it. The mailbox would be int n , since it stores an integer. We might have another mailbox with the address \u201c456\u201d, inside of which is the value \u201c123\u201d, which is the address of our other mailbox. This would be int *p , since it\u2019s a pointer to an integer. A pointer , then, is a data item whose value is a memory address type describes the data located at that memory address The simplest pointer available to us in C is the NULL pointer. As you might expect, this pointer points to nothing (a fact which can actually come in handy). When you create a pointer and you don't set its value immediately, you should always set the value of the pointer to NULL. string Let's use a variable string s for a name like EMMA for an example. We should be able to access each character in EMMA with s[0] - s[4] : It actually turns out that each character is stored in memory at a byte with some address, and s is actually just a pointer with the address of the first character: Because s is just a pointer to the beginning, only the \\0 indicates the end of the string. In fact, the CS50 Library defines a string with typedef char *string , which just says that we want to name a new type, string , as a char * , or a pointer to a character. 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { char * s = \"EMMA\" ; // notice how we are no longer using string, we are using char *s printf ( \"%s \\n \" , s ); } Compare and Copy Let's create a quick program to compare integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two integers int i = get_int ( \"i: \" ); int j = get_int ( \"j: \" ); // Compare integers if ( i == j ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } We can compile and run this, and our program works as we\u2019d expect, with the same values of the two integers giving us \u201cSame\u201d and different values \u201cDifferent\u201d. Now let's try the same thing, but using strings instead of integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two strings string s = get_string ( \"s: \" ); string t = get_string ( \"t: \" ); // Compare strings' addresses if ( s == t ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } If we run the above program we will see that it will give us the result \"Different\" each time, even when the strings are identical. Why does this happen? Simply, this is caused by how C stores strings in memory. When these are compared, C looks at the addresses of the stings, not the user input data. The strings are stored in different places of memory (pointers), which will return different hexadecimal results when compared. Now let's look at how we can copy strings. Let's make a simple program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cs50.h> #include <ctype.h> #include <stdio.h> int main ( void ) { string s = get_string ( \"s: \" ); string t = s ; // copies string s to string t (but only as an address) t [ 0 ] = toupper ( t [ 0 ]); // capitalizes string t // Print string twice printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We get a string s , and copy the value of s into t . Then, we capitalize the first letter in t . But when we run our program, we see that both s and t are now capitalized. Since we set s and t to the same values, they\u2019re actually pointers to the same character, and so we capitalized the same character! To actually make a copy of a string, we have to do a little more work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <string.h> // needed for strlen (string length) int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); // malloc is \"memory allocate\" to store the copy for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) // we need n+1 for the null character in a string { t [ i ] = s [ i ]; // copies strings } t [ 0 ] = toupper ( t [ 0 ]); // capitalizes the first character of the string printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We create a new variable, t , of the type char * , with char *t . Now, we want to point it to a new chunk of memory that\u2019s large enough to store the copy of the string. With malloc , we can allocate some number of bytes in memory (that aren\u2019t already used to store other values), and we pass in the number of bytes we\u2019d like. We already know the length of s , so we add 1 to that for the terminating null character. So, our final line of code is char *t = malloc(strlen(s) + 1); . Then, we copy each character, one at a time, and now we can capitalize just the first letter of t . And we use i < n + 1 , since we actually want to go up to n , to ensure we copy the terminating character in the string. We can actually also use the strcpy library function with strcpy(t, s) instead of our loop, to copy the string s into t . To be clear, the concept of a \u201cstring\u201d is from the C language and well-supported; the only training wheels from CS50 are the type string instead of char * , and the get_string function. If we didn\u2019t copy the null terminating character, \\0 , and tried to print out our string t , printf will continue and print out the unknown, or garbage, values that we have in memory, until it happens to reach a \\0 , or crashes entirely, since our program might end up trying to read memory that doesn\u2019t belong to it! valgrind It turns out that, after we\u2019re done with memory that we\u2019ve allocated with malloc , we should call free (as in free(t) ), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again. If we kept running our program and allocating memory with malloc , but never freed the memory after we were done using it, we would have a memory leak , which will slow down our computer and use up more and more memory until our computer runs out. valgrind is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with help50 valgrind ./*program* and see, from the error message, that line 10, we allocated memory that we never freed (or \u201clost\u201d). So at the end, we can add a line free(t) , which won\u2019t change how our program runs, but no errors from valgrind. Let's look at an example program provided from valgrind's official documentation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare #include <stdlib.h> void f ( void ) { int * x = malloc ( 10 * sizeof ( int )); x [ 10 ] = 0 ; // this int [10] is not in the correct range (0-9) and will result in a buffer overflow } int main ( void ) { f (); return 0 ; } The function f allocates enough memory for 10 integers, and stores the address in a pointer called x . Then we try to set the 11 th value of x with x[10] to 0 , which goes past the array of memory we\u2019ve allocated for our program. This is called buffer overflow , where we go past the boundaries of our buffer, or array, and into unknown memory. valgrind will also tell us there\u2019s an \u201cInvalid write of size 4\u201d for line 8, where we are indeed trying to change the value of an integer (of size 4 bytes). Swap We have two colored drinks, purple and green, each of which is in a cup. We want to swap the drinks between the two cups, but we can\u2019t do that without a third cup (temporary variable) to pour one of the drink into first. Now, let\u2019s say we wanted to swap the values of two integers. 1 2 3 4 5 6 void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } With a third variable to use as temporary storage space, we can do this pretty easily, by putting a into tmp , and then b to a , and finally the original value of a , now in tmp , into b . But, if we tried to use that function in a program, we don\u2019t see any changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> void swap ( int a , int b ); int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( x , y ); printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } This does not work because the swap function successfully swaps int a and int b , but these are simply copies of int x and int y . When x and y are printed, the copies used by the swap funciton do not alter the actual x and y integers in the main function. Memory Layout Within our computer\u2019s memory, the different types of data that need to be stored for our program are organized into different sections: The machine code section is our compiled program\u2019s binary code. When we run our program, that code is loaded into the \u201ctop\u201d of memory. Globals are global variables we declare in our program or other shared variables that our entire program can access. The heap section is an empty area where malloc can get free memory from, for our program to use. The stack section is used by functions in our program as they are called. For example, our main function is at the very bottom of the stack, and has the local variables x and y . The swap function, when it\u2019s called, has its own frame, or slice, of memory that\u2019s on top of main \u2019s, with the local variables a , b , and tmp : Once the function swap returns, the memory it was using is freed for the next function call, and we lose anything we did, other than the return values, and our program goes back to the function that called swap . So by passing in the addresses of x and y from main to swap , we can actually change the values of x and y : By passing in the address of x and y , our swap function from above can actually work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> void swap ( int * a , int * b ); // we use * throughout to point to the real integer, not the copy int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( & x , & y ); // address of x and y printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; } The addresses of x and y are passed in from main to swap , and we use the int *a syntax to declare that our swap function takes in pointers. We save the value of x to tmp by following the pointer a , and then take the value of y by following the pointer b , and store that to the location a is pointing to ( x ). Finally, we store the value of tmp to the location pointed to by b ( y ), and we\u2019re done. If we call malloc too many times, we will have a heap overflow , where we end up going past our heap. Or, if we have too many functions being called, we will have a stack overflow , where our stack has too many frames of memory allocated as well. And these two types of overflow are generally known as buffer overflows, after which our program (or entire computer) might crash. get_int We can implement get_int ourselve with a C library function, scanf : 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { int x ; printf ( \"x: \" ); scanf ( \"%i\" , & x ); printf ( \"x: %i \\n \" , x ); } scanf takes a format, %i , so the input is \u201cscanned\u201d for that format, and the address in memory where we want that input to go. But scanf doesn\u2019t have much error checking, so we might not get an integer. We can try to get a string the same way: 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { char * s = NULL ; printf ( \"s: \" ); scanf ( \"%s\" , s ); printf ( \"s: %s \\n \" , s ); } But we haven\u2019t actually allocated any memory for s ( s is NULL , or not pointing to anything), so we might want to call char s[5] to allocate an array of 5 characters for our string. Then, s will be treated as a pointer in scanf and printf . Now, if the user types in a string of length 4 or less, our program will work safely. But if the user types in a longer string, scanf might be trying to write past the end of our array into unknown memory, causing our program to crash. File Pointers The ability to read data from and write data to files is the primary means of storing persistent data , data that does not disappear when your program stops running. The abstraction of files that C provides is implemented in a data structure known as a FILE . Almost universally when working with files, we will be using pointers to them, FILE* . Some of the most common file input/output (I/O) functions that we will be working with are: fopen() , fclose() , fgetc() , fputc() , fread() , and fwrite() . fopen() opens a file and returns a file pointer to it. It always checks the return value to make sure you don't get back NULL. fclose() closes the file pointed to by the given file pointer. fgetc() reads and returns the next character from the file pointed to. Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fputc() writes or appends the specified character to the pointed-to file. Note: the operation of the file pointer must be \"w\" for write or \"a\" for append, or you will have an error. fread() reads <qty> units of size <size> from the file pointed to and stores them in memory in a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fwrite() writes <qty> units of size <size> to the file pointed to by reading them from a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"w\" for write or \"a\" for append, or you will suffer an error. With the ability to use pointers, we can also open files: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { // Open file FILE * file = fopen ( \"phonebook.csv\" , \"a\" ); // Get strings from user char * name = get_string ( \"Name: \" ); char * number = get_string ( \"Number: \" ); // Print (write) strings to file fprintf ( file , \"%s,%s \\n \" , name , number ); // Close file fclose ( file ); } fopen is a new function we can use to open a file. It will return a pointer to a new type, FILE , that we can read from and write to. The first argument is the name of the file, and the second argument is the mode we want to open the file in ( r for read, w for write, and a for append, or adding to). After we get some strings, we can use fprintf to print to a file. Finally, we close the file with fclose . Now we can create our own CSV files, files of comma-separated values (like a mini-spreadsheet), programmatically. JPEG We can also write a program that opens a file and tells us if it\u2019s a JPEG (image) file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> int main ( int argc , char * argv []) { // Check usage if ( argc != 2 ) { return 1 ; } // Open file FILE * file = fopen ( argv [ 1 ], \"r\" ); if ( ! file ) { return 1 ; } // Read first three bytes unsigned char bytes [ 3 ]; fread ( bytes , 3 , 1 , file ); // Check first three bytes if ( bytes [ 0 ] == 0xff && bytes [ 1 ] == 0xd8 && bytes [ 2 ] == 0xff ) { printf ( \"Maybe \\n \" ); } else { printf ( \"No \\n \" ); } // Close file fclose ( file ); } Now, if we run this program with ./jpeg brian.jpg , our program will try to open the file we specify (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with fread . We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they\u2019re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they\u2019re not the same, we know it\u2019s definitely not a JPEG file. We can use these abilities to read and write files, in particular images, and modify them by changing the bytes in them, in this week\u2019s problem set!","title":"Memory Overview"},{"location":"c-memory/#memory","text":"In previous weeks, we have discussed binary. We have also covered how each byte has an address, or identifier, so we can refer to where our variables are actually stored. It turns out, by convention, the addresses for memory use the counting system hexadecimal , where there are 16 digits (0-9 and A-F). In binary ( base-2 ), each digit stood for a power of 2: 128 64 32 16 8 4 2 1 1 1 1 1 1 1 1 1 With 8 bits, we can count up to 255. Hexadecimal ( base-16 ) is a much more concise way to express the data on a computer's system. Hexadecimal is displayed as follows: 0 1 2 3 4 5 6 7 8 9 A B C D E F . Just like binary has place values (1, 2, 4, 8...) and decimal has place values (1, 10, 100, 1000...), hexadecimal does too. Hexadecimal's place values are by the power of 16. For example, if we were to look at the hex number 0x397, it would be as follows: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x 3 9 7 So the above number would be (3 x 256) + (9 x 16) + 7 = 919. Another example that uses alphanumeric hex characters: 256 (16 2 ) 16 (16 1 ) 1 (16 0 ) 0x A D C This would look like (10 x 256) + (13 x 16) + 12 = 2780 in decimal form. Here, the F is a value of 15 in decimal, and each place is a power of 16, so the first F is 16^1 * 15 = 240, plus the second F with the value of 16^0 * 15 = 15, for a total of 255. Here is a quick chart to compare decimal, hexadecimal, and binary: The RGB color system also conventionally uses hexadecimal to describe the amount of each color. For example, 000000 in hexadecimal means 0 of each red, green, and blue, for a color of black. And FF0000 would be 255, or the highest possible, amount of red. With different values for each color, we can represent millions of different colors. In writing, we can also indicate a value is in hexadecimal by prefixing it with 0x , as in 0x10 , where the value is equal to 16 in decimal, as opposed to 10. 0x means nothing to a computer, this is simply to help humans see when hexadecimal will be used.","title":"Memory"},{"location":"c-memory/#pointers","text":"Pointers provide an alternative way to pass data between functions. Up until this point we have passed all data by value, which means we have only passed a copy of that data. If we use pointers instead, we have the power to pass the actual variable itself. That means that if a change is made in one function, it can impact what happens in other functions. Let's create a small program that prints out a value of n : 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , n ); } In our computer's memory, there are now 4 bytes somewhere that have the binary value of 50, labeled n . The bytes for the variable n will start at a unique address and may look something like 0x12345678 . In C, we can actually see the address with the & operator, which means \"get the address of this variable\": 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%p \\n \" , & n ); // notice the %p and & here } When this program was run, I received the result 0x7ffe5878a42c . The address of a variable is called a pointer , which we can think of as a value that \"points\" to a location in the memory. The * operator lets us \"go to\" the location that a pointer is point to. For example, we can print *&n , where we \"go to\" the address of n and print out the value of n , 50 . The * is known as the deference operator . It \"goes to the reference\" and access that data at that location, allowing you to manipulate it at will. 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { int n = 50 ; printf ( \"%i \\n \" , *& n ); // notice the *&n here } We also have to use the * operator (in an unfortunately confusing way) to declare a variable that we want to be a pointer: 1 2 3 4 5 6 7 8 #include <stdio.h> int main ( void ) { int n = 50 ; int * p = & n ; // declaring the pointer variable printf ( \"%p \\n \" , p ); } Here, we use int *p to declare a variable, p , that has the type of * , a pointer, to a value of type int , an integer. Then, we can print its value (something like 0x12345678 ), or print the value at its location with printf(\"%i\\n\", *p); . In our computer\u2019s memory, the variables might look like this (each square representing a byte of memory): We have a pointer, p , with the address of some variable. We can abstract away the actual value of the addresses now, since they\u2019ll be different as we declare variables in our programs, and simply think of p as \u201cpointing at\u201d some value: An easier way to look at this is if we have a mailbox labeled \"123\", with the number \"50\" inside it. The mailbox would be int n , since it stores an integer. We might have another mailbox with the address \u201c456\u201d, inside of which is the value \u201c123\u201d, which is the address of our other mailbox. This would be int *p , since it\u2019s a pointer to an integer. A pointer , then, is a data item whose value is a memory address type describes the data located at that memory address The simplest pointer available to us in C is the NULL pointer. As you might expect, this pointer points to nothing (a fact which can actually come in handy). When you create a pointer and you don't set its value immediately, you should always set the value of the pointer to NULL.","title":"Pointers"},{"location":"c-memory/#string","text":"Let's use a variable string s for a name like EMMA for an example. We should be able to access each character in EMMA with s[0] - s[4] : It actually turns out that each character is stored in memory at a byte with some address, and s is actually just a pointer with the address of the first character: Because s is just a pointer to the beginning, only the \\0 indicates the end of the string. In fact, the CS50 Library defines a string with typedef char *string , which just says that we want to name a new type, string , as a char * , or a pointer to a character. 1 2 3 4 5 6 7 #include <stdio.h> int main ( void ) { char * s = \"EMMA\" ; // notice how we are no longer using string, we are using char *s printf ( \"%s \\n \" , s ); }","title":"string"},{"location":"c-memory/#compare-and-copy","text":"Let's create a quick program to compare integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two integers int i = get_int ( \"i: \" ); int j = get_int ( \"j: \" ); // Compare integers if ( i == j ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } We can compile and run this, and our program works as we\u2019d expect, with the same values of the two integers giving us \u201cSame\u201d and different values \u201cDifferent\u201d. Now let's try the same thing, but using strings instead of integers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> int main ( void ) { // Get two strings string s = get_string ( \"s: \" ); string t = get_string ( \"t: \" ); // Compare strings' addresses if ( s == t ) { printf ( \"Same \\n \" ); } else { printf ( \"Different \\n \" ); } } If we run the above program we will see that it will give us the result \"Different\" each time, even when the strings are identical. Why does this happen? Simply, this is caused by how C stores strings in memory. When these are compared, C looks at the addresses of the stings, not the user input data. The strings are stored in different places of memory (pointers), which will return different hexadecimal results when compared. Now let's look at how we can copy strings. Let's make a simple program: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cs50.h> #include <ctype.h> #include <stdio.h> int main ( void ) { string s = get_string ( \"s: \" ); string t = s ; // copies string s to string t (but only as an address) t [ 0 ] = toupper ( t [ 0 ]); // capitalizes string t // Print string twice printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We get a string s , and copy the value of s into t . Then, we capitalize the first letter in t . But when we run our program, we see that both s and t are now capitalized. Since we set s and t to the same values, they\u2019re actually pointers to the same character, and so we capitalized the same character! To actually make a copy of a string, we have to do a little more work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cs50.h> #include <ctype.h> #include <stdio.h> #include <string.h> // needed for strlen (string length) int main ( void ) { char * s = get_string ( \"s: \" ); char * t = malloc ( strlen ( s ) + 1 ); // malloc is \"memory allocate\" to store the copy for ( int i = 0 , n = strlen ( s ); i < n + 1 ; i ++ ) // we need n+1 for the null character in a string { t [ i ] = s [ i ]; // copies strings } t [ 0 ] = toupper ( t [ 0 ]); // capitalizes the first character of the string printf ( \"s: %s \\n \" , s ); printf ( \"t: %s \\n \" , t ); } We create a new variable, t , of the type char * , with char *t . Now, we want to point it to a new chunk of memory that\u2019s large enough to store the copy of the string. With malloc , we can allocate some number of bytes in memory (that aren\u2019t already used to store other values), and we pass in the number of bytes we\u2019d like. We already know the length of s , so we add 1 to that for the terminating null character. So, our final line of code is char *t = malloc(strlen(s) + 1); . Then, we copy each character, one at a time, and now we can capitalize just the first letter of t . And we use i < n + 1 , since we actually want to go up to n , to ensure we copy the terminating character in the string. We can actually also use the strcpy library function with strcpy(t, s) instead of our loop, to copy the string s into t . To be clear, the concept of a \u201cstring\u201d is from the C language and well-supported; the only training wheels from CS50 are the type string instead of char * , and the get_string function. If we didn\u2019t copy the null terminating character, \\0 , and tried to print out our string t , printf will continue and print out the unknown, or garbage, values that we have in memory, until it happens to reach a \\0 , or crashes entirely, since our program might end up trying to read memory that doesn\u2019t belong to it!","title":"Compare and Copy"},{"location":"c-memory/#valgrind","text":"It turns out that, after we\u2019re done with memory that we\u2019ve allocated with malloc , we should call free (as in free(t) ), which tells our computer that those bytes are no longer useful to our program, so those bytes in memory can be reused again. If we kept running our program and allocating memory with malloc , but never freed the memory after we were done using it, we would have a memory leak , which will slow down our computer and use up more and more memory until our computer runs out. valgrind is a command-line tool that we can use to run our program and see if it has any memory leaks. We can run valgrind on our program above with help50 valgrind ./*program* and see, from the error message, that line 10, we allocated memory that we never freed (or \u201clost\u201d). So at the end, we can add a line free(t) , which won\u2019t change how our program runs, but no errors from valgrind. Let's look at an example program provided from valgrind's official documentation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // http://valgrind.org/docs/manual/quick-start.html#quick-start.prepare #include <stdlib.h> void f ( void ) { int * x = malloc ( 10 * sizeof ( int )); x [ 10 ] = 0 ; // this int [10] is not in the correct range (0-9) and will result in a buffer overflow } int main ( void ) { f (); return 0 ; } The function f allocates enough memory for 10 integers, and stores the address in a pointer called x . Then we try to set the 11 th value of x with x[10] to 0 , which goes past the array of memory we\u2019ve allocated for our program. This is called buffer overflow , where we go past the boundaries of our buffer, or array, and into unknown memory. valgrind will also tell us there\u2019s an \u201cInvalid write of size 4\u201d for line 8, where we are indeed trying to change the value of an integer (of size 4 bytes).","title":"valgrind"},{"location":"c-memory/#swap","text":"We have two colored drinks, purple and green, each of which is in a cup. We want to swap the drinks between the two cups, but we can\u2019t do that without a third cup (temporary variable) to pour one of the drink into first. Now, let\u2019s say we wanted to swap the values of two integers. 1 2 3 4 5 6 void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } With a third variable to use as temporary storage space, we can do this pretty easily, by putting a into tmp , and then b to a , and finally the original value of a , now in tmp , into b . But, if we tried to use that function in a program, we don\u2019t see any changes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> void swap ( int a , int b ); int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( x , y ); printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int a , int b ) { int tmp = a ; a = b ; b = tmp ; } This does not work because the swap function successfully swaps int a and int b , but these are simply copies of int x and int y . When x and y are printed, the copies used by the swap funciton do not alter the actual x and y integers in the main function.","title":"Swap"},{"location":"c-memory/#memory-layout","text":"Within our computer\u2019s memory, the different types of data that need to be stored for our program are organized into different sections: The machine code section is our compiled program\u2019s binary code. When we run our program, that code is loaded into the \u201ctop\u201d of memory. Globals are global variables we declare in our program or other shared variables that our entire program can access. The heap section is an empty area where malloc can get free memory from, for our program to use. The stack section is used by functions in our program as they are called. For example, our main function is at the very bottom of the stack, and has the local variables x and y . The swap function, when it\u2019s called, has its own frame, or slice, of memory that\u2019s on top of main \u2019s, with the local variables a , b , and tmp : Once the function swap returns, the memory it was using is freed for the next function call, and we lose anything we did, other than the return values, and our program goes back to the function that called swap . So by passing in the addresses of x and y from main to swap , we can actually change the values of x and y : By passing in the address of x and y , our swap function from above can actually work: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <stdio.h> void swap ( int * a , int * b ); // we use * throughout to point to the real integer, not the copy int main ( void ) { int x = 1 ; int y = 2 ; printf ( \"x is %i, y is %i \\n \" , x , y ); swap ( & x , & y ); // address of x and y printf ( \"x is %i, y is %i \\n \" , x , y ); } void swap ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; } The addresses of x and y are passed in from main to swap , and we use the int *a syntax to declare that our swap function takes in pointers. We save the value of x to tmp by following the pointer a , and then take the value of y by following the pointer b , and store that to the location a is pointing to ( x ). Finally, we store the value of tmp to the location pointed to by b ( y ), and we\u2019re done. If we call malloc too many times, we will have a heap overflow , where we end up going past our heap. Or, if we have too many functions being called, we will have a stack overflow , where our stack has too many frames of memory allocated as well. And these two types of overflow are generally known as buffer overflows, after which our program (or entire computer) might crash.","title":"Memory Layout"},{"location":"c-memory/#get_int","text":"We can implement get_int ourselve with a C library function, scanf : 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { int x ; printf ( \"x: \" ); scanf ( \"%i\" , & x ); printf ( \"x: %i \\n \" , x ); } scanf takes a format, %i , so the input is \u201cscanned\u201d for that format, and the address in memory where we want that input to go. But scanf doesn\u2019t have much error checking, so we might not get an integer. We can try to get a string the same way: 1 2 3 4 5 6 7 8 9 #include <stdio.h> int main ( void ) { char * s = NULL ; printf ( \"s: \" ); scanf ( \"%s\" , s ); printf ( \"s: %s \\n \" , s ); } But we haven\u2019t actually allocated any memory for s ( s is NULL , or not pointing to anything), so we might want to call char s[5] to allocate an array of 5 characters for our string. Then, s will be treated as a pointer in scanf and printf . Now, if the user types in a string of length 4 or less, our program will work safely. But if the user types in a longer string, scanf might be trying to write past the end of our array into unknown memory, causing our program to crash.","title":"get_int"},{"location":"c-memory/#file-pointers","text":"The ability to read data from and write data to files is the primary means of storing persistent data , data that does not disappear when your program stops running. The abstraction of files that C provides is implemented in a data structure known as a FILE . Almost universally when working with files, we will be using pointers to them, FILE* . Some of the most common file input/output (I/O) functions that we will be working with are: fopen() , fclose() , fgetc() , fputc() , fread() , and fwrite() . fopen() opens a file and returns a file pointer to it. It always checks the return value to make sure you don't get back NULL. fclose() closes the file pointed to by the given file pointer. fgetc() reads and returns the next character from the file pointed to. Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fputc() writes or appends the specified character to the pointed-to file. Note: the operation of the file pointer must be \"w\" for write or \"a\" for append, or you will have an error. fread() reads <qty> units of size <size> from the file pointed to and stores them in memory in a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"r\" for read, or you will have an error. fwrite() writes <qty> units of size <size> to the file pointed to by reading them from a buffer (usually an array) pointed to by <buffer> . Note: the operation of the file pointer passed in as a parameter must be \"w\" for write or \"a\" for append, or you will suffer an error. With the ability to use pointers, we can also open files: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cs50.h> #include <stdio.h> #include <string.h> int main ( void ) { // Open file FILE * file = fopen ( \"phonebook.csv\" , \"a\" ); // Get strings from user char * name = get_string ( \"Name: \" ); char * number = get_string ( \"Number: \" ); // Print (write) strings to file fprintf ( file , \"%s,%s \\n \" , name , number ); // Close file fclose ( file ); } fopen is a new function we can use to open a file. It will return a pointer to a new type, FILE , that we can read from and write to. The first argument is the name of the file, and the second argument is the mode we want to open the file in ( r for read, w for write, and a for append, or adding to). After we get some strings, we can use fprintf to print to a file. Finally, we close the file with fclose . Now we can create our own CSV files, files of comma-separated values (like a mini-spreadsheet), programmatically.","title":"File Pointers"},{"location":"c-memory/#jpeg","text":"We can also write a program that opens a file and tells us if it\u2019s a JPEG (image) file: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <stdio.h> int main ( int argc , char * argv []) { // Check usage if ( argc != 2 ) { return 1 ; } // Open file FILE * file = fopen ( argv [ 1 ], \"r\" ); if ( ! file ) { return 1 ; } // Read first three bytes unsigned char bytes [ 3 ]; fread ( bytes , 3 , 1 , file ); // Check first three bytes if ( bytes [ 0 ] == 0xff && bytes [ 1 ] == 0xd8 && bytes [ 2 ] == 0xff ) { printf ( \"Maybe \\n \" ); } else { printf ( \"No \\n \" ); } // Close file fclose ( file ); } Now, if we run this program with ./jpeg brian.jpg , our program will try to open the file we specify (checking that we indeed get a non-NULL file back), and read the first three bytes from the file with fread . We can compare the first three bytes (in hexadecimal) to the three bytes required to begin a JPEG file. If they\u2019re the same, then our file is likely to be a JPEG file (though, other types of files may still begin with those bytes). But if they\u2019re not the same, we know it\u2019s definitely not a JPEG file. We can use these abilities to read and write files, in particular images, and modify them by changing the bytes in them, in this week\u2019s problem set!","title":"JPEG"},{"location":"c-variable-scope/","text":"Variables and Scope Variable Scope Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; } Why do local and global distinctions matter? For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Variables and Scope"},{"location":"c-variable-scope/#variables-and-scope","text":"","title":"Variables and Scope"},{"location":"c-variable-scope/#variable-scope","text":"Scope is a characteristic of a variable that defines from which functions that variable may be accessed. There are two primary scopes in C: Local Variables can only be accessed within the functions in which they are created. Global Variables can be accessed by any funtion in the program. These are declared outside of all functions. So far in the CS50 course, we have almost always been working with local variables. int main ( void ) { int result = triple ( 5 ); } int triple ( int x ) { return x * 3 ; } Here, x is local to the function triple () . No other function can refer to that variable, not even main () . result is local to main () . Global variables exist too. If a variable is declared outside of all functions, any function may refer to it. #include <stdio.h> float global = 0.5050 ; // variable is named global for ease of explanation int main ( void ) { triple (); printf ( \"%f \\n \" , global ); // global is referred to here inside a function } void triple ( void ) { global *= 3 ; }","title":"Variable Scope"},{"location":"c-variable-scope/#why-do-local-and-global-distinctions-matter","text":"For the most part, local variables in C are passed by value in function calls. When a variable is passed by value, the callee (the function receiving the variable) receives a copy of the passed variable, not the variable itself. That means that the variable in the caller (the function making the function call) is unchanged unless overwritten. For example, the following has no effect on foo : int main ( void ) { int foo = 4 ; triple ( foo ); } int triple ( int x ) { return x *= 3 ; } The following code does effect foo by overwritting it: int main ( void ) { int foo = 4 ; foo = triple ( foo ); // the call for triple here overwrites foo after the function call } int triple ( int x ) { return x *= 3 ; } Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly ok as long as the variables exist in different scopes. For example: int increment ( int x ); int main ( void ) { int x = 1 ; // x(m) - m is local to main int y ; y = increment ( x ); // x(m) printf ( \"x is %i, y is %i \\n \" , x , y ); // x(m) } int increment ( int x ) // x(i) - i is local to increment { x ++ ; // x(i) return x ; // x(i) } The above has the variable x stored locally in both int main ( void ) and int increment ( int x ) . The output of the program above would be \"x is 1, y is 2\".","title":"Why do local and global distinctions matter?"},{"location":"c/","text":"C Basics Basic Data Types int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\"). Creating a Variable To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ; Using a Variable After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment Operators In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==). Conditional Statements Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); } Loops Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled. First Code #include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename* Hello, *name*! Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); } Mario Problem Set Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n -1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } } Cash Problem Set When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { float dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"C Basics"},{"location":"c/#c-basics","text":"","title":"C Basics"},{"location":"c/#basic-data-types","text":"int \u2013 used for variables that store integers (numbers). char \u2013 used for variables that will store single characters. These us single quotes (Ex. 'A'). float \u2013 used for variables that will store floating point-values (real numbers) (numbers with decimal point) (32 bits). double \u2013 like float but are double precision (64 bits). void \u2013 not a data type \u2013 is a type. Void return type does not return a value and does not take arguments. printf is a void function because it returns nothing, just shows a result. bool \u2013 used for variables that will store a Boolean value ( true or false ). string \u2013 used for variables that will store a series of characters (words, sentences, paragraphs). These use double quotes (Ex. \"Hi!\").","title":"Basic Data Types"},{"location":"c/#creating-a-variable","text":"To create a variable, you need to simply specify the data type of the variable and give it a name. \u2003\u2003 int number ; -> number is the name of the integer. \u2003\u2003 char letter ; -> letter is the name of the character. To create multiple variables of the same type, you specify the variable type once and then list as many variables as needed (separated by a comma). \u2003\u2003 int height , width ;","title":"Creating a Variable"},{"location":"c/#using-a-variable","text":"After a variable has been declared, it is no longer necessary to specify that variable\u2019s type. \u2003\u2003 int number ; // declaration \u2003\u2003 number = 17 ; // assignment \u2003\u2003 char letter ; // declaration \u2003\u2003 letter = 'H' // assignment","title":"Using a Variable"},{"location":"c/#operators","text":"In order to manipulate and work with variables and values in C, operators must be used. Arithmetic Operators In C we can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) numbers. \u2003\u2003 int x = y + 1 ; \u2003\u2003 x = x * 5 ; We also have the modulus operator ( % ), which gives us the remainder when the number on the left of the operator is divided by the number on the right. \u2003\u2003 int m = 13 % 4 // m is now 1 because after division there was a remainder of 1 (13/4=3 with one left over). There is also a shorthand way to apply an arithmetic operator to a single variable. \u2003\u2003 x = x * 5 ; is the same as x *= 5 ; Incrementing or decrementing a variable by 1 is very simple: \u2003\u2003 x ++ ; or x -- ; Boolean Expressions Boolean expressions are used in C for comparing values. All Boolean expressions evaluate to one of two possible values - true or false . Boolean expression results can be used to decide which branch in a conditional (if true/if false fork) to take, or determine whether a loop should continue to run. Sometimes when working with Boolean expressions we will use the variables of type bool , but we don\u2019t have to. In C, every nonzero value is equivalent to true , and zero is false . There are two main types of Boolean expressions: logical operators and relational operators. Logical Operators Logical AND (&&) is true if and only if both operands are true, otherwise false. X Y (X && Y) true true true true false false false true false false false false Logical OR (||) is true if and only if at least one operand is true, otherwise false. X Y (X || Y) true true true true false true false true true false false false Logical NOT (!) inverts the value of its operand. X !X true false false true Relational Operators These behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic. \u2003\u2003Less than (x < y) \u2003\u2003Less than or equal to (x <= y) \u2003\u2003Greater than (x > y) \u2003\u2003Greater than or equal to (x >= y) C can also test two variables for equality and inequality. \u2003\u2003Equality (x == y) \u2003\u2003Inequality (x != y) Be careful with equality! It is a common mistake to use the assignment operator (=) when you intend to use the equality operator (==).","title":"Operators"},{"location":"c/#conditional-statements","text":"Conditional expressions allow your programs to make decisions and take different forks in the road, depending on the values of variables or user input. C Provides a few different ways to implement conditional expressions (also known as branches) in your programs. if ( boolean - expression ){} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , those lines of code will not execute. if ( boolean - expression ){} else {} If the boolean-expression evaluates to true , all lines of code between the {} will execute in order from top-to-bottom. If the boolean-expression evaluates to false , all lines of code between the second set of {} will execute in order from top-to-bottom. It is possible in C to have an if - else if - else chain. if ( boolean - expr1 ){ } else if ( boolean - expr2 ){ } else if ( boolean - expr3 ){ } else { } Note: The final else will only link to the final if . switch C\u2019s switch () statement is a conditional statement that permits enumeration of discrete cases, instead of relying on Boolean expressions. It is important to break between each case, or you will \u201cfall through\u201d each case (unless that is intended) int x = GetInt (); switch ( x ) { case 1 : printf ( \u201c One ! \\ n \u201d ); break ; case 2 : printf ( \u201c Two ! \\ n \u201d ); break ; case 3 : printf ( \u201c Three ! \\ n \u201d ); break ; default : printf ( \u201c Sorry ! \\ n \u201d ); }","title":"Conditional Statements"},{"location":"c/#loops","text":"Loops allow your program to execute lines of code repeatedly, saving you from needing to copy/paste or otherwise repeat lines of code. Infinite Loop while ( true ) { } The lines of code between the {} will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement) or otherwise kill the program. While Loop while ( boolean - expr ) { } If the boolean-expr evaluates to true , all lines of code between the {} will execute repeatedly, in order from top-to-bottom, until boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, and possibly not at all. Do While Loop do { } while ( boolean - expr ); This loop will execute all lines of code between {} once, and then, if the boolean-expr evaluates to true , will go back and repeat that process until the boolean-expr evaluates to false . Use when you want a loop to repeat an unknown number of times, but at least once. For Loop for ( int i = 0 ; i < 10 ; i ++ ) { } Syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times (in the above example - 10 times). The process undertaken in a for loop is: The counter variable(s) (here, i) is set. The Boolean expression is checked. If it evaluates to true , the body of the loop executes. If it evaluates to false , the body of the loop does not execute. The counter variable is incremented, and then the Boolean Expression is checked again, etc. Use for when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled.","title":"Loops"},{"location":"c/#first-code","text":"#include <stdio.h> int main ( void ) { printf ( \"Hello, World! \\n \" ); } Source code -> compiler -> machine code clang hello.c (clang is the c language compiler) This compiles the hello world source code. ./a.out (a.out is the compiled machine code from the hello world source code). To rename a.out simply put a -o *filename* before the file that needs to be compiled (Ex. clang -o hello hello.c ). To see a list of files in a directory \u2013 type ls Files with * means it is executable (has been compiled). To remove a file in a directory \u2013 type rm *filename*","title":"First Code"},{"location":"c/#hello-name","text":"Now lets create a \"Hello World\"-like program that allows input from the user. We will now include a string prompt that asks the user for their name. string answer = get_string ( \u201c What \u2019 s your name ? \\ n \u201d ); (answer is the variable in the string). printf ( \u201c Hello , % s \\ n \u201d , answer ); % s is a placeholder for a string which is defined by the comma and string name. A string is a sequence (variable) of zero or more characters in double quotes (\u201c\u201d); #include <cs50.h> #include <stdio.h> int main ( void ) { string answer = get_string ( \"What\u2019s your name? \\n \" ); printf ( \"Hello, %s. \\n \" , answer ); }","title":"Hello, *name*!"},{"location":"c/#mario-problem-set","text":"Toward the end of World 1-1 in Super Mario Bros, Mario must ascend a right-alighned pyramid of blocks. We are going to recreate this in C (Using #'s instead of blocks), but allow the user to choose the block height while setting limits. If a user inputs a height of 4 , this is how the program should work: # ## ### #### To begin, we need to import some libraries: #include <cs50.h> #include <stdio.h> Before writing the code, we should look at the loop type we want to use. The best option in this case would be a do while loop, like the code that follows: int n ; do { n = get_int ( \"Positive Number: \" ); } while ( n < 1 ); The code above will continue to prompt the user for a number until it is positive. For our Mario blocks, we will make the options only positive integers ranging from 1 to 8. Using a do while loop we will begin with a prompt for user input: int main ( void ) { int n ; do { n = get int ( \"Height (1-8): \" ); } while ( n < 1 || n > 8 ) } Next, we will need to add a for loop. We will add the following: for ( int i = 0 ; i < n ; i ++ ) { printf ( \"# \\n \" ); } Making this right aligned is a more difficult task. Looking at the problem as a box with rows and columns helps. Imagine that the 8X8 grid prints the following. (Note that we start counting at 0) 0 1 2 3 4 5 6 7 0 # 1 # # 2 # # # 3 # # # # 4 # # # # # 5 # # # # # # 6 # # # # # # # 7 # # # # # # # # We will rename int i from earlier to int rows and create int columns to be the columns. (These can be named whatever you want). From here we can create the following code to create the right-aligned blocks. #include <stdio.h> #include <cs50.h> int main ( void ) { int n ; do { n = get_int ( \"Height (1-8): \" ); } // user input 1-8 while ( n < 1 || n > 8 ); for ( int rows = 0 ; rows < n ; rows ++ ) { for ( int columns = 0 ; columns <= n - 1 ; columns ++ ) { if ( rows + columns < n -1 ) printf ( \" \" ); else printf ( \"#\" ); } printf ( \" \\n \" ); } }","title":"Mario Problem Set"},{"location":"c/#cash-problem-set","text":"When a cashier gives change to a customer they give the biggest denomination they can and go until they must use a less valuable denomination. For example, if someone is owed $0.47, they will be given 1 quarter (.25), 2 dimes (2 * .10), and 2 pennies (2 * .01). For this problem set we will create a program that asks how much change is owed and then prints out the fewest number of coins that can be used. The easiest way to do this, which requires some copy/pasting, is to create a while loop for the different denominations. It should also be noted that we must use a float instead of a int , as we have previously, because money will not always be a whole number. The code works as the following: #include <stdio.h> #include <cs50.h> #include <math.h> int main ( void ) { float dollars ; do { dollars = get_float ( \"How much change is owed? \\n \" ); } while ( dollars < 0 ); int cents = round ( dollars * 100 ); int coins = 0 ; while ( cents >= 25 ) { cents -= 25 ; coins ++ ; } while ( cents >= 10 ) { cents -= 10 ; coins ++ ; } while ( cents >= 5 ) { cents -= 5 ; coins ++ ; } while ( cents >= 1 ) { cents -= 1 ; coins ++ ; } printf ( \"%i \\n \" , coins ); }","title":"Cash Problem Set"},{"location":"chrome-extensions/","text":"How to Install Chrome Extensions & Themes .lightgallery{ width:75% !important; } You are able to customize Google Chrome on both your desktop and mobile applications by adding extensions from the Chrome Web Store . The Chrome Web Store allows users to install both extensions and themes to your browser! Browser extensions are small pieces of software that are specifically designed to run within your web browser and run additional code. This can include custom scripts, user interface modifications, ad blocking, cookie management, privacy enhancers, password managers, and many, many more. Installing Extensions to the Chrome Browser Installing extensions is as simple as a few clicks: Open the Chrome Web Store . Click on the \"Extensions\" tab found below the \"Search the store\" box. Browse the store and find the extension you want to add to your browser. Click the Add to Chrome button. The extension should now either be added to your browser or ask for approval if the extension requires additional permissions. Make sure you only approve extensions that you trust. The extension will now be accessible to the right of the main address bar at the top of your browser. If your extension is not visible, you can access the extensions page by clicking on the three dots > More tools > Extensions or by putting chrome://extensions/ in the top address bar. Most extensions will require additional setup before you see the results you are expecting. You can manage the extension by clicking on the extension and changing options within the GUI. You are also able to manage extensions in the chrome://extensions/ area. Installing Themes to the Chrome Browser Customizing the look of your browser has never been easier. Google Chrome themes can be found in the same Chrome Web Store mentioned above. Open the Chrome Web Store . Click on the \"Themes\" tab found below the \"Search the store\" box. Browse the store and find the theme you want to add to your browser. Click the Add to Chrome button. Your theme should now be applied immediately to your browser! To access your downloaded themes, click on the three dots > Settings > Appearance or by putting chrome://settings/appearance in the top address bar.","title":"Google Chrome Extensions/Themes"},{"location":"chrome-extensions/#how-to-install-chrome-extensions-themes","text":".lightgallery{ width:75% !important; } You are able to customize Google Chrome on both your desktop and mobile applications by adding extensions from the Chrome Web Store . The Chrome Web Store allows users to install both extensions and themes to your browser! Browser extensions are small pieces of software that are specifically designed to run within your web browser and run additional code. This can include custom scripts, user interface modifications, ad blocking, cookie management, privacy enhancers, password managers, and many, many more.","title":"How to Install Chrome Extensions &amp; Themes"},{"location":"chrome-extensions/#installing-extensions-to-the-chrome-browser","text":"Installing extensions is as simple as a few clicks: Open the Chrome Web Store . Click on the \"Extensions\" tab found below the \"Search the store\" box. Browse the store and find the extension you want to add to your browser. Click the Add to Chrome button. The extension should now either be added to your browser or ask for approval if the extension requires additional permissions. Make sure you only approve extensions that you trust. The extension will now be accessible to the right of the main address bar at the top of your browser. If your extension is not visible, you can access the extensions page by clicking on the three dots > More tools > Extensions or by putting chrome://extensions/ in the top address bar. Most extensions will require additional setup before you see the results you are expecting. You can manage the extension by clicking on the extension and changing options within the GUI. You are also able to manage extensions in the chrome://extensions/ area.","title":"Installing Extensions to the Chrome Browser"},{"location":"chrome-extensions/#installing-themes-to-the-chrome-browser","text":"Customizing the look of your browser has never been easier. Google Chrome themes can be found in the same Chrome Web Store mentioned above. Open the Chrome Web Store . Click on the \"Themes\" tab found below the \"Search the store\" box. Browse the store and find the theme you want to add to your browser. Click the Add to Chrome button. Your theme should now be applied immediately to your browser! To access your downloaded themes, click on the three dots > Settings > Appearance or by putting chrome://settings/appearance in the top address bar.","title":"Installing Themes to the Chrome Browser"},{"location":"chrome/","text":"What is Google Chrome? Google Chrome Overview Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"What is Google Chrome?"},{"location":"chrome/#what-is-google-chrome","text":"","title":"What is Google Chrome?"},{"location":"chrome/#google-chrome-overview","text":"Google Chrome is a cross-platform web browser developed by Google. Chrome is a fast, simple, and secure browser for all your devices. As of April 2020, StatCounter estimates that Chrome has a 68% worldwide browser market share (after peaking at 72.36%) on traditional PCs and 64% across all platforms. Chrome allows its users to customize and control their user experience to a degree most other browsers don't, and this is largely thanks to Chrome extensions. While on the surface, Chrome might seem a simple browser, once you customize it with extensions it can be a tool that's both powerful and easy to use. Google Chrome offers some amazing features, including: Speed - Chrome\u2019s address bar uses Google Search to make any fact-finding mission fast and simple. It also searches your Google Drive, so diving into next week\u2019s vacation plan is just that much easier. Simplicity - Chrome is a clean and simple browser. The omnibox and multi tabbed browsing make navigating the web a breeze. When you close chrome, it will remember the tabs you had open so you can pick up right where you left off. Security/Privacy - Chrome provides build-in malware and phishing protection. Automatic updates keep your browser up-to-date and resilient against online threats. Chrome also lets you keep control of your private information while you browse online. Incognito mode is also included, which allows you to browse without saving your history, cookies, or downloads. Customization - Chrome boasts a large and robust web store that includes thousands of applications, themes, and extensions. Changing the theme of your browser allows you to tweak it to your liking. Extensions can make webpages more responsive to your needs! Integration with Google Suite - Chrome offers the ability to sign into your Google account, which automatically syncs across your laptop, tablet, or on your phone. You get the same experience \u2013 no matter where you go! Anything you update on one device will instantly update everywhere else you sign in to Chrome brower.","title":"Google Chrome Overview"},{"location":"chromeinstall/","text":"How to Install Google Chrome .lightgallery{ width:75% !important; } Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"Google Chrome Install"},{"location":"chromeinstall/#how-to-install-google-chrome","text":".lightgallery{ width:75% !important; } Before you download Google Chrome, you should check and make sure that your device's operating system (OS) is supported. As of April 2020, Windows, Mac, and Linux are all supported. For more information on Chrome system requuirements, please see this Google Help documentation . To begin the installation process, users must visit the following Google Chrome download page . To install Google Chrome, follow the instructions below: Visit the following Google Chrome download page and click on Download Chrome . Click on Save File, when prompted Locate the save .exe file in your Downloads folder. This can be found by clicking the downloads button in your browser or going to Windows Explorer and locating the location downloaded files populate. Run the ChromeSetup.exe file If there is a Security Warning popup, click on Run. Chrome should immediately begin installation. Chrome should now be installed! After installation, Chrome should open immediately and present a welcome screen. From here, you can click on Get Started or Already a Chrome user? Sign in. Clicking on Get Started will begin an initial setup, where you can add bookmarks to various Google applications (e.g. Gmail, YouTube, Maps, etc.), pick a browser background image, and set Chrome as your device's default browser. Clicking on Already a Chrome user? Sign in will take you to a Google sign in page where you can link your browser to your Google account.","title":"How to Install Google Chrome"},{"location":"chromemedia/","text":"Google Chrome Media Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome 1 Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"chromemedia/#google-chrome-media","text":"Below are some simple walkthroughs on Google Chrome features: Chrome Web Store Overview How to use Icognito Mode Using Chrome on Different Devices How to Clear Cookies and Cache in Chrome 1 Videos linked are from the Google Chrome YouTube Account .","title":"Google Chrome Media"},{"location":"django/","text":"Django Basics Quick Links Django 3: By Example (PDF) Django 3 Documentation Django Web Framework - Full Course Introduction Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. A web framework is a set of components that helps you to develop websites faster and easier. Django's primary goal is to ease the creation of complex, database-driven websites. The framework emphasizes reusability and \"pluggability\" of components, less code, low coupling, rapid development, and the principle of don't repeat yourself.","title":"Django"},{"location":"django/#django-basics","text":"","title":"Django Basics"},{"location":"django/#quick-links","text":"Django 3: By Example (PDF) Django 3 Documentation Django Web Framework - Full Course","title":"Quick Links"},{"location":"django/#introduction","text":"Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. It takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It\u2019s free and open source. A web framework is a set of components that helps you to develop websites faster and easier. Django's primary goal is to ease the creation of complex, database-driven websites. The framework emphasizes reusability and \"pluggability\" of components, less code, low coupling, rapid development, and the principle of don't repeat yourself.","title":"Introduction"},{"location":"glossary/","text":"Below is a list of key words and their definitions: Bookmark - A bookmark is a saved shortcut that directs your browser to a specific webpage. It stores the title, URL, and favicon of the corresponding page. Saving bookmarks allows you to easily access your favorite locations on the Web. Browser - Software programs that enable you to view web pages and other documents on the Internet. They \"translate\" HTML-encoded files into the text, images, sounds, and other features you see. Google Chrome is a browser. Cache - In browsers, \"cache\" is used to identify a space where web pages you have visited are stored in your computer. A copy of documents you retrieve is stored in cache. When you use GO, BACK, or any other means to revisit a document, the browser first checks to see if it is in cache and will retrieve it from there because it is much faster than retrieving it from the server. Cookie - An HTTP cookie is a small piece of data sent from a website and stored on the user's computer by the user's web browser while the user is browsing. Cookies were designed to be a reliable mechanism for websites to remember stateful information or to record the user's browsing activity. Extension - Extensions are small software programs that customize the browsing experience. They enable users to tailor Chrome functionality and behavior to individual needs or preferences. They are built on web technologies such as HTML, JavaScript, and CSS. HTML - HTML stands for Hyper Text Markup Language. HTML is the standard markup language for Web pages, which are the building blocks of most web pages. Link - A link (short for hyperlink) is an HTML object that allows you to jump to a new location when you click or tap it. Links are found on almost every webpage and provide a simple means of navigating between pages on the web. Links can be attached to text, images, or other HTML elements. URL - URL stands for Uniform Resource Locator. A URL is nothing more than the address of a given unique resource on the Web (e.g. website, page, or file). In theory, each valid URL points to a unique resource.","title":"Glossary"},{"location":"java-2d-arrays/","text":"2D Arrays Introduction to 2D Arrays As we have noted previously , an array is a group of data consisting of the same type. This means that we can have an array of primitive data types (such as integers): [ 1 , 2 , 3 , 4 , 5 ] We can even have an array of Objects. For example, the following example shows an array of String Objects: [ \"hello\" , \"world\" , \"how\" , \"are\" \"you\" ] In Java, arrays are considered Objects; therefore, we can also have an array of arrays: [[ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ]] These are called 2D arrays since we can logically view them as a two-dimensional matrix of values containing both rows and columns. Additionally, we can have 2D arrays which are not rectangular in shape. These are called jagged arrays: [[ 'a' , 'b' , 'c' , 'd' ] , [ 'e' , 'f' ] , [ 'g' , 'h' , 'i' , 'j' ] , [ 'k' ]] Why use 2D arrays? It is useful to use 2D arrays for situations where you need to store and organize data by rows and columns. For example, exporting data to be used in a spreadsheet. You can condense multiple arrays down to a single variable using 2D arrays. For example, if you have 10 students who each have 10 different quiz grades, you can represent the overall class quiz grades as a 10x10 2D array by having each row represent a student and each column represent one of the quizzes they have taken. 2D arrays can be used to map out data. For example, if you want to create a game of tic-tac-toe, you can represent the game state by using a 3x3 2D array. There are many other ways to use 2D arrays depending on the application. The only downside is that once initialized, no new rows or columns can be added or removed without copying the data to a newly initialized 2D array. This is because the length of arrays in Java are immutable (unable to be changed after creation). Declaration, Initialization, and Assignment When declaring 2D arrays, the format is similar to normal, one-dimensional arrays, except that you include an extra set of brackets after the data type. In this example, int represents the data type, the first set of brackets [] represent an array, and the second set of brackets [] represent that we are declaring an array of arrays. int [][] intTwoDArray ; You can think of this as creating an array ( [] ) of int arrays ( int [] ) . So we end up with int [][] . Now that we've declared a 2D array, let's look at how to initialize it with starting values. When initializing arrays, we define their size. Initializing a 2D array is different because, instead of only including the number of elements in the array, you also indicate how many elements are going to be in the sub-arrays. This can also be thought of as the number of rows and columns in the 2D matrix. 1 2 int [][] intArray1 ; intArray1 = new int [ row ][ column ] ; Jere os am example of initializing an empty 2D array with 3 rows and 5 columns: 1 2 int [][] intArray2 ; intArray2 = new int [ 3 ][ 5 ] This results in a matrix which looks like this: If you already know what values are going to be in the 2D array, you can initialize it and write all of the values into it at once. We can accomplish this through initializer lists. In Java, initializer lists are a way of initializing arrays and assigning values to them at the same time. We can use this for 2D arrays as well by creating an initializer list of initializer lists. An example of an intializer list for a regular array would be: char [] charArray = { 'a' , 'b' , 'c' , 'd' }; Similar to how a regular initializer list defines the size and values of the array, nested initializer lists will define the number of rows, columns, and the values for a 2D array. There are three situations in which we can use initializer lists for 2D arrays: In the case where the variable has not yet been declared, we can provide an abbreviated form since Java will infer the data type of the values in the initializer lists: double [][] doubleValues = {{ 1.5 , 2.6 , 3.7 }, { 7.5 , 6.4 , 5.3 }, { 9.8 , 8.7 , 7.6 }, { 3.6 , 5.7 , 7.8 }}; If the variable has already been declared, you can initialize it by creating a new 2D array object with the initializer list values: 1 2 String [][] stringValues ; stringValues = new String [][] {{ \"working\" , \"with\" }, { \"2D\" , \"arrays\" }, { \"is\" , \"fun\" }}; The previous method also applies to assigning a new 2D array to an existing 2D array stored in a variable. Accessing Elements in a 2D Array For a normal array, all we need is to provide an index (starting at 0 ) which represents the position of the element we want to access. Let's look at an example! Given an array of five strings: String [] words = { \"cat\" , \"dog\" , \"apple\" , \"bear\" , \"eagle\" }; We can access the first element using index 0 , the last element of the array minus one (in this case, 4 ), and any of the elements in between. We provide the index of the element we want to access inside a set of brackets. Let's see those examples in code: 1 2 3 4 5 6 7 8 // store the first element from the String array String firstWord = words [ 0 ] ; // store the last element of the String array String lastWord = words [ words . length - 1 ] ; // store an element from a different position in the array String middleWord = words [ 2 ] ; Now for 2D arrays, the syntax is slightly different. This is because instead of only providing a single index, we provide two indices. Take a look at this example: 1 2 3 4 5 // given a 2d array of integer data int [][] data = {{ 2 , 4 , 6 }, { 8 , 10 , 12 }, { 14 , 16 , 18 }}; // access and store a desired element int stored = data [ 0 ][ 2 ] There are two ways of thinking when accessing a specific element in a 2D array: The first value represents and row and the second value represents a column in the matrix. The first value represents which subarray to access from the main array and the second value represents which element of the subarray is accessed. The above example of the 2D array called data can be visualized like so. The indices are labeled outside the matrix: Using this knowledge, we now know that the result of int stored = data [ 0 ][ 2 ] ; would store the integer 6 . This is because the value of 6 is located on the first row (index 0 ) and the third column (index 2 ). Here is a template which cal be used for accessing elements in 2D arrays: datatype variableName = existing2DArray [ row ][ column ] ; When accessing these elements, if either the row or column value is out of bounds, then an ArrayIndexOutOfBoundsException error will be given by the application. Modifying Elements in a 2D Array Now let's review how to modify elements in a normal array. For a one dimensional array, you provide the index of the element which you want to modify within a set of brackets next to the variable name and set it equal to an acceptable value: storedArray [ 5 ] = 10 ; For 2D arrays, the format is similar, but we will provide the outer array index in the first set of brackets and the subarray index in the second set of brackets. We can also think of it as providing the row in the first set of brakcets if we were to visualize the 2D array as a rectangular matrix: twoDArray [ 1 ][ 3 ] = 150 ; To assign a new value to a certain element, make sure that the new value you are using is either of the same type or is castable to the type already in the 2D array. Let's say we wanted to replace four values from a new 2D array called intTwoD . Look at this example code to see how to pick individual elements and assign new values to them. 1 2 3 4 5 6 int [][] intTwoD = new int [ 4 ][ 3 ] ; intTwoD [ 3 ][ 2 ] = 16 ; intTwoD [ 0 ][ 0 ] = 4 ; intTwoD [ 2 ][ 1 ] = 12 ; intTwoD [ 1 ][ 1 ] = 8 ; Here is a before and after image showing when the 2D array was first initialized compared to when the four elements were accessed and modified: Review of Nested Loops Nested loops consist of two or more loops placed within each other. We will be looking at one loop nested within another for 2D traversal. The way it works is that, for every iteration of the outer loop, the inner loop finishes all of its iterations. Here is an example using for loops: 1 2 3 4 5 6 for ( int outer = 0 ; outer < 3 ; outer ++ ){ System . out . println ( \"The outer index is: \" + outer ); for ( int inner = 0 ; inner < 4 ; inner ++ ){ System . out . println ( \"\\tThe inner index is: \" + inner ); } } The output of the above nested loop looks like so: The outer index is: 0 The inner index is: 0 The inner index is: 1 The inner index is: 2 The inner index is: 3 The outer index is: 1 The inner index is: 0 The inner index is: 1 The inner index is: 2 The inner index is: 3 The outer index is: 2 The inner index is: 0 The inner index is: 1 The inner index is: 2 The inner index is: 3 For this example we can see how every time the outer loop iterates one time, the inner loop iterates fully. This is an important concept for 2D array traversal, because for every row in a two dimensional matrix, we want to iterate through every column. Nested loops can consist of any type of loop and with any combination of loops. Let's take a look at a few more interesting examples. Here is an example of nested while loops: 1 2 3 4 5 6 7 8 9 int outerCounter = 0 ; int innerCounter = 0 ; while ( outerCounter < 5 ){ outerCounter ++ ; innerCounter = 0 ; while ( innerCounter < 7 ){ innerCounter ++ ; } } We can even have some interesting combinations. Here is an enhanced for loop inside of a while loop: 1 2 3 4 5 6 7 8 9 10 int outerCounter = 0 ; int [] innerArray = { 1 , 2 , 3 , 4 , 5 }; while ( outerCounter < 7 ){ System . out . println (); for ( int number : innerArray ){ System . out . print ( number * outerCounter + \" \" ); } outerCounter ++ ; } The output of the above example creates a multiplication table: 0 0 0 0 0 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20 5 10 15 20 25 6 12 18 24 30 This is an interesting example, because for every iteration of the while loop, we iterate through every element of an array using an enhanced for loop. This is similar to the iteration pattern we use for 2D array traversal. Traversing 2D Arrays: Introduction Traversing 2D arrays using loops is important because it allows us to access many elements quickly, access elements in very large 2D arrays, and even access elements in 2D arrays of unknown sizes. Let's remember the structure of 2D arrays in Java: char [][] letterBlock = {{ 'a' , 'b' , 'c' },{ 'd' , 'e' , 'f' },{ 'g' , 'h' , 'i' },{ 'j' , 'k' , 'l' }}; In Java, 2D arrays are like normal arrays, but each element is another array. This is shown by the initialized 2D array above. The outer array consists of four elements, where each element consists of a three element subarray. Let\u2019s see what happens when we access elements of the outer array 1 2 3 4 System . out . println ( Arrays . toString ( letterBlock [ 0 ] ) + \"\\n\" ); System . out . println ( Arrays . toString ( letterBlock [ 1 ] ) + \"\\n\" ); System . out . println ( Arrays . toString ( letterBlock [ 2 ] ) + \"\\n\" ); System . out . println ( Arrays . toString ( letterBlock [ 3 ] ) + \"\\n\" ); This would output the following: [a, b, c] [d, e, f] [g, h, i] [j, k, l] As you can see, we can retrieve the entire subarray from each of the outer array elements. If you look at how we are accessing these subarrays, we are just increasing the index. This means we can access each sub-array in the 2D array using a loop! Let\u2019s take a look at an example which produces the same output, but can handle any sized 2D array. 1 2 3 for ( int index = 0 ; index < letterBlock . length ; index ++ ){ System . out . println ( Arrays . toString ( letterBlock [ index ] ) + \"\\n\" ); } Here is the output: [a, b, c] [d, e, f] [g, h, i] [j, k, l] Now let's remember how to access a value from the subarray. Previously, we learned that we can use the double brackets [][] , where the first set of brackets contains the index of the element of the outer array and the second set of brackets contains the index of the element in the subarray. If we wanted to retrieve the letter 'f' we would use: char storedLetter = letterBlock [ 1 ][ 2 ] ; Since we know we can use a loop to retrieve each of the subarrays stored in the outer array, we can then use a nested loop to access each of the elements from the sub-array. You might be wondering how we can figure out the number of iterations needed in order to fully traverse the 2D array. In order to find the number of elements in the outer array, we just need to get the length of the 2D array. int lengthOfOuterArray = letterBlock . length ; When thinking about the 2D array in matrix form, this is the height of the matrix (the number of rows) In order to find the number of elements in the subarray, we can get the length of the subarray after it has been retrieved from the outer array. Remember that we retrieved the sub array earlier using this format: char [] subArray = letterBlock [ 0 ] ; Therefore, we can use this to get the length of the first subarray in the 2D array int lengthOfSubArray = letterBlock [ 0 ] . length ; When thinking about the 2D array in matrix form, this is the width of the matrix (the number of columns) In most cases, getting the length of the first subarray in the 2D array will apply to the rest of the subarrays (if it is rectangular in shape), but there are rare occasions where the length of the subarrays could be different. This occurs if the 2D array is a jagged array. Let's look at an example: 1 2 3 4 5 6 for ( int a = 0 ; a < letterBlock . length ; a ++ ) { for ( int b = 0 ; b < letterBlock [ a ] . length ; b ++ ) { System . out . print ( \"Accessed: \" + letterBlock [ a ][ b ] + \"\\t\" ); } System . out . println (); } You can think of the variable a as being the outer loop index, and the variable b as being the inner loop index. This gives the following output: Accessed: a Accessed: b Accessed: c Accessed: d Accessed: e Accessed: f Accessed: g Accessed: h Accessed: i Within the nested for loop, we can see that each of the subarray elements are being accessed by using the outer loop index for the outer array, and the inner loop index for the subarray. Here is a diagram to help visualize how the 2D array is traversed using nested loops: We don't have to only use regular for loops for traversing 2D arrays. We can use enhanced for loops if we do not need to keep track of the indices. Since enhanced for loops only use the element of the arrays, it is a bit more cumbersome to keep track of which index we are at. This same idea applies to while and do-while loops as well. This is why we usually use regular for loops except for when we want to do something simple like printing. Traversing 2D Arrays: Practice with Loops In enhanced for loops, each element is iterated through until the end of the array. When we think about the structure of 2D arrays in Java (arrays of array objects) then we know that the outer enhanced for loop elements are going to be arrays. Let's take a look at an example: Given this 2D array of character data: char [][] charData = {{ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' },{ 'g' , 'h' , 'i' , 'j' , 'k' , 'l' }}; Print out every character using enhanced for loops: 1 2 3 4 5 6 for ( char [] charRow : charData ) { for ( char c : charRow ) { System . out . print ( c + \" \" ); } System . out . println (); } Remember that the syntax for enhanced for loops looks like so: for ( datatype elementName : arrayName ){ . Since 2D arrays in Java are arrays of arrays, each element in the outer enhanced for loop is an entire row of the 2D array. The nested enhanced for loop is then used to iterate through each element in the extracted row. Here is the output of the above code: a b c d e f g h i j k l Here is an example which accomplishes the same thing, but using while loops: 1 2 3 4 5 6 7 8 9 10 int i = 0 , j = 0 ; while ( i < charData . length ) { j = 0 ; while ( j < charData [ i ] . length ) { System . out . print ( charData [ i ][ j ] + \" \" ); j ++ ; } System . out . println (); i ++ ; } Here is the output of the above code: a b c d e f g h i j k l Notice how we can use different loop types for traversal, but still receive the same result. Traversing 2D Arrays: Row-Major Order Row-major order for 2D arrays refers to a traversal path which moves horizontally through each row starting at the first row and ending with the last. Although we have already looked at how 2D array objects are stored in Java, this ordering system conceptualizes the 2D array into a rectangular matrix and starts the traversal at the top left element and ends at the bottom right element. Here is a diagram which shows the path through the 2D array: This path is created by the way we set up our nested loops. In the previous exercise, we looked at how we can traverse the 2D array by having nested loops in a variety of formats, but if we want to control the indices, we typically use standard for loops. Let\u2019s take a closer look at the structure of the nested for loops when traversing a 2D array: Given this 2D array of strings describing the element positions: 1 2 3 4 String [][] matrix = {{ \"[0][0]\" , \"[0][1]\" , \"[0][2]\" }, { \"[1][0]\" , \"[1][1]\" , \"[1][2]\" }, { \"[2][0]\" , \"[2][1]\" , \"[2][2]\" }, { \"[3][0]\" , \"[3][1]\" , \"[3][2]\" }}; Lets keep track of the total number of iterations as we traverse the 2D array: 1 2 3 4 5 6 7 8 9 10 int stepCount = 0 ; for ( int a = 0 ; a < matrix . length ; a ++ ) { for ( int b = 0 ; b < matrix [ a ] . length ; b ++ ) { System . out . print ( \"Step: \" + stepCount ); System . out . print ( \", Element: \" + matrix [ a ][ b ] ); System . out . println (); stepCount ++ ; } } This would produce the following output: Step: 0, Element: [0][0] Step: 1, Element: [0][1] Step: 2, Element: [0][2] Step: 3, Element: [1][0] Step: 4, Element: [1][1] Step: 5, Element: [1][2] Step: 6, Element: [2][0] Step: 7, Element: [2][1] Step: 8, Element: [2][2] Step: 9, Element: [3][0] Step: 10, Element: [3][1] Step: 11, Element: [3][2] The step value increases with every iteration within the inner for loop. Because of this, we can see the order in which each element is accessed. If we follow the step value in the output shows us that the elements are accessed in the same order as the row-major diagram above. Now why is that? This is because in our for loop, we are using the number of rows as the termination condition within the outer for loop header a < matrix . length ; . Additionally, we are using the number of columns b < matrix [ a ] . length as the termination condition for our inner loop. Logically we are saying: \u201cFor every row in our matrix, iterate through every single column before moving to the next row\u201d. This is why our above example is traversing the 2D array using row-major order. Here is a diagram showing which loop accesses which part of the 2D array for row-major order: Why Use Row-Major Order? Row-major order is important when we need to process data in our 2D array by row. You can be provided data in a variety of formats and you may need to perform calculations of rows of data at a time instead of individual elements. Let's take one of our previous checkpoint exercises as an example. You were asked to calculate the sum of the entire 2D array of integers by traversing and accessing each element. Now, if we wanted to calculate the sum of each row, or take the average of each row, we can use row-major order to access the data in the order that we need. Let's look at an example! Given a 6X3 2D array of doubles: 1 2 3 4 5 6 double [][] data = {{ 0.51 , 0.99 , 0.12 }, { 0.28 , 0.99 , 0.89 }, { 0.05 , 0.94 , 0.05 }, { 0.32 , 0.22 , 0.61 }, { 1.00 , 0.95 , 0.09 }, { 0.67 , 0.22 , 0.17 }}; Calculate the sum of each row using row-major order: 1 2 3 4 5 6 7 8 double rowSum = 0.0 ; for ( int o = 0 ; o < data . length ; o ++ ) { rowSum = 0.0 ; for ( int i = 0 ; i < data [ o ] . length ; i ++ ) { rowSum += data [ o ][ i ] ; } System . out . println ( \"Row: \" + o + \", Sum: \" + rowSum ); } The output for the above code is: Row: 0, Sum: 1.62 Row: 1, Sum: 2.16 Row: 2, Sum: 1.04 Row: 3, Sum: 1.15 Row: 4, Sum: 2.04 Row: 5, Sum: 1.06 An interesting thing to note is that, due to the way 2D arrays are structured in Java, enhanced for loops are always in row-major order. This is because an enhanced for loop iterates through the elements of the outer array which causes the terminating condition to be the length of the 2D array which is the number of rows. Traversing 2D Arrays: Column-Major Order Column-major order for 2D arrays refers to a traversal path which moves vertically down each column starting at the first column and ending with the last. This ordering system also conceptualizes the 2D array into a rectangular matrix and starts the traversal at the top left element and ends at the bottom right element. Column-major order has the same starting and finishing point as row-major order, but it\u2019s traversal is completely different Here is a diagram which shows the path through the 2D array: In order to perform column-major traversal, we need to set up our nested loops in a different way. We need to change the outer loop from depending on the number of rows, to depending on the number of columns. Likewise we need the inner loop to depend on the number of rows in its termination condition. Let's look at our example 2D array from the last exercise and see what needs to be changed. Given this 2D array of strings describing the element positions: 1 2 3 4 String [][] matrix = {{ \"[0][0]\" , \"[0][1]\" , \"[0][2]\" }, { \"[1][0]\" , \"[1][1]\" , \"[1][2]\" }, { \"[2][0]\" , \"[2][1]\" , \"[2][2]\" }, { \"[3][0]\" , \"[3][1]\" , \"[3][2]\" }}; Let's keep track of the total number of iterations as we traverse the 2D array. We also need to change the termination condition (middle section) within the outer and inner for loop. 1 2 3 4 5 6 7 8 9 10 int stepCount = 0 ; for ( int a = 0 ; a < matrix [ 0 ] . length ; a ++ ) { for ( int b = 0 ; b < matrix . length ; b ++ ) { System . out . print ( \"Step: \" + stepCount ); System . out . print ( \", Element: \" + matrix [ b ][ a ] ); System . out . println (); stepCount ++ ; } } Here is the output for the above code: Step: 0, Element: [0][0] Step: 1, Element: [1][0] Step: 2, Element: [2][0] Step: 3, Element: [3][0] Step: 4, Element: [0][1] Step: 5, Element: [1][1] Step: 6, Element: [2][1] Step: 7, Element: [3][1] Step: 8, Element: [0][2] Step: 9, Element: [1][2] Step: 10, Element: [2][2] Step: 11, Element: [3][2] As you can see in the code above, the way we accessed the elements from our 2D array of strings called matrix is different from the way we accessed them when using row-major order. Let\u2019s remember that the way we get the number of columns is by using matrix [ 0 ] . length and the way we get the number of rows is by using matrix . length . Because of these changes to our for loops, our iterator a now iterates through every column while our iterator b iterates through every row. Since our iterators now represent the opposite values, whenever we access an element from our 2D array, we need to keep in mind what indices we are passing to our accessor. Remember the format we use for accessing the elements matrix [ row ][ column ] ? Since a now iterates through our column indices, we place it in the right set of brackets, and the b is now placed in the left set of brackets. Here is a diagram showing which loop accesses which part of the 2D array for column-major order: Why Use Column-Major Order? Column major order is important because there are a lot of cases when you need to process data vertically. Let\u2019s say that we have a chart of information which includes temperature data about each day. The top of each column is labeled with a day, and each row represents an hour. In order to find the average temperature per day, we would need to traverse the data vertically since each column represents a day. As mentioned in the last exercise, data can be provided in many different formats and shapes and you will need to know how to traverse it accordingly. Let\u2019s look at our sum example from the last exercise, but now using column-major order. Given a 6X3 2D array of doubles: 1 2 3 4 5 6 double [][] data = {{ 0.51 , 0.99 , 0.12 }, { 0.28 , 0.99 , 0.89 }, { 0.05 , 0.94 , 0.05 }, { 0.32 , 0.22 , 0.61 }, { 1.00 , 0.95 , 0.09 }, { 0.67 , 0.22 , 0.17 }}; Calculate the sum of each column using column-major order: 1 2 3 4 5 6 7 8 double colSum = 0.0 ; for ( int o = 0 ; o < data [ 0 ] . length ; o ++ ) { colSum = 0.0 ; for ( int i = 0 ; i < data . length ; i ++ ) { colSum += data [ i ][ o ] ; } System . out . println ( \"Column: \" + o + \", Sum: \" + colSum ); } The output of the above code is: Column: 0, Sum: 2.83 Column: 1, Sum: 4.31 Column: 2, Sum: 1.93 Combining Traversal and Conditional Logic When working with 2D arrays, it is important to be able to combine traversal logic with conditional logic in order to effectively navigate and process the data. Here are a few ways in how conditional logic can affect 2D array traversal: Skipping or selecting certain rows and columns Modifying elements only if they meet certain conditions Complex calculations using the 2D array data Formatting the 2D array Avoiding exceptions / smart processing Let\u2019s go over a few examples which use these ideas: First, let\u2019s think about a situation where you have some string data inside a 2D array. We have an application which allows users to input events on a calendar. This is represented by a 5x7 2D array of strings. Due to the fact that the number of days in each month is slightly different and that there are less than 35 days in a month, we know that some of our elements are going to be empty. We want our application to do a few things: Detect which days of which weeks have something planned and alert us about the event. Count the number of events for each week Count the number of events for each day Here is a visualization of what our calendar data looks like after a user has entered in some event information: Here\u2019s what our calendar data looks like in our application: 1 String [][] calendar = {{ \"volunteer\" , \"delivery\" , null , null , \"doctor\" , null , \"soccer\" }, { null , \"exam 1\" , null , \"mechanic\" , null , null , \"soccer\" }, { \"volunteer\" , \"off work\" , null , \"birthday\" , null , \"concert\" , null }, { null , \"exam 2\" , null , null , \"doctor\" , null , \"soccer\" }, { \"visit family\" , null , null , null , null , null , null }}; Let\u2019s look at some code which accomplishes the requirements above. Carefully look through each line of code and read all of the comments. There are a few things to note: Row-major or column-major order can be used to access the individual events Row-major order must be used to count the number of events per week since each row represents a week Let\u2019s take care of the first 2 requirements in one set of nested row-major loops 1 2 3 4 5 6 7 8 9 10 11 12 13 for ( int i = 0 ; i < calendar . length ; i ++ ) { numberOfEventsPerWeek = 0 ; for ( int j = 0 ; j < calendar [ i ] . length ; j ++ ) { // We need conditional logic to ensure that we do not count the empty days String event = calendar [ i ][ j ] ; if ( event != null && ! event . equals ( \"\" )) { // If the day does not have a null value or empty string for an event, then we print it and count it System . out . println ( \"Week: \" + ( i + 1 ) + \", Day: \" + ( j + 1 ) + \", Event: \" + event ); numberOfEventsPerWeek ++ ; } } System . out . println ( \"Total number of events for week \" + ( i + 1 ) + \": \" + numberOfEventsPerWeek + \"\\n\" ); } The code above produces the following output: Week: 1, Day: 1, Event: volunteer Week: 1, Day: 2, Event: delivery Week: 1, Day: 5, Event: doctor Week: 1, Day: 7, Event: soccer Total number of events for week 1: 4 Week: 2, Day: 2, Event: exam 1 Week: 2, Day: 4, Event: mechanic Week: 2, Day: 7, Event: soccer Total number of events for week 2: 3 Week: 3, Day: 1, Event: volunteer Week: 3, Day: 2, Event: off work Week: 3, Day: 4, Event: birthday Week: 3, Day: 6, Event: concert Total number of events for week 3: 4 Week: 4, Day: 2, Event: exam 2 Week: 4, Day: 5, Event: doctor Week: 4, Day: 7, Event: soccer Total number of events for week 4: 3 Week: 5, Day: 1, Event: visit family Total number of events for week 5: 1 Now let's complete the third requirement. Since we need to count all of the events for each of the weekdays, we will need to traverse the calendar vertically. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int numberOfEventsPerWeekday = 0 ; // We will use this array of day strings for our output later on so we don't have (day: 1) String [] days = { \"Sundays\" , \"Mondays\" , \"Tuesdays\" , \"Wednesdays\" , \"Thursdays\" , \"Fridays\" , \"Saturdays\" }; for ( int i = 0 ; i < calendar [ 0 ] . length ; i ++ ) { numberOfEventsPerWeekday = 0 ; for ( int j = 0 ; j < calendar . length ; j ++ ) { // Don't forget to flip the iterators in the accessor since we are flipping the direction we are navigating. // Remember, i now controls columns and j now controls rows String event = calendar [ j ][ i ] ; if ( event != null && ! event . equals ( \"\" )) { // Make sure we have an event for the day before counting it numberOfEventsPerWeekday ++ ; } } // Use the days string array from earlier to convert the day index to a real weekday string System . out . println ( \"Number of events on \" + days [ i ] + \": \" + numberOfEventsPerWeekday ); } The output is: Number of events on Sundays: 3 Number of events on Mondays: 4 Number of events on Tuesdays: 0 Number of events on Wednesdays: 2 Number of events on Thursdays: 2 Number of events on Fridays: 1 Number of events on Saturdays: 3 This example uses many of the concepts we have learned before. We use row-major order, column-major order, as well as including conditional logic to ensure that we have data for the elements we are accessing. Additionally, we can use conditional logic to skip portions of the 2D array. For example, let\u2019s say we wanted to print the events for weekdays only and skip the weekends. We could use a conditional statement such as if ( j != 0 && j != 6 ) in order to skip Sunday ( 0 ) and Saturday ( 6 ). These modifications to our 2D array traversal are very common when processing data in applications. We need to know which cells to look at (skipping column titles for example), which cells to ignore (empty data, invalid data, outliers, etc.), and which cells to convert (converting string input from a file to numbers). 2D Array Review Let\u2019s review the concepts we have learned throughout these notes. Arrays are objects in Java, we can have arrays of objects, therefore we can also have arrays of arrays. This is the way 2D arrays are structured in Java. We can declare and initialize 2D arrays in a few different ways depending on the situation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Declaring without initializing int [][] intTwoD ; // Initializing an empty 2D array which has already been declared intTwoD = new int [ 5 ][ 5 ] ; // Declaring and initializing an empty 2D array at once String [][] stringData = new String [ 3 ][ 6 ] ; // Declaring and initializing a 2D array using initializer lists double [][] doubleValues = {{ 1.5 , 2.6 , 3.7 }, { 7.5 , 6.4 , 5.3 }, { 9.8 , 8.7 , 7.6 }, { 3.6 , 5.7 , 7.8 }}; // Initializing a 2D array using initializer lists after it has already been declared, or already contains data; char [][] letters = new char [ 100 ][ 250 ] ; letters = new char [][] {{ 'a' , 'b' , 'c' }, { 'd' , 'e' , 'f' }}; We retrieve elements in a 2D array by providing a row and column index char c = letters [ 0 ][ 1 ] ; We can also think of them as the index of the outer array and the index of the subarray We can modify elements the same way letters [ 1 ][ 2 ] = 'z' ; We traverse 2D arrays using nested loops. We can use loops of any type, but we typically use nested for loops to keep track of the indices Row-major order traverses through each row moving horizontally to the right through each row Column-major order traverses through each column moving vertically down through each column Row-major order and column-major order start and end on the same elements, but the paths are different. In order to convert row-major to column-major, we need to make the outer loop terminating condition depend on the number of columns, make the inner loop terminating condition depend on the number of rows, and flip the variables in our accessor within the inner loop to ensure that we don\u2019t try to access outside of the 2D array since we flipped the direction of traversal. Here are examples of row-major and column-major order: 1 2 3 4 5 6 7 8 9 10 11 12 13 // Row-major order for ( int o = 0 ; o < letters . length ; o ++ ) { for ( int i = 0 ; i < letters [ o ] . length ; i ++ ) { char c = letters [ o ][ i ] ; } } // Column-major order for ( int o = 0 ; o < letters [ 0 ] . length ; o ++ ) { for ( int i = 0 ; i < letters . length ; i ++ ) { char c = letters [ i ][ o ] ; } } Conditional logic in our 2D array traversal allows us to use the data in a meaningful way. We can control which rows and columns we look at, ensure that the data we are looking at is what we want, perform calculations on specific elements, avoid throwing exceptions, and more. Here is an example of traversal with conditional logic. Given this 2D array of Strings: String [][] words = {{ \"championship\" , \"QUANTITY\" , \"month\" },{ \"EMPLOYEE\" , \"queen\" , \"understanding\" },{ \"method\" , \"writer\" , \"MOVIE\" }}; We are going to flip the capitalization of the words: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 System . out . println ( \"Before...\" ); System . out . println ( Arrays . deepToString ( words ). replace ( \"],\" , \"],\\n\" ) + \"\\n\" ); for ( int i = 0 ; i < words . length ; i ++ ) { for ( int j = 0 ; j < words [ i ] . length ; j ++ ) { if ( words [ i ][ j ]!= null ) { // Check the capitalization boolean allCaps = true ; for ( char c : words [ i ][ j ] . toCharArray ()) if ( ! Character . isUpperCase ( c )) allCaps = false ; // Flip the capitalization if ( allCaps ) words [ i ][ j ] = words [ i ][ j ] . toLowerCase (); else words [ i ][ j ] = words [ i ][ j ] . toUpperCase (); } } } System . out . println ( \"After...\" ); System . out . println ( Arrays . deepToString ( words ). replace ( \"],\" , \"],\\n\" ) + \"\\n\" ); Here is the output of the above code: Before... [[championship, QUANTITY, month], [EMPLOYEE, queen, understanding], [method, writer, MOVIE]] After... [[CHAMPIONSHIP, quantity, MONTH], [employee, QUEEN, UNDERSTANDING], [METHOD, WRITER, movie]]","title":"2D Arrays"},{"location":"java-2d-arrays/#2d-arrays","text":"","title":"2D Arrays"},{"location":"java-2d-arrays/#introduction-to-2d-arrays","text":"As we have noted previously , an array is a group of data consisting of the same type. This means that we can have an array of primitive data types (such as integers): [ 1 , 2 , 3 , 4 , 5 ] We can even have an array of Objects. For example, the following example shows an array of String Objects: [ \"hello\" , \"world\" , \"how\" , \"are\" \"you\" ] In Java, arrays are considered Objects; therefore, we can also have an array of arrays: [[ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ]] These are called 2D arrays since we can logically view them as a two-dimensional matrix of values containing both rows and columns. Additionally, we can have 2D arrays which are not rectangular in shape. These are called jagged arrays: [[ 'a' , 'b' , 'c' , 'd' ] , [ 'e' , 'f' ] , [ 'g' , 'h' , 'i' , 'j' ] , [ 'k' ]] Why use 2D arrays? It is useful to use 2D arrays for situations where you need to store and organize data by rows and columns. For example, exporting data to be used in a spreadsheet. You can condense multiple arrays down to a single variable using 2D arrays. For example, if you have 10 students who each have 10 different quiz grades, you can represent the overall class quiz grades as a 10x10 2D array by having each row represent a student and each column represent one of the quizzes they have taken. 2D arrays can be used to map out data. For example, if you want to create a game of tic-tac-toe, you can represent the game state by using a 3x3 2D array. There are many other ways to use 2D arrays depending on the application. The only downside is that once initialized, no new rows or columns can be added or removed without copying the data to a newly initialized 2D array. This is because the length of arrays in Java are immutable (unable to be changed after creation).","title":"Introduction to 2D Arrays"},{"location":"java-2d-arrays/#declaration-initialization-and-assignment","text":"When declaring 2D arrays, the format is similar to normal, one-dimensional arrays, except that you include an extra set of brackets after the data type. In this example, int represents the data type, the first set of brackets [] represent an array, and the second set of brackets [] represent that we are declaring an array of arrays. int [][] intTwoDArray ; You can think of this as creating an array ( [] ) of int arrays ( int [] ) . So we end up with int [][] . Now that we've declared a 2D array, let's look at how to initialize it with starting values. When initializing arrays, we define their size. Initializing a 2D array is different because, instead of only including the number of elements in the array, you also indicate how many elements are going to be in the sub-arrays. This can also be thought of as the number of rows and columns in the 2D matrix. 1 2 int [][] intArray1 ; intArray1 = new int [ row ][ column ] ; Jere os am example of initializing an empty 2D array with 3 rows and 5 columns: 1 2 int [][] intArray2 ; intArray2 = new int [ 3 ][ 5 ] This results in a matrix which looks like this: If you already know what values are going to be in the 2D array, you can initialize it and write all of the values into it at once. We can accomplish this through initializer lists. In Java, initializer lists are a way of initializing arrays and assigning values to them at the same time. We can use this for 2D arrays as well by creating an initializer list of initializer lists. An example of an intializer list for a regular array would be: char [] charArray = { 'a' , 'b' , 'c' , 'd' }; Similar to how a regular initializer list defines the size and values of the array, nested initializer lists will define the number of rows, columns, and the values for a 2D array. There are three situations in which we can use initializer lists for 2D arrays: In the case where the variable has not yet been declared, we can provide an abbreviated form since Java will infer the data type of the values in the initializer lists: double [][] doubleValues = {{ 1.5 , 2.6 , 3.7 }, { 7.5 , 6.4 , 5.3 }, { 9.8 , 8.7 , 7.6 }, { 3.6 , 5.7 , 7.8 }}; If the variable has already been declared, you can initialize it by creating a new 2D array object with the initializer list values: 1 2 String [][] stringValues ; stringValues = new String [][] {{ \"working\" , \"with\" }, { \"2D\" , \"arrays\" }, { \"is\" , \"fun\" }}; The previous method also applies to assigning a new 2D array to an existing 2D array stored in a variable.","title":"Declaration, Initialization, and Assignment"},{"location":"java-2d-arrays/#accessing-elements-in-a-2d-array","text":"For a normal array, all we need is to provide an index (starting at 0 ) which represents the position of the element we want to access. Let's look at an example! Given an array of five strings: String [] words = { \"cat\" , \"dog\" , \"apple\" , \"bear\" , \"eagle\" }; We can access the first element using index 0 , the last element of the array minus one (in this case, 4 ), and any of the elements in between. We provide the index of the element we want to access inside a set of brackets. Let's see those examples in code: 1 2 3 4 5 6 7 8 // store the first element from the String array String firstWord = words [ 0 ] ; // store the last element of the String array String lastWord = words [ words . length - 1 ] ; // store an element from a different position in the array String middleWord = words [ 2 ] ; Now for 2D arrays, the syntax is slightly different. This is because instead of only providing a single index, we provide two indices. Take a look at this example: 1 2 3 4 5 // given a 2d array of integer data int [][] data = {{ 2 , 4 , 6 }, { 8 , 10 , 12 }, { 14 , 16 , 18 }}; // access and store a desired element int stored = data [ 0 ][ 2 ] There are two ways of thinking when accessing a specific element in a 2D array: The first value represents and row and the second value represents a column in the matrix. The first value represents which subarray to access from the main array and the second value represents which element of the subarray is accessed. The above example of the 2D array called data can be visualized like so. The indices are labeled outside the matrix: Using this knowledge, we now know that the result of int stored = data [ 0 ][ 2 ] ; would store the integer 6 . This is because the value of 6 is located on the first row (index 0 ) and the third column (index 2 ). Here is a template which cal be used for accessing elements in 2D arrays: datatype variableName = existing2DArray [ row ][ column ] ; When accessing these elements, if either the row or column value is out of bounds, then an ArrayIndexOutOfBoundsException error will be given by the application.","title":"Accessing Elements in a 2D Array"},{"location":"java-2d-arrays/#modifying-elements-in-a-2d-array","text":"Now let's review how to modify elements in a normal array. For a one dimensional array, you provide the index of the element which you want to modify within a set of brackets next to the variable name and set it equal to an acceptable value: storedArray [ 5 ] = 10 ; For 2D arrays, the format is similar, but we will provide the outer array index in the first set of brackets and the subarray index in the second set of brackets. We can also think of it as providing the row in the first set of brakcets if we were to visualize the 2D array as a rectangular matrix: twoDArray [ 1 ][ 3 ] = 150 ; To assign a new value to a certain element, make sure that the new value you are using is either of the same type or is castable to the type already in the 2D array. Let's say we wanted to replace four values from a new 2D array called intTwoD . Look at this example code to see how to pick individual elements and assign new values to them. 1 2 3 4 5 6 int [][] intTwoD = new int [ 4 ][ 3 ] ; intTwoD [ 3 ][ 2 ] = 16 ; intTwoD [ 0 ][ 0 ] = 4 ; intTwoD [ 2 ][ 1 ] = 12 ; intTwoD [ 1 ][ 1 ] = 8 ; Here is a before and after image showing when the 2D array was first initialized compared to when the four elements were accessed and modified:","title":"Modifying Elements in a 2D Array"},{"location":"java-2d-arrays/#review-of-nested-loops","text":"Nested loops consist of two or more loops placed within each other. We will be looking at one loop nested within another for 2D traversal. The way it works is that, for every iteration of the outer loop, the inner loop finishes all of its iterations. Here is an example using for loops: 1 2 3 4 5 6 for ( int outer = 0 ; outer < 3 ; outer ++ ){ System . out . println ( \"The outer index is: \" + outer ); for ( int inner = 0 ; inner < 4 ; inner ++ ){ System . out . println ( \"\\tThe inner index is: \" + inner ); } } The output of the above nested loop looks like so: The outer index is: 0 The inner index is: 0 The inner index is: 1 The inner index is: 2 The inner index is: 3 The outer index is: 1 The inner index is: 0 The inner index is: 1 The inner index is: 2 The inner index is: 3 The outer index is: 2 The inner index is: 0 The inner index is: 1 The inner index is: 2 The inner index is: 3 For this example we can see how every time the outer loop iterates one time, the inner loop iterates fully. This is an important concept for 2D array traversal, because for every row in a two dimensional matrix, we want to iterate through every column. Nested loops can consist of any type of loop and with any combination of loops. Let's take a look at a few more interesting examples. Here is an example of nested while loops: 1 2 3 4 5 6 7 8 9 int outerCounter = 0 ; int innerCounter = 0 ; while ( outerCounter < 5 ){ outerCounter ++ ; innerCounter = 0 ; while ( innerCounter < 7 ){ innerCounter ++ ; } } We can even have some interesting combinations. Here is an enhanced for loop inside of a while loop: 1 2 3 4 5 6 7 8 9 10 int outerCounter = 0 ; int [] innerArray = { 1 , 2 , 3 , 4 , 5 }; while ( outerCounter < 7 ){ System . out . println (); for ( int number : innerArray ){ System . out . print ( number * outerCounter + \" \" ); } outerCounter ++ ; } The output of the above example creates a multiplication table: 0 0 0 0 0 1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20 5 10 15 20 25 6 12 18 24 30 This is an interesting example, because for every iteration of the while loop, we iterate through every element of an array using an enhanced for loop. This is similar to the iteration pattern we use for 2D array traversal.","title":"Review of Nested Loops"},{"location":"java-2d-arrays/#traversing-2d-arrays-introduction","text":"Traversing 2D arrays using loops is important because it allows us to access many elements quickly, access elements in very large 2D arrays, and even access elements in 2D arrays of unknown sizes. Let's remember the structure of 2D arrays in Java: char [][] letterBlock = {{ 'a' , 'b' , 'c' },{ 'd' , 'e' , 'f' },{ 'g' , 'h' , 'i' },{ 'j' , 'k' , 'l' }}; In Java, 2D arrays are like normal arrays, but each element is another array. This is shown by the initialized 2D array above. The outer array consists of four elements, where each element consists of a three element subarray. Let\u2019s see what happens when we access elements of the outer array 1 2 3 4 System . out . println ( Arrays . toString ( letterBlock [ 0 ] ) + \"\\n\" ); System . out . println ( Arrays . toString ( letterBlock [ 1 ] ) + \"\\n\" ); System . out . println ( Arrays . toString ( letterBlock [ 2 ] ) + \"\\n\" ); System . out . println ( Arrays . toString ( letterBlock [ 3 ] ) + \"\\n\" ); This would output the following: [a, b, c] [d, e, f] [g, h, i] [j, k, l] As you can see, we can retrieve the entire subarray from each of the outer array elements. If you look at how we are accessing these subarrays, we are just increasing the index. This means we can access each sub-array in the 2D array using a loop! Let\u2019s take a look at an example which produces the same output, but can handle any sized 2D array. 1 2 3 for ( int index = 0 ; index < letterBlock . length ; index ++ ){ System . out . println ( Arrays . toString ( letterBlock [ index ] ) + \"\\n\" ); } Here is the output: [a, b, c] [d, e, f] [g, h, i] [j, k, l] Now let's remember how to access a value from the subarray. Previously, we learned that we can use the double brackets [][] , where the first set of brackets contains the index of the element of the outer array and the second set of brackets contains the index of the element in the subarray. If we wanted to retrieve the letter 'f' we would use: char storedLetter = letterBlock [ 1 ][ 2 ] ; Since we know we can use a loop to retrieve each of the subarrays stored in the outer array, we can then use a nested loop to access each of the elements from the sub-array. You might be wondering how we can figure out the number of iterations needed in order to fully traverse the 2D array. In order to find the number of elements in the outer array, we just need to get the length of the 2D array. int lengthOfOuterArray = letterBlock . length ; When thinking about the 2D array in matrix form, this is the height of the matrix (the number of rows) In order to find the number of elements in the subarray, we can get the length of the subarray after it has been retrieved from the outer array. Remember that we retrieved the sub array earlier using this format: char [] subArray = letterBlock [ 0 ] ; Therefore, we can use this to get the length of the first subarray in the 2D array int lengthOfSubArray = letterBlock [ 0 ] . length ; When thinking about the 2D array in matrix form, this is the width of the matrix (the number of columns) In most cases, getting the length of the first subarray in the 2D array will apply to the rest of the subarrays (if it is rectangular in shape), but there are rare occasions where the length of the subarrays could be different. This occurs if the 2D array is a jagged array. Let's look at an example: 1 2 3 4 5 6 for ( int a = 0 ; a < letterBlock . length ; a ++ ) { for ( int b = 0 ; b < letterBlock [ a ] . length ; b ++ ) { System . out . print ( \"Accessed: \" + letterBlock [ a ][ b ] + \"\\t\" ); } System . out . println (); } You can think of the variable a as being the outer loop index, and the variable b as being the inner loop index. This gives the following output: Accessed: a Accessed: b Accessed: c Accessed: d Accessed: e Accessed: f Accessed: g Accessed: h Accessed: i Within the nested for loop, we can see that each of the subarray elements are being accessed by using the outer loop index for the outer array, and the inner loop index for the subarray. Here is a diagram to help visualize how the 2D array is traversed using nested loops: We don't have to only use regular for loops for traversing 2D arrays. We can use enhanced for loops if we do not need to keep track of the indices. Since enhanced for loops only use the element of the arrays, it is a bit more cumbersome to keep track of which index we are at. This same idea applies to while and do-while loops as well. This is why we usually use regular for loops except for when we want to do something simple like printing.","title":"Traversing 2D Arrays: Introduction"},{"location":"java-2d-arrays/#traversing-2d-arrays-practice-with-loops","text":"In enhanced for loops, each element is iterated through until the end of the array. When we think about the structure of 2D arrays in Java (arrays of array objects) then we know that the outer enhanced for loop elements are going to be arrays. Let's take a look at an example: Given this 2D array of character data: char [][] charData = {{ 'a' , 'b' , 'c' , 'd' , 'e' , 'f' },{ 'g' , 'h' , 'i' , 'j' , 'k' , 'l' }}; Print out every character using enhanced for loops: 1 2 3 4 5 6 for ( char [] charRow : charData ) { for ( char c : charRow ) { System . out . print ( c + \" \" ); } System . out . println (); } Remember that the syntax for enhanced for loops looks like so: for ( datatype elementName : arrayName ){ . Since 2D arrays in Java are arrays of arrays, each element in the outer enhanced for loop is an entire row of the 2D array. The nested enhanced for loop is then used to iterate through each element in the extracted row. Here is the output of the above code: a b c d e f g h i j k l Here is an example which accomplishes the same thing, but using while loops: 1 2 3 4 5 6 7 8 9 10 int i = 0 , j = 0 ; while ( i < charData . length ) { j = 0 ; while ( j < charData [ i ] . length ) { System . out . print ( charData [ i ][ j ] + \" \" ); j ++ ; } System . out . println (); i ++ ; } Here is the output of the above code: a b c d e f g h i j k l Notice how we can use different loop types for traversal, but still receive the same result.","title":"Traversing 2D Arrays: Practice with Loops"},{"location":"java-2d-arrays/#traversing-2d-arrays-row-major-order","text":"Row-major order for 2D arrays refers to a traversal path which moves horizontally through each row starting at the first row and ending with the last. Although we have already looked at how 2D array objects are stored in Java, this ordering system conceptualizes the 2D array into a rectangular matrix and starts the traversal at the top left element and ends at the bottom right element. Here is a diagram which shows the path through the 2D array: This path is created by the way we set up our nested loops. In the previous exercise, we looked at how we can traverse the 2D array by having nested loops in a variety of formats, but if we want to control the indices, we typically use standard for loops. Let\u2019s take a closer look at the structure of the nested for loops when traversing a 2D array: Given this 2D array of strings describing the element positions: 1 2 3 4 String [][] matrix = {{ \"[0][0]\" , \"[0][1]\" , \"[0][2]\" }, { \"[1][0]\" , \"[1][1]\" , \"[1][2]\" }, { \"[2][0]\" , \"[2][1]\" , \"[2][2]\" }, { \"[3][0]\" , \"[3][1]\" , \"[3][2]\" }}; Lets keep track of the total number of iterations as we traverse the 2D array: 1 2 3 4 5 6 7 8 9 10 int stepCount = 0 ; for ( int a = 0 ; a < matrix . length ; a ++ ) { for ( int b = 0 ; b < matrix [ a ] . length ; b ++ ) { System . out . print ( \"Step: \" + stepCount ); System . out . print ( \", Element: \" + matrix [ a ][ b ] ); System . out . println (); stepCount ++ ; } } This would produce the following output: Step: 0, Element: [0][0] Step: 1, Element: [0][1] Step: 2, Element: [0][2] Step: 3, Element: [1][0] Step: 4, Element: [1][1] Step: 5, Element: [1][2] Step: 6, Element: [2][0] Step: 7, Element: [2][1] Step: 8, Element: [2][2] Step: 9, Element: [3][0] Step: 10, Element: [3][1] Step: 11, Element: [3][2] The step value increases with every iteration within the inner for loop. Because of this, we can see the order in which each element is accessed. If we follow the step value in the output shows us that the elements are accessed in the same order as the row-major diagram above. Now why is that? This is because in our for loop, we are using the number of rows as the termination condition within the outer for loop header a < matrix . length ; . Additionally, we are using the number of columns b < matrix [ a ] . length as the termination condition for our inner loop. Logically we are saying: \u201cFor every row in our matrix, iterate through every single column before moving to the next row\u201d. This is why our above example is traversing the 2D array using row-major order. Here is a diagram showing which loop accesses which part of the 2D array for row-major order:","title":"Traversing 2D Arrays: Row-Major Order"},{"location":"java-2d-arrays/#why-use-row-major-order","text":"Row-major order is important when we need to process data in our 2D array by row. You can be provided data in a variety of formats and you may need to perform calculations of rows of data at a time instead of individual elements. Let's take one of our previous checkpoint exercises as an example. You were asked to calculate the sum of the entire 2D array of integers by traversing and accessing each element. Now, if we wanted to calculate the sum of each row, or take the average of each row, we can use row-major order to access the data in the order that we need. Let's look at an example! Given a 6X3 2D array of doubles: 1 2 3 4 5 6 double [][] data = {{ 0.51 , 0.99 , 0.12 }, { 0.28 , 0.99 , 0.89 }, { 0.05 , 0.94 , 0.05 }, { 0.32 , 0.22 , 0.61 }, { 1.00 , 0.95 , 0.09 }, { 0.67 , 0.22 , 0.17 }}; Calculate the sum of each row using row-major order: 1 2 3 4 5 6 7 8 double rowSum = 0.0 ; for ( int o = 0 ; o < data . length ; o ++ ) { rowSum = 0.0 ; for ( int i = 0 ; i < data [ o ] . length ; i ++ ) { rowSum += data [ o ][ i ] ; } System . out . println ( \"Row: \" + o + \", Sum: \" + rowSum ); } The output for the above code is: Row: 0, Sum: 1.62 Row: 1, Sum: 2.16 Row: 2, Sum: 1.04 Row: 3, Sum: 1.15 Row: 4, Sum: 2.04 Row: 5, Sum: 1.06 An interesting thing to note is that, due to the way 2D arrays are structured in Java, enhanced for loops are always in row-major order. This is because an enhanced for loop iterates through the elements of the outer array which causes the terminating condition to be the length of the 2D array which is the number of rows.","title":"Why Use Row-Major Order?"},{"location":"java-2d-arrays/#traversing-2d-arrays-column-major-order","text":"Column-major order for 2D arrays refers to a traversal path which moves vertically down each column starting at the first column and ending with the last. This ordering system also conceptualizes the 2D array into a rectangular matrix and starts the traversal at the top left element and ends at the bottom right element. Column-major order has the same starting and finishing point as row-major order, but it\u2019s traversal is completely different Here is a diagram which shows the path through the 2D array: In order to perform column-major traversal, we need to set up our nested loops in a different way. We need to change the outer loop from depending on the number of rows, to depending on the number of columns. Likewise we need the inner loop to depend on the number of rows in its termination condition. Let's look at our example 2D array from the last exercise and see what needs to be changed. Given this 2D array of strings describing the element positions: 1 2 3 4 String [][] matrix = {{ \"[0][0]\" , \"[0][1]\" , \"[0][2]\" }, { \"[1][0]\" , \"[1][1]\" , \"[1][2]\" }, { \"[2][0]\" , \"[2][1]\" , \"[2][2]\" }, { \"[3][0]\" , \"[3][1]\" , \"[3][2]\" }}; Let's keep track of the total number of iterations as we traverse the 2D array. We also need to change the termination condition (middle section) within the outer and inner for loop. 1 2 3 4 5 6 7 8 9 10 int stepCount = 0 ; for ( int a = 0 ; a < matrix [ 0 ] . length ; a ++ ) { for ( int b = 0 ; b < matrix . length ; b ++ ) { System . out . print ( \"Step: \" + stepCount ); System . out . print ( \", Element: \" + matrix [ b ][ a ] ); System . out . println (); stepCount ++ ; } } Here is the output for the above code: Step: 0, Element: [0][0] Step: 1, Element: [1][0] Step: 2, Element: [2][0] Step: 3, Element: [3][0] Step: 4, Element: [0][1] Step: 5, Element: [1][1] Step: 6, Element: [2][1] Step: 7, Element: [3][1] Step: 8, Element: [0][2] Step: 9, Element: [1][2] Step: 10, Element: [2][2] Step: 11, Element: [3][2] As you can see in the code above, the way we accessed the elements from our 2D array of strings called matrix is different from the way we accessed them when using row-major order. Let\u2019s remember that the way we get the number of columns is by using matrix [ 0 ] . length and the way we get the number of rows is by using matrix . length . Because of these changes to our for loops, our iterator a now iterates through every column while our iterator b iterates through every row. Since our iterators now represent the opposite values, whenever we access an element from our 2D array, we need to keep in mind what indices we are passing to our accessor. Remember the format we use for accessing the elements matrix [ row ][ column ] ? Since a now iterates through our column indices, we place it in the right set of brackets, and the b is now placed in the left set of brackets. Here is a diagram showing which loop accesses which part of the 2D array for column-major order:","title":"Traversing 2D Arrays: Column-Major Order"},{"location":"java-2d-arrays/#why-use-column-major-order","text":"Column major order is important because there are a lot of cases when you need to process data vertically. Let\u2019s say that we have a chart of information which includes temperature data about each day. The top of each column is labeled with a day, and each row represents an hour. In order to find the average temperature per day, we would need to traverse the data vertically since each column represents a day. As mentioned in the last exercise, data can be provided in many different formats and shapes and you will need to know how to traverse it accordingly. Let\u2019s look at our sum example from the last exercise, but now using column-major order. Given a 6X3 2D array of doubles: 1 2 3 4 5 6 double [][] data = {{ 0.51 , 0.99 , 0.12 }, { 0.28 , 0.99 , 0.89 }, { 0.05 , 0.94 , 0.05 }, { 0.32 , 0.22 , 0.61 }, { 1.00 , 0.95 , 0.09 }, { 0.67 , 0.22 , 0.17 }}; Calculate the sum of each column using column-major order: 1 2 3 4 5 6 7 8 double colSum = 0.0 ; for ( int o = 0 ; o < data [ 0 ] . length ; o ++ ) { colSum = 0.0 ; for ( int i = 0 ; i < data . length ; i ++ ) { colSum += data [ i ][ o ] ; } System . out . println ( \"Column: \" + o + \", Sum: \" + colSum ); } The output of the above code is: Column: 0, Sum: 2.83 Column: 1, Sum: 4.31 Column: 2, Sum: 1.93","title":"Why Use Column-Major Order?"},{"location":"java-2d-arrays/#combining-traversal-and-conditional-logic","text":"When working with 2D arrays, it is important to be able to combine traversal logic with conditional logic in order to effectively navigate and process the data. Here are a few ways in how conditional logic can affect 2D array traversal: Skipping or selecting certain rows and columns Modifying elements only if they meet certain conditions Complex calculations using the 2D array data Formatting the 2D array Avoiding exceptions / smart processing Let\u2019s go over a few examples which use these ideas: First, let\u2019s think about a situation where you have some string data inside a 2D array. We have an application which allows users to input events on a calendar. This is represented by a 5x7 2D array of strings. Due to the fact that the number of days in each month is slightly different and that there are less than 35 days in a month, we know that some of our elements are going to be empty. We want our application to do a few things: Detect which days of which weeks have something planned and alert us about the event. Count the number of events for each week Count the number of events for each day Here is a visualization of what our calendar data looks like after a user has entered in some event information: Here\u2019s what our calendar data looks like in our application: 1 String [][] calendar = {{ \"volunteer\" , \"delivery\" , null , null , \"doctor\" , null , \"soccer\" }, { null , \"exam 1\" , null , \"mechanic\" , null , null , \"soccer\" }, { \"volunteer\" , \"off work\" , null , \"birthday\" , null , \"concert\" , null }, { null , \"exam 2\" , null , null , \"doctor\" , null , \"soccer\" }, { \"visit family\" , null , null , null , null , null , null }}; Let\u2019s look at some code which accomplishes the requirements above. Carefully look through each line of code and read all of the comments. There are a few things to note: Row-major or column-major order can be used to access the individual events Row-major order must be used to count the number of events per week since each row represents a week Let\u2019s take care of the first 2 requirements in one set of nested row-major loops 1 2 3 4 5 6 7 8 9 10 11 12 13 for ( int i = 0 ; i < calendar . length ; i ++ ) { numberOfEventsPerWeek = 0 ; for ( int j = 0 ; j < calendar [ i ] . length ; j ++ ) { // We need conditional logic to ensure that we do not count the empty days String event = calendar [ i ][ j ] ; if ( event != null && ! event . equals ( \"\" )) { // If the day does not have a null value or empty string for an event, then we print it and count it System . out . println ( \"Week: \" + ( i + 1 ) + \", Day: \" + ( j + 1 ) + \", Event: \" + event ); numberOfEventsPerWeek ++ ; } } System . out . println ( \"Total number of events for week \" + ( i + 1 ) + \": \" + numberOfEventsPerWeek + \"\\n\" ); } The code above produces the following output: Week: 1, Day: 1, Event: volunteer Week: 1, Day: 2, Event: delivery Week: 1, Day: 5, Event: doctor Week: 1, Day: 7, Event: soccer Total number of events for week 1: 4 Week: 2, Day: 2, Event: exam 1 Week: 2, Day: 4, Event: mechanic Week: 2, Day: 7, Event: soccer Total number of events for week 2: 3 Week: 3, Day: 1, Event: volunteer Week: 3, Day: 2, Event: off work Week: 3, Day: 4, Event: birthday Week: 3, Day: 6, Event: concert Total number of events for week 3: 4 Week: 4, Day: 2, Event: exam 2 Week: 4, Day: 5, Event: doctor Week: 4, Day: 7, Event: soccer Total number of events for week 4: 3 Week: 5, Day: 1, Event: visit family Total number of events for week 5: 1 Now let's complete the third requirement. Since we need to count all of the events for each of the weekdays, we will need to traverse the calendar vertically. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int numberOfEventsPerWeekday = 0 ; // We will use this array of day strings for our output later on so we don't have (day: 1) String [] days = { \"Sundays\" , \"Mondays\" , \"Tuesdays\" , \"Wednesdays\" , \"Thursdays\" , \"Fridays\" , \"Saturdays\" }; for ( int i = 0 ; i < calendar [ 0 ] . length ; i ++ ) { numberOfEventsPerWeekday = 0 ; for ( int j = 0 ; j < calendar . length ; j ++ ) { // Don't forget to flip the iterators in the accessor since we are flipping the direction we are navigating. // Remember, i now controls columns and j now controls rows String event = calendar [ j ][ i ] ; if ( event != null && ! event . equals ( \"\" )) { // Make sure we have an event for the day before counting it numberOfEventsPerWeekday ++ ; } } // Use the days string array from earlier to convert the day index to a real weekday string System . out . println ( \"Number of events on \" + days [ i ] + \": \" + numberOfEventsPerWeekday ); } The output is: Number of events on Sundays: 3 Number of events on Mondays: 4 Number of events on Tuesdays: 0 Number of events on Wednesdays: 2 Number of events on Thursdays: 2 Number of events on Fridays: 1 Number of events on Saturdays: 3 This example uses many of the concepts we have learned before. We use row-major order, column-major order, as well as including conditional logic to ensure that we have data for the elements we are accessing. Additionally, we can use conditional logic to skip portions of the 2D array. For example, let\u2019s say we wanted to print the events for weekdays only and skip the weekends. We could use a conditional statement such as if ( j != 0 && j != 6 ) in order to skip Sunday ( 0 ) and Saturday ( 6 ). These modifications to our 2D array traversal are very common when processing data in applications. We need to know which cells to look at (skipping column titles for example), which cells to ignore (empty data, invalid data, outliers, etc.), and which cells to convert (converting string input from a file to numbers).","title":"Combining Traversal and Conditional Logic"},{"location":"java-2d-arrays/#2d-array-review","text":"Let\u2019s review the concepts we have learned throughout these notes. Arrays are objects in Java, we can have arrays of objects, therefore we can also have arrays of arrays. This is the way 2D arrays are structured in Java. We can declare and initialize 2D arrays in a few different ways depending on the situation: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Declaring without initializing int [][] intTwoD ; // Initializing an empty 2D array which has already been declared intTwoD = new int [ 5 ][ 5 ] ; // Declaring and initializing an empty 2D array at once String [][] stringData = new String [ 3 ][ 6 ] ; // Declaring and initializing a 2D array using initializer lists double [][] doubleValues = {{ 1.5 , 2.6 , 3.7 }, { 7.5 , 6.4 , 5.3 }, { 9.8 , 8.7 , 7.6 }, { 3.6 , 5.7 , 7.8 }}; // Initializing a 2D array using initializer lists after it has already been declared, or already contains data; char [][] letters = new char [ 100 ][ 250 ] ; letters = new char [][] {{ 'a' , 'b' , 'c' }, { 'd' , 'e' , 'f' }}; We retrieve elements in a 2D array by providing a row and column index char c = letters [ 0 ][ 1 ] ; We can also think of them as the index of the outer array and the index of the subarray We can modify elements the same way letters [ 1 ][ 2 ] = 'z' ; We traverse 2D arrays using nested loops. We can use loops of any type, but we typically use nested for loops to keep track of the indices Row-major order traverses through each row moving horizontally to the right through each row Column-major order traverses through each column moving vertically down through each column Row-major order and column-major order start and end on the same elements, but the paths are different. In order to convert row-major to column-major, we need to make the outer loop terminating condition depend on the number of columns, make the inner loop terminating condition depend on the number of rows, and flip the variables in our accessor within the inner loop to ensure that we don\u2019t try to access outside of the 2D array since we flipped the direction of traversal. Here are examples of row-major and column-major order: 1 2 3 4 5 6 7 8 9 10 11 12 13 // Row-major order for ( int o = 0 ; o < letters . length ; o ++ ) { for ( int i = 0 ; i < letters [ o ] . length ; i ++ ) { char c = letters [ o ][ i ] ; } } // Column-major order for ( int o = 0 ; o < letters [ 0 ] . length ; o ++ ) { for ( int i = 0 ; i < letters . length ; i ++ ) { char c = letters [ i ][ o ] ; } } Conditional logic in our 2D array traversal allows us to use the data in a meaningful way. We can control which rows and columns we look at, ensure that the data we are looking at is what we want, perform calculations on specific elements, avoid throwing exceptions, and more. Here is an example of traversal with conditional logic. Given this 2D array of Strings: String [][] words = {{ \"championship\" , \"QUANTITY\" , \"month\" },{ \"EMPLOYEE\" , \"queen\" , \"understanding\" },{ \"method\" , \"writer\" , \"MOVIE\" }}; We are going to flip the capitalization of the words: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 System . out . println ( \"Before...\" ); System . out . println ( Arrays . deepToString ( words ). replace ( \"],\" , \"],\\n\" ) + \"\\n\" ); for ( int i = 0 ; i < words . length ; i ++ ) { for ( int j = 0 ; j < words [ i ] . length ; j ++ ) { if ( words [ i ][ j ]!= null ) { // Check the capitalization boolean allCaps = true ; for ( char c : words [ i ][ j ] . toCharArray ()) if ( ! Character . isUpperCase ( c )) allCaps = false ; // Flip the capitalization if ( allCaps ) words [ i ][ j ] = words [ i ][ j ] . toLowerCase (); else words [ i ][ j ] = words [ i ][ j ] . toUpperCase (); } } } System . out . println ( \"After...\" ); System . out . println ( Arrays . deepToString ( words ). replace ( \"],\" , \"],\\n\" ) + \"\\n\" ); Here is the output of the above code: Before... [[championship, QUANTITY, month], [EMPLOYEE, queen, understanding], [method, writer, MOVIE]] After... [[CHAMPIONSHIP, quantity, MONTH], [employee, QUEEN, UNDERSTANDING], [METHOD, WRITER, movie]]","title":"2D Array Review"},{"location":"java-access-scope/","text":"Access, Encapsulation, & Scope The public Keyword The public and private keywords are very important within Java. These keywords are defining what parts of our code have access to other parts of our code. We can define the access of many different parts of our code including instance variables, methods, constructors, and even a class itself. If we choose to declare these as public this means that any part of our code can interact with them - even if that code is in a different class! The way we declare something to be public is to use the public keyword in the declaration statement. In the code block belowm, we have a public class, constructor, instance variables, and method. Notice the five different uses of public : 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Dog { public String name ; public int age ; public Dog ( String input_name , int input_age ){ name = input_name ; age = input_age ; } public void speak (){ System . out . println ( \"Arf! Arf! My name is \" + name + \" and I am a good dog!\" ); } } Since everything about a Dog is public, any other class can access anything about a Dog . For example, let's say there was a DogSchool class. Any method of the DogSchool class could make a new Dog using the public Dog constructor, directly access that Dog 's instance variables, and directly use that Dog 's methods: 1 2 3 4 5 6 7 public class DogSchool { public void makeADog (){ Dog cujo = new Dog ( \"Cujo\" , 7 ); System . out . println ( cujo . age ); cujo . speak (); } } Notice that the DogSchool class and the makeADog () method are also public. This means that if some other class created a DogSchool , they would have access to these methods as well! We have public methods calling public methods! One final thing to note is that for the purposes of this lesson, we'll almost always make our classes and constructors public . While you can set them to private , it's fairly uncommon to do so. Instead, we'll focus on why you might make your instance variables and methods private . The private Keyword and Encapsulation When a Class' instance variable or method is marked as private , that means that you can only access those structures from elsewhere inside that same class. Let's look back at our DogSchool example: 1 2 3 4 5 6 7 8 public class DogSchool { public void makeADog (){ Dog cujo = new Dog ( \"Cujo\" , 7 ); System . out . println ( cujo . age ); cujo . speak (); } } makeADog is trying to directly access Dog 's .age variable. It's also trying to use the . speak () method. If those are marked as private in the Dog class, the DogSchool class won't be able to do that. Other methods within the Dog class would be able to us . age or . speak () (for example, we could use cujo . age within the Dog class), but other classes won't have access. Accessor and Mutator Methods When writing classes, we often make all of our instance variables private . However, we still might want some other classes to have access to them, we just don't want those classes to know the exact variable name. To give other classes access to a private instance variable, we would write an accessor method (sometimes also known as a \"getter\" method). 1 2 3 4 5 6 7 8 9 public class Dog { private String name ; // other methods and constructors public String getName (){ return name ; } } Even though the instance variable name is private , other classes could call the public method getName () which returns the value of that instance variable. Accessor methods will always be public , and will have a return type of the instance variable they're accessing. Similarly, private instance variables often have mutator methods (sometimes known as \"setters\"). These methods allow other classes to reset the value stored in private instance variables. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Dog { private String name ; // Other methods and constructors public void setName ( String newName ){ name = newName ; } public static void main ( String [] args ){ Dog myDog = new Dog ( \"Cujo\" ); myDog . setName ( \"Lassie\" ); } } Mutator methods, or \"setters\", often are void methods - they don't return anything, they just reset the value of an existing variable. Similarly, they often have one parameter that is the same type as the variable they're trying to change. Scope: Local Variables In addition to access modifiers like public and private , the scope of the variable also determines what parts of your code can access that variable. The scope of a variable is determined by where the variable is declared. For example, because instance variables are declared inside a class but outside any methods or constructors, all methods and constructors are within the scope of that variable. For example, in the code block below, constructors and methods of the Dog class are using the Dog instance variables like name and age : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Dog { public String name ; public int age ; public int weight ; public Dog (){ name = \"Dani\" ; age = 5 ; weight = 30 ; } public void speak (){ System . out . println ( \"My name is \" + name ); } } However, if we have a variable declared inside a method, that variable can only be used inside that method. The same is true for parameters. The scope of those parameters is only the method they're associated with. If you try to use a parameter outside the function it's defined in, you'll get an error. These variables are often called local variables. Note that we don't use public or private when declaring local variables. This idea of scope extends to conditionals and loops as well. If you declare a variable inside the body of a conditional or in a loop, that variable can only be used inside that structure. This also includes the variable you're using as your looping value. For example, consider the following block of code: 1 2 3 4 for ( int i = 0 ; i < 10 ; i ++ ){ // you can use i here } // i is out of scope here You can only use i between the curly braces of the for loop. In general, whenever you see curly braces, be aware of the scope. If a variable is defined inside curly braces, and you try to use that variable outside those curly braces, you will likely see an error! Scope: The this Keyword Often times when creating classes, programmers will create local variables with the same name as instance variables. For example, consider the code block below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Dog { public String name ; public Dog ( String inputName ){ name = inputName ; } public void speakNewName ( String name ){ System . out . println ( \"Hello, my new name is\" + name ); } public static void main ( String [] args ){ Dog myDog = new Dog ( \"Winston\" ); myDog . speakNewName ( \"Darla\" ); // Prints \"Darla\" - \"Winston\" ignored } } We have an instance variable named name , but the method speakNewName has a parameter named name . So when the method tries to print name , which variable will be printed? By default, Java refers to the local variable name . So in this case, the value passed to the parameter will be printed and not the instance variable. If we wanted to access the instance variable and not the local variable, we could use the this keyword. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Dog { public String name ; public Dog ( String inputName ){ name = inputName ; } public void speakNewName ( String name ){ System . out . println ( \"Hello, my new name is\" + this . name ); } public static void main ( String [] args ){ Dog a = new Dog ( \"Fido\" ); Dog b = new Dog ( \"Odie\" ); a . speakNewName ( \"Winston\" ); // \"Fido\", the instance variable of Dog a is printed. \"Winston\" is ignored b . speakNewName ( \"Darla\" ); // \"Odie\", the instance variable of Dog b is printed. \"Darla\" is ignored. } } The this keyword is a reference to the current object. We used this . name in our speakNewName () method. This caused the method to print out the value stored in the instance variable name of whatever Dog Object called speakNewName () . (Note that in this somewhat contrived example, the local variable name used as a parameter gets completely ignored). Oftentimes, you\u2019ll see constructors have parameters with the same name as the instance variable. For example, you might see something like: 1 2 3 public Dog ( String name ){ this . name = name ; } You can read this as \u201cset this Dog 's instance variable name equal to the variable passed into the constructor\u201d. While this naming is a common convention, it can also be confusing. There\u2019s nothing wrong with naming your parameters something else to be more clear. Sometimes you will see something like: 1 2 3 public Dog ( String inputName ){ this . name = inputName ; } This is now a little clearer \u2014 we\u2019re setting the Dog 's instance variable name equal to the name we give the constructor. Finally, mutator methods also usually follow this pattern: 1 2 3 public void setName ( String name ){ this . name = name ; } We reset the instance variable to the value passed into the parameter. Throughout the rest of this lesson, we\u2019ll use this . when referring to an instance variable. This isn't always explicitly necessary \u2014 if there's no local variable with the same name, Java will know to use the instance variable with that name. That being said, it is a good habit to use this . when working with your instance variables to avoid potential confusion. Using this With Methods We've seen how the this works with variables, but we can also use the this with methods. Recall how we've been calling methods up to this point: 1 2 3 4 public static void main ( String ][] args ){ Dog myDog = new Dog ( \"Odie\" ); myDog . speak (); } Here we're creating an instance of a Dog and using that Dog to call the speak () method. However, when defining methods, we can also use the this keyword to call other methods. Consider the code block below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Computer { public int brightness ; public int volume ; public void setBrightness ( int inputBrightness ){ this . brightness = inputBrightness ; } public void setVolume ( int inputVolume ){ this . volume = inputvolume ; } public void resetSettings (){ this . setBrightness ( 0 ); this . setVolume ( 0 ); } } Take a look at resetSettings () method in particular. This method calls other methods from the class. But it needs an object to call those methods! Rather than create a new object (like we did with the Dog named myDog earlier), we use this as the object. What this means is that the object that calls resetSettings () will be used to call setBrightness ( 0 ) and setVolume ( 0 ) . 1 2 3 4 public static void main ( String [] args ){ Computer myComputer = new Computer (); myComputer . resetSettings (); } In this example, calling myComputer.resetSettings() is as if we called myComputer.setBrightness(0) and myComputer.setVolume(0) . this serves as a placeholder for whatever object was used to call the original method. Other Private Methods Now that we've seen how methods can call other methods using this. , let's look at a situation where you micht want to use private methods. Oftentimes, private methods are helper methods - that is to say that they're methods that other, bigger methods use. For example, for our CheckingAccount example, we might want a public method like getAccountInformation () that prints information like the name of the account owner, the amount of money in the account, and the amount of interest the account will make in a month. That way, another class, like a Bank , could call that public method to get all of that information quickly. Well, in order to get that information, we might want to break that larger method into several helper methods. For example, inside getAccountInformation () , we might want to call a function called calculateNextMonthInterest () . That helper method should probably be private . There's no need for a Bank to call these smaller helper methods - instead, a Bank can call one public method, and rely on that method to do all of the complicated work by calling smaller rivate methods. Access, Encapsualtion, & Scope Review The public and private keywords are used to define what parts of code have access to other classes, methods, constructors, and instance variables. Encapsulation is a technique used to keep implementation details hidden from other classes. Its aim is to create small bundles of logic. The this keyword can be used to designate the difference between instance variables and local variables. Local variables can only be used within the scope that they were defined in. The this keyword can be used to call methods when writing classes. Static Methods Refresher In these notes, we're going to dive into how to create classes with our own static methods and static variables. To begin, let's brush up on static methods. Static methods are methods that belong to an entire class, not a specific object of the class. Static methods are clled using the class name and the . operator. We've seen a couple static methods already! 1 2 3 4 5 double randomNumber = math . random (); // stores a random decimal between 0 and 1 in randomNumber double number = String . valueOf ( \"2.5\" ); // transforms the String \"2.5\" into a double In the first example. random () is a static method that belongs to the Math class. We didn't need to create a Math object (like Math myMathObject = new Math () ) in order to use that method. We could just call it using the class name. Similarly, valueOf () is a static method of the String class. Given a String as an input, this method will turn that String into a double . Again, we don't need to create a String object in order to call this method - we use the class itself to call it. Finally, notice that our main () methods have been static this whole time. When Java runs your program, it calls that main method of your class - YourClassName . main () . Static Variables We'll begin writing our own static methods soon, but before we do, let's take a look at static variables. Much like static methods, you can think of static variables as belonging to the class itself instead of belonging to a particular object of the class. Just like with static methods, we can access static variables by using the name of the class and the . operator. Finally, we declare static variables by using the static keyword during declaration. This keyword usually comes after the variable's access modifier ( public or private ). When we put this all together, we might end up with a class that looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Dog { // static variables public static String genus = \"Canis\" ; // instance variables public int age ; public String name ; public Dog ( int inputAge , String inputName ){ this . age = inputAge ; this . name = inputName ; } } Since all dogs share the same genus, we could use a static variable to store that information for the entire class. However, we want each dog to have it's own unique name and age , so those aren't static . We could now access this static variable in a main () function, like so: 1 2 3 4 5 6 7 public class Dog { // variables, constructors, and methods defined here public static void main ( String [] args ){ System . out . println ( Dog . genus ); // prints Canis } } Unlike static methods, you can still access static variables from a specific object of the class. However, no matter what object you use to access the variable, the value will always be the same. You can think of it as all objects of the class sharing the same variable. 1 2 3 4 5 6 7 8 public static void main ( String [] args ){ Dog snoopy = new Dog ( 3 , \"Snoopy\" ); Dog ringo = new Dog ( 5 , \"Ringo\" ); System . out . println ( Dog . genus ); // prints Canis System . out . println ( snoopy . genus ); // prints Canis System . out . println ( ringo . genus ); // prints Canis } Modifying Static Variables Now that we've created a couple of static variables, let's start to edit them. The good news is that editing static variables is similar to editing any other variable. Whether you're writing code in a constructor, a non-static method, or a static method, you have access to static variables. Often times, you'll see static variables used to keep track of information about all objects of a class. For example, our variable numATMs is keep track of the total number of ATM s in the system. Therefore, every time an ATM is created (using the constructor), we should increase that variable by 1 . If we could somehow destroy the ATM , the method that destroys it should decrease numATMs static variable by 1 . Similarly, we have a variable names totalMoney . This variable is keeping track of all money across all ATMs. Whenever we remove money from an ATM using the non-static withdrawMoney() method, we should modify the money instance variable for that particular ATM as well as the totalMoney variable. In doing so, all ATMs will know how much money is in the system. Writing Your Own Static Methods Now that we have seen how static variables work, let's look into how to write our own static methods. Let's get the syntax out of the way first - just like with variables, to create a static method, use the static keyword in the method's definition. Just like with variables, this keyword usually comes after public or private . 1 2 3 public static void myFirstStaticMethod (){ // code goes here } Often times, you'll see static methods that are accessors or mutators for static variables. 1 2 3 4 5 6 7 public static int getMyStaticVariable (){ return myStaticVariable ; } public static void setMyStaticVariable ( int newValue ){ myStaticVariable = newValue ; } One important rule to note is that static methods can't interact with non-static instance variables. To wrap our mind's around this, let's consider why we use this when working with non-static instance variables. Let's say we have a Dog class with a non-static instance variable named age . If we have a line of code like this . age = 5 ; , that means we're setting the age of a specific Dog equal to 5 . However, if age were static, that would mean that the variable belongs to the entire class, not just a specific object. The this keyword can't be used by a static method since static methods are associated with an entire class, not a specific object of that class. If you try to mix this with a static method, you'll see the error message non-static variable this cannot be referenced from a static context . Static Variables Review Static methods and variables are associated with the class as a whole, not objects of the class. Static methods and variables are declared as static by using the static keyword upon declaration. Static methods cannot interact with non-static instance variables. This is due to static methods not having a this reference. Both static methods and non-static methods can interact with static variables.","title":"Access, Encapsulation, & Scope"},{"location":"java-access-scope/#access-encapsulation-scope","text":"","title":"Access, Encapsulation, &amp; Scope"},{"location":"java-access-scope/#the-public-keyword","text":"The public and private keywords are very important within Java. These keywords are defining what parts of our code have access to other parts of our code. We can define the access of many different parts of our code including instance variables, methods, constructors, and even a class itself. If we choose to declare these as public this means that any part of our code can interact with them - even if that code is in a different class! The way we declare something to be public is to use the public keyword in the declaration statement. In the code block belowm, we have a public class, constructor, instance variables, and method. Notice the five different uses of public : 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Dog { public String name ; public int age ; public Dog ( String input_name , int input_age ){ name = input_name ; age = input_age ; } public void speak (){ System . out . println ( \"Arf! Arf! My name is \" + name + \" and I am a good dog!\" ); } } Since everything about a Dog is public, any other class can access anything about a Dog . For example, let's say there was a DogSchool class. Any method of the DogSchool class could make a new Dog using the public Dog constructor, directly access that Dog 's instance variables, and directly use that Dog 's methods: 1 2 3 4 5 6 7 public class DogSchool { public void makeADog (){ Dog cujo = new Dog ( \"Cujo\" , 7 ); System . out . println ( cujo . age ); cujo . speak (); } } Notice that the DogSchool class and the makeADog () method are also public. This means that if some other class created a DogSchool , they would have access to these methods as well! We have public methods calling public methods! One final thing to note is that for the purposes of this lesson, we'll almost always make our classes and constructors public . While you can set them to private , it's fairly uncommon to do so. Instead, we'll focus on why you might make your instance variables and methods private .","title":"The public Keyword"},{"location":"java-access-scope/#the-private-keyword-and-encapsulation","text":"When a Class' instance variable or method is marked as private , that means that you can only access those structures from elsewhere inside that same class. Let's look back at our DogSchool example: 1 2 3 4 5 6 7 8 public class DogSchool { public void makeADog (){ Dog cujo = new Dog ( \"Cujo\" , 7 ); System . out . println ( cujo . age ); cujo . speak (); } } makeADog is trying to directly access Dog 's .age variable. It's also trying to use the . speak () method. If those are marked as private in the Dog class, the DogSchool class won't be able to do that. Other methods within the Dog class would be able to us . age or . speak () (for example, we could use cujo . age within the Dog class), but other classes won't have access.","title":"The private Keyword and Encapsulation"},{"location":"java-access-scope/#accessor-and-mutator-methods","text":"When writing classes, we often make all of our instance variables private . However, we still might want some other classes to have access to them, we just don't want those classes to know the exact variable name. To give other classes access to a private instance variable, we would write an accessor method (sometimes also known as a \"getter\" method). 1 2 3 4 5 6 7 8 9 public class Dog { private String name ; // other methods and constructors public String getName (){ return name ; } } Even though the instance variable name is private , other classes could call the public method getName () which returns the value of that instance variable. Accessor methods will always be public , and will have a return type of the instance variable they're accessing. Similarly, private instance variables often have mutator methods (sometimes known as \"setters\"). These methods allow other classes to reset the value stored in private instance variables. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Dog { private String name ; // Other methods and constructors public void setName ( String newName ){ name = newName ; } public static void main ( String [] args ){ Dog myDog = new Dog ( \"Cujo\" ); myDog . setName ( \"Lassie\" ); } } Mutator methods, or \"setters\", often are void methods - they don't return anything, they just reset the value of an existing variable. Similarly, they often have one parameter that is the same type as the variable they're trying to change.","title":"Accessor and Mutator Methods"},{"location":"java-access-scope/#scope-local-variables","text":"In addition to access modifiers like public and private , the scope of the variable also determines what parts of your code can access that variable. The scope of a variable is determined by where the variable is declared. For example, because instance variables are declared inside a class but outside any methods or constructors, all methods and constructors are within the scope of that variable. For example, in the code block below, constructors and methods of the Dog class are using the Dog instance variables like name and age : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Dog { public String name ; public int age ; public int weight ; public Dog (){ name = \"Dani\" ; age = 5 ; weight = 30 ; } public void speak (){ System . out . println ( \"My name is \" + name ); } } However, if we have a variable declared inside a method, that variable can only be used inside that method. The same is true for parameters. The scope of those parameters is only the method they're associated with. If you try to use a parameter outside the function it's defined in, you'll get an error. These variables are often called local variables. Note that we don't use public or private when declaring local variables. This idea of scope extends to conditionals and loops as well. If you declare a variable inside the body of a conditional or in a loop, that variable can only be used inside that structure. This also includes the variable you're using as your looping value. For example, consider the following block of code: 1 2 3 4 for ( int i = 0 ; i < 10 ; i ++ ){ // you can use i here } // i is out of scope here You can only use i between the curly braces of the for loop. In general, whenever you see curly braces, be aware of the scope. If a variable is defined inside curly braces, and you try to use that variable outside those curly braces, you will likely see an error!","title":"Scope: Local Variables"},{"location":"java-access-scope/#scope-the-this-keyword","text":"Often times when creating classes, programmers will create local variables with the same name as instance variables. For example, consider the code block below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Dog { public String name ; public Dog ( String inputName ){ name = inputName ; } public void speakNewName ( String name ){ System . out . println ( \"Hello, my new name is\" + name ); } public static void main ( String [] args ){ Dog myDog = new Dog ( \"Winston\" ); myDog . speakNewName ( \"Darla\" ); // Prints \"Darla\" - \"Winston\" ignored } } We have an instance variable named name , but the method speakNewName has a parameter named name . So when the method tries to print name , which variable will be printed? By default, Java refers to the local variable name . So in this case, the value passed to the parameter will be printed and not the instance variable. If we wanted to access the instance variable and not the local variable, we could use the this keyword. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Dog { public String name ; public Dog ( String inputName ){ name = inputName ; } public void speakNewName ( String name ){ System . out . println ( \"Hello, my new name is\" + this . name ); } public static void main ( String [] args ){ Dog a = new Dog ( \"Fido\" ); Dog b = new Dog ( \"Odie\" ); a . speakNewName ( \"Winston\" ); // \"Fido\", the instance variable of Dog a is printed. \"Winston\" is ignored b . speakNewName ( \"Darla\" ); // \"Odie\", the instance variable of Dog b is printed. \"Darla\" is ignored. } } The this keyword is a reference to the current object. We used this . name in our speakNewName () method. This caused the method to print out the value stored in the instance variable name of whatever Dog Object called speakNewName () . (Note that in this somewhat contrived example, the local variable name used as a parameter gets completely ignored). Oftentimes, you\u2019ll see constructors have parameters with the same name as the instance variable. For example, you might see something like: 1 2 3 public Dog ( String name ){ this . name = name ; } You can read this as \u201cset this Dog 's instance variable name equal to the variable passed into the constructor\u201d. While this naming is a common convention, it can also be confusing. There\u2019s nothing wrong with naming your parameters something else to be more clear. Sometimes you will see something like: 1 2 3 public Dog ( String inputName ){ this . name = inputName ; } This is now a little clearer \u2014 we\u2019re setting the Dog 's instance variable name equal to the name we give the constructor. Finally, mutator methods also usually follow this pattern: 1 2 3 public void setName ( String name ){ this . name = name ; } We reset the instance variable to the value passed into the parameter. Throughout the rest of this lesson, we\u2019ll use this . when referring to an instance variable. This isn't always explicitly necessary \u2014 if there's no local variable with the same name, Java will know to use the instance variable with that name. That being said, it is a good habit to use this . when working with your instance variables to avoid potential confusion.","title":"Scope: The this Keyword"},{"location":"java-access-scope/#using-this-with-methods","text":"We've seen how the this works with variables, but we can also use the this with methods. Recall how we've been calling methods up to this point: 1 2 3 4 public static void main ( String ][] args ){ Dog myDog = new Dog ( \"Odie\" ); myDog . speak (); } Here we're creating an instance of a Dog and using that Dog to call the speak () method. However, when defining methods, we can also use the this keyword to call other methods. Consider the code block below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class Computer { public int brightness ; public int volume ; public void setBrightness ( int inputBrightness ){ this . brightness = inputBrightness ; } public void setVolume ( int inputVolume ){ this . volume = inputvolume ; } public void resetSettings (){ this . setBrightness ( 0 ); this . setVolume ( 0 ); } } Take a look at resetSettings () method in particular. This method calls other methods from the class. But it needs an object to call those methods! Rather than create a new object (like we did with the Dog named myDog earlier), we use this as the object. What this means is that the object that calls resetSettings () will be used to call setBrightness ( 0 ) and setVolume ( 0 ) . 1 2 3 4 public static void main ( String [] args ){ Computer myComputer = new Computer (); myComputer . resetSettings (); } In this example, calling myComputer.resetSettings() is as if we called myComputer.setBrightness(0) and myComputer.setVolume(0) . this serves as a placeholder for whatever object was used to call the original method.","title":"Using this With Methods"},{"location":"java-access-scope/#other-private-methods","text":"Now that we've seen how methods can call other methods using this. , let's look at a situation where you micht want to use private methods. Oftentimes, private methods are helper methods - that is to say that they're methods that other, bigger methods use. For example, for our CheckingAccount example, we might want a public method like getAccountInformation () that prints information like the name of the account owner, the amount of money in the account, and the amount of interest the account will make in a month. That way, another class, like a Bank , could call that public method to get all of that information quickly. Well, in order to get that information, we might want to break that larger method into several helper methods. For example, inside getAccountInformation () , we might want to call a function called calculateNextMonthInterest () . That helper method should probably be private . There's no need for a Bank to call these smaller helper methods - instead, a Bank can call one public method, and rely on that method to do all of the complicated work by calling smaller rivate methods.","title":"Other Private Methods"},{"location":"java-access-scope/#access-encapsualtion-scope-review","text":"The public and private keywords are used to define what parts of code have access to other classes, methods, constructors, and instance variables. Encapsulation is a technique used to keep implementation details hidden from other classes. Its aim is to create small bundles of logic. The this keyword can be used to designate the difference between instance variables and local variables. Local variables can only be used within the scope that they were defined in. The this keyword can be used to call methods when writing classes.","title":"Access, Encapsualtion, &amp; Scope Review"},{"location":"java-access-scope/#static-methods-refresher","text":"In these notes, we're going to dive into how to create classes with our own static methods and static variables. To begin, let's brush up on static methods. Static methods are methods that belong to an entire class, not a specific object of the class. Static methods are clled using the class name and the . operator. We've seen a couple static methods already! 1 2 3 4 5 double randomNumber = math . random (); // stores a random decimal between 0 and 1 in randomNumber double number = String . valueOf ( \"2.5\" ); // transforms the String \"2.5\" into a double In the first example. random () is a static method that belongs to the Math class. We didn't need to create a Math object (like Math myMathObject = new Math () ) in order to use that method. We could just call it using the class name. Similarly, valueOf () is a static method of the String class. Given a String as an input, this method will turn that String into a double . Again, we don't need to create a String object in order to call this method - we use the class itself to call it. Finally, notice that our main () methods have been static this whole time. When Java runs your program, it calls that main method of your class - YourClassName . main () .","title":"Static Methods Refresher"},{"location":"java-access-scope/#static-variables","text":"We'll begin writing our own static methods soon, but before we do, let's take a look at static variables. Much like static methods, you can think of static variables as belonging to the class itself instead of belonging to a particular object of the class. Just like with static methods, we can access static variables by using the name of the class and the . operator. Finally, we declare static variables by using the static keyword during declaration. This keyword usually comes after the variable's access modifier ( public or private ). When we put this all together, we might end up with a class that looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Dog { // static variables public static String genus = \"Canis\" ; // instance variables public int age ; public String name ; public Dog ( int inputAge , String inputName ){ this . age = inputAge ; this . name = inputName ; } } Since all dogs share the same genus, we could use a static variable to store that information for the entire class. However, we want each dog to have it's own unique name and age , so those aren't static . We could now access this static variable in a main () function, like so: 1 2 3 4 5 6 7 public class Dog { // variables, constructors, and methods defined here public static void main ( String [] args ){ System . out . println ( Dog . genus ); // prints Canis } } Unlike static methods, you can still access static variables from a specific object of the class. However, no matter what object you use to access the variable, the value will always be the same. You can think of it as all objects of the class sharing the same variable. 1 2 3 4 5 6 7 8 public static void main ( String [] args ){ Dog snoopy = new Dog ( 3 , \"Snoopy\" ); Dog ringo = new Dog ( 5 , \"Ringo\" ); System . out . println ( Dog . genus ); // prints Canis System . out . println ( snoopy . genus ); // prints Canis System . out . println ( ringo . genus ); // prints Canis }","title":"Static Variables"},{"location":"java-access-scope/#modifying-static-variables","text":"Now that we've created a couple of static variables, let's start to edit them. The good news is that editing static variables is similar to editing any other variable. Whether you're writing code in a constructor, a non-static method, or a static method, you have access to static variables. Often times, you'll see static variables used to keep track of information about all objects of a class. For example, our variable numATMs is keep track of the total number of ATM s in the system. Therefore, every time an ATM is created (using the constructor), we should increase that variable by 1 . If we could somehow destroy the ATM , the method that destroys it should decrease numATMs static variable by 1 . Similarly, we have a variable names totalMoney . This variable is keeping track of all money across all ATMs. Whenever we remove money from an ATM using the non-static withdrawMoney() method, we should modify the money instance variable for that particular ATM as well as the totalMoney variable. In doing so, all ATMs will know how much money is in the system.","title":"Modifying Static Variables"},{"location":"java-access-scope/#writing-your-own-static-methods","text":"Now that we have seen how static variables work, let's look into how to write our own static methods. Let's get the syntax out of the way first - just like with variables, to create a static method, use the static keyword in the method's definition. Just like with variables, this keyword usually comes after public or private . 1 2 3 public static void myFirstStaticMethod (){ // code goes here } Often times, you'll see static methods that are accessors or mutators for static variables. 1 2 3 4 5 6 7 public static int getMyStaticVariable (){ return myStaticVariable ; } public static void setMyStaticVariable ( int newValue ){ myStaticVariable = newValue ; } One important rule to note is that static methods can't interact with non-static instance variables. To wrap our mind's around this, let's consider why we use this when working with non-static instance variables. Let's say we have a Dog class with a non-static instance variable named age . If we have a line of code like this . age = 5 ; , that means we're setting the age of a specific Dog equal to 5 . However, if age were static, that would mean that the variable belongs to the entire class, not just a specific object. The this keyword can't be used by a static method since static methods are associated with an entire class, not a specific object of that class. If you try to mix this with a static method, you'll see the error message non-static variable this cannot be referenced from a static context .","title":"Writing Your Own Static Methods"},{"location":"java-access-scope/#static-variables-review","text":"Static methods and variables are associated with the class as a whole, not objects of the class. Static methods and variables are declared as static by using the static keyword upon declaration. Static methods cannot interact with non-static instance variables. This is due to static methods not having a this reference. Both static methods and non-static methods can interact with static variables.","title":"Static Variables Review"},{"location":"java-arrays/","text":"Arrays Introduction to Arrays We have seen how to store single pieces of data in variables. What happens when we need to store a group of data? What if we have a list of students in a classroom? Or a ranking of the top 10 horses finishing a horse race? If we were storing 5 lottery ticket numbers, for example, we could create a different variable for each value: 1 2 3 4 5 int firstNumber = 4 ; int secondNumber = 8 ; int thirdNumber = 12 ; int fourthNumber = 16 ; int fifthNumber = 20 ; That is a lot of ungainly repeated code. What if we had 100 lottery numbers? It is more clean and convenient to use a Java array to stroe the data as a list. An array hold a fixed number of values of one type. Arrays hold double s, int s, boolean s, or any other primitives . Arrays can also contains String s as well as object references! Each index of an array corresponds with a different value. Here is a diagram of an array filled with integer values: elements 4 8 12 16 20 indices 0 1 2 3 4 Similar to C and Python, the indexes start at 0! The element at index 0 is 4 , while the element at index 1 is 8 . This array has a length of 5, since it holds five elements, but the highest index of the array is 4. Creating an Array Explicitly Imagine that we're using a program to keep track of the prices of different items we want to buy. We would want a list of the prices and a list of the items they correspond to. To create an array, we first declare the type of data it holds. double [] prices ; Then, we can explicitly initialize the array to contain the data we want to store: prices = { 13.15 , 15.87 , 14.22 , 16.55 }; Just like with simple variables, we can declare and initialize in the same line: double [] prices = { 13.15 , 15.87 , 14.22 , 16.55 }; We can use arrays to hold String s and other objects as well as primitives: String [] clothingItems = { \"Tank Top\" , \"Beanie\" , \"Funny Socks\" , \"Pants\" }; Importing Arrays If we want to have a descriptive printout of an array, we need a toString () method that is provided by the Arrays package in Java. import java.util.Arrays ; We put this line at the top of the file, before we even define the class! When we import a package in Java, we are making all of the methods of that package available in our code. The Arrays package has many useful methods, including Arrays . toString () . When we pass an array into Arrays . toString () , we can see the contents of the array printed out. 1 2 3 4 5 6 7 8 9 10 import java.util.Arrays ; public class Lottery (){ public static void main ( String [] args ){ int [] lotteryNumbers = { 4 , 8 , 12 , 16 , 20 }; String betterPrintout = Arrays . toString ( lotteryNumbers ); System . out . println ( betterPrintout ); } } This code will print: [4, 8, 12, 16, 20] Get Element By Index Now that we have an array declared and intitialized, we want to be able to get values out of it. We use square brackets [] to access data at a certain index: 1 2 3 double [] prices = { 13.1 , 15.87 , 14.22 , 16.55 } System . out . println ( prices [ 1 ] ); This command will print out 15.87 . This happens because 15.87 is the item at the 1 index of the array. If we try to access an element outside of its appropriate index range, we will receive an ArrayIndexOutOfBoundsException error. For example, if we were to run the command System . out . println ( prices [ 5 ] ) , we would get the following output: java.lang.ArrayIndexOutOfBoundsException: 5 Creating an Empty Array We can also create empty arrays and then fill the items one by one. Empty arrays have to be intitialized with a fixed size: String [] menuItems = new String [ 5 ] ; Once you declare this size, it cannot be changed! This array will always be of size 5 . After declaring and intializing, we can set each index of the array to be a different item: 1 2 3 4 5 menuItems [ 0 ] = \"Veggie hot Dog\" ; menuItems [ 1 ] = \"Potato salad\" ; menuItems [ 2 ] = \"Cornbread\" ; menuItems [ 3 ] = \"Roasted broccoli\" ; menuItems [ 4 ] = \"Coffee ice cream\" ; This group of commands has the same effect as assigning the entire array at once: 1 String [] menuItems = { \"Veggie hot dog\" , \"Potato salad\" , \"Cornbread\" , \"Roasted broccoli\" , \"Coffee ice cream\" }; We can also change an item after it has been assigned! Let's say this restaurant is changing its broccoli dish to a cauliflower one: menuItems [ 3 ] = \"Baked cauliflower\" ; Now the array looks like: [\"Veggie hot dog\", \"Potato salad\", \"Cornbread\", \"Baked cauliflower\", \"Coffee ice cream\"] Array Length What if we have an array storing all the usernames for our program, and we want to quickly see how many users we have? To get the length of an array, we can access the length field of the array object: 1 2 String [] menuItems = new String [ 5 ] ; System . out . println ( menuItems . length ); This command would print 5 , since the menuItems array has 5 slots, even though they are all empty. If we print out the length of the prices array: 1 2 3 double [] prices = { 13.1 , 15.87 , 14.22 , 16.55 }; System . out . println ( prices . length ); We would see 4 , since there are four items in the prices array! String [] args When we write main () methods for our programs, we use the parameter String [] args . Now that we know about array syntax, we can start to parse what that means. A String [] is an array made up of String s. Examples of String arrays: 1 2 String [] humans = { \"Nick\" , \"Alyssa\" , \"Matt\" , \"Nathan\" }; String [] robots = { \"R2D2\" , \"Marvin\" , \"Wall-E\" , \"Bender\" }; The args parameter is another example of a String array. In this case, the array args contains the arguments that we pass in from the terminal when we run the class file. (So far args has been empty.) So how can you pass arguments to main () > Let's say we have this class HelloYou : 1 2 3 4 5 public class HelloYou { public static void main ( String [] args ){ System . out . println ( \"Hello \" + args [ 0 ] ;) } } When we runn the file HelloYou in the terminal with an argument of \"Laura\" : java HelloYou Laura We get the output: Hello Laura The String [] args would be interpreted as an array with one element, \"Laura\" . When we use args [ 0 ] in the main method, we can access that element like we did in HelloYou . We can actually create if-else statements that run based on the input: 1 2 3 4 5 6 7 if ( args [ 0 ] . equals ( \"A\" )){ // do something } else if ( args [ 0 ] . equals ( \"B\" )){ // do something } else { // do something } Arrays Review We have now seen how to store a list of values in an array. We can use this knowledge to make organized programs with more complex variables. Throughout these notes, we have leared about: Creating arrays explicitly, using { and } . Accessing an index of an array, using [ and ] . Creating empty arrays of a certain size, and filling the indices one by one. Getting the length of an array using .length . Using the argument args that is passed into the main () method of a class. Let's create a small program that holds student names and test scores with the following characteristics: Make an array of strings called students with the following names: Sade, Alexus, Sam, Koma. Create an empty array of double s called mathScores of size 4. Sade got a 94.5 on the test. Store this value in the same indice that she is listed in the students array. Sam got a 76.8. Store this value in the appropriate spot in the mathScores array. Finally, add a print statement that says: \"The number of students in the class is numStudents .\" using the .length operator. 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.util.Arrays ; public class Classroom { public static void main ( String [] args ){ String [] students = { \"Sade\" , \"Alexus\" , \"Sam\" , \"Koma\" }; double [] mathScores = new double [ 4 ] ; mathScores [ 0 ] = 94.5 ; mathScores [ 2 ] = 76.8 ; System . out . println ( \"The number of students in the class is \" + students . length + \".\" ); } } Introduction to ArrayLists When we work with arrays in Java, we've been limited by the fact that once an array is created, it has a fixed size. We can't add or remove elements. But what if we needed to add to the book lists, newsfeeds, and other structures we were using arrays to represent? To create multiple and dynamic lists, we can use Java's ArrayList s. ArrayList s allow us to: Store object references as elements Store elements of the same type (just like arrays) Access elements by index (just like arrays) Add elements Remove elements Remember how we had to import java.util.Arrays in order to use additional array methods? To use an ArrayList at all, we need to import them from Java's util package as well: import java.util.ArrayList ; Creating ArrayLists To create an ArrayList , we need to declare the type of object it will hold, just as we do with arrays: ArrayList < String > babyNames ; We use angle brackets ( <> ) to declare the type of the ArrayList . These symbols are used for generics . Generics are a Java construct that allows us to define classes and objects as parameters of an ArrayList . For this reason, we can't use primitive types in an ArrayList : 1 2 3 4 5 // This code won't compile: ArrayList < int > ages ; // This code will compile: ArrayList < Integer > ages ; The <Integer> generic has to be used in an ArrayList instead. You can also use <Double> and <Char> for types you would normally declare as double s or char s. We can intialize to an empty ArrayList using the new keyword: 1 2 3 4 5 6 7 // Declaring: ArrayList < Integer > ages ; // Intializing: ages = new ArrayList < Integer > (); // Declaring and intializing in one line: ArrayList < String > babyNames = new ArrayList < String > (); Adding Items to an ArrayList Now we have an empty ArrayList , but how do we get it to store values? ArrayList comes with an add() method which inserts an element into the structure. There are two ways we can use add() . If we want to add an element to the end of the ArrayList , we'll call add() using only one arguement that represents the value we are inserting. In this example, we'll add objects from the Car class to an ArrayList called carShow : 1 2 3 4 5 6 7 8 ArrayList < Car > carShow = new ArrayList < Car > (); carShow . add ( ferrari ); // carShow now holds [ferrari] carShow . add ( thunderbird ); // carShow now holds [ferrari, thunderbird] carShow . add ( volkswagen ); // carShow now holds [ferrari, thunderbird, volkswagen] If we want to add an element at a specific index of our ArrayList , we'll need two arguments in our method call: the first arguement will define the index of the new element while the second argument defines the value of the new element: 1 2 3 4 5 6 7 // Insert object corvette at index 1 carShow . add ( 1 , corvette ); // carShow now holds [ferrari, corvette, thunderbird, volkswagen] // Insert object porsche at index 2 carShow . add ( 2 , porsche ); // carShow now holds [ferrari, corvette, porsche, thunderbird, volkswagen] By inserting a value at a specified index, any elements that appear after this new element will have their index shift over by 1. Also, note that an error will occur if we try to insert a value at an index that does not exist. You are able to add multiple data types to the same array using add() : 1 2 3 4 5 ArrayList assortment = new ArrayList <> (); assortment . add ( \"Hello\" ); // String assortment . add ( 12 ); // Integer assortment . add ( ferrari ); // reference to Car // assortment holds [\"Hello\", 12, ferrari] In this case, the items stored in this ArrayList will be considered Objects . As a result, they won\u2019t have access to some of their methods without doing some fancy casting. Although this type of ArrayList is allowed, using an ArrayList that specifies its type is preferred. ArrayList Size Let's say we have an ArrayList that stores items in a user's online shopping cart. As the user navigates through the site and adds items, their cart grows bigger and bigger. If we wanted to display the number of items in the cart, we could find the size of it using the size() method: 1 2 3 4 5 6 7 8 9 10 11 ArrayList < String > shoppingCart = new ArrayList < String > (); shoppingCart . add ( \"Goofy socks\" ); System . out . println ( shoppingCart . size ()); // 1 is printed shoppingCart . add ( \"Funny tie\" ); System . out . println ( shoppingCart . size ()); // 2 is printed shoppingCart . add ( \"HK-416 Assault Rifle\" ); System . out . println ( shoppingCart . size ()); // 3 is printed In dynamic objects like ArrayList s, it's important to know how to access the amount of objects we have stored. Accessing an Index With arrays, we can use bracket notation to access a value at a particular index: 1 2 3 4 double [] ratings = { 3.2 , 5.5 , 1.6 }; System . out . println ( ratings [ 1 ] ); // this will print 5.5 This code prints 5.5 , the value at index 1 of the array. For ArrayList s, bracket notation won't work. Instead we use the method get() to access an index: 1 2 3 4 5 6 7 ArrayList < String > shoopingCart = new ArrayList < String > (); shoppingCart . add ( \"Goofy Socks\" ); shoppingCart . add ( \"Funny tie\" ); shoppingCart . add ( \"HK-416 Assault Rifle\" ); System . out . println ( shoppingCart . get ( 2 )); This code prints \"HK-416 Assault Rifle\" , which is the value at index 2 of the ArrayList . Changing a Value When we were using arrays, we could rewrite entries by using bracket notation to reassign values: 1 2 3 4 String [] shoppingCart = { \"Goofy Socks\" , \"Funny tie\" , \"HK-416 Assault Rifle\" }; shoppingCart [ 0 ] = \"Serious Socks\" ; // This overwrites the \"Goofy Socks\" string with \"Serious Socks\" ArrayList has a slightly different way of doing this, using the set() method: 1 2 3 4 5 6 7 8 9 ArrayList < String > shoppingCart = new ArrayList < shoppingCart > (); shoppingCart . add ( \"Goofy Socks\" ); shoppingCart . add ( \"Funny tie\" ); shoppingCart . add ( \"HK-416 Assault Rifle\" ); shoppingCart . set ( 0 , \"Serious Socks\" ); // shoppingCart now holds [\"Serious Socks\", \"Funny tie\", \"HK-416 Assault Rifle\"] Removing an Item What if we wanted to get rid of an entry alltogether? For arrays, we would have to make a completely new array without the value. Luckily, ArrayList s allow us to remove an item by specifying the index to remove: 1 2 3 4 5 6 7 8 ArrayList < String > shoppingCart = new ArrayList < shoppingCart > (); shoppingCart . add ( \"Goofy Socks\" ); shoppingCart . add ( \"Funny tie\" ); shoppingCart . add ( \"HK-416 Assault Rifle\" ); shoppingCart . remove ( 1 ); // shoppingCart now holds [\"Goofy Socks\", \"HK-416 Assault Rifle\"] We can also remove an item by specifying the value to remove: 1 2 3 4 5 6 7 8 ArrayList < String > shoppingCart = new ArrayList < shoppingCart > (); shoppingCart . add ( \"Goofy Socks\" ); shoppingCart . add ( \"Funny tie\" ); shoppingCart . add ( \"HK-416 Assault Rifle\" ); shoppingCart . remove ( \"Funny tie\" ); // shoppingCart now holds [\"Goofy Socks\", \"HK-416 Assault Rifle\"] Note : This command removes the FIRST instance of the value \"Funny tie\". Getting an Item's Index What if we had a really large list and wanted to know the position of a certain element in it? For instance, what if we had an ArrayList detectives with the names of fictional detectives in chronological order, and we wanted to know what position \"Flecther\" was. 1 2 // detectives holds [\"Holmes\", \"Poirot\", \"Marple\", \"Spade\", \"Fletcher\", \"Conan\", \"Ramotswe\"]; System . out . println ( detectives . indexOf ( \"Fletcher\" )); This code would print 4 , since \"Fletcher\" is at index 4 of the detectives ArrayList . ArrayLists Review Some crucial methods in ArrayList s: Adding a new ArrayList item using add() . Accessing the size of an ArrayList using size() . Finding an item by index using get() . Changing the value of an ArrayList item using set() . Removing an item with a specific value using remove() . Retrieving the index of an item with a specific value using indexOf() .","title":"Arrays"},{"location":"java-arrays/#arrays","text":"","title":"Arrays"},{"location":"java-arrays/#introduction-to-arrays","text":"We have seen how to store single pieces of data in variables. What happens when we need to store a group of data? What if we have a list of students in a classroom? Or a ranking of the top 10 horses finishing a horse race? If we were storing 5 lottery ticket numbers, for example, we could create a different variable for each value: 1 2 3 4 5 int firstNumber = 4 ; int secondNumber = 8 ; int thirdNumber = 12 ; int fourthNumber = 16 ; int fifthNumber = 20 ; That is a lot of ungainly repeated code. What if we had 100 lottery numbers? It is more clean and convenient to use a Java array to stroe the data as a list. An array hold a fixed number of values of one type. Arrays hold double s, int s, boolean s, or any other primitives . Arrays can also contains String s as well as object references! Each index of an array corresponds with a different value. Here is a diagram of an array filled with integer values: elements 4 8 12 16 20 indices 0 1 2 3 4 Similar to C and Python, the indexes start at 0! The element at index 0 is 4 , while the element at index 1 is 8 . This array has a length of 5, since it holds five elements, but the highest index of the array is 4.","title":"Introduction to Arrays"},{"location":"java-arrays/#creating-an-array-explicitly","text":"Imagine that we're using a program to keep track of the prices of different items we want to buy. We would want a list of the prices and a list of the items they correspond to. To create an array, we first declare the type of data it holds. double [] prices ; Then, we can explicitly initialize the array to contain the data we want to store: prices = { 13.15 , 15.87 , 14.22 , 16.55 }; Just like with simple variables, we can declare and initialize in the same line: double [] prices = { 13.15 , 15.87 , 14.22 , 16.55 }; We can use arrays to hold String s and other objects as well as primitives: String [] clothingItems = { \"Tank Top\" , \"Beanie\" , \"Funny Socks\" , \"Pants\" };","title":"Creating an Array Explicitly"},{"location":"java-arrays/#importing-arrays","text":"If we want to have a descriptive printout of an array, we need a toString () method that is provided by the Arrays package in Java. import java.util.Arrays ; We put this line at the top of the file, before we even define the class! When we import a package in Java, we are making all of the methods of that package available in our code. The Arrays package has many useful methods, including Arrays . toString () . When we pass an array into Arrays . toString () , we can see the contents of the array printed out. 1 2 3 4 5 6 7 8 9 10 import java.util.Arrays ; public class Lottery (){ public static void main ( String [] args ){ int [] lotteryNumbers = { 4 , 8 , 12 , 16 , 20 }; String betterPrintout = Arrays . toString ( lotteryNumbers ); System . out . println ( betterPrintout ); } } This code will print: [4, 8, 12, 16, 20]","title":"Importing Arrays"},{"location":"java-arrays/#get-element-by-index","text":"Now that we have an array declared and intitialized, we want to be able to get values out of it. We use square brackets [] to access data at a certain index: 1 2 3 double [] prices = { 13.1 , 15.87 , 14.22 , 16.55 } System . out . println ( prices [ 1 ] ); This command will print out 15.87 . This happens because 15.87 is the item at the 1 index of the array. If we try to access an element outside of its appropriate index range, we will receive an ArrayIndexOutOfBoundsException error. For example, if we were to run the command System . out . println ( prices [ 5 ] ) , we would get the following output: java.lang.ArrayIndexOutOfBoundsException: 5","title":"Get Element By Index"},{"location":"java-arrays/#creating-an-empty-array","text":"We can also create empty arrays and then fill the items one by one. Empty arrays have to be intitialized with a fixed size: String [] menuItems = new String [ 5 ] ; Once you declare this size, it cannot be changed! This array will always be of size 5 . After declaring and intializing, we can set each index of the array to be a different item: 1 2 3 4 5 menuItems [ 0 ] = \"Veggie hot Dog\" ; menuItems [ 1 ] = \"Potato salad\" ; menuItems [ 2 ] = \"Cornbread\" ; menuItems [ 3 ] = \"Roasted broccoli\" ; menuItems [ 4 ] = \"Coffee ice cream\" ; This group of commands has the same effect as assigning the entire array at once: 1 String [] menuItems = { \"Veggie hot dog\" , \"Potato salad\" , \"Cornbread\" , \"Roasted broccoli\" , \"Coffee ice cream\" }; We can also change an item after it has been assigned! Let's say this restaurant is changing its broccoli dish to a cauliflower one: menuItems [ 3 ] = \"Baked cauliflower\" ; Now the array looks like: [\"Veggie hot dog\", \"Potato salad\", \"Cornbread\", \"Baked cauliflower\", \"Coffee ice cream\"]","title":"Creating an Empty Array"},{"location":"java-arrays/#array-length","text":"What if we have an array storing all the usernames for our program, and we want to quickly see how many users we have? To get the length of an array, we can access the length field of the array object: 1 2 String [] menuItems = new String [ 5 ] ; System . out . println ( menuItems . length ); This command would print 5 , since the menuItems array has 5 slots, even though they are all empty. If we print out the length of the prices array: 1 2 3 double [] prices = { 13.1 , 15.87 , 14.22 , 16.55 }; System . out . println ( prices . length ); We would see 4 , since there are four items in the prices array!","title":"Array Length"},{"location":"java-arrays/#string-args","text":"When we write main () methods for our programs, we use the parameter String [] args . Now that we know about array syntax, we can start to parse what that means. A String [] is an array made up of String s. Examples of String arrays: 1 2 String [] humans = { \"Nick\" , \"Alyssa\" , \"Matt\" , \"Nathan\" }; String [] robots = { \"R2D2\" , \"Marvin\" , \"Wall-E\" , \"Bender\" }; The args parameter is another example of a String array. In this case, the array args contains the arguments that we pass in from the terminal when we run the class file. (So far args has been empty.) So how can you pass arguments to main () > Let's say we have this class HelloYou : 1 2 3 4 5 public class HelloYou { public static void main ( String [] args ){ System . out . println ( \"Hello \" + args [ 0 ] ;) } } When we runn the file HelloYou in the terminal with an argument of \"Laura\" : java HelloYou Laura We get the output: Hello Laura The String [] args would be interpreted as an array with one element, \"Laura\" . When we use args [ 0 ] in the main method, we can access that element like we did in HelloYou . We can actually create if-else statements that run based on the input: 1 2 3 4 5 6 7 if ( args [ 0 ] . equals ( \"A\" )){ // do something } else if ( args [ 0 ] . equals ( \"B\" )){ // do something } else { // do something }","title":"String[] args"},{"location":"java-arrays/#arrays-review","text":"We have now seen how to store a list of values in an array. We can use this knowledge to make organized programs with more complex variables. Throughout these notes, we have leared about: Creating arrays explicitly, using { and } . Accessing an index of an array, using [ and ] . Creating empty arrays of a certain size, and filling the indices one by one. Getting the length of an array using .length . Using the argument args that is passed into the main () method of a class. Let's create a small program that holds student names and test scores with the following characteristics: Make an array of strings called students with the following names: Sade, Alexus, Sam, Koma. Create an empty array of double s called mathScores of size 4. Sade got a 94.5 on the test. Store this value in the same indice that she is listed in the students array. Sam got a 76.8. Store this value in the appropriate spot in the mathScores array. Finally, add a print statement that says: \"The number of students in the class is numStudents .\" using the .length operator. 1 2 3 4 5 6 7 8 9 10 11 12 13 import java.util.Arrays ; public class Classroom { public static void main ( String [] args ){ String [] students = { \"Sade\" , \"Alexus\" , \"Sam\" , \"Koma\" }; double [] mathScores = new double [ 4 ] ; mathScores [ 0 ] = 94.5 ; mathScores [ 2 ] = 76.8 ; System . out . println ( \"The number of students in the class is \" + students . length + \".\" ); } }","title":"Arrays Review"},{"location":"java-arrays/#introduction-to-arraylists","text":"When we work with arrays in Java, we've been limited by the fact that once an array is created, it has a fixed size. We can't add or remove elements. But what if we needed to add to the book lists, newsfeeds, and other structures we were using arrays to represent? To create multiple and dynamic lists, we can use Java's ArrayList s. ArrayList s allow us to: Store object references as elements Store elements of the same type (just like arrays) Access elements by index (just like arrays) Add elements Remove elements Remember how we had to import java.util.Arrays in order to use additional array methods? To use an ArrayList at all, we need to import them from Java's util package as well: import java.util.ArrayList ;","title":"Introduction to ArrayLists"},{"location":"java-arrays/#creating-arraylists","text":"To create an ArrayList , we need to declare the type of object it will hold, just as we do with arrays: ArrayList < String > babyNames ; We use angle brackets ( <> ) to declare the type of the ArrayList . These symbols are used for generics . Generics are a Java construct that allows us to define classes and objects as parameters of an ArrayList . For this reason, we can't use primitive types in an ArrayList : 1 2 3 4 5 // This code won't compile: ArrayList < int > ages ; // This code will compile: ArrayList < Integer > ages ; The <Integer> generic has to be used in an ArrayList instead. You can also use <Double> and <Char> for types you would normally declare as double s or char s. We can intialize to an empty ArrayList using the new keyword: 1 2 3 4 5 6 7 // Declaring: ArrayList < Integer > ages ; // Intializing: ages = new ArrayList < Integer > (); // Declaring and intializing in one line: ArrayList < String > babyNames = new ArrayList < String > ();","title":"Creating ArrayLists"},{"location":"java-arrays/#adding-items-to-an-arraylist","text":"Now we have an empty ArrayList , but how do we get it to store values? ArrayList comes with an add() method which inserts an element into the structure. There are two ways we can use add() . If we want to add an element to the end of the ArrayList , we'll call add() using only one arguement that represents the value we are inserting. In this example, we'll add objects from the Car class to an ArrayList called carShow : 1 2 3 4 5 6 7 8 ArrayList < Car > carShow = new ArrayList < Car > (); carShow . add ( ferrari ); // carShow now holds [ferrari] carShow . add ( thunderbird ); // carShow now holds [ferrari, thunderbird] carShow . add ( volkswagen ); // carShow now holds [ferrari, thunderbird, volkswagen] If we want to add an element at a specific index of our ArrayList , we'll need two arguments in our method call: the first arguement will define the index of the new element while the second argument defines the value of the new element: 1 2 3 4 5 6 7 // Insert object corvette at index 1 carShow . add ( 1 , corvette ); // carShow now holds [ferrari, corvette, thunderbird, volkswagen] // Insert object porsche at index 2 carShow . add ( 2 , porsche ); // carShow now holds [ferrari, corvette, porsche, thunderbird, volkswagen] By inserting a value at a specified index, any elements that appear after this new element will have their index shift over by 1. Also, note that an error will occur if we try to insert a value at an index that does not exist. You are able to add multiple data types to the same array using add() : 1 2 3 4 5 ArrayList assortment = new ArrayList <> (); assortment . add ( \"Hello\" ); // String assortment . add ( 12 ); // Integer assortment . add ( ferrari ); // reference to Car // assortment holds [\"Hello\", 12, ferrari] In this case, the items stored in this ArrayList will be considered Objects . As a result, they won\u2019t have access to some of their methods without doing some fancy casting. Although this type of ArrayList is allowed, using an ArrayList that specifies its type is preferred.","title":"Adding Items to an ArrayList"},{"location":"java-arrays/#arraylist-size","text":"Let's say we have an ArrayList that stores items in a user's online shopping cart. As the user navigates through the site and adds items, their cart grows bigger and bigger. If we wanted to display the number of items in the cart, we could find the size of it using the size() method: 1 2 3 4 5 6 7 8 9 10 11 ArrayList < String > shoppingCart = new ArrayList < String > (); shoppingCart . add ( \"Goofy socks\" ); System . out . println ( shoppingCart . size ()); // 1 is printed shoppingCart . add ( \"Funny tie\" ); System . out . println ( shoppingCart . size ()); // 2 is printed shoppingCart . add ( \"HK-416 Assault Rifle\" ); System . out . println ( shoppingCart . size ()); // 3 is printed In dynamic objects like ArrayList s, it's important to know how to access the amount of objects we have stored.","title":"ArrayList Size"},{"location":"java-arrays/#accessing-an-index","text":"With arrays, we can use bracket notation to access a value at a particular index: 1 2 3 4 double [] ratings = { 3.2 , 5.5 , 1.6 }; System . out . println ( ratings [ 1 ] ); // this will print 5.5 This code prints 5.5 , the value at index 1 of the array. For ArrayList s, bracket notation won't work. Instead we use the method get() to access an index: 1 2 3 4 5 6 7 ArrayList < String > shoopingCart = new ArrayList < String > (); shoppingCart . add ( \"Goofy Socks\" ); shoppingCart . add ( \"Funny tie\" ); shoppingCart . add ( \"HK-416 Assault Rifle\" ); System . out . println ( shoppingCart . get ( 2 )); This code prints \"HK-416 Assault Rifle\" , which is the value at index 2 of the ArrayList .","title":"Accessing an Index"},{"location":"java-arrays/#changing-a-value","text":"When we were using arrays, we could rewrite entries by using bracket notation to reassign values: 1 2 3 4 String [] shoppingCart = { \"Goofy Socks\" , \"Funny tie\" , \"HK-416 Assault Rifle\" }; shoppingCart [ 0 ] = \"Serious Socks\" ; // This overwrites the \"Goofy Socks\" string with \"Serious Socks\" ArrayList has a slightly different way of doing this, using the set() method: 1 2 3 4 5 6 7 8 9 ArrayList < String > shoppingCart = new ArrayList < shoppingCart > (); shoppingCart . add ( \"Goofy Socks\" ); shoppingCart . add ( \"Funny tie\" ); shoppingCart . add ( \"HK-416 Assault Rifle\" ); shoppingCart . set ( 0 , \"Serious Socks\" ); // shoppingCart now holds [\"Serious Socks\", \"Funny tie\", \"HK-416 Assault Rifle\"]","title":"Changing a Value"},{"location":"java-arrays/#removing-an-item","text":"What if we wanted to get rid of an entry alltogether? For arrays, we would have to make a completely new array without the value. Luckily, ArrayList s allow us to remove an item by specifying the index to remove: 1 2 3 4 5 6 7 8 ArrayList < String > shoppingCart = new ArrayList < shoppingCart > (); shoppingCart . add ( \"Goofy Socks\" ); shoppingCart . add ( \"Funny tie\" ); shoppingCart . add ( \"HK-416 Assault Rifle\" ); shoppingCart . remove ( 1 ); // shoppingCart now holds [\"Goofy Socks\", \"HK-416 Assault Rifle\"] We can also remove an item by specifying the value to remove: 1 2 3 4 5 6 7 8 ArrayList < String > shoppingCart = new ArrayList < shoppingCart > (); shoppingCart . add ( \"Goofy Socks\" ); shoppingCart . add ( \"Funny tie\" ); shoppingCart . add ( \"HK-416 Assault Rifle\" ); shoppingCart . remove ( \"Funny tie\" ); // shoppingCart now holds [\"Goofy Socks\", \"HK-416 Assault Rifle\"] Note : This command removes the FIRST instance of the value \"Funny tie\".","title":"Removing an Item"},{"location":"java-arrays/#getting-an-items-index","text":"What if we had a really large list and wanted to know the position of a certain element in it? For instance, what if we had an ArrayList detectives with the names of fictional detectives in chronological order, and we wanted to know what position \"Flecther\" was. 1 2 // detectives holds [\"Holmes\", \"Poirot\", \"Marple\", \"Spade\", \"Fletcher\", \"Conan\", \"Ramotswe\"]; System . out . println ( detectives . indexOf ( \"Fletcher\" )); This code would print 4 , since \"Fletcher\" is at index 4 of the detectives ArrayList .","title":"Getting an Item's Index"},{"location":"java-arrays/#arraylists-review","text":"Some crucial methods in ArrayList s: Adding a new ArrayList item using add() . Accessing the size of an ArrayList using size() . Finding an item by index using get() . Changing the value of an ArrayList item using set() . Removing an item with a specific value using remove() . Retrieving the index of an item with a specific value using indexOf() .","title":"ArrayLists Review"},{"location":"java-basics/","text":"Java Basics Hello World Java runs on different platforms, but programmers write it the same way. Let's explore some rules for writing Java. On the First Program section on the Java Basics page, we saw the HelloWorld.java file. Java files have a .java extension. Some programs are one file, others have hundreds of files! Inside HelloWorld.java we have a class : 1 2 3 public class HelloWorld { } We will talk about classes more in the future, but for now think of them as a single concept. The HelloWorld concept is: Hello World Printer. Other class concepts could be: Bicycle, or: Savings Account. We marked the domain of this concept using curly braces: {} . Syntax inside the curly braces is part of the class. Each file has one primary class named after the file. Our class name: HelloWorld and our filename: HelloWorld . Every word is capitalized. Inside the class we made a main () method which lists our program tasks: 1 2 3 public static void main ( String [] args ) { } Like classes, we used curly braces to mark the beginning and end of a method. public , static , and void are syntax we will learn about on future pages. String [] args is a placeholder for information we want to pass into our program. This syntax is necessary for the program to run but more advanced than we need to explain at the moment. Our program also displayed the text \"Hello World\" on the screen. This was accomplished using a print statement: 1 System . out . println ( \"Hello World\" ); Print Statements Let's take a closer look at the print statement from above: 1 System . out . println ( \"Hello World\" ); Print statements output information to the screen (also referred to as the output terminal). Let's break this line of code down a little more. Don't worry if some of the terms here are new to you. System is a built-in Java class that contains useful tools for our programs. out is short for \"output\". println is short for \"print line\". We can use System . out . println () whenever we want the program to create a new line on the screen after outputting a value: 1 2 System . out . println ( \"Hello World\" ); System . out . println ( \"Today is a great day to code!\" ); After \"Hello World\" is printed, the output terminal creates a new line for the next statement to be outputted. This program will print each statement on a new line like so: Hello World Today is a great day to code! We also can output information using System . out . print () . Notice the we're using print () , not println () . Unlike System . out . println () , this type of print statement outputs everything on the same line. For example: 1 2 System . out . print ( \"Hello \" ); System . out . print ( \"World\" ); The above code will have the following output: Hello World In this example, if we were to use print () or println () again, the new text will print immediately after World on the same line. It's important to remember where you left your program's \"cursor\". If we use println () the cursor is moved to the next line. If we use print () the cursor stays on the same line. Commenting Code Writing code is an exciting process of instructing the computer to complete tasks. Code is also read by people, and we want our intentions to be clear to humans just like we want our instructions to be clear to the computer. Fortunately, we are not limited to writing syntax to perform a task. We can also write comments , notes to human readers of our code. These commments are not executed, so there's no need for valid syntax within a comment. When comments are short we use the single-line syntax: // . 1 // The following code does X When comments are long we use the multi-line syntax: /* and */ . 1 2 3 4 /* The following code does X Expected input is the following: X and Y */ Another type of commenting option is the Javadoc comment which is represented by /** and */ . Javadoc comments are used to create documentation for APIs . When writing Javadoc comments, remember that they will eventually be used in the documentation that your users might read, so make sure to be especially thoughtful when writing these comments. Javadoc comments are typically written before the declaration of fields, methods, and classes: 1 2 3 /** * The following class accomplishes the following task... */ Here's how a comment would look in a complete program: 1 2 3 4 5 6 7 8 9 10 /** * The following class shows what a comment would look like in a program. */ public class CommentExample { // I'm a comment inside the class public static void main ( String [] args ) { // I'm a comment inside a method System . out . println ( \"This program has comments!\" ); } } Comments are different from printing to the screen, when we use System . out . println () . These comments won't show up in our terminal, they're only for people who read our code in the text editor. Semicolons and Whitespace As we saw with the comments above, reading code is just as important as writing code. We should write code that is easy for other people to read. Those people can be co-workers, or even yourself! Java does not interpret whitespace , the areas of the code without syntax, but humans can use whitespace to read code more effeciently and with less difficulty. Functionally, these two code samples are identical: 1 System . out . println ( \"Java\" ); System . out . println ( \"Lava\" ); System . out . println ( \"Guava\" ); 1 2 3 4 5 System . out . println ( \"Java\" ); System . out . println ( \"Lava\" ); System . out . println ( \"Guava\" ); These will both print the same text to the screen, but which would humans prefer to read? Imagine if there were hundreds of lines of code! Whitespace would be essential. Java does interpret semicolons. Semicolons are used to markt the end of a statement , one line of code that performs a single task. The only statements we've seen so far are System . out . println ( \"My message!\" ); . Let's contrast statements with the curly brace, {} . Curly braces mark the scope of our classes and methods. There are no semicolons at the end of a curly brace. Compiling & Catching Errors Java is a compiled programming language, meaning the code we write in a .java file is transformed into byte code by a compiler before it is executed by the Java Virtual Machine on your computer. A compiler is a program that translates \"human-friendly\" programming languages into other programming languages (machine code) that computers can execute. The compiling process catches mistakes before the computer runs our code. The Java compiler runs a series of checks while it transforms our code. Code that does not pass these checks will not be compiled. For example, with a file called Example.java , we would compile it with the terminal command: javac Example.java A successful compilation produces a .class file: Example.class , that we execute with the terminal command: java Example An unsuccessful compilation produces a list of errors, which are helpful for fixing the program. No .class file is made until the errors are corrected and the compile command is run again.","title":"Java Basics"},{"location":"java-basics/#java-basics","text":"","title":"Java Basics"},{"location":"java-basics/#hello-world","text":"Java runs on different platforms, but programmers write it the same way. Let's explore some rules for writing Java. On the First Program section on the Java Basics page, we saw the HelloWorld.java file. Java files have a .java extension. Some programs are one file, others have hundreds of files! Inside HelloWorld.java we have a class : 1 2 3 public class HelloWorld { } We will talk about classes more in the future, but for now think of them as a single concept. The HelloWorld concept is: Hello World Printer. Other class concepts could be: Bicycle, or: Savings Account. We marked the domain of this concept using curly braces: {} . Syntax inside the curly braces is part of the class. Each file has one primary class named after the file. Our class name: HelloWorld and our filename: HelloWorld . Every word is capitalized. Inside the class we made a main () method which lists our program tasks: 1 2 3 public static void main ( String [] args ) { } Like classes, we used curly braces to mark the beginning and end of a method. public , static , and void are syntax we will learn about on future pages. String [] args is a placeholder for information we want to pass into our program. This syntax is necessary for the program to run but more advanced than we need to explain at the moment. Our program also displayed the text \"Hello World\" on the screen. This was accomplished using a print statement: 1 System . out . println ( \"Hello World\" );","title":"Hello World"},{"location":"java-basics/#print-statements","text":"Let's take a closer look at the print statement from above: 1 System . out . println ( \"Hello World\" ); Print statements output information to the screen (also referred to as the output terminal). Let's break this line of code down a little more. Don't worry if some of the terms here are new to you. System is a built-in Java class that contains useful tools for our programs. out is short for \"output\". println is short for \"print line\". We can use System . out . println () whenever we want the program to create a new line on the screen after outputting a value: 1 2 System . out . println ( \"Hello World\" ); System . out . println ( \"Today is a great day to code!\" ); After \"Hello World\" is printed, the output terminal creates a new line for the next statement to be outputted. This program will print each statement on a new line like so: Hello World Today is a great day to code! We also can output information using System . out . print () . Notice the we're using print () , not println () . Unlike System . out . println () , this type of print statement outputs everything on the same line. For example: 1 2 System . out . print ( \"Hello \" ); System . out . print ( \"World\" ); The above code will have the following output: Hello World In this example, if we were to use print () or println () again, the new text will print immediately after World on the same line. It's important to remember where you left your program's \"cursor\". If we use println () the cursor is moved to the next line. If we use print () the cursor stays on the same line.","title":"Print Statements"},{"location":"java-basics/#commenting-code","text":"Writing code is an exciting process of instructing the computer to complete tasks. Code is also read by people, and we want our intentions to be clear to humans just like we want our instructions to be clear to the computer. Fortunately, we are not limited to writing syntax to perform a task. We can also write comments , notes to human readers of our code. These commments are not executed, so there's no need for valid syntax within a comment. When comments are short we use the single-line syntax: // . 1 // The following code does X When comments are long we use the multi-line syntax: /* and */ . 1 2 3 4 /* The following code does X Expected input is the following: X and Y */ Another type of commenting option is the Javadoc comment which is represented by /** and */ . Javadoc comments are used to create documentation for APIs . When writing Javadoc comments, remember that they will eventually be used in the documentation that your users might read, so make sure to be especially thoughtful when writing these comments. Javadoc comments are typically written before the declaration of fields, methods, and classes: 1 2 3 /** * The following class accomplishes the following task... */ Here's how a comment would look in a complete program: 1 2 3 4 5 6 7 8 9 10 /** * The following class shows what a comment would look like in a program. */ public class CommentExample { // I'm a comment inside the class public static void main ( String [] args ) { // I'm a comment inside a method System . out . println ( \"This program has comments!\" ); } } Comments are different from printing to the screen, when we use System . out . println () . These comments won't show up in our terminal, they're only for people who read our code in the text editor.","title":"Commenting Code"},{"location":"java-basics/#semicolons-and-whitespace","text":"As we saw with the comments above, reading code is just as important as writing code. We should write code that is easy for other people to read. Those people can be co-workers, or even yourself! Java does not interpret whitespace , the areas of the code without syntax, but humans can use whitespace to read code more effeciently and with less difficulty. Functionally, these two code samples are identical: 1 System . out . println ( \"Java\" ); System . out . println ( \"Lava\" ); System . out . println ( \"Guava\" ); 1 2 3 4 5 System . out . println ( \"Java\" ); System . out . println ( \"Lava\" ); System . out . println ( \"Guava\" ); These will both print the same text to the screen, but which would humans prefer to read? Imagine if there were hundreds of lines of code! Whitespace would be essential. Java does interpret semicolons. Semicolons are used to markt the end of a statement , one line of code that performs a single task. The only statements we've seen so far are System . out . println ( \"My message!\" ); . Let's contrast statements with the curly brace, {} . Curly braces mark the scope of our classes and methods. There are no semicolons at the end of a curly brace.","title":"Semicolons and Whitespace"},{"location":"java-basics/#compiling-catching-errors","text":"Java is a compiled programming language, meaning the code we write in a .java file is transformed into byte code by a compiler before it is executed by the Java Virtual Machine on your computer. A compiler is a program that translates \"human-friendly\" programming languages into other programming languages (machine code) that computers can execute. The compiling process catches mistakes before the computer runs our code. The Java compiler runs a series of checks while it transforms our code. Code that does not pass these checks will not be compiled. For example, with a file called Example.java , we would compile it with the terminal command: javac Example.java A successful compilation produces a .class file: Example.class , that we execute with the terminal command: java Example An unsuccessful compilation produces a list of errors, which are helpful for fixing the program. No .class file is made until the errors are corrected and the compile command is run again.","title":"Compiling &amp; Catching Errors"},{"location":"java-classes/","text":"Object Oriented Java Introduction to Classes All programs require one or more classes that act as a model for the world. For example, a program to track student test scores might have Student , Course , and Grade classes. Our real-world concerns, students and their grades, are inside the program as classes. We represent each student as an instance , or object , of the Student class. This is object-oriented programming (OOP) because programs are built around objects and their interactions. An object contains a state and behavior. Classes are a blueprint for objects . Blueprints detail the general structure. For example, all students have an ID, all courses can enroll a student, etc. An instance is the thing itself. This student has an ID of 42 , this course enrolled that student, etc. Let's review with another example, a savings account at a bank. What should a savings account know? The balance of money available. What should a savings account do? Deposit money. Withdraw money. Imagine that two people have accounts that are instances of the SavingsAccount class. They share behavior (the ability to deposit/withdraw) but have an individual state (their balances), and even with the same balance these accounts are separate entities. Let's put that same concept into a store class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Store { // instance fields String productType ; int inventoryCount ; double inventoryPrice ; // constructor method public Store ( String product , int count , double price ) { productType = product ; inventoryCount = count ; inventoryPrice = price ; } // main method public static void main ( String [] args ) { Store lemonadeStand = new Store ( \"lemonade\" , 42 , .99 ); Store cookieShop = new Store ( \"cookies\" , 12 , 3.75 ); System . out . println ( \"Our first shop sells \" + lemonadeStand . productType + \" at \" + lemonadeStand . inventoryPrice + \" per unit.\" ); System . out . println ( \"Our second shop has \" + cookieShop . inventoryCount + \" units remaining.\" ); } } Running the above code should give the following output: Our first shop sells lemonade at 0.99 per unit. Our second shop has 12 units remaining. Class Syntax The fundamental concept of object-oriented programming is the class. A class is the set of instructions that describe how an instance can behave and what information it contains. Java has pre-defined classes such as System , which we have used previously to log text to our screen, but we also need to write our own classes for the custom needs of a program. Here is a definition of a Java class: 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Car { // scope of Car class starts after curly brace public static void main ( String [] args ) { // scope of main() starts after curly brace // program tasks } // scope of main() ends after curly brace } // scope of Car class ends after curly brace This example defines a class named Car . public is an access level modifier that allows other classes to interact with this class. For now, all classes will be public . This class has a main () method, which lists the tasks performed by the program. main () runs when we execute the compiled Car.class file. Constructors In order to create an object (an instance of a class), we need a constructor method. The constructor is defined within the class. Let's take a look at the Car class with a constructor. The constructor, Car () , shares the same name as the class: 1 2 3 4 5 6 7 8 9 10 public class Car { // Constructor method public Car () { // instructions for creating a Car instance } public static void main ( String [] args ) { // body of main method } } To create an instance , we need to call or invoke the constructor within main () . The following example assigns a Car instance to the variable ferrari : 1 2 3 4 5 6 7 8 9 10 11 public class Car { public Car () { // instructions for creating a Car instance } public static void main ( String [] args ) { // Invoke the constructor Car ferrari = new Car (); } } Instance Fields In our first example, we ended with printing an instance of Store , which looked something like Store@6bc7c054 . The first part, Store , refers to the class, and the second part, @6bc7c054 refers to the instance's location in the computer's memory. We don't care about memory location, but our instances have no other characteristics! When an object is created, the constructor sets the initial state of the obkect. The state is made up of associated data that represents the characteristics of an object. We'll add data to an object by introducing instance variables , or instance fields . We want Car instances of different colors, so we declare a String color instance field. Often times, instance variables are described as a \"has-a\" relationship with the object. For example, a Car \"has-a\" color . Another way to think of that is that instance variables are nouns and adjectives associated with an object. What qualities other than color might a car have ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Car { /* declare fields inside the class by specifying the type and name */ String color ; public Car () { /* instance fields available in scope of constructor method */ } public static void main ( String [] args ) { // body of main method } } The declaration is within the class and the instance variable will be available for assignment inside the constructor. Fields are a type of state each instance will possess. One instance may have \"red\" as its color , another \"blue\" , etc. It's the job of the constructor to give these instance fields initial value. Contructor Parameters To create objects with dynamic, individual states, we'll use a combination of the constructor method and instance fields. In order to assign a value to an instance variable, we need to alter our constructor method to include parameters so that it can access the data we want to assign to an instance. We've already seen a parameter in the main () method: String [] args , but this is the first time we're using the parameter value within a method body. The Car constructor now has a parameter: String carColor : : 1 2 3 4 5 6 7 8 9 10 11 public class Car { String color ; //constructor method with a parameter public Car ( String carColor ) { // parameter value assigned to the field color = carColor ; } public static void main ( String [] args ){ // program tasks } } When a String value gets passed into Car , it is assigned to the parameter carColor . Then, inside the constructor, carColor will be assigned as the value to the instance variable color . Our method also has a signature which defines the name and parameters of the method. In the above example, the signature is Car ( String carColor ) . Assigning Values to Instance Fields Now that the constructor has a parameter, we must pass values into the method call. These values are referred to as arguments ; once they are passed in, they will be used to give the instance fields intial value. Here we create an instance, ferrari , in the main () method with \"red\" as its color field: 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Car { String color ; public Car ( String carColor ){ // assign parameter value to instance field color = carColor ; } public static void main ( String [] args ) { // parameter value supplied when calling the constructor Car ferrari = new Car ( \"red\" ); } } We pass the String value \"red\" to our constructor method call: new Car ( \"red\" ); . The type of value given to the invocation must match the type declared by the parameter. Inside the constructor, the parameter carColor refers to the value passed in during the invocation \"red\" . This value is assigned to the instance field color . color has already been declared, so we don't specify the type during assignment. The object, ferrari , holds the state of color as an instance field referencing the value \"red\" . We access the value of this field with the dot operator ( . ): 1 2 3 4 5 6 7 /* accessing a field: objectName.fieldName */ ferrari . color ; // \"red\" Using Multiple Fields Objects are not limited to a single instance field. We can declare as many fields as are necessary for the requirements of our program. Let's change Car instances so they have multiple fields. We'll add a boolean isRunning , that indicates if the car engine is on and an int velocity , that indicates the speed at which the car is travelling. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Car { String color ; boolean isRunning ; int velocity ; public Car ( String carColor , boolean carRunning , int milesPerHour ) { color = carColor ; isRunning = carRunning ; velocity = milesPerHour ; } public static void main ( String [] args ) { Car ferrari = new Car ( \"red\" , true , 27 ); Car renault = new Car ( \"blue\" , false , 70 ); System . out . println ( renault . isRunning ); // will print false System . out . println ( ferrari . velocity ); // will print 27 } } The constructor now has multiple parameters to receive values for the new fields. We still specify the type as well as the name for each parameter. Ordering matters! We must pass values into the constructor invocation in the same order that they're listed in the parameters. 1 2 3 4 5 // values match types, no error Car honda = new Car ( \"green\" , false , 0 ); // values do not match types, error! Car junker = new Car ( true , 42 , \"brown\" ); Classes Review Java is an object-orriented programming language where every program has at least one class. Programs are often built from many classes and objects, which are the instances of a class. Classes define the state and behavior of their instances. Behavior comes from methods defined in the class. State comes from instance fields declared inside the class. Classes are modeled on the real-world things we want to represent in our program. Later we will explore how a program can be made from multiple classes. For now, our programs are a single class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Dog { // instance field String breed ; //constructor method public Dog ( String dogBreed ) { /* value of parameter dogBreed assigned to instance field breed */ breed = dogBreed ; } public static void main ( String [] args ) { /* create instance: use 'new' operator and invoke constructor */ Dog dani = new Dog ( \"border collie\" ); /* fields are accessed using: the instance name, '.' operator, and the field name */ dani . breed ; // \"border collie\" } } Introduction to Methods A method is a block of code which only runs when it is called. You can pass data, known as parameters into a method. Methods are used to perform certain actions, and they are also known as functions . Methods are repeatable, modular blocks of code, used to accomplish specific tasks. We have the ability to define our own methods that will take input, do something with it, and return the kind of output we want. Method decomposition is a way we can use methods to break fown a large problem into smaller, more manageable problems. Methods are very reusable. Imagine we wrote a sandwich-making program that used 20 lines of code to make a single sandwich. Our program would become very long very quickly if we were making multiple sandwiches. By creating a makeSandwich () method, we can make a sandwich anytime simply by calling it. We will be using the following code to build a method later on: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class SavingsAccount { int balance ; public SavingsAccount ( int initialBalance ){ balance = initialBalance ; } public static void main ( String [] args ){ SavingsAccount savings = new SavingsAccount ( 2000 ); //Check balance: System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + savings . balance ); //Withdrawing: int afterWithdraw = savings . balance - 300 ; savings . balance = afterWithdraw ; System . out . println ( \"You just withdrew \" + 300 ); //Check balance: System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + savings . balance ); //Deposit: int afterDeposit = savings . balance + 600 ; savings . balance = afterDeposit ; System . out . println ( \"You just deposited \" + 600 ); //Check balance: System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + savings . balance ); //Deposit: int afterDeposit2 = savings . balance + 600 ; savings . balance = afterDeposit2 ; System . out . println ( \"You just deposited \" + 600 ); //Check balance: System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + savings . balance ); } } Defining Methods If we were to define a checkBalance () method for the Savings Account example above, it would look like the following: 1 2 3 4 public void checkBalance (){ System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + balance ); } The first line, public void checkBalance () , is the method declaration. It gives the program some information about the method: public means that other classes can access this method. The void keyword means that there is no specific output from the method. We will see methods that are not void later in these notes, but for now, all of our methods will be void . checkBalance () is the name of the method. Every method has its own unique method signature which is comprised of the method's name and its parameter type. In this example, the method signature checkBalance () . The two print statements are inside the body of the method, which is defined by the curly braces: { and } . Anything we can do in our main () method, we can do in other methods! All of the java tools we have learned, like the math and comparison operators, can be used to make interesting and useful methods. Calling Methods When we add a non-static method to a class, it becomes available to use on an object of that class. In order to have our methods get executed, we must call the method on the object we created. Let's add a non-static startEngine () method to our Car class from earlier notes . Inside the main () method, we'll call startEngine () on the myFastCar object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Car { String color ; public Car ( String carColor ) { color = carColor ; } public void startEngine () { System . out . println ( \"Starting the car!\" ); System . out . println ( \"Vroom!\" ); } public static void main ( String [] args ){ Car myFastCar = new Car ( \"red\" ); // Call a method on an object myFastCar . startEngine (); System . out . println ( \"That was one fast car!\" ); } } Let's take a closer look at the method call: myFastCar . startEngine (); First, we reference our object myFastCar . Then, we use the dot operator ( . ) to call the method startEngine () . Noter that we must include parentheses () after our method name in order to call it. If we run the above program, we get the following output: Starting the car! Vroom! That was one fast car! Code generally runs in a top-down order where code execution starts at the top of a program and ends at the bottom; however, methods are ignored by the compiler unless they are being called. When a method is called, the compiler executes every statement contained within the method. Once all method instructions are executed, the top-down order of execution continues. This is why Starting the car! and Vroom! are outputted before That was one fast car! . Scope A method is a task that an object of a class performs. We mark the domain of this task using curly braces { and } . Everything inside the curly braces is part of the task. This domain is called the scope of a method. We can't access variables that are declared inside a method in code that is outside the scope of that method. Looking at the Car class again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Car { String color ; int milesDriven ; public Car ( String carColor ) { color = carColor ; milesDriven = 0 ; } public void drive () { String message = \"Miles driven: \" + milesDriven ; System . out . println ( message ); } public static void main ( String [] args ){ Car myFastCar = new Car ( \"Red\" ); myFastCar . drive (); } } The variable message , which is declared and initialized inside of drive , cannot be used inside of main () ! It only exists within the scope of the drive () method. However, milesDriven , which is declared at the top of the class, can be used inside all methods in the class, since it is in the scope of the whole class. Adding Parameters We saw how a method's scope prevents us from using variables declared in one method in another method. What if we had some information in one method that we needed to pass into another method? Similar to how we added parameters to constructors , we can customize all other methods to accept parameters. For example, in the following code, we create a startRadio () method that accepts a Double parameter, stationNum , and a String parameter called stationName : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Car { String color ; public Car ( String carColor ){ color = carColor ; } public void startRadio ( double stationNum , String stationName ) { System . out . println ( \"Turning on the radio to \" + stationNum + \", \" + stationName + \"!\" ); System . out . println ( \"Enjoy!\" ); } public static void main ( String [] args ){ Car myCar = new Car ( \"red\" ); myCar . startRadio ( 103.7 , \"Meditation Station\" ); } } Adding parameter values impacts our method's signature. Like constructor signatures, the method signature includes the method name as well as the parameter types of the method. The signature of the above method is startRadio ( double , String ) . In the main () method, we call the startRadio () method on the myCar object and probide a double argument of 103.7 and String argument of Meditation Station , resulting in the following output: Turning on the radio to 103.7, Meditation Station! Enjoy! Note that when we call on a method with multiple parameters, the arguments given in the call must be placed in the same order as the parameters appear in the signature. If the argument types do not match the parameter types, we'll receive an error. Reassigning Instance Fields Earlier, we thought about a Savings Account as a type of object wer could represent in Java. Two of the methods we need are depositing and withdrawing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public SavingsAccount { double balance ; public SavingsAccount ( double startingBalance ){ balance = startingBalance ; } public void deposit ( double amountToDeposit ){ // Add amountToDeposit to the balance } public void withdraw ( double amountToWithdraw ){ // Subtract amountToWithdraw from the balance } public static void main ( String [] args ){ } } These methods would change the valuie of the variable balance . We can reassign balance to be a new value by using our assignment operator, = , again. 1 2 3 4 public void deposit ( double amountToDeposit ){ double updatedBalance = balance + amountToDeposit ; balance = updatedBalance ; } nNow, when we call deposit () , it should change the value of the instance field balance : 1 2 3 4 5 6 public static void main ( String [] args ){ SavingsAccount myAccount = new SavingsAccount ( 2000 ); System . out . println ( myAccount . balance ); myAccount . deposit ( 100 ); System . out . println ( myAccount . balance ); } The code first prints 2000 , the initial value of myAccount . balance , and then prints 2100 , which is the value of myAccount . balance after the deposit () method has run. Change instance fields is how we change the state of an object and make our objects more flexible and realistic. Returns Remeber, variables only exist in the scope that they were declared in. We can use a value outside of the method it was created in if we return it from the method. We return a value by using the keyword return : 1 2 3 4 5 public int numberOfTires () { int tires = 4 ; // return statement return tires ; } This method, called numberOfTires () , returns 4 . Once the return statement is executed, the compiler exits the function. Any code that exists after the return statement in a function is ignored. In past exercises, when creating new methods, we use the keyword void . Here, we are replacing void with int , to signify that the return type is an int . The void keyword (which means \"completely empty\") indicates that no value is returned after calling that method. A non-void method, like numberOfTires () returns a value when it is called. We can use datatype keywords (such as int , char , etc.) to specify the type of value the method should return. The return value's type must match the return type of the method. If the return expression is compatible with the return type, a copy of that value gets returned in a process known as return by value . Unlike void mehods, non-void methods can be used as either a variable value or as part of an expression like so: 1 2 3 4 public static void main ( String [] args ){ Car myCar = new Car ( \"Red\" ); int numTires = myCar . numberOfTires (); } Within main () , we called the numberOfTires () method on myCar . Since the method returns an int value of 4 , we store the value in an integer value called numTires . If we printed numTires , we would see 4 . The toString () method When we print out Objects, we often see a String that is not very helpful in determining what the object represents. In earlier notes, we saw that printing our Store object would output something like: Store@6bc7c123 Where Store is the name of the object and @6bc7c123 is its position in memory. This doesn't tell us anything about what the Store sells, the price, or the other instance fields we've defined. We can add a method to our classes that makes this printout more descriptive. When we define a toString () method for a class, we can return a String that will print when we print the object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Car { String color ; public Car ( String carColor ){ color = carColor ; } public static void main ( String [] args ){ Car myCar = new Car ( \"red\" ); System . out . println ( myCar ); } public String toString (){ return \"This is a \" + color + \" car!\" ; } } When this runs the command System . out . println ( myCar ) will print This is a red car! , which tells us about the Object myCar . Methods Review Methods are a powerful way to abstract tasks away and make them repeatable. They allow us to define behavior for classes, so that the Objects we create can do the things we expect them to. Let's review everything we have learned about methods so far: Defining a method : Methods have a method signature that declares their return type, name, and parameters. Calling a method : Methods are invoked with a . and () . Parameters : Inputs to the method and their types are declared in parentheses in the method signature. Changing Instance Fields : Methods can be used to change the value of an instance field. Scope : Variables only exist within the domain that they are created in. Return : The type of the variables that are output are declared in the method signature. Basic Calculator 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Calculator { public Calculator (){ } public int add ( int a , int b ){ return a + b ; } public int subtract ( int a , int b ){ return a - b ; } public int multiply ( int a , int b ){ return a * b ; } public int divide ( int a , int b ){ return a / b ; } public int modulo ( int a , int b ){ return a % b ; } public static void main ( String [] args ){ Calculator myCalculator = new Calculator (); System . out . println ( myCalculator . add ( 5 , 7 )); System . out . println ( myCalculator . subtract ( 45 , 11 )); } }","title":"Classes"},{"location":"java-classes/#object-oriented-java","text":"","title":"Object Oriented Java"},{"location":"java-classes/#introduction-to-classes","text":"All programs require one or more classes that act as a model for the world. For example, a program to track student test scores might have Student , Course , and Grade classes. Our real-world concerns, students and their grades, are inside the program as classes. We represent each student as an instance , or object , of the Student class. This is object-oriented programming (OOP) because programs are built around objects and their interactions. An object contains a state and behavior. Classes are a blueprint for objects . Blueprints detail the general structure. For example, all students have an ID, all courses can enroll a student, etc. An instance is the thing itself. This student has an ID of 42 , this course enrolled that student, etc. Let's review with another example, a savings account at a bank. What should a savings account know? The balance of money available. What should a savings account do? Deposit money. Withdraw money. Imagine that two people have accounts that are instances of the SavingsAccount class. They share behavior (the ability to deposit/withdraw) but have an individual state (their balances), and even with the same balance these accounts are separate entities. Let's put that same concept into a store class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Store { // instance fields String productType ; int inventoryCount ; double inventoryPrice ; // constructor method public Store ( String product , int count , double price ) { productType = product ; inventoryCount = count ; inventoryPrice = price ; } // main method public static void main ( String [] args ) { Store lemonadeStand = new Store ( \"lemonade\" , 42 , .99 ); Store cookieShop = new Store ( \"cookies\" , 12 , 3.75 ); System . out . println ( \"Our first shop sells \" + lemonadeStand . productType + \" at \" + lemonadeStand . inventoryPrice + \" per unit.\" ); System . out . println ( \"Our second shop has \" + cookieShop . inventoryCount + \" units remaining.\" ); } } Running the above code should give the following output: Our first shop sells lemonade at 0.99 per unit. Our second shop has 12 units remaining.","title":"Introduction to Classes"},{"location":"java-classes/#class-syntax","text":"The fundamental concept of object-oriented programming is the class. A class is the set of instructions that describe how an instance can behave and what information it contains. Java has pre-defined classes such as System , which we have used previously to log text to our screen, but we also need to write our own classes for the custom needs of a program. Here is a definition of a Java class: 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Car { // scope of Car class starts after curly brace public static void main ( String [] args ) { // scope of main() starts after curly brace // program tasks } // scope of main() ends after curly brace } // scope of Car class ends after curly brace This example defines a class named Car . public is an access level modifier that allows other classes to interact with this class. For now, all classes will be public . This class has a main () method, which lists the tasks performed by the program. main () runs when we execute the compiled Car.class file.","title":"Class Syntax"},{"location":"java-classes/#constructors","text":"In order to create an object (an instance of a class), we need a constructor method. The constructor is defined within the class. Let's take a look at the Car class with a constructor. The constructor, Car () , shares the same name as the class: 1 2 3 4 5 6 7 8 9 10 public class Car { // Constructor method public Car () { // instructions for creating a Car instance } public static void main ( String [] args ) { // body of main method } } To create an instance , we need to call or invoke the constructor within main () . The following example assigns a Car instance to the variable ferrari : 1 2 3 4 5 6 7 8 9 10 11 public class Car { public Car () { // instructions for creating a Car instance } public static void main ( String [] args ) { // Invoke the constructor Car ferrari = new Car (); } }","title":"Constructors"},{"location":"java-classes/#instance-fields","text":"In our first example, we ended with printing an instance of Store , which looked something like Store@6bc7c054 . The first part, Store , refers to the class, and the second part, @6bc7c054 refers to the instance's location in the computer's memory. We don't care about memory location, but our instances have no other characteristics! When an object is created, the constructor sets the initial state of the obkect. The state is made up of associated data that represents the characteristics of an object. We'll add data to an object by introducing instance variables , or instance fields . We want Car instances of different colors, so we declare a String color instance field. Often times, instance variables are described as a \"has-a\" relationship with the object. For example, a Car \"has-a\" color . Another way to think of that is that instance variables are nouns and adjectives associated with an object. What qualities other than color might a car have ? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Car { /* declare fields inside the class by specifying the type and name */ String color ; public Car () { /* instance fields available in scope of constructor method */ } public static void main ( String [] args ) { // body of main method } } The declaration is within the class and the instance variable will be available for assignment inside the constructor. Fields are a type of state each instance will possess. One instance may have \"red\" as its color , another \"blue\" , etc. It's the job of the constructor to give these instance fields initial value.","title":"Instance Fields"},{"location":"java-classes/#contructor-parameters","text":"To create objects with dynamic, individual states, we'll use a combination of the constructor method and instance fields. In order to assign a value to an instance variable, we need to alter our constructor method to include parameters so that it can access the data we want to assign to an instance. We've already seen a parameter in the main () method: String [] args , but this is the first time we're using the parameter value within a method body. The Car constructor now has a parameter: String carColor : : 1 2 3 4 5 6 7 8 9 10 11 public class Car { String color ; //constructor method with a parameter public Car ( String carColor ) { // parameter value assigned to the field color = carColor ; } public static void main ( String [] args ){ // program tasks } } When a String value gets passed into Car , it is assigned to the parameter carColor . Then, inside the constructor, carColor will be assigned as the value to the instance variable color . Our method also has a signature which defines the name and parameters of the method. In the above example, the signature is Car ( String carColor ) .","title":"Contructor Parameters"},{"location":"java-classes/#assigning-values-to-instance-fields","text":"Now that the constructor has a parameter, we must pass values into the method call. These values are referred to as arguments ; once they are passed in, they will be used to give the instance fields intial value. Here we create an instance, ferrari , in the main () method with \"red\" as its color field: 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Car { String color ; public Car ( String carColor ){ // assign parameter value to instance field color = carColor ; } public static void main ( String [] args ) { // parameter value supplied when calling the constructor Car ferrari = new Car ( \"red\" ); } } We pass the String value \"red\" to our constructor method call: new Car ( \"red\" ); . The type of value given to the invocation must match the type declared by the parameter. Inside the constructor, the parameter carColor refers to the value passed in during the invocation \"red\" . This value is assigned to the instance field color . color has already been declared, so we don't specify the type during assignment. The object, ferrari , holds the state of color as an instance field referencing the value \"red\" . We access the value of this field with the dot operator ( . ): 1 2 3 4 5 6 7 /* accessing a field: objectName.fieldName */ ferrari . color ; // \"red\"","title":"Assigning Values to Instance Fields"},{"location":"java-classes/#using-multiple-fields","text":"Objects are not limited to a single instance field. We can declare as many fields as are necessary for the requirements of our program. Let's change Car instances so they have multiple fields. We'll add a boolean isRunning , that indicates if the car engine is on and an int velocity , that indicates the speed at which the car is travelling. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Car { String color ; boolean isRunning ; int velocity ; public Car ( String carColor , boolean carRunning , int milesPerHour ) { color = carColor ; isRunning = carRunning ; velocity = milesPerHour ; } public static void main ( String [] args ) { Car ferrari = new Car ( \"red\" , true , 27 ); Car renault = new Car ( \"blue\" , false , 70 ); System . out . println ( renault . isRunning ); // will print false System . out . println ( ferrari . velocity ); // will print 27 } } The constructor now has multiple parameters to receive values for the new fields. We still specify the type as well as the name for each parameter. Ordering matters! We must pass values into the constructor invocation in the same order that they're listed in the parameters. 1 2 3 4 5 // values match types, no error Car honda = new Car ( \"green\" , false , 0 ); // values do not match types, error! Car junker = new Car ( true , 42 , \"brown\" );","title":"Using Multiple Fields"},{"location":"java-classes/#classes-review","text":"Java is an object-orriented programming language where every program has at least one class. Programs are often built from many classes and objects, which are the instances of a class. Classes define the state and behavior of their instances. Behavior comes from methods defined in the class. State comes from instance fields declared inside the class. Classes are modeled on the real-world things we want to represent in our program. Later we will explore how a program can be made from multiple classes. For now, our programs are a single class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Dog { // instance field String breed ; //constructor method public Dog ( String dogBreed ) { /* value of parameter dogBreed assigned to instance field breed */ breed = dogBreed ; } public static void main ( String [] args ) { /* create instance: use 'new' operator and invoke constructor */ Dog dani = new Dog ( \"border collie\" ); /* fields are accessed using: the instance name, '.' operator, and the field name */ dani . breed ; // \"border collie\" } }","title":"Classes Review"},{"location":"java-classes/#introduction-to-methods","text":"A method is a block of code which only runs when it is called. You can pass data, known as parameters into a method. Methods are used to perform certain actions, and they are also known as functions . Methods are repeatable, modular blocks of code, used to accomplish specific tasks. We have the ability to define our own methods that will take input, do something with it, and return the kind of output we want. Method decomposition is a way we can use methods to break fown a large problem into smaller, more manageable problems. Methods are very reusable. Imagine we wrote a sandwich-making program that used 20 lines of code to make a single sandwich. Our program would become very long very quickly if we were making multiple sandwiches. By creating a makeSandwich () method, we can make a sandwich anytime simply by calling it. We will be using the following code to build a method later on: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 public class SavingsAccount { int balance ; public SavingsAccount ( int initialBalance ){ balance = initialBalance ; } public static void main ( String [] args ){ SavingsAccount savings = new SavingsAccount ( 2000 ); //Check balance: System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + savings . balance ); //Withdrawing: int afterWithdraw = savings . balance - 300 ; savings . balance = afterWithdraw ; System . out . println ( \"You just withdrew \" + 300 ); //Check balance: System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + savings . balance ); //Deposit: int afterDeposit = savings . balance + 600 ; savings . balance = afterDeposit ; System . out . println ( \"You just deposited \" + 600 ); //Check balance: System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + savings . balance ); //Deposit: int afterDeposit2 = savings . balance + 600 ; savings . balance = afterDeposit2 ; System . out . println ( \"You just deposited \" + 600 ); //Check balance: System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + savings . balance ); } }","title":"Introduction to Methods"},{"location":"java-classes/#defining-methods","text":"If we were to define a checkBalance () method for the Savings Account example above, it would look like the following: 1 2 3 4 public void checkBalance (){ System . out . println ( \"Hello!\" ); System . out . println ( \"Your balance is \" + balance ); } The first line, public void checkBalance () , is the method declaration. It gives the program some information about the method: public means that other classes can access this method. The void keyword means that there is no specific output from the method. We will see methods that are not void later in these notes, but for now, all of our methods will be void . checkBalance () is the name of the method. Every method has its own unique method signature which is comprised of the method's name and its parameter type. In this example, the method signature checkBalance () . The two print statements are inside the body of the method, which is defined by the curly braces: { and } . Anything we can do in our main () method, we can do in other methods! All of the java tools we have learned, like the math and comparison operators, can be used to make interesting and useful methods.","title":"Defining Methods"},{"location":"java-classes/#calling-methods","text":"When we add a non-static method to a class, it becomes available to use on an object of that class. In order to have our methods get executed, we must call the method on the object we created. Let's add a non-static startEngine () method to our Car class from earlier notes . Inside the main () method, we'll call startEngine () on the myFastCar object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Car { String color ; public Car ( String carColor ) { color = carColor ; } public void startEngine () { System . out . println ( \"Starting the car!\" ); System . out . println ( \"Vroom!\" ); } public static void main ( String [] args ){ Car myFastCar = new Car ( \"red\" ); // Call a method on an object myFastCar . startEngine (); System . out . println ( \"That was one fast car!\" ); } } Let's take a closer look at the method call: myFastCar . startEngine (); First, we reference our object myFastCar . Then, we use the dot operator ( . ) to call the method startEngine () . Noter that we must include parentheses () after our method name in order to call it. If we run the above program, we get the following output: Starting the car! Vroom! That was one fast car! Code generally runs in a top-down order where code execution starts at the top of a program and ends at the bottom; however, methods are ignored by the compiler unless they are being called. When a method is called, the compiler executes every statement contained within the method. Once all method instructions are executed, the top-down order of execution continues. This is why Starting the car! and Vroom! are outputted before That was one fast car! .","title":"Calling Methods"},{"location":"java-classes/#scope","text":"A method is a task that an object of a class performs. We mark the domain of this task using curly braces { and } . Everything inside the curly braces is part of the task. This domain is called the scope of a method. We can't access variables that are declared inside a method in code that is outside the scope of that method. Looking at the Car class again: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Car { String color ; int milesDriven ; public Car ( String carColor ) { color = carColor ; milesDriven = 0 ; } public void drive () { String message = \"Miles driven: \" + milesDriven ; System . out . println ( message ); } public static void main ( String [] args ){ Car myFastCar = new Car ( \"Red\" ); myFastCar . drive (); } } The variable message , which is declared and initialized inside of drive , cannot be used inside of main () ! It only exists within the scope of the drive () method. However, milesDriven , which is declared at the top of the class, can be used inside all methods in the class, since it is in the scope of the whole class.","title":"Scope"},{"location":"java-classes/#adding-parameters","text":"We saw how a method's scope prevents us from using variables declared in one method in another method. What if we had some information in one method that we needed to pass into another method? Similar to how we added parameters to constructors , we can customize all other methods to accept parameters. For example, in the following code, we create a startRadio () method that accepts a Double parameter, stationNum , and a String parameter called stationName : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Car { String color ; public Car ( String carColor ){ color = carColor ; } public void startRadio ( double stationNum , String stationName ) { System . out . println ( \"Turning on the radio to \" + stationNum + \", \" + stationName + \"!\" ); System . out . println ( \"Enjoy!\" ); } public static void main ( String [] args ){ Car myCar = new Car ( \"red\" ); myCar . startRadio ( 103.7 , \"Meditation Station\" ); } } Adding parameter values impacts our method's signature. Like constructor signatures, the method signature includes the method name as well as the parameter types of the method. The signature of the above method is startRadio ( double , String ) . In the main () method, we call the startRadio () method on the myCar object and probide a double argument of 103.7 and String argument of Meditation Station , resulting in the following output: Turning on the radio to 103.7, Meditation Station! Enjoy! Note that when we call on a method with multiple parameters, the arguments given in the call must be placed in the same order as the parameters appear in the signature. If the argument types do not match the parameter types, we'll receive an error.","title":"Adding Parameters"},{"location":"java-classes/#reassigning-instance-fields","text":"Earlier, we thought about a Savings Account as a type of object wer could represent in Java. Two of the methods we need are depositing and withdrawing: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public SavingsAccount { double balance ; public SavingsAccount ( double startingBalance ){ balance = startingBalance ; } public void deposit ( double amountToDeposit ){ // Add amountToDeposit to the balance } public void withdraw ( double amountToWithdraw ){ // Subtract amountToWithdraw from the balance } public static void main ( String [] args ){ } } These methods would change the valuie of the variable balance . We can reassign balance to be a new value by using our assignment operator, = , again. 1 2 3 4 public void deposit ( double amountToDeposit ){ double updatedBalance = balance + amountToDeposit ; balance = updatedBalance ; } nNow, when we call deposit () , it should change the value of the instance field balance : 1 2 3 4 5 6 public static void main ( String [] args ){ SavingsAccount myAccount = new SavingsAccount ( 2000 ); System . out . println ( myAccount . balance ); myAccount . deposit ( 100 ); System . out . println ( myAccount . balance ); } The code first prints 2000 , the initial value of myAccount . balance , and then prints 2100 , which is the value of myAccount . balance after the deposit () method has run. Change instance fields is how we change the state of an object and make our objects more flexible and realistic.","title":"Reassigning Instance Fields"},{"location":"java-classes/#returns","text":"Remeber, variables only exist in the scope that they were declared in. We can use a value outside of the method it was created in if we return it from the method. We return a value by using the keyword return : 1 2 3 4 5 public int numberOfTires () { int tires = 4 ; // return statement return tires ; } This method, called numberOfTires () , returns 4 . Once the return statement is executed, the compiler exits the function. Any code that exists after the return statement in a function is ignored. In past exercises, when creating new methods, we use the keyword void . Here, we are replacing void with int , to signify that the return type is an int . The void keyword (which means \"completely empty\") indicates that no value is returned after calling that method. A non-void method, like numberOfTires () returns a value when it is called. We can use datatype keywords (such as int , char , etc.) to specify the type of value the method should return. The return value's type must match the return type of the method. If the return expression is compatible with the return type, a copy of that value gets returned in a process known as return by value . Unlike void mehods, non-void methods can be used as either a variable value or as part of an expression like so: 1 2 3 4 public static void main ( String [] args ){ Car myCar = new Car ( \"Red\" ); int numTires = myCar . numberOfTires (); } Within main () , we called the numberOfTires () method on myCar . Since the method returns an int value of 4 , we store the value in an integer value called numTires . If we printed numTires , we would see 4 .","title":"Returns"},{"location":"java-classes/#the-tostring-method","text":"When we print out Objects, we often see a String that is not very helpful in determining what the object represents. In earlier notes, we saw that printing our Store object would output something like: Store@6bc7c123 Where Store is the name of the object and @6bc7c123 is its position in memory. This doesn't tell us anything about what the Store sells, the price, or the other instance fields we've defined. We can add a method to our classes that makes this printout more descriptive. When we define a toString () method for a class, we can return a String that will print when we print the object: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Car { String color ; public Car ( String carColor ){ color = carColor ; } public static void main ( String [] args ){ Car myCar = new Car ( \"red\" ); System . out . println ( myCar ); } public String toString (){ return \"This is a \" + color + \" car!\" ; } } When this runs the command System . out . println ( myCar ) will print This is a red car! , which tells us about the Object myCar .","title":"The toString() method"},{"location":"java-classes/#methods-review","text":"Methods are a powerful way to abstract tasks away and make them repeatable. They allow us to define behavior for classes, so that the Objects we create can do the things we expect them to. Let's review everything we have learned about methods so far: Defining a method : Methods have a method signature that declares their return type, name, and parameters. Calling a method : Methods are invoked with a . and () . Parameters : Inputs to the method and their types are declared in parentheses in the method signature. Changing Instance Fields : Methods can be used to change the value of an instance field. Scope : Variables only exist within the domain that they are created in. Return : The type of the variables that are output are declared in the method signature.","title":"Methods Review"},{"location":"java-classes/#basic-calculator","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class Calculator { public Calculator (){ } public int add ( int a , int b ){ return a + b ; } public int subtract ( int a , int b ){ return a - b ; } public int multiply ( int a , int b ){ return a * b ; } public int divide ( int a , int b ){ return a / b ; } public int modulo ( int a , int b ){ return a % b ; } public static void main ( String [] args ){ Calculator myCalculator = new Calculator (); System . out . println ( myCalculator . add ( 5 , 7 )); System . out . println ( myCalculator . subtract ( 45 , 11 )); } }","title":"Basic Calculator"},{"location":"java-conditionals/","text":"Conditionals and Control Flow Intoduction to Control Flow Imagine we're writing a program that enrolls students in courses. If a student has completed the prerequisites, then they can enroll in a course. Else , they need to take the prerequisite courses. For example, a student cannot take Physics II without first completing Physics I. We represent this kind of decision-making in our program using conditional or control flow statements. Before this point, our code runs line-by-line from the top down, but conditional statements allow us to be selective in which portions will run. Conditional statements check a boolean condition and run a block of code depending on the condition. Curly braces mark the scope of a conditional block similar to a method or class. Here's a complete conditional statement: 1 2 3 if ( true ) { System . out . println ( \"Hellow World!\" ); } If the condition is true , then the block is run, which results in Hello World! being printed. But suppose the condition is different: 1 2 3 if ( false ) { System . out . println ( \"Hello World!\" ); } If the condition is false , then the block does not run. This code is also called if-then statements: \"If (condition) is true , then do something\". If-Then Statement The if-then statement is the most simple control flow we can write. It tests an expression for truth and executes some code based on it. 1 2 3 if ( flip == 1 ) { System . out . println ( \"Heads!\" ); } the if keyword marks the beginning of the conditional statement, followed by parentheses () . The parentheses hold a boolean datatype. For the condition in parentheses we can also use variables that reference a boolean, or comparisons that evaluate to a boolean. The boolean condition is followed by opening and closing curly braces that mark a block of code. This block runs if, and only if, the boolean is true . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 boolean isValidPassword = true ; if ( isValidPassword ) { System . out . println ( \"Password Accepted!\" ); } // prints \"Password accepted!\" int numberOfItemsInCart = 9 ; if ( numberOfItemsInCart > 12 ) { System . out . println ( \"Express checkout not available\" ); } // nothing is printed If a conditional is brief we can omit the curly braces entirely: 1 if ( true ) System . out . println ( \"Brevity is the soul of wit\" ); If-Then-Else We've seem how to conditionally execute one block of code, but what if there are two possible blocks of code we'd like to execute? Let's say if a student has the required prerequisite, then they enroll in the selected course, else they're enrolled in the prerequisite course instead. We create an alternate conditional branch with the else keyword: 1 2 3 4 5 if ( hasPrerequisite ) { // enroll in course } else { // enroll in prerequisite } This conditional statement ensures that exactly one code block will be run. If the condition hasPrerequisite , is false , the block after else runs. There are now two separate code blocks in our conditional statement. The first block runs if the condition evaluates to true , the second block runs if the condition evaluates to false . This code is also called an if-then-else statement: If condition is true, then do something. Else, do a different thing. If-Then-Else-If The conditional structure we've learned can be chained together to check as many conditions as are required by our program. Imagine our program is now selecting the appropriate course for a student. We'll check their submission to find the correct course enrollment. The conditional statement now has multiple conditions that are evaluated from the top down: 1 2 3 4 5 6 7 8 9 10 11 String course = \"Theatre\" ; if ( course . equals ( \"Biology\" )) { // enroll in Biology course } else if ( course . equals ( \"Algebra\" )) { // enroll in Algebra course } else if ( course . equals ( \"Theatre\" )) { // enroll in Theatre course } else { System . out . println ( \"Course not found!\" ); } The first condition to evaluate to true will have that code block run. Here's an example demonstrating the order: 1 2 3 4 5 6 7 8 9 10 11 12 13 int testScore = 72 ; if ( testScore >= 90 ){ System . out . println ( \"A\" ); } else if ( testScore >= 80 ) { System . out . println ( \"B\" ); } else if ( testScore >= 70 ) { System . out . println ( \"C\" ); } else if ( testScore >= 60 ) { System . out . println ( \"D\" ); } else { System . out . println ( \"F\" ); } This chained conditional statement has two conditions that evaluate to true . Because testScore >= 70 comes before testScore >= 60 , only the earlier code block is run. Note: Only one of the code blocks will run. Nested Conditional Statements We can create more complex conditional structures by creating nested contitional statements , which is created by placing conditional statements inside other conditional statements: 1 2 3 4 5 if ( outer condition ) { if ( nested condition ) { // instruction to execute if both conditions are true } } When we implement nested conditional statements, the outer statement is evaluated first. If the outer condition is true , then the inner, nested statement is evaluated. Let's create a program that helps us decide what to wear based on the weather: 1 2 3 4 5 6 7 8 9 10 11 int temp = 45 ; boolean raining = true ; if ( temp < 60 ) { System . out . println ( \"Wear a jacket!\" ); if ( raining == true ) { System . out . println ( \"Bring your umbrella!\" ); } else { System . out . println ( \"Leave your umbrella at home.\" ); } } In the code snippet above, our compiler will check the condition in the first if-then statement: temp < 60 . Since temp has a value of 45 , this condition is true ; therefore, our program will print Wear a jacket! . Then, we'll evaluate the condition in the nested if-then statement: raining == true . This condition is also true , so Bring your umbrella is also printed to the screen. Note that, if the first condition was false , the nested condition would not be evaluated. Switch Statement An alternative to chaining if-then-else conditions together is to use the switch statement. This conditional will check a given value against any number of conditions and run the code block where there is a match. Here's an example of our course selection conditional as a switch statement instead: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 String course = \"History\" ; switch ( course ) { case \"Algebra\" : // Enroll in Algebra break ; case \"Biology\" : // Enroll in Biology break ; case \"History\" : // Enroll in History break ; case \"Theatre\" : // Enroll in Theatre break ; default : System . out . println ( \"Course not found\" ); } This example enrolls the student in History class by checking the value contained in the parentheses, course , against each of the case labels. If the value after the case lable matches the value within the parentheses, the switch block is run. In the above example, course references the string \"History\" , which matches case \"History\" : . When no value matches, the default block runs. Think of this as the else equivalent. Switch blocks are different than other code blocks because they are not marked by curly braces and we use the break keyword to exit the switch statement. Without break , code below the matching case label is run, including code under other case labels , which is rareley the desired behavior. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 String course = \"Biology\" ; switch ( course ) { case \"Algebra\" : // Enroll in Algebra case \"Biology\" : // Enroll in Biology case \"History\" : // Enroll in History case \"Theatre\" : // Enroll in Theatre default : System . out . println ( \"Course not found\" ); } // enrolls student in Biology... AND History and Theatre! Conditional/Control Flow Review Conditional statements add branching paths to our programs. We use conditionals to make decisions in the program so that different inputs will produce different results. Conditionals have the general structure: 1 2 3 4 5 if ( condition ) { // consequent path } else { // alternate path } Specific conditional statements have the following behavior: if-then : Code block runs if the condition is true. if-then-else : One block runs if condition is true. Another block runs if condition is false. if-then-else chained: Same as if-then but an arbitrary number of conditions. switch : Switch block runs if condition matches the case value. Introduction to Conditional Operators Java includes operators that only use boolean values. These conditional operators help simplify expressions containing complex boolean relationships by reducing multiple boolean values to a single use: true or false . For example, what if we want to run a code block only if multiple conditions are true. We could use the AND operator: && . Or, we want to run a code block if at least one of two conditions are true . We could use the OR operator: || . Finally, we can produce the opposite value, where true becomes false and false becomes true , with the NOT operator: ! . In the following notes, we'll go over each of these conditional operators to see how they can be implemented into our conditional statements. AND A B A&&B true true true true false false false true false false false false OR A B A||B true true true true false true false true true false false false NOT A !A true false false true Conditional-AND: && Let's return to our student enrollment program. We've added an additional requirement: not only must students have the prerequisite, but their tuition must be paid up as well. We have two conditionals that must be true before we enroll the student. Here is one way we can write the code: 1 2 3 4 5 if ( tuitionPaid ) { if ( hasPrerequisite ){ // enroll student } } We've nested two if - then statements. This does the job but we can be more concise with the AND operator: 1 2 3 if ( tuitionPaid && hasPrerequisite ){ // enroll student } The AND operator, && , is used between two boolean values and evaluates to a single boolean value. If the values on both sides are true , then the resulting value is true , otherwise the resulting value is false . This code illustrates every combination: true && true // true false && true // false true && false // false false && false // false Conditional-OR: || The requirements of our enrollment program have changed again. Certain courses have prerequisites that are satisfied by multiple courses. As long as students have taken at least one prerequisite, they should be allowed to enroll. Here's one way we could write the code: 1 2 3 4 5 6 7 if ( hasAlgebraPrerequisite ){ // enroll student } if ( hasGeometryPrerequisite ){ // enroll student } We're using two if - then statements with the same code block . We can be more concise with the OR operator: 1 2 3 if ( hasAlgebraPrerequisite || hasGeometryPrerequisite ){ // enroll student } The OR operator, || , is used between two boolean values and evaluates to a single boolean value. If either of the two values are true , then the resulting value is true , otherwise the resulting value is false . This code illustrates every combination: true || false // true true || false // true false || true // true false || false // false Logical NOT: ! The unary operator NOT, ! , works on a single value. This operator evaluates to the opposite boolean to which it is applied: ! false // true ! true // false NOT is useful for expressing our intent clearly in programs. For example sometimes we need the opposite behavior of an if - then : run a code block only if the condition is false . 1 2 3 4 5 6 7 boolean hasPrerequisite = false ; if ( hasPrerequisite ) { // do nothing } else { System . out . println ( \"Must complete prerequisite course!\" ); } This code does what we want but it's strange to have a code block that does nothing! The logical NOT operator cleans up our example: 1 2 3 4 5 boolean hasPrerequisite = false ; if ( ! hasPrerequisite ){ System . out . println ( \"Must complete prerequisite course!\" ); } We can write a succint conditional statement without an empty code block. Combining Conditional Operators We have the ability to expand our boolean expressions by using multiple conditional operators in a single expression. For example: boolean foo = true && ! ( false || ! true ) How does an expression like this get evaluated by the compiler? The order of evaluation when it comes to conditional operators is as follows: Conditions placed in parentheses - {} NOT - ! AND - && OR - || Using this information, let's dissect the expression above to find the value of foo : true && ! ( false || ! true ) First, we'll evaluate the ( false || ! true ) because it is enclosed within parentheses. Following the order of evaluation, we will evaluate ! true , which equals false : true && ! ( false || false ) Then, we'll evaluate ( false || false ) which equals false . Now our expression looks like this: true && !false Next, we'll evaluate ! false because it uses the NOT operator. This expression equals true making our expression the following: true && true true && true evaluates to true ; therefore, the value of foo is true . Conditional Operators Review Conditional Operators work on boolean values to simplify our code. They're often combined with conditional statements to consolidate the branching logic. Conditional-AND, && , evaluates to true if the booleans on both sides are true . Conditional-OR, || , evaluates to true if one or both oif the booleans on either side is true . Conditional-NOT, ! , evaluates to the opposite boolean value to which it is applied.","title":"Conditionals/Control Flow"},{"location":"java-conditionals/#conditionals-and-control-flow","text":"","title":"Conditionals and Control Flow"},{"location":"java-conditionals/#intoduction-to-control-flow","text":"Imagine we're writing a program that enrolls students in courses. If a student has completed the prerequisites, then they can enroll in a course. Else , they need to take the prerequisite courses. For example, a student cannot take Physics II without first completing Physics I. We represent this kind of decision-making in our program using conditional or control flow statements. Before this point, our code runs line-by-line from the top down, but conditional statements allow us to be selective in which portions will run. Conditional statements check a boolean condition and run a block of code depending on the condition. Curly braces mark the scope of a conditional block similar to a method or class. Here's a complete conditional statement: 1 2 3 if ( true ) { System . out . println ( \"Hellow World!\" ); } If the condition is true , then the block is run, which results in Hello World! being printed. But suppose the condition is different: 1 2 3 if ( false ) { System . out . println ( \"Hello World!\" ); } If the condition is false , then the block does not run. This code is also called if-then statements: \"If (condition) is true , then do something\".","title":"Intoduction to Control Flow"},{"location":"java-conditionals/#if-then-statement","text":"The if-then statement is the most simple control flow we can write. It tests an expression for truth and executes some code based on it. 1 2 3 if ( flip == 1 ) { System . out . println ( \"Heads!\" ); } the if keyword marks the beginning of the conditional statement, followed by parentheses () . The parentheses hold a boolean datatype. For the condition in parentheses we can also use variables that reference a boolean, or comparisons that evaluate to a boolean. The boolean condition is followed by opening and closing curly braces that mark a block of code. This block runs if, and only if, the boolean is true . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 boolean isValidPassword = true ; if ( isValidPassword ) { System . out . println ( \"Password Accepted!\" ); } // prints \"Password accepted!\" int numberOfItemsInCart = 9 ; if ( numberOfItemsInCart > 12 ) { System . out . println ( \"Express checkout not available\" ); } // nothing is printed If a conditional is brief we can omit the curly braces entirely: 1 if ( true ) System . out . println ( \"Brevity is the soul of wit\" );","title":"If-Then Statement"},{"location":"java-conditionals/#if-then-else","text":"We've seem how to conditionally execute one block of code, but what if there are two possible blocks of code we'd like to execute? Let's say if a student has the required prerequisite, then they enroll in the selected course, else they're enrolled in the prerequisite course instead. We create an alternate conditional branch with the else keyword: 1 2 3 4 5 if ( hasPrerequisite ) { // enroll in course } else { // enroll in prerequisite } This conditional statement ensures that exactly one code block will be run. If the condition hasPrerequisite , is false , the block after else runs. There are now two separate code blocks in our conditional statement. The first block runs if the condition evaluates to true , the second block runs if the condition evaluates to false . This code is also called an if-then-else statement: If condition is true, then do something. Else, do a different thing.","title":"If-Then-Else"},{"location":"java-conditionals/#if-then-else-if","text":"The conditional structure we've learned can be chained together to check as many conditions as are required by our program. Imagine our program is now selecting the appropriate course for a student. We'll check their submission to find the correct course enrollment. The conditional statement now has multiple conditions that are evaluated from the top down: 1 2 3 4 5 6 7 8 9 10 11 String course = \"Theatre\" ; if ( course . equals ( \"Biology\" )) { // enroll in Biology course } else if ( course . equals ( \"Algebra\" )) { // enroll in Algebra course } else if ( course . equals ( \"Theatre\" )) { // enroll in Theatre course } else { System . out . println ( \"Course not found!\" ); } The first condition to evaluate to true will have that code block run. Here's an example demonstrating the order: 1 2 3 4 5 6 7 8 9 10 11 12 13 int testScore = 72 ; if ( testScore >= 90 ){ System . out . println ( \"A\" ); } else if ( testScore >= 80 ) { System . out . println ( \"B\" ); } else if ( testScore >= 70 ) { System . out . println ( \"C\" ); } else if ( testScore >= 60 ) { System . out . println ( \"D\" ); } else { System . out . println ( \"F\" ); } This chained conditional statement has two conditions that evaluate to true . Because testScore >= 70 comes before testScore >= 60 , only the earlier code block is run. Note: Only one of the code blocks will run.","title":"If-Then-Else-If"},{"location":"java-conditionals/#nested-conditional-statements","text":"We can create more complex conditional structures by creating nested contitional statements , which is created by placing conditional statements inside other conditional statements: 1 2 3 4 5 if ( outer condition ) { if ( nested condition ) { // instruction to execute if both conditions are true } } When we implement nested conditional statements, the outer statement is evaluated first. If the outer condition is true , then the inner, nested statement is evaluated. Let's create a program that helps us decide what to wear based on the weather: 1 2 3 4 5 6 7 8 9 10 11 int temp = 45 ; boolean raining = true ; if ( temp < 60 ) { System . out . println ( \"Wear a jacket!\" ); if ( raining == true ) { System . out . println ( \"Bring your umbrella!\" ); } else { System . out . println ( \"Leave your umbrella at home.\" ); } } In the code snippet above, our compiler will check the condition in the first if-then statement: temp < 60 . Since temp has a value of 45 , this condition is true ; therefore, our program will print Wear a jacket! . Then, we'll evaluate the condition in the nested if-then statement: raining == true . This condition is also true , so Bring your umbrella is also printed to the screen. Note that, if the first condition was false , the nested condition would not be evaluated.","title":"Nested Conditional Statements"},{"location":"java-conditionals/#switch-statement","text":"An alternative to chaining if-then-else conditions together is to use the switch statement. This conditional will check a given value against any number of conditions and run the code block where there is a match. Here's an example of our course selection conditional as a switch statement instead: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 String course = \"History\" ; switch ( course ) { case \"Algebra\" : // Enroll in Algebra break ; case \"Biology\" : // Enroll in Biology break ; case \"History\" : // Enroll in History break ; case \"Theatre\" : // Enroll in Theatre break ; default : System . out . println ( \"Course not found\" ); } This example enrolls the student in History class by checking the value contained in the parentheses, course , against each of the case labels. If the value after the case lable matches the value within the parentheses, the switch block is run. In the above example, course references the string \"History\" , which matches case \"History\" : . When no value matches, the default block runs. Think of this as the else equivalent. Switch blocks are different than other code blocks because they are not marked by curly braces and we use the break keyword to exit the switch statement. Without break , code below the matching case label is run, including code under other case labels , which is rareley the desired behavior. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 String course = \"Biology\" ; switch ( course ) { case \"Algebra\" : // Enroll in Algebra case \"Biology\" : // Enroll in Biology case \"History\" : // Enroll in History case \"Theatre\" : // Enroll in Theatre default : System . out . println ( \"Course not found\" ); } // enrolls student in Biology... AND History and Theatre!","title":"Switch Statement"},{"location":"java-conditionals/#conditionalcontrol-flow-review","text":"Conditional statements add branching paths to our programs. We use conditionals to make decisions in the program so that different inputs will produce different results. Conditionals have the general structure: 1 2 3 4 5 if ( condition ) { // consequent path } else { // alternate path } Specific conditional statements have the following behavior: if-then : Code block runs if the condition is true. if-then-else : One block runs if condition is true. Another block runs if condition is false. if-then-else chained: Same as if-then but an arbitrary number of conditions. switch : Switch block runs if condition matches the case value.","title":"Conditional/Control Flow Review"},{"location":"java-conditionals/#introduction-to-conditional-operators","text":"Java includes operators that only use boolean values. These conditional operators help simplify expressions containing complex boolean relationships by reducing multiple boolean values to a single use: true or false . For example, what if we want to run a code block only if multiple conditions are true. We could use the AND operator: && . Or, we want to run a code block if at least one of two conditions are true . We could use the OR operator: || . Finally, we can produce the opposite value, where true becomes false and false becomes true , with the NOT operator: ! . In the following notes, we'll go over each of these conditional operators to see how they can be implemented into our conditional statements. AND A B A&&B true true true true false false false true false false false false OR A B A||B true true true true false true false true true false false false NOT A !A true false false true","title":"Introduction to Conditional Operators"},{"location":"java-conditionals/#conditional-and","text":"Let's return to our student enrollment program. We've added an additional requirement: not only must students have the prerequisite, but their tuition must be paid up as well. We have two conditionals that must be true before we enroll the student. Here is one way we can write the code: 1 2 3 4 5 if ( tuitionPaid ) { if ( hasPrerequisite ){ // enroll student } } We've nested two if - then statements. This does the job but we can be more concise with the AND operator: 1 2 3 if ( tuitionPaid && hasPrerequisite ){ // enroll student } The AND operator, && , is used between two boolean values and evaluates to a single boolean value. If the values on both sides are true , then the resulting value is true , otherwise the resulting value is false . This code illustrates every combination: true && true // true false && true // false true && false // false false && false // false","title":"Conditional-AND: &amp;&amp;"},{"location":"java-conditionals/#conditional-or","text":"The requirements of our enrollment program have changed again. Certain courses have prerequisites that are satisfied by multiple courses. As long as students have taken at least one prerequisite, they should be allowed to enroll. Here's one way we could write the code: 1 2 3 4 5 6 7 if ( hasAlgebraPrerequisite ){ // enroll student } if ( hasGeometryPrerequisite ){ // enroll student } We're using two if - then statements with the same code block . We can be more concise with the OR operator: 1 2 3 if ( hasAlgebraPrerequisite || hasGeometryPrerequisite ){ // enroll student } The OR operator, || , is used between two boolean values and evaluates to a single boolean value. If either of the two values are true , then the resulting value is true , otherwise the resulting value is false . This code illustrates every combination: true || false // true true || false // true false || true // true false || false // false","title":"Conditional-OR: ||"},{"location":"java-conditionals/#logical-not","text":"The unary operator NOT, ! , works on a single value. This operator evaluates to the opposite boolean to which it is applied: ! false // true ! true // false NOT is useful for expressing our intent clearly in programs. For example sometimes we need the opposite behavior of an if - then : run a code block only if the condition is false . 1 2 3 4 5 6 7 boolean hasPrerequisite = false ; if ( hasPrerequisite ) { // do nothing } else { System . out . println ( \"Must complete prerequisite course!\" ); } This code does what we want but it's strange to have a code block that does nothing! The logical NOT operator cleans up our example: 1 2 3 4 5 boolean hasPrerequisite = false ; if ( ! hasPrerequisite ){ System . out . println ( \"Must complete prerequisite course!\" ); } We can write a succint conditional statement without an empty code block.","title":"Logical NOT: !"},{"location":"java-conditionals/#combining-conditional-operators","text":"We have the ability to expand our boolean expressions by using multiple conditional operators in a single expression. For example: boolean foo = true && ! ( false || ! true ) How does an expression like this get evaluated by the compiler? The order of evaluation when it comes to conditional operators is as follows: Conditions placed in parentheses - {} NOT - ! AND - && OR - || Using this information, let's dissect the expression above to find the value of foo : true && ! ( false || ! true ) First, we'll evaluate the ( false || ! true ) because it is enclosed within parentheses. Following the order of evaluation, we will evaluate ! true , which equals false : true && ! ( false || false ) Then, we'll evaluate ( false || false ) which equals false . Now our expression looks like this: true && !false Next, we'll evaluate ! false because it uses the NOT operator. This expression equals true making our expression the following: true && true true && true evaluates to true ; therefore, the value of foo is true .","title":"Combining Conditional Operators"},{"location":"java-conditionals/#conditional-operators-review","text":"Conditional Operators work on boolean values to simplify our code. They're often combined with conditional statements to consolidate the branching logic. Conditional-AND, && , evaluates to true if the booleans on both sides are true . Conditional-OR, || , evaluates to true if one or both oif the booleans on either side is true . Conditional-NOT, ! , evaluates to the opposite boolean value to which it is applied.","title":"Conditional Operators Review"},{"location":"java-debugging/","text":"Debugging When we are writing Java programs, the compiler is our first line of defense against errors. It can catch syntax errors. Syntax errors represent grammar errors in the use of the programming language. They are the easiest to find and correct. The compiler will tell you where it got into trouble, and its best guess as to what you did wrong. Some common syntax errors are: Misspelled variable and method names Omitting semicolons ; Omitting closing parenthesis ) , square bracket ] , or curly brace } Here is an example of a syntax error message: Debug.java:5: error: ';' expected int year = 2021 ^ 1 error Usually the error is on the exact line indicated by the compiler, or the line just before it; however, if the problem is incorrectly nested braces, the actual error may be at the beginning of the nested block. Run-time Errors If our program has no compile-time errors, it will run. This is where the \"fun\" really starts. Errors which happen during program execution (run-time) after successful compilation are called run-time errors. Run-time errors occur when a program with no compile-time errors asks the computer to do something that the coputer is unable to reliably do. Some common run-time errors: Division by zero also known as a division error Trying to open a file that doesn't exist There is no way for the compiler to know about these kinds of errors when the program is compiled. Here is an example of a run-time error message: Exception in thread \"main\" java.lang.ArithmeticException: / by zero at Debug.main(Debug.java:8) Exceptions Java uses exceptions to handle errors and other exceptional events. Exceptions are the conditions that occur at runtime and may cause the termination of the program. When an exceptions occurs, Java displays a message that includes thame of the exception, the line of the program where the exception occurred, and a stack trace . The stack trace includes: The method that was running The method that invoked it The method that invoked that one and so on... Make sure to examine each method involved in the exception. Some common exceptions are: ArithmeticException : Something went wrong during an arithmetic operation; for example, division by zero. NullPointerException : You tried to access an instance variable or invoke a method on an object that is currently null . ArrayIndexOutOfBoundsException : The index you are using is either negative or greater than the last index of the array (i.e., array.length-1 ). FileNotFoundException : Java didn\u2019t find the file it was looking for. Exception Handling Exception handling is an essential feature of Java programming that allows us to use run-time error exceptions to make our debugging process a little easier. One way to handle exceptions is using the try / catch : The try statement allows you to define a block of code to be tested for errors while it is being executed. The catch statement allows you to define a block of code to be executed if an error occurs in the try block. The try and catch keywords come in pairs, though you can also catch several types of exceptions in a single block: 1 2 3 4 5 6 7 try { // block of code to try } catch ( NullPointerException e ) { // print error message like this: System . err . println ( \"NullPointerException: \" + e . getMessage ()); // or handle the error another way here } Notice how we used System . err . println () here instead of System . out . println () . System . err . println () will print out the standard error and the text will be in red. You can also chain exceptions together: 1 2 3 4 5 6 7 try { // block of code to try } catch ( NullPointerException e ){ // code to handle a NullPointerException } catch ( ArithmeticException e ){ // code to handle an ArithmeticException } Logic Errors Sometimes programs still do not do what we want them to do or no output is produced. These types of errors which provide incorrect output, but appears to be error-free, are called logic errors . Logic errors occur when there is a design flaw in your program. These are some of the most common errors that happen to beginners and also usually the most difficult to find and eliminate. Because logical errors solely depend on the logical thinking of the programmer, your job now is to figure out why the program didn\u2019t do what you wanted it to do. Some common logic errors: Program logic is flawed Some \u201csilly\u201d mistake in an if statement or a for / while loop Debugging Techniques If you have examined the code thoroughly, and you are sure the compiler is compiling the right source file, it is time for desperate measures: Divide and conquer: Comment out or temporarily delete half the code to isolate an issue. If the program compiles now, you know the error is in the code you deleted. Bring back about half of what you removed and repeat. If the program still doesn\u2019t compile, the error must be in the code that remains. Delete about half of the remaining code and repeat. Tip: In most code editors, one can highlight a block of code and use the keyboard shortcut ctrl + / to comment it out. Print statements for the rescue: Use System . out . println () to check variable/return values at various points throughout the program. A lot of the time with logic errors, there was a flawed piece of logic, a miscalculation, a missing step, etc. By printing out the values at different stages of the execution flow, you can then hopefully pinpoint where you made a mistake.","title":"Debugging"},{"location":"java-debugging/#debugging","text":"When we are writing Java programs, the compiler is our first line of defense against errors. It can catch syntax errors. Syntax errors represent grammar errors in the use of the programming language. They are the easiest to find and correct. The compiler will tell you where it got into trouble, and its best guess as to what you did wrong. Some common syntax errors are: Misspelled variable and method names Omitting semicolons ; Omitting closing parenthesis ) , square bracket ] , or curly brace } Here is an example of a syntax error message: Debug.java:5: error: ';' expected int year = 2021 ^ 1 error Usually the error is on the exact line indicated by the compiler, or the line just before it; however, if the problem is incorrectly nested braces, the actual error may be at the beginning of the nested block.","title":"Debugging"},{"location":"java-debugging/#run-time-errors","text":"If our program has no compile-time errors, it will run. This is where the \"fun\" really starts. Errors which happen during program execution (run-time) after successful compilation are called run-time errors. Run-time errors occur when a program with no compile-time errors asks the computer to do something that the coputer is unable to reliably do. Some common run-time errors: Division by zero also known as a division error Trying to open a file that doesn't exist There is no way for the compiler to know about these kinds of errors when the program is compiled. Here is an example of a run-time error message: Exception in thread \"main\" java.lang.ArithmeticException: / by zero at Debug.main(Debug.java:8)","title":"Run-time Errors"},{"location":"java-debugging/#exceptions","text":"Java uses exceptions to handle errors and other exceptional events. Exceptions are the conditions that occur at runtime and may cause the termination of the program. When an exceptions occurs, Java displays a message that includes thame of the exception, the line of the program where the exception occurred, and a stack trace . The stack trace includes: The method that was running The method that invoked it The method that invoked that one and so on... Make sure to examine each method involved in the exception. Some common exceptions are: ArithmeticException : Something went wrong during an arithmetic operation; for example, division by zero. NullPointerException : You tried to access an instance variable or invoke a method on an object that is currently null . ArrayIndexOutOfBoundsException : The index you are using is either negative or greater than the last index of the array (i.e., array.length-1 ). FileNotFoundException : Java didn\u2019t find the file it was looking for.","title":"Exceptions"},{"location":"java-debugging/#exception-handling","text":"Exception handling is an essential feature of Java programming that allows us to use run-time error exceptions to make our debugging process a little easier. One way to handle exceptions is using the try / catch : The try statement allows you to define a block of code to be tested for errors while it is being executed. The catch statement allows you to define a block of code to be executed if an error occurs in the try block. The try and catch keywords come in pairs, though you can also catch several types of exceptions in a single block: 1 2 3 4 5 6 7 try { // block of code to try } catch ( NullPointerException e ) { // print error message like this: System . err . println ( \"NullPointerException: \" + e . getMessage ()); // or handle the error another way here } Notice how we used System . err . println () here instead of System . out . println () . System . err . println () will print out the standard error and the text will be in red. You can also chain exceptions together: 1 2 3 4 5 6 7 try { // block of code to try } catch ( NullPointerException e ){ // code to handle a NullPointerException } catch ( ArithmeticException e ){ // code to handle an ArithmeticException }","title":"Exception Handling"},{"location":"java-debugging/#logic-errors","text":"Sometimes programs still do not do what we want them to do or no output is produced. These types of errors which provide incorrect output, but appears to be error-free, are called logic errors . Logic errors occur when there is a design flaw in your program. These are some of the most common errors that happen to beginners and also usually the most difficult to find and eliminate. Because logical errors solely depend on the logical thinking of the programmer, your job now is to figure out why the program didn\u2019t do what you wanted it to do. Some common logic errors: Program logic is flawed Some \u201csilly\u201d mistake in an if statement or a for / while loop","title":"Logic Errors"},{"location":"java-debugging/#debugging-techniques","text":"If you have examined the code thoroughly, and you are sure the compiler is compiling the right source file, it is time for desperate measures: Divide and conquer: Comment out or temporarily delete half the code to isolate an issue. If the program compiles now, you know the error is in the code you deleted. Bring back about half of what you removed and repeat. If the program still doesn\u2019t compile, the error must be in the code that remains. Delete about half of the remaining code and repeat. Tip: In most code editors, one can highlight a block of code and use the keyboard shortcut ctrl + / to comment it out. Print statements for the rescue: Use System . out . println () to check variable/return values at various points throughout the program. A lot of the time with logic errors, there was a flawed piece of logic, a miscalculation, a missing step, etc. By printing out the values at different stages of the execution flow, you can then hopefully pinpoint where you made a mistake.","title":"Debugging Techniques"},{"location":"java-inheritance-polymorphism/","text":"Inheritance & Polymorphism Inheritance in Practice So how do we define a child class so that it inherits from a parent class? We use the keyword extends like this: 1 2 3 4 5 6 7 class Shape { // shape class members } class Triangle extends Shape { // additional Triangle class members } Now Triangle has inherited traits from Shape , meaning it copied over class members from Shape . When we use inheritance to extend a subclass from a superclass, we create an \"is-a\" relationship from the subclass to the superclass. For example, an object of Triangle is a member of the Shape class; however an object of Shape is not necessarily an object of Triangle . Until now, we've only covered working with one class and one file. However, most Java programs utilize multiple classes, each of which requires its own file. Only one file needs a main () method - this is the file we run. Note: the various classes in our Java package - even though they are in different files - will have access to each other, so we can instantiate one class inside another. Inheriting the Constructor If the class inherits its paren'ts fields and methods, does it also inherit the constructor? Let's take a look at how the super () constructor works! Let's say Shape has a numSides field that is set by passing an integer into the constructor. If we're instantiating a Triangle , we would want that number to always be 3 , so we'd want to modify the constructor to automatically assign numSides with a value of 3 . Can we do that? As it happens, Java has a trick up its sleeve just for this occasion: using the super () method, which acts like the parent constructor inside the class constructor: 1 2 3 4 5 6 7 8 class Triangle extends shape { Triangle (){ super ( 3 ); } // additional Triangle class members } By passing 3 to super () , we are making it possible to instantiate a Triangle without passing in a value for numSides . Meanwhile, super ( 3 ) (behaving as Shape ( 3 ) ) will shoulder the responsibility of setting numSides to 3 for our Triangle object. It's like we called Shape ( 3 ) . It is also possible to write a constructor without making a call to any super () constructor: 1 2 3 4 5 6 7 8 class Triangle extends Shape { Triangle (){ this . numSides = 3 ; } // additional Triangle class methods } In this situation, Java secretly calls the parent class' no-argument constructor ( super () ). So in this specific example, the Triangle () constructor first calls the Shape () constructor. That Shape () takes care of whatever business it needs to take care of. And then after that is complete, we go in and set this . numSides to 3 . If you're writing a constructor of a child class, and don't explicitly make a call to a constructor to a parent class using super , it's important to remember that Java will automatically (and secretly) call super () as the first line of your child class constructor. Parent Class Aspect Modifiers You may recall that Java class members use private and public access modifiers to determine whether they can be accessed from outside the class. So does a child class inherit its parent's private members? Well, no. But there is another access modifier we can use to keep a parent class member accessible to its child classes and to files in the package it's contained in - and otherwise private: protected . Modifier Class Package Child Class Global public protected no modifier private Here's what protected looks like in use: 1 2 3 4 5 6 class Shape { protected double perimeter ; } // any child class of Shape can access perimeter In addition to access modifiers, there's another way to establish how child classes can interact with inherited parent class members: using the final keyword. If we add final before a parent class method's access modifier, we disallow any child classes from changing that method. This is helpful in limiting bugs that might occur from modifying a particular method. Introducing Polymorphism In Java, if Orange is a Fruit through inheritance, you can use Orange in the same contexts as Fruit like this: 1 2 3 4 5 6 7 8 9 String makeJuice ( Fruit fruit ){ return \"Apple juice and \" + fruit . squeeze (); } // inside main() Orange orange = new Orange (); System . out . println ( juicer . makeJuice ( orange )); Wait, how does that work? This is because Java incorporates the object-oriented programming principle of polymorphism . Polymorphism, which derives from Greek meaning \"many forms\", allows a child class to share the information and behavior of its parent class while also incorporating its own functionality. The main advantages of polymorphic programming: Simplifying syntax Reducing cognitive overload for devlopers These benefits are particularly helpful when we want to develop our own Java packages for other developers to import and use. For example, the built-in operator + can be used for both double s and int s. To the computer, the + means something like addDouble () for the other, but the creators of Java (and other languages) didn't want to burden us developers with recalling each individual method. Note that the reverse situation is not true; you cannot use generic parent class inheritance where a child class instance is required. So an Orange can be used as a Fruit , but a Fruit cannot be used as an Orange . Method Overriding One common use of polymorphism with Java classes is something we mentioned earlier - Overriding parent class methods in a child class. Like the + operator, we can give a single method slightly different meanings for different classes. This is useful when we want our child method to have the same name as a parent class method but behave a bit differently in some way. Let's say we have a BankAccount class that allows us to print the current balance. We want to build a CheckingAccount class that inherits the functionality of a BankAccount but with a modified printBalance () method. We can do the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class BankAccount { protected double balance ; public BankAccount ( double balanceIn ){ balance = balanceIn ; } public void printBalance () { System . out . println ( \"Your account balance is $\" + balance ); } } class CheckingAccount extends BankAccount { public CheckingAccount ( double balance ){ super ( balance ); } @Override public void printBalance (){ System . out . println ( \"Your checking account balance is $\" + balance ); } } Notice that in order to properly override printBalance () , in CheckingAccount the method has the following in common with the corresponding method BankAccount : Method name Return type Number and type of parameters You may also have noticed the @Override keyword above printBalance () in CheckingAccount . This annotation informs the compiler that we want to override a method in the parent class. If the method doesn't exist in the parent class, we'll get a helpful error when we compile the program. Using a Child Class as its Parent Class An important facet of polymorphism is the ability to use a child class object where an object of its parent class is expected. One way to do this explicitly is to instantiate a child class object as a member of the parent class. We can instantiate a CheckingAccount object as a BankAccount object like this: BankAccount nicksAccount = new CheckingAccount ( 5000.00 ); We can use nicksAccount as if we were an instance of BankAccount , in any situation where a BankAccount object is expected. (This would be true even if nicksAccount was instantiated as a CheckingAccount , but using the explicit child as parent syntax is most helpful when we want to declare objects in bulk.) It is imporant to note that the compiler considers nicksAccount to be any old BankAccount . But because method overriding is handled at runtime, if we call printBalance () , we'll see something CheckingAccount specific: Your checking account balance is $5000.00 This is because at runtime, nicksAccount is recognized as the CheckingAccount it is. So, what if CheckingAccount has a method transferToSavings () that BankAccount does not have? Can nicksAccount still use that method? Well, no. The compiler believes that nicksAccount is just a BankAccount that doesn't have some fancy child class transferToSavings () method, so it would return an error. Child Classes in Arrays and ArrayList s Usually, when we create an array or an ArrayList , the list items all need to be the same type. But polymorphism puts a new spin on what is considered the same type... In fact, we can put instances of different classes that share a parent class together in an array or ArrayList ! For example, let's say we have a Monster parent class with a few child classes: Vampire , Werewolf , and Zombie . We can set up an array with instances of each: 1 2 3 4 5 6 7 Monster dracula , wolfman , zombie1 ; dracula = new Vampire (); wolfman = new Werewolf (); zombie1 = new Zombie (); Monster [] monsters = { dracula , wolfman , zombie1 }; We can even iterate through the list of items - regardless of subclass - and perform the same action with each item: 1 2 3 4 for ( Monster monster : monsters ) { monster . attack (); } In the code above, we are able to call attack () on each monster in monsters despite the fact that, in the for-each loop, monster is declared as the parent class type Monster . Child Classes in Method Parameters When we call a method that contains parameters, the arguments we place in our method call must match the parameter type. Polymorphism gives us a little more flexibility with the arguements we can use. If we use a superclass reference as a method parameter, we can call the method using subclass reference arguments! For example, imagine the class ScaryStory , whose constructor takes in a reference to the Monster class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ScaryStory { Monster monster ; String setting ; public ScaryStory ( Monster antagonist , String place ){ monster = antagonist ; setting = place ; } public static void tellStory (){ System . out . println ( \"Once upon a time, \" + monster . name + \" was at \" + setting + \" looking to scare some mortals.\" ); } public static void main ( String [] args ) { Monster dracula ; dracula = new Vampire ( \"Dracula\" ); ScaryStory countDracula = new ScaryStory ( dracula , \"Dracula Castle\" ); countDracula . tellStory (); } } In the main () method, we used a reference of the class Vampire as our argument even though the constructor requested an object of class Monster . This is allowed because Vampire is a subclass of the Monster class. Review of Inheritance and Polymorphism A Java class can inherit fields and methods from another class. Each Java class requires its own file, but only one class in a Java package needs a main () method. Child classes inherit the parent constructor by default, but it\u2019s possible to modify the constructor using super () or override it completely. You can use protected and final to control child class access to parent class members. Java\u2019s OOP principle of polymorphism means you can use a child class object like a member of its parent class, but also give it its own traits. You can override parent class methods in the child class, ideally using the @Override keyword. It\u2019s possible to use objects of different classes that share a parent class together in an array or ArrayList .","title":"Inheritance & Polymorphism"},{"location":"java-inheritance-polymorphism/#inheritance-polymorphism","text":"","title":"Inheritance &amp; Polymorphism"},{"location":"java-inheritance-polymorphism/#inheritance-in-practice","text":"So how do we define a child class so that it inherits from a parent class? We use the keyword extends like this: 1 2 3 4 5 6 7 class Shape { // shape class members } class Triangle extends Shape { // additional Triangle class members } Now Triangle has inherited traits from Shape , meaning it copied over class members from Shape . When we use inheritance to extend a subclass from a superclass, we create an \"is-a\" relationship from the subclass to the superclass. For example, an object of Triangle is a member of the Shape class; however an object of Shape is not necessarily an object of Triangle . Until now, we've only covered working with one class and one file. However, most Java programs utilize multiple classes, each of which requires its own file. Only one file needs a main () method - this is the file we run. Note: the various classes in our Java package - even though they are in different files - will have access to each other, so we can instantiate one class inside another.","title":"Inheritance in Practice"},{"location":"java-inheritance-polymorphism/#inheriting-the-constructor","text":"If the class inherits its paren'ts fields and methods, does it also inherit the constructor? Let's take a look at how the super () constructor works! Let's say Shape has a numSides field that is set by passing an integer into the constructor. If we're instantiating a Triangle , we would want that number to always be 3 , so we'd want to modify the constructor to automatically assign numSides with a value of 3 . Can we do that? As it happens, Java has a trick up its sleeve just for this occasion: using the super () method, which acts like the parent constructor inside the class constructor: 1 2 3 4 5 6 7 8 class Triangle extends shape { Triangle (){ super ( 3 ); } // additional Triangle class members } By passing 3 to super () , we are making it possible to instantiate a Triangle without passing in a value for numSides . Meanwhile, super ( 3 ) (behaving as Shape ( 3 ) ) will shoulder the responsibility of setting numSides to 3 for our Triangle object. It's like we called Shape ( 3 ) . It is also possible to write a constructor without making a call to any super () constructor: 1 2 3 4 5 6 7 8 class Triangle extends Shape { Triangle (){ this . numSides = 3 ; } // additional Triangle class methods } In this situation, Java secretly calls the parent class' no-argument constructor ( super () ). So in this specific example, the Triangle () constructor first calls the Shape () constructor. That Shape () takes care of whatever business it needs to take care of. And then after that is complete, we go in and set this . numSides to 3 . If you're writing a constructor of a child class, and don't explicitly make a call to a constructor to a parent class using super , it's important to remember that Java will automatically (and secretly) call super () as the first line of your child class constructor.","title":"Inheriting the Constructor"},{"location":"java-inheritance-polymorphism/#parent-class-aspect-modifiers","text":"You may recall that Java class members use private and public access modifiers to determine whether they can be accessed from outside the class. So does a child class inherit its parent's private members? Well, no. But there is another access modifier we can use to keep a parent class member accessible to its child classes and to files in the package it's contained in - and otherwise private: protected . Modifier Class Package Child Class Global public protected no modifier private Here's what protected looks like in use: 1 2 3 4 5 6 class Shape { protected double perimeter ; } // any child class of Shape can access perimeter In addition to access modifiers, there's another way to establish how child classes can interact with inherited parent class members: using the final keyword. If we add final before a parent class method's access modifier, we disallow any child classes from changing that method. This is helpful in limiting bugs that might occur from modifying a particular method.","title":"Parent Class Aspect Modifiers"},{"location":"java-inheritance-polymorphism/#introducing-polymorphism","text":"In Java, if Orange is a Fruit through inheritance, you can use Orange in the same contexts as Fruit like this: 1 2 3 4 5 6 7 8 9 String makeJuice ( Fruit fruit ){ return \"Apple juice and \" + fruit . squeeze (); } // inside main() Orange orange = new Orange (); System . out . println ( juicer . makeJuice ( orange )); Wait, how does that work? This is because Java incorporates the object-oriented programming principle of polymorphism . Polymorphism, which derives from Greek meaning \"many forms\", allows a child class to share the information and behavior of its parent class while also incorporating its own functionality. The main advantages of polymorphic programming: Simplifying syntax Reducing cognitive overload for devlopers These benefits are particularly helpful when we want to develop our own Java packages for other developers to import and use. For example, the built-in operator + can be used for both double s and int s. To the computer, the + means something like addDouble () for the other, but the creators of Java (and other languages) didn't want to burden us developers with recalling each individual method. Note that the reverse situation is not true; you cannot use generic parent class inheritance where a child class instance is required. So an Orange can be used as a Fruit , but a Fruit cannot be used as an Orange .","title":"Introducing Polymorphism"},{"location":"java-inheritance-polymorphism/#method-overriding","text":"One common use of polymorphism with Java classes is something we mentioned earlier - Overriding parent class methods in a child class. Like the + operator, we can give a single method slightly different meanings for different classes. This is useful when we want our child method to have the same name as a parent class method but behave a bit differently in some way. Let's say we have a BankAccount class that allows us to print the current balance. We want to build a CheckingAccount class that inherits the functionality of a BankAccount but with a modified printBalance () method. We can do the following: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class BankAccount { protected double balance ; public BankAccount ( double balanceIn ){ balance = balanceIn ; } public void printBalance () { System . out . println ( \"Your account balance is $\" + balance ); } } class CheckingAccount extends BankAccount { public CheckingAccount ( double balance ){ super ( balance ); } @Override public void printBalance (){ System . out . println ( \"Your checking account balance is $\" + balance ); } } Notice that in order to properly override printBalance () , in CheckingAccount the method has the following in common with the corresponding method BankAccount : Method name Return type Number and type of parameters You may also have noticed the @Override keyword above printBalance () in CheckingAccount . This annotation informs the compiler that we want to override a method in the parent class. If the method doesn't exist in the parent class, we'll get a helpful error when we compile the program.","title":"Method Overriding"},{"location":"java-inheritance-polymorphism/#using-a-child-class-as-its-parent-class","text":"An important facet of polymorphism is the ability to use a child class object where an object of its parent class is expected. One way to do this explicitly is to instantiate a child class object as a member of the parent class. We can instantiate a CheckingAccount object as a BankAccount object like this: BankAccount nicksAccount = new CheckingAccount ( 5000.00 ); We can use nicksAccount as if we were an instance of BankAccount , in any situation where a BankAccount object is expected. (This would be true even if nicksAccount was instantiated as a CheckingAccount , but using the explicit child as parent syntax is most helpful when we want to declare objects in bulk.) It is imporant to note that the compiler considers nicksAccount to be any old BankAccount . But because method overriding is handled at runtime, if we call printBalance () , we'll see something CheckingAccount specific: Your checking account balance is $5000.00 This is because at runtime, nicksAccount is recognized as the CheckingAccount it is. So, what if CheckingAccount has a method transferToSavings () that BankAccount does not have? Can nicksAccount still use that method? Well, no. The compiler believes that nicksAccount is just a BankAccount that doesn't have some fancy child class transferToSavings () method, so it would return an error.","title":"Using a Child Class as its Parent Class"},{"location":"java-inheritance-polymorphism/#child-classes-in-arrays-and-arraylists","text":"Usually, when we create an array or an ArrayList , the list items all need to be the same type. But polymorphism puts a new spin on what is considered the same type... In fact, we can put instances of different classes that share a parent class together in an array or ArrayList ! For example, let's say we have a Monster parent class with a few child classes: Vampire , Werewolf , and Zombie . We can set up an array with instances of each: 1 2 3 4 5 6 7 Monster dracula , wolfman , zombie1 ; dracula = new Vampire (); wolfman = new Werewolf (); zombie1 = new Zombie (); Monster [] monsters = { dracula , wolfman , zombie1 }; We can even iterate through the list of items - regardless of subclass - and perform the same action with each item: 1 2 3 4 for ( Monster monster : monsters ) { monster . attack (); } In the code above, we are able to call attack () on each monster in monsters despite the fact that, in the for-each loop, monster is declared as the parent class type Monster .","title":"Child Classes in Arrays and ArrayLists"},{"location":"java-inheritance-polymorphism/#child-classes-in-method-parameters","text":"When we call a method that contains parameters, the arguments we place in our method call must match the parameter type. Polymorphism gives us a little more flexibility with the arguements we can use. If we use a superclass reference as a method parameter, we can call the method using subclass reference arguments! For example, imagine the class ScaryStory , whose constructor takes in a reference to the Monster class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ScaryStory { Monster monster ; String setting ; public ScaryStory ( Monster antagonist , String place ){ monster = antagonist ; setting = place ; } public static void tellStory (){ System . out . println ( \"Once upon a time, \" + monster . name + \" was at \" + setting + \" looking to scare some mortals.\" ); } public static void main ( String [] args ) { Monster dracula ; dracula = new Vampire ( \"Dracula\" ); ScaryStory countDracula = new ScaryStory ( dracula , \"Dracula Castle\" ); countDracula . tellStory (); } } In the main () method, we used a reference of the class Vampire as our argument even though the constructor requested an object of class Monster . This is allowed because Vampire is a subclass of the Monster class.","title":"Child Classes in Method Parameters"},{"location":"java-inheritance-polymorphism/#review-of-inheritance-and-polymorphism","text":"A Java class can inherit fields and methods from another class. Each Java class requires its own file, but only one class in a Java package needs a main () method. Child classes inherit the parent constructor by default, but it\u2019s possible to modify the constructor using super () or override it completely. You can use protected and final to control child class access to parent class members. Java\u2019s OOP principle of polymorphism means you can use a child class object like a member of its parent class, but also give it its own traits. You can override parent class methods in the child class, ideally using the @Override keyword. It\u2019s possible to use objects of different classes that share a parent class together in an array or ArrayList .","title":"Review of Inheritance and Polymorphism"},{"location":"java-loops/","text":"Loops Introduction to Loops In the programming world, we hate repeating ourselves. There are two reasons for this: Writing the same code over and over is time-consuming. Having less code means having less to debug. But we often need to do the same task more than once. Fortunately, computers are really good (and fast) at doing repetitive tasks. We do this through loops. A loop is a programming tool that allows developers to repeat the same block of code until some condition is met. The compiler first evaluates a boolean condition. If the condition is true , then the loop body is executed. When the last line of the loop body is executed, the condition is re-evaluated. This process continues until the condition is false . If the initial condition is false , the loop never gets executed. We employ loops to easily scale programs - saving time and minimizing mistatkes. We'll go over three types of loops that we'll see everywhere: while loops for loops for-each loops While Loops A while loop looks a bit like an if statement: 1 2 3 4 5 while ( silliness > 10 ) { // code to run } Like an if statement, the code inside a while loop will only run if the condition is true . However, a while loop will continue running the code over and over until the condition evaluates to false . So the above codeblock will continue to repeat until silliness is less than or equal to 10 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // set attempts to 0 int attempts = 0 ; // enter loop if condition is true while ( passcode != - 524 && attempts < 4 ){ System . out . println ( \"Try again.\" ); passcode = getNewPasscode (); attempts += 1 ; // is the condition still true? // if so, repeat code block } // exit when condition is not true while loops are extremely useful when you want to run some code until a specific change happens. However, if you aren't certain that change will occur, beware the infinite loop! Infinite loops occur when the condition will never evaluate to false . This can cause your entire program to crash. 1 2 3 4 5 6 7 int hedgehogs = 5 ; // this will cause an infinite loop: while ( hedgehogs < 6 ){ System . out . println ( \"Not enough hedgehogs!\" ); } In the example above, hedegehogs remains equal to 5 , which is less than 6 , leading to an infinite loop. Incrementing While Loops When looping through code, it's common to use a counter variable. A counter (also known as an iterator ) is a variable used in the conditional logic of the loop and (usually) incremented in value during each iteration through the code. For example: 1 2 3 4 5 6 7 8 9 10 // counter is initialized int wishes = 0 ; // conditional logic uses counters while ( wishes < 3 ) { System . out . println ( \"Wish granted.\" ); // counter is incremented wishes ++ ; } In the above example, the counter wishes gets intialized before the loop with a value of 0 , then the program will keep printing \"Wish granted.\" and adding 1 to wishes as long as wishes has a value of less than 3 . Once wishes reaches a value of 3 or more, the program will exit the loop. So the output would look like: Wish granted. Wish granted. Wish granted. We can also decrement counters like this: 1 2 3 4 5 6 7 8 int pushupsToDo = 10 ; while ( pushupsToDo > 0 ) { doPushup (); pushupsToDo -- ; } In the code above, the counter, pushupsToDo , starts at 10, and increments down one at a time. When it hits 0, the loop exits. For Loops Incrementing with loops is actually so common in programming that Java (like many other programming languages) includes syntax specifically to address this pattern: for loops. A for loop header is made up of the following three parts, each separated by a semicolon: The intialization of the loop control variable. A boolean expression. An increment or decrement statement. The opening line might look like this: 1 2 3 4 5 for ( int i = 0 ; i < 5 ; i ++> ){ // code that will run } In a for loop, an intialization statement is run once in order to intialize the loop control variable. This variable is modified in every iteration, can be referenced in the loop body, and used to test the boolean condition. In the example above, i is the loop control variable. Let's breakdown the above example: i = 0 : i is intialized to 0 . i < 5 : the loop is given a boolean confition that relies on the value of i . The loop will continue to execute until i < 5 is false . i++ : i will be incremented at the end of each loop and before the condition is re-evaluated. So the code will run through the loop a total of five times. We'll also hear the term \"iteration\" in reference to loops. When we iterate , it just means that we are repeating the same block of code. Using For Loops Even though we can write while loops that accomplish the same task, for loops are useful because they help us remember to increment our counter - something that is easy to forget when we increment with a while loop. Leaving out that line of code would cause an infinite loop! Fortunately, equipped with our new understanding of for loops, we can help prevent infinite loops in our own code. It's important to be aware that, if we don't create the correct for loop header, we can cause the iteration to loop one too many times or one too few times; this occurance is known as an \"off by one\" error. For example, imagine we wanted to find the sum of the first ten numbers and wrote the following code: 1 2 3 4 int sum = 0 ; for ( int i = 0 ; i < 10 ; i ++ ){ sum += i ; } This code would produce an incorrect value of 45 . We skipped adding 10 to sum because our loop control variable started with a value of 0 and stopped the iteration after it had a value of 9 . We were off by one! We could fix this by changing the condition of our loop to be i <= 0; or i < 11; . These errors can be tricky because, while they do not always produce an error in the terminal, they can cause some miscalculations in our code. These are called logical errors - the code runs fine, but it didn't do what you expected it to do. Iterating Over Arrays and ArrayLists One common pattern we'll encounter as a programmer is traversing , or looping, through a list of data and doing something with each item. In Java, that list would be an array or ArrayList and the loop could be a for loop. In order to traverse an array or ArrayList using a loop, we must find a way to access each element via its index. We may recall that for loops are created with a counter variable. We can use that counter to track the index of the current element as we iterate over the list of data. Because the first index in an array or ArrayList is 0 , the counter would begin with a value of 0 and increment until the end of the list. So we can increment through an array or ArrayList using its indices. For example, if we wanted to add 1 to every int in an array secretCode , we could do this: 1 2 3 4 for ( int i = 0 ; i < secretCode . length ; i ++ ){ // increase value of element value by 1 secretCode [ i ] += 1 ; } Notice that our condition in this example is i < secretCode.length . Because arrray indices start at 0 , the length of secretCode is 1 larger than its final index. A loop should stop its traverse before its counter is equal to the length of the list. To give a concrete example, if the length of an array is 5 , the last index we want to access is 4 . If we were to try to access index 5 , we would get an ArrayIndexOutOfBoundsException error! This is a very common mistake when first starting to traverse arrays. Traversing an ArrayList looks very similar: 1 2 3 4 5 for ( int i = 0 ; i < secretCode . size (); i ++ ){ // increase value of element value by 1 int num = secretCode . get ( i ); secretCode . set ( i , num + 1 ); } We can also use while loops to travers through arrays and ArrayList s. If we use a while loop, we need to create our own counter variable to access individual elements. We'll also set our condition to continue looping until our counter variable equals the list length. For example, let's use a while loop to travers through an array: 1 2 3 4 5 6 int i = 0 ; // initialize counter while ( i < secretCode . length ) { secretCode [ i ] += 1 ; i ++ ; // increment the while loop } Traversing through an ArrayList with a while loop would look like this: 1 2 3 4 5 6 7 int i = 0 ; // intialize counter while ( i < secretCode . size ()){ int num = secretCode . get ( i ); secretCode . set ( i , num + 1 ); i ++ ; // increment the while loop } break and continue If we ever want to exit a loop before it finishes all its iterations or want to skip one of the iterations, we can use the break and continue keywords. The break keyword is used to exit, or break, a loop. Once break is executed, the loop will stop iterating. For example: 1 2 3 4 5 6 for ( int i = 0 ; i < 10 ; i ++ ){ System . out . println ( i ); if ( i == 4 ) { break ; } } Even though the loop was set to iterate until the condition i < 10 is false , the above code will output the following because we used break : 0 1 2 3 4 The continue keyword can be placed inside of a loop if we want to skip an iteration. If continue is executed, the current loop iteration will immediately end, and the next iteration will begin. We can use the continue keyword to skip any even valued iteration: 1 2 3 4 5 6 7 8 9 int [] numbers = { 1 , 2 , 3 , 4 , 5 }; for ( int i = 0 ; i < numbers . length ; i ++ ){ if ( numbers [ i ] % 2 == 0 ) { continue ; } System . out . println ( numbers [ i ] ); } This program would output the following: 1 3 5 In this case, if a number is even, we hit a continue statement, which skips the rest of that iteration, so the print statement is skipped. As a result, we only see odd numbers print. For-Each Loops Sometimes we need access to the elements' indices or we only want to iterate through a portion of a list. If that's the case, a regular for loop or while loop is a great choice. For example, we can use a for loop to print out each element in an array called inventoryItems : 1 2 3 4 for ( int inventoryItem = 0 ; inventoryItem < inventoryItems . length ; inventoryItem ++ ){ // print element at current index System . out . println ( inventoryItems [ inventoryItem ] ); } But sometimes we couldn't care less about the indices; we only care about the element itself. At times like this, for-each loops come in handy. For-each loops , which are also referred to as enhanced loops , allow us to directly loop through each item in a list of items (like an array or ArrayList ) and perform some action with each item. If we want to use a for-each loop to rewrite our program above, the syntax looks like this: 1 2 3 4 for ( String inventoryItem : invenoryItems ) { // print element value System . out . println ( inventoryItem ); } Our enhanced loop contains two items: an enhanced for loop variable ( inventoryItem ) and a list to traverse through ( inventoryItems ). We can read the : as \"in\" like this: for each inventoryItem (which should be a String ) in inventoryItems , print inventoryItem . If we try to assign a new value to the enhanced for loop variable, the value stored in the array or ArrayList will not change. This is because, for every iteration in the enhanced loop, the loop variable is assigned a copy of the list element. Note : we can name the enhanced for loop variable whatever we wantl using the singular of a plural is just a convention. We may also encounter conventions like String word : sentence . Removing Elements During Traversal If we want to remove elements from an ArrayList while traversing through one, we can easily run into an error if we aren't careful. When an element is removed from an ArrayList , all the items that appear after the removed element will have their index value shift by negative one - it's like all elements shifted to the left! We'll have to be very careful with how we use our counter variable to avoid skipping elements. Removing an Element Using while When using a while loop and removing elements from an ArrayList , we should not increment the while loop's counter whenever we remove an element. We don't need to increase the counter because all of the other elements have now shifted to the left. For example, if we removed the element at index 3 , then the element that was at index 4 will be moved to index 3 . If we increase our counter to 4 , we'll skip that element. Take a look at this block of code that will remove all odd numbers from an ArrayList . Think about what the value of i is, when we're increasing the value of i , and when i < lst.size() becomes false . 1 2 3 4 5 6 7 8 9 10 11 int i = 0 ; // initializing counter while ( i < lst . size ()){ // if value is odd, remove value if ( lst . get ( i ) % 2 != 0 ){ lst . remove ( i ); } else { // if content is even, increment counter i ++ ; } } Removing an Element Using for We can use a similar strategy when removing elements using a for loop. When using a while loop, we decided to not increase our loop control variable whenever we removed an element. This ensured that we would not skip an element when all of the other elements shifted to the left. When using a for loop, we, unfortunately, must increase our loop control variable - the loop control variable will always change when we reach the end of the loop (and it will usually change by 1 because we often use something like i++ ). Since we can't avoid increasing our loop control variable, we can take matters into our own hands and decrease the loop control variable whenever we remove an item. For example: 1 2 3 4 5 6 7 8 for ( int i = 0 ; i < lst . size (); i ++ ){ if ( lst . get ( i ) == \"value to remove\" ){ // remove value from ArrayList lst . remove ( lst . get ( i )); // decrease loop control variable by ` i -- ; } } Now whenever we remove an item, we'll decrease i by 1 . Then when we reach the end of the loop, i will increase by 1 . It will be like i never changed! Note : avoid manipulating the size of an ArrayList when using an enhanced for loop. Actions like adding or removing elements from an ArrayList when using a for each loop can cause a ConcurrentModificationException error. Loops Review Quick recap on what the Loops notes cover: while loops: these are useful to repeat a code block an unknown number of times until some condition is met. For example: 1 2 3 4 5 6 7 8 int wishes = 0 ; while ( wishes < 3 ) { // code that will run wishes ++ ; } for loops: these are ideal for when you are incrementing or decrementing with a counter variable. For example: 1 2 3 4 5 for ( int i = 0 ; i < 5 ; i ++ ) { // code that will run } for-each loops: these make it simple to do something with each item in a list. For example: 1 2 3 4 5 for ( String inventoryItem : inventoryItems ) { // do something with each inventoryItem }","title":"Loops"},{"location":"java-loops/#loops","text":"","title":"Loops"},{"location":"java-loops/#introduction-to-loops","text":"In the programming world, we hate repeating ourselves. There are two reasons for this: Writing the same code over and over is time-consuming. Having less code means having less to debug. But we often need to do the same task more than once. Fortunately, computers are really good (and fast) at doing repetitive tasks. We do this through loops. A loop is a programming tool that allows developers to repeat the same block of code until some condition is met. The compiler first evaluates a boolean condition. If the condition is true , then the loop body is executed. When the last line of the loop body is executed, the condition is re-evaluated. This process continues until the condition is false . If the initial condition is false , the loop never gets executed. We employ loops to easily scale programs - saving time and minimizing mistatkes. We'll go over three types of loops that we'll see everywhere: while loops for loops for-each loops","title":"Introduction to Loops"},{"location":"java-loops/#while-loops","text":"A while loop looks a bit like an if statement: 1 2 3 4 5 while ( silliness > 10 ) { // code to run } Like an if statement, the code inside a while loop will only run if the condition is true . However, a while loop will continue running the code over and over until the condition evaluates to false . So the above codeblock will continue to repeat until silliness is less than or equal to 10 . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // set attempts to 0 int attempts = 0 ; // enter loop if condition is true while ( passcode != - 524 && attempts < 4 ){ System . out . println ( \"Try again.\" ); passcode = getNewPasscode (); attempts += 1 ; // is the condition still true? // if so, repeat code block } // exit when condition is not true while loops are extremely useful when you want to run some code until a specific change happens. However, if you aren't certain that change will occur, beware the infinite loop! Infinite loops occur when the condition will never evaluate to false . This can cause your entire program to crash. 1 2 3 4 5 6 7 int hedgehogs = 5 ; // this will cause an infinite loop: while ( hedgehogs < 6 ){ System . out . println ( \"Not enough hedgehogs!\" ); } In the example above, hedegehogs remains equal to 5 , which is less than 6 , leading to an infinite loop.","title":"While Loops"},{"location":"java-loops/#incrementing-while-loops","text":"When looping through code, it's common to use a counter variable. A counter (also known as an iterator ) is a variable used in the conditional logic of the loop and (usually) incremented in value during each iteration through the code. For example: 1 2 3 4 5 6 7 8 9 10 // counter is initialized int wishes = 0 ; // conditional logic uses counters while ( wishes < 3 ) { System . out . println ( \"Wish granted.\" ); // counter is incremented wishes ++ ; } In the above example, the counter wishes gets intialized before the loop with a value of 0 , then the program will keep printing \"Wish granted.\" and adding 1 to wishes as long as wishes has a value of less than 3 . Once wishes reaches a value of 3 or more, the program will exit the loop. So the output would look like: Wish granted. Wish granted. Wish granted. We can also decrement counters like this: 1 2 3 4 5 6 7 8 int pushupsToDo = 10 ; while ( pushupsToDo > 0 ) { doPushup (); pushupsToDo -- ; } In the code above, the counter, pushupsToDo , starts at 10, and increments down one at a time. When it hits 0, the loop exits.","title":"Incrementing While Loops"},{"location":"java-loops/#for-loops","text":"Incrementing with loops is actually so common in programming that Java (like many other programming languages) includes syntax specifically to address this pattern: for loops. A for loop header is made up of the following three parts, each separated by a semicolon: The intialization of the loop control variable. A boolean expression. An increment or decrement statement. The opening line might look like this: 1 2 3 4 5 for ( int i = 0 ; i < 5 ; i ++> ){ // code that will run } In a for loop, an intialization statement is run once in order to intialize the loop control variable. This variable is modified in every iteration, can be referenced in the loop body, and used to test the boolean condition. In the example above, i is the loop control variable. Let's breakdown the above example: i = 0 : i is intialized to 0 . i < 5 : the loop is given a boolean confition that relies on the value of i . The loop will continue to execute until i < 5 is false . i++ : i will be incremented at the end of each loop and before the condition is re-evaluated. So the code will run through the loop a total of five times. We'll also hear the term \"iteration\" in reference to loops. When we iterate , it just means that we are repeating the same block of code.","title":"For Loops"},{"location":"java-loops/#using-for-loops","text":"Even though we can write while loops that accomplish the same task, for loops are useful because they help us remember to increment our counter - something that is easy to forget when we increment with a while loop. Leaving out that line of code would cause an infinite loop! Fortunately, equipped with our new understanding of for loops, we can help prevent infinite loops in our own code. It's important to be aware that, if we don't create the correct for loop header, we can cause the iteration to loop one too many times or one too few times; this occurance is known as an \"off by one\" error. For example, imagine we wanted to find the sum of the first ten numbers and wrote the following code: 1 2 3 4 int sum = 0 ; for ( int i = 0 ; i < 10 ; i ++ ){ sum += i ; } This code would produce an incorrect value of 45 . We skipped adding 10 to sum because our loop control variable started with a value of 0 and stopped the iteration after it had a value of 9 . We were off by one! We could fix this by changing the condition of our loop to be i <= 0; or i < 11; . These errors can be tricky because, while they do not always produce an error in the terminal, they can cause some miscalculations in our code. These are called logical errors - the code runs fine, but it didn't do what you expected it to do.","title":"Using For Loops"},{"location":"java-loops/#iterating-over-arrays-and-arraylists","text":"One common pattern we'll encounter as a programmer is traversing , or looping, through a list of data and doing something with each item. In Java, that list would be an array or ArrayList and the loop could be a for loop. In order to traverse an array or ArrayList using a loop, we must find a way to access each element via its index. We may recall that for loops are created with a counter variable. We can use that counter to track the index of the current element as we iterate over the list of data. Because the first index in an array or ArrayList is 0 , the counter would begin with a value of 0 and increment until the end of the list. So we can increment through an array or ArrayList using its indices. For example, if we wanted to add 1 to every int in an array secretCode , we could do this: 1 2 3 4 for ( int i = 0 ; i < secretCode . length ; i ++ ){ // increase value of element value by 1 secretCode [ i ] += 1 ; } Notice that our condition in this example is i < secretCode.length . Because arrray indices start at 0 , the length of secretCode is 1 larger than its final index. A loop should stop its traverse before its counter is equal to the length of the list. To give a concrete example, if the length of an array is 5 , the last index we want to access is 4 . If we were to try to access index 5 , we would get an ArrayIndexOutOfBoundsException error! This is a very common mistake when first starting to traverse arrays. Traversing an ArrayList looks very similar: 1 2 3 4 5 for ( int i = 0 ; i < secretCode . size (); i ++ ){ // increase value of element value by 1 int num = secretCode . get ( i ); secretCode . set ( i , num + 1 ); } We can also use while loops to travers through arrays and ArrayList s. If we use a while loop, we need to create our own counter variable to access individual elements. We'll also set our condition to continue looping until our counter variable equals the list length. For example, let's use a while loop to travers through an array: 1 2 3 4 5 6 int i = 0 ; // initialize counter while ( i < secretCode . length ) { secretCode [ i ] += 1 ; i ++ ; // increment the while loop } Traversing through an ArrayList with a while loop would look like this: 1 2 3 4 5 6 7 int i = 0 ; // intialize counter while ( i < secretCode . size ()){ int num = secretCode . get ( i ); secretCode . set ( i , num + 1 ); i ++ ; // increment the while loop }","title":"Iterating Over Arrays and ArrayLists"},{"location":"java-loops/#break-and-continue","text":"If we ever want to exit a loop before it finishes all its iterations or want to skip one of the iterations, we can use the break and continue keywords. The break keyword is used to exit, or break, a loop. Once break is executed, the loop will stop iterating. For example: 1 2 3 4 5 6 for ( int i = 0 ; i < 10 ; i ++ ){ System . out . println ( i ); if ( i == 4 ) { break ; } } Even though the loop was set to iterate until the condition i < 10 is false , the above code will output the following because we used break : 0 1 2 3 4 The continue keyword can be placed inside of a loop if we want to skip an iteration. If continue is executed, the current loop iteration will immediately end, and the next iteration will begin. We can use the continue keyword to skip any even valued iteration: 1 2 3 4 5 6 7 8 9 int [] numbers = { 1 , 2 , 3 , 4 , 5 }; for ( int i = 0 ; i < numbers . length ; i ++ ){ if ( numbers [ i ] % 2 == 0 ) { continue ; } System . out . println ( numbers [ i ] ); } This program would output the following: 1 3 5 In this case, if a number is even, we hit a continue statement, which skips the rest of that iteration, so the print statement is skipped. As a result, we only see odd numbers print.","title":"break and continue"},{"location":"java-loops/#for-each-loops","text":"Sometimes we need access to the elements' indices or we only want to iterate through a portion of a list. If that's the case, a regular for loop or while loop is a great choice. For example, we can use a for loop to print out each element in an array called inventoryItems : 1 2 3 4 for ( int inventoryItem = 0 ; inventoryItem < inventoryItems . length ; inventoryItem ++ ){ // print element at current index System . out . println ( inventoryItems [ inventoryItem ] ); } But sometimes we couldn't care less about the indices; we only care about the element itself. At times like this, for-each loops come in handy. For-each loops , which are also referred to as enhanced loops , allow us to directly loop through each item in a list of items (like an array or ArrayList ) and perform some action with each item. If we want to use a for-each loop to rewrite our program above, the syntax looks like this: 1 2 3 4 for ( String inventoryItem : invenoryItems ) { // print element value System . out . println ( inventoryItem ); } Our enhanced loop contains two items: an enhanced for loop variable ( inventoryItem ) and a list to traverse through ( inventoryItems ). We can read the : as \"in\" like this: for each inventoryItem (which should be a String ) in inventoryItems , print inventoryItem . If we try to assign a new value to the enhanced for loop variable, the value stored in the array or ArrayList will not change. This is because, for every iteration in the enhanced loop, the loop variable is assigned a copy of the list element. Note : we can name the enhanced for loop variable whatever we wantl using the singular of a plural is just a convention. We may also encounter conventions like String word : sentence .","title":"For-Each Loops"},{"location":"java-loops/#removing-elements-during-traversal","text":"If we want to remove elements from an ArrayList while traversing through one, we can easily run into an error if we aren't careful. When an element is removed from an ArrayList , all the items that appear after the removed element will have their index value shift by negative one - it's like all elements shifted to the left! We'll have to be very careful with how we use our counter variable to avoid skipping elements.","title":"Removing Elements During Traversal"},{"location":"java-loops/#removing-an-element-using-while","text":"When using a while loop and removing elements from an ArrayList , we should not increment the while loop's counter whenever we remove an element. We don't need to increase the counter because all of the other elements have now shifted to the left. For example, if we removed the element at index 3 , then the element that was at index 4 will be moved to index 3 . If we increase our counter to 4 , we'll skip that element. Take a look at this block of code that will remove all odd numbers from an ArrayList . Think about what the value of i is, when we're increasing the value of i , and when i < lst.size() becomes false . 1 2 3 4 5 6 7 8 9 10 11 int i = 0 ; // initializing counter while ( i < lst . size ()){ // if value is odd, remove value if ( lst . get ( i ) % 2 != 0 ){ lst . remove ( i ); } else { // if content is even, increment counter i ++ ; } }","title":"Removing an Element Using while"},{"location":"java-loops/#removing-an-element-using-for","text":"We can use a similar strategy when removing elements using a for loop. When using a while loop, we decided to not increase our loop control variable whenever we removed an element. This ensured that we would not skip an element when all of the other elements shifted to the left. When using a for loop, we, unfortunately, must increase our loop control variable - the loop control variable will always change when we reach the end of the loop (and it will usually change by 1 because we often use something like i++ ). Since we can't avoid increasing our loop control variable, we can take matters into our own hands and decrease the loop control variable whenever we remove an item. For example: 1 2 3 4 5 6 7 8 for ( int i = 0 ; i < lst . size (); i ++ ){ if ( lst . get ( i ) == \"value to remove\" ){ // remove value from ArrayList lst . remove ( lst . get ( i )); // decrease loop control variable by ` i -- ; } } Now whenever we remove an item, we'll decrease i by 1 . Then when we reach the end of the loop, i will increase by 1 . It will be like i never changed! Note : avoid manipulating the size of an ArrayList when using an enhanced for loop. Actions like adding or removing elements from an ArrayList when using a for each loop can cause a ConcurrentModificationException error.","title":"Removing an Element Using for"},{"location":"java-loops/#loops-review","text":"Quick recap on what the Loops notes cover: while loops: these are useful to repeat a code block an unknown number of times until some condition is met. For example: 1 2 3 4 5 6 7 8 int wishes = 0 ; while ( wishes < 3 ) { // code that will run wishes ++ ; } for loops: these are ideal for when you are incrementing or decrementing with a counter variable. For example: 1 2 3 4 5 for ( int i = 0 ; i < 5 ; i ++ ) { // code that will run } for-each loops: these make it simple to do something with each item in a list. For example: 1 2 3 4 5 for ( String inventoryItem : inventoryItems ) { // do something with each inventoryItem }","title":"Loops Review"},{"location":"java-string-methods/","text":"String Methods Introduction to String Methods As you may recall, a String , which is widely used in Java, is an object that represents a sequence of characters. it is a great way to store information. Because character strings are so vital to programming, Java dedicated an entire class to them. This is great news for us because the String class has a lot of useful methods to help us perform operations on String s and data manipulation. We don't have to import anything to use the String class because it's apart of the java.lang package, which is available by default. In these notes, we are going to go over several String methods: length() concat() equals() indexOf() charAt() substring() toUpperCase() / toLowerCase() length() In Java, the length() string method returns the length - total number of characters - of a String . Suppose we have a String called str , str.length() would return its length. Take a look at this code for example: 1 2 3 String str = \"Hello World!\" ; System . out . println ( str . length ()); 12 would be printed because str has 12 characters: H e l l o _ W o r l d ! In theory, the length of a String is the same as the Unicode units of the String . For example, escape sequences such as \\n count as only one character. concat() The concat() method concatenates one string to the end of another string. Concatenation is the operation of joining two strings together. Suppose we have a String called str1 and another String called str2 , using str1 . concat ( str2 ) would return str1 with str2 appended to the end of it. For example: 1 2 3 4 5 String name = new String ( \"Nick's \" ); name = name . concat ( \"Docs\" ); System . out . println ( name ); Nick's Docs would be printed. String s are immutable objects, which means that String methods, like concat() do not actually change a String object. Our variable, name holds a reference to the String object, \"Nick's \" . When we use concat() on name , we changed its value so that it references a new object - \"Nick's \" , combined with the String literal, \"Docs\" . Suppose we do something slightly different. We'll use concat() on name without reassigning its value: 1 2 3 4 5 String name = new String ( \"Nick's \" ); name . concat ( \"Docs\" ); System . out . println ( name ); Nick's would be printed instead. The value of the String can't change! Instead, we create a new object and need to assign that new object some variable. equals() With objects, such as String s, we can't use the primitive equality operator == to check for equality between two strings. To test equality with strings, we use a built-in method called equals() . For example: 1 2 3 4 5 6 7 String flavor1 = \"Mango\" ; String flavor2 = \"Peach\" ; System . out . println ( flavor1 . equals ( \"Mango\" )); // prints true System . out . println ( flavor2 . equals ( \"Mango\" )); // prints false Side note, there's also an equalsIgnoreCase() method that compares two strings without considering upper/lower case. We can also compare String values lexicographically (think dictionary order) using the .compareTo() method. When we call the .compareTo() method, each character in the String is converted to Unicode; then the Unicode character from each String is compared. The method will return an int that represents the difference between the two String s. For example: 1 2 3 4 String flavor1 = \"Mango\" ; String flavor2 = \"Peach\" ; System . out . println ( flavor1 . compareTo ( flavor2 )); Our program will output -3 . When using a compareTo() method, we must pay attention to the return value: If the method returns 0 , the two String s are equal. If the value is less that 0 , then the String object is lexicographically less than the String object argument. If the value is greater than 0 , then the String object is lexicographically greater than the String object argument. indexOf() If we want to know the index of the first occurence of a character in a string, we can use the indexOf() method on a string. Remember that the indices in Java start with 0 : 1 2 3 String letters = \"ABCDEFGHIJKLMN\" ; System . out . println ( letters . indexOf ( \"C\" )); This would output 2 . Although C is the third letter in the English alphabet, it is located in the second index of the string. Suppose we want to know the index of the first occurrence of an entire substring. The indexOf() instance method can also return where the substring begins (the index of the first character in the substring): 1 2 3 String letters = \"ABCDEFGHIJKLMN\" ; System . out . println ( letters . indexOf ( \"EFG\" )); This would output 4 because EFG starts at index 4 . If the indexOf() doesn't find what it's looking for, it'll return a -1 . charAt() The charAt() method returns the character located at a String 's specified index. For example: 1 2 3 String str = \"qwer\" ; System . out . println ( str . charAt ( 2 )); It would output e because that is what is located at index 2. Suppose we try to return the character located at index 4. It would produce an IndexOutOfBoundsException error because index 4 is out of str 's range. substring() There may be times when we only want a part of a string. In such cases, we may want to extract a substring from a string. The substring() method does exactly that. For example: 1 2 3 String line = \"The Heav'ns and all the Constellations rung\" ; System . out . println ( line . substring ( 24 )); It would output Constellations rung because that's what begins at index 24 and ends at the end of line . The substring begins with the character at the specified index and extends the end of the string. But suppose we want a substring from the middle of the string. We can include two arguments with this string method. For example: 1 2 3 String line = \"The Heav'ns and all the Constellations rung\" ; System . out . println ( line . substring ( 24 , 38 )); It would output Constellations because that's the substring that begins at index 24 and ends at index 38. We can use this method to return a single-element substring at a specific index by calling substring() with the wanted index value plus one as the second argument. For example, we can use this method to output just C : 1 2 3 String line = \"The Heav'ns and all the Constellations rung\" ; System . out . println ( line . substring ( 24 , 25 )); toUpperCase() / toLowerCase() There will be times when we have a word in a case other than what we need it in. Luckily, Java has a couple String methods to help us out: toUpperCase() : returns the string value converted to uppercase. toLowerCase() : returns the string value converted to lowercase. For example: 1 2 3 4 5 6 7 String input = \"Cricket!\" ; String upper = input . toUpperCase (); // stores \"CRICKET!\" String lower = input . toLowerCase (); // stores \"cricket!\" A good use of this functionality is to ensure consistency of the data you store in a database. Making sure all of the data you get from a user is lowercase before you store it in your database will make your database easier to search through later. String Methods Review String Method Value length() returns the length concat() concatenates two strings equals() checks for equality between two strings indexOf() returns the index of a substring charAt() returns a character substring() returns a substring toUpperCase() returns the upper case version toLowerCase() returns the lower case version","title":"String Methods"},{"location":"java-string-methods/#string-methods","text":"","title":"String Methods"},{"location":"java-string-methods/#introduction-to-string-methods","text":"As you may recall, a String , which is widely used in Java, is an object that represents a sequence of characters. it is a great way to store information. Because character strings are so vital to programming, Java dedicated an entire class to them. This is great news for us because the String class has a lot of useful methods to help us perform operations on String s and data manipulation. We don't have to import anything to use the String class because it's apart of the java.lang package, which is available by default. In these notes, we are going to go over several String methods: length() concat() equals() indexOf() charAt() substring() toUpperCase() / toLowerCase()","title":"Introduction to String Methods"},{"location":"java-string-methods/#length","text":"In Java, the length() string method returns the length - total number of characters - of a String . Suppose we have a String called str , str.length() would return its length. Take a look at this code for example: 1 2 3 String str = \"Hello World!\" ; System . out . println ( str . length ()); 12 would be printed because str has 12 characters: H e l l o _ W o r l d ! In theory, the length of a String is the same as the Unicode units of the String . For example, escape sequences such as \\n count as only one character.","title":"length()"},{"location":"java-string-methods/#concat","text":"The concat() method concatenates one string to the end of another string. Concatenation is the operation of joining two strings together. Suppose we have a String called str1 and another String called str2 , using str1 . concat ( str2 ) would return str1 with str2 appended to the end of it. For example: 1 2 3 4 5 String name = new String ( \"Nick's \" ); name = name . concat ( \"Docs\" ); System . out . println ( name ); Nick's Docs would be printed. String s are immutable objects, which means that String methods, like concat() do not actually change a String object. Our variable, name holds a reference to the String object, \"Nick's \" . When we use concat() on name , we changed its value so that it references a new object - \"Nick's \" , combined with the String literal, \"Docs\" . Suppose we do something slightly different. We'll use concat() on name without reassigning its value: 1 2 3 4 5 String name = new String ( \"Nick's \" ); name . concat ( \"Docs\" ); System . out . println ( name ); Nick's would be printed instead. The value of the String can't change! Instead, we create a new object and need to assign that new object some variable.","title":"concat()"},{"location":"java-string-methods/#equals","text":"With objects, such as String s, we can't use the primitive equality operator == to check for equality between two strings. To test equality with strings, we use a built-in method called equals() . For example: 1 2 3 4 5 6 7 String flavor1 = \"Mango\" ; String flavor2 = \"Peach\" ; System . out . println ( flavor1 . equals ( \"Mango\" )); // prints true System . out . println ( flavor2 . equals ( \"Mango\" )); // prints false Side note, there's also an equalsIgnoreCase() method that compares two strings without considering upper/lower case. We can also compare String values lexicographically (think dictionary order) using the .compareTo() method. When we call the .compareTo() method, each character in the String is converted to Unicode; then the Unicode character from each String is compared. The method will return an int that represents the difference between the two String s. For example: 1 2 3 4 String flavor1 = \"Mango\" ; String flavor2 = \"Peach\" ; System . out . println ( flavor1 . compareTo ( flavor2 )); Our program will output -3 . When using a compareTo() method, we must pay attention to the return value: If the method returns 0 , the two String s are equal. If the value is less that 0 , then the String object is lexicographically less than the String object argument. If the value is greater than 0 , then the String object is lexicographically greater than the String object argument.","title":"equals()"},{"location":"java-string-methods/#indexof","text":"If we want to know the index of the first occurence of a character in a string, we can use the indexOf() method on a string. Remember that the indices in Java start with 0 : 1 2 3 String letters = \"ABCDEFGHIJKLMN\" ; System . out . println ( letters . indexOf ( \"C\" )); This would output 2 . Although C is the third letter in the English alphabet, it is located in the second index of the string. Suppose we want to know the index of the first occurrence of an entire substring. The indexOf() instance method can also return where the substring begins (the index of the first character in the substring): 1 2 3 String letters = \"ABCDEFGHIJKLMN\" ; System . out . println ( letters . indexOf ( \"EFG\" )); This would output 4 because EFG starts at index 4 . If the indexOf() doesn't find what it's looking for, it'll return a -1 .","title":"indexOf()"},{"location":"java-string-methods/#charat","text":"The charAt() method returns the character located at a String 's specified index. For example: 1 2 3 String str = \"qwer\" ; System . out . println ( str . charAt ( 2 )); It would output e because that is what is located at index 2. Suppose we try to return the character located at index 4. It would produce an IndexOutOfBoundsException error because index 4 is out of str 's range.","title":"charAt()"},{"location":"java-string-methods/#substring","text":"There may be times when we only want a part of a string. In such cases, we may want to extract a substring from a string. The substring() method does exactly that. For example: 1 2 3 String line = \"The Heav'ns and all the Constellations rung\" ; System . out . println ( line . substring ( 24 )); It would output Constellations rung because that's what begins at index 24 and ends at the end of line . The substring begins with the character at the specified index and extends the end of the string. But suppose we want a substring from the middle of the string. We can include two arguments with this string method. For example: 1 2 3 String line = \"The Heav'ns and all the Constellations rung\" ; System . out . println ( line . substring ( 24 , 38 )); It would output Constellations because that's the substring that begins at index 24 and ends at index 38. We can use this method to return a single-element substring at a specific index by calling substring() with the wanted index value plus one as the second argument. For example, we can use this method to output just C : 1 2 3 String line = \"The Heav'ns and all the Constellations rung\" ; System . out . println ( line . substring ( 24 , 25 ));","title":"substring()"},{"location":"java-string-methods/#touppercasetolowercase","text":"There will be times when we have a word in a case other than what we need it in. Luckily, Java has a couple String methods to help us out: toUpperCase() : returns the string value converted to uppercase. toLowerCase() : returns the string value converted to lowercase. For example: 1 2 3 4 5 6 7 String input = \"Cricket!\" ; String upper = input . toUpperCase (); // stores \"CRICKET!\" String lower = input . toLowerCase (); // stores \"cricket!\" A good use of this functionality is to ensure consistency of the data you store in a database. Making sure all of the data you get from a user is lowercase before you store it in your database will make your database easier to search through later.","title":"toUpperCase()/toLowerCase()"},{"location":"java-string-methods/#string-methods-review","text":"String Method Value length() returns the length concat() concatenates two strings equals() checks for equality between two strings indexOf() returns the index of a substring charAt() returns a character substring() returns a substring toUpperCase() returns the upper case version toLowerCase() returns the lower case version","title":"String Methods Review"},{"location":"java-variables/","text":"Variables Introduction to Variables Let's say we need a program that connects a user with new jobs. We need the user's name, their salary, and they current employment status. All of these pieces of information are stored in our program. We store information in variables , which are named locations in memory. Naming a piece of information allows us to use that name later, accessing the information we stored. Variables also give context and meaning to the data we're storing. The value 42 could be someone's age, a weight in pounds, or the number of orders placed. With a name, we know the value of 42 is age , weightInPounds , or numOrdersPlaced . In Java, we specify the type of information we're storing. Primitive datatypes are types of data built-in to the Java system. The three main primitive types we will cover in these notes are: int - Stores whole numbers double - Stores bigger whole numbers and decimal numbers boolean - Stores true and false char - Stores single characters using single quotes ( '' ) String - Stores multiple characters using double quotes ( \"\" ) We must declare a variable to reference it within our program. Declaring a variable requires that we specify the type and name: 1 2 3 4 // datatype variableName int age ; double salaryRequirement ; boolean isEmployed ; The names of the variables above are age , salaryRequirement , and isEmployed . These variables don't have any associated value. To assign a value to a variable, we use the assignment operator = : 1 age = 85 ; Now, age has a value of 85 . When code is used to represent a fixed value, like 85 , it is referred to as a literal . For example, to assign 2013 to a variable named yearNickGraduatedHighSchool of type int , we write: 1 int yearNickGraduatedHighSchool = 2013 ; Using this logic towards the System . out . println () statements we used from Java Basics , instead of putting text within parenthesis, we could print a variable: 1 2 3 4 5 6 7 8 public class Nick { public static void main ( String [] args ) { String name = \"Nick\" ; int yearBorn = 1995 ; System . out . println ( name ); System . out . println ( yearBorn ); } } This would have the output: Nick 1995 int The first type of data we will store is the whole number. Whole numbers are very common in programming. You often see them stored as ages, maximum sizes, or the number of times some code has been run, among many other uses. In Java, whole numbers are stored in the int primitive data type. int s hold positive numbers, negative numbers, and zero. They do not store fractions or numbers with decimals in them. The int data type allows values between -2,147,483,648 and 2,147,483,647, inclusive. To declare a variable of type int , we use the int keyword before the variable name: 1 2 3 4 5 6 // int variable declaration int yearJavaWasCreated ; // assignment yearJavaWasCreated = 1996 ; // declaration and assignment int numOfPrimitiveTypes = 8 ; double Whole numbers don't accomplish what we need for every program. What if we wanted to store the price of stomething? We need a decimal point. What if we need to store the world's population? That number would be larger than the int type can hold. The double primitive data type can help. double can hold decimals as well as very small/large numbers. The maximum value is 1.797,693,134,862,315,7 E+308, which is approximately 17 followed by 307 zeros. The minimum value is 4.9 E-324, which is 324 decimal places! To declare a variable of type double , we use the double keyword in the declaration: 1 2 3 4 // doubles can have decimal places: double price = 8.99 ; // doubles can have values bigger than an int can hold: double gdp = 12237700000 ; boolean Often our programs face questions that can only be answered with yes or no. These questions could be: is the oven on? Is the light green? Did I eat breakfast? These questions are answered with a boolean , a type that references on of two values: true or false . We declare boolean variables by using the keyword boolean before the variable name: 1 2 boolean javaIsACompiledLanguage = true ; boolean javaIsACupOfCoffee = false ; char How do we answer questions like: What grade did you get on the test? What letter does your name start with? The char data type can hold any character, like a letter, space, or punctuation mark. It must be surrounded by single quotes, ' . For example: 1 2 3 char grade = 'A' ; char firstLetter = 'p' ; char punctuation = '!' ; String So far, we have learned about primitive data types, which are the simplest types of data with no built-in behavior. Our programs will also use String s, which are objects , instead of primitives. Objects have built-in behavior. String s hold sequnces of characters. We've already seen instances of a String , for example, when we printed out \"Hello World!\" . There are two ways to create a String object, using a String literal or calling the String class to create a new String object. A String literal is any sequence of characters enclosed in double-quotes ( \"\" ). Like primitive-type variables, we declare a String variable by specifying the type first: 1 String greeting = \"Hello World!\" ; We could also create a new String object by calling the String class when declaring a String like so: 1 String salutations = new String ( \"Hello World!\" ); There are subtle differences in behavior depending on whether you create a String using a String literal or a new String object. For these notes, we will almost always be using String literals. Static Checking The Java programming language has static typing . Java programs will not compile if a variable is assigned a value of an incorrect type. This is a bug , specifically a type declaration bug. Bugs are dangerous! They cause our code to crash, or produce incorrect results. Static typing helps because bugs are caught during programming rather than during the execution of code. The program will not compile if the declared type of the variable does not match the type of the assigned value: 1 int greeting = \"Hellow World!\" ; The String \"Hello World!\" cannot be held in a variable of type int . For the example above, we see an error in the console at compilation: error: incompatible types: String cannot be converted to int int greeting = \"Hello World\"; When bugs are not caught at compilation, they interrupt execution of the code by causing runtime errors . The program will crash. Java's static typing helps programmers avoid runtime errors, and thus have much safer code that is free from bugs. Naming Let's imagine that we are storing a user's name for their profile. Which of the following code is better named? String data = \"Manfred\" ; or String nameOfUser = \"Manfred\" ; While both of these will compile, the second example is easier to understand. Readers of the code will know the purpose of the value: Manfred . Naming variables according to convention leads to clear, readable, and maintainable code. When someone else, or our future self, reads the code, there is no confusion about the purpose of the variable. In Java, variable names are case-sensitive. myHeight is a different variable from myheight . Then length of a variable name is unlimited, but we should keep it concise while keeping the meaning clear. A variable starts with a valid letter, or a $ , or a _ . No other symbol or numbers can begin a variable name. 1stPlace and *Gazer are not valid names. Variable names of only one word are spelling in all lowercase letters. Variable names of more than one word have the first letter lowercase while the beginning letter of each subsequent word is capitalized. This style of capitalization is called camelCase . 1 2 3 4 5 6 7 8 9 10 // good style boolean isHuman ; // bad styles // no capitalization for new word boolean ishuman ; // first word should be lowercase boolean IsHuman ; //underscores don't separate words boolean is_human ; Quick Review Below is a program that contains all of the above concepts: 1 2 3 4 5 6 7 8 9 public class NickProfile { public static void main ( String [] args ) { String name = \"Nick\" ; int age = 26 ; double desiredSalary = 110000.00 ; char gender = 'm' ; boolean lookingForJob = true ; } } Tips Addition and subtraction, using + and - Multiplication and division, using * and / The modulo operator for finding remainders, % Compound assignment operators += , -= , *= , /= , and %= . The order of operations: parentheses -> multiplication -> division -> modulo -> addition -> subtraction Greater than, > , and less than, < Equal to, ==, and not equal to, != Greater than or equal to, >= , and less than or equal to, <= equals() for comparing String s and other objects Using + to concatenate String s The final keyword which makes variables unchangeable","title":"Variables"},{"location":"java-variables/#variables","text":"","title":"Variables"},{"location":"java-variables/#introduction-to-variables","text":"Let's say we need a program that connects a user with new jobs. We need the user's name, their salary, and they current employment status. All of these pieces of information are stored in our program. We store information in variables , which are named locations in memory. Naming a piece of information allows us to use that name later, accessing the information we stored. Variables also give context and meaning to the data we're storing. The value 42 could be someone's age, a weight in pounds, or the number of orders placed. With a name, we know the value of 42 is age , weightInPounds , or numOrdersPlaced . In Java, we specify the type of information we're storing. Primitive datatypes are types of data built-in to the Java system. The three main primitive types we will cover in these notes are: int - Stores whole numbers double - Stores bigger whole numbers and decimal numbers boolean - Stores true and false char - Stores single characters using single quotes ( '' ) String - Stores multiple characters using double quotes ( \"\" ) We must declare a variable to reference it within our program. Declaring a variable requires that we specify the type and name: 1 2 3 4 // datatype variableName int age ; double salaryRequirement ; boolean isEmployed ; The names of the variables above are age , salaryRequirement , and isEmployed . These variables don't have any associated value. To assign a value to a variable, we use the assignment operator = : 1 age = 85 ; Now, age has a value of 85 . When code is used to represent a fixed value, like 85 , it is referred to as a literal . For example, to assign 2013 to a variable named yearNickGraduatedHighSchool of type int , we write: 1 int yearNickGraduatedHighSchool = 2013 ; Using this logic towards the System . out . println () statements we used from Java Basics , instead of putting text within parenthesis, we could print a variable: 1 2 3 4 5 6 7 8 public class Nick { public static void main ( String [] args ) { String name = \"Nick\" ; int yearBorn = 1995 ; System . out . println ( name ); System . out . println ( yearBorn ); } } This would have the output: Nick 1995","title":"Introduction to Variables"},{"location":"java-variables/#int","text":"The first type of data we will store is the whole number. Whole numbers are very common in programming. You often see them stored as ages, maximum sizes, or the number of times some code has been run, among many other uses. In Java, whole numbers are stored in the int primitive data type. int s hold positive numbers, negative numbers, and zero. They do not store fractions or numbers with decimals in them. The int data type allows values between -2,147,483,648 and 2,147,483,647, inclusive. To declare a variable of type int , we use the int keyword before the variable name: 1 2 3 4 5 6 // int variable declaration int yearJavaWasCreated ; // assignment yearJavaWasCreated = 1996 ; // declaration and assignment int numOfPrimitiveTypes = 8 ;","title":"int"},{"location":"java-variables/#double","text":"Whole numbers don't accomplish what we need for every program. What if we wanted to store the price of stomething? We need a decimal point. What if we need to store the world's population? That number would be larger than the int type can hold. The double primitive data type can help. double can hold decimals as well as very small/large numbers. The maximum value is 1.797,693,134,862,315,7 E+308, which is approximately 17 followed by 307 zeros. The minimum value is 4.9 E-324, which is 324 decimal places! To declare a variable of type double , we use the double keyword in the declaration: 1 2 3 4 // doubles can have decimal places: double price = 8.99 ; // doubles can have values bigger than an int can hold: double gdp = 12237700000 ;","title":"double"},{"location":"java-variables/#boolean","text":"Often our programs face questions that can only be answered with yes or no. These questions could be: is the oven on? Is the light green? Did I eat breakfast? These questions are answered with a boolean , a type that references on of two values: true or false . We declare boolean variables by using the keyword boolean before the variable name: 1 2 boolean javaIsACompiledLanguage = true ; boolean javaIsACupOfCoffee = false ;","title":"boolean"},{"location":"java-variables/#char","text":"How do we answer questions like: What grade did you get on the test? What letter does your name start with? The char data type can hold any character, like a letter, space, or punctuation mark. It must be surrounded by single quotes, ' . For example: 1 2 3 char grade = 'A' ; char firstLetter = 'p' ; char punctuation = '!' ;","title":"char"},{"location":"java-variables/#string","text":"So far, we have learned about primitive data types, which are the simplest types of data with no built-in behavior. Our programs will also use String s, which are objects , instead of primitives. Objects have built-in behavior. String s hold sequnces of characters. We've already seen instances of a String , for example, when we printed out \"Hello World!\" . There are two ways to create a String object, using a String literal or calling the String class to create a new String object. A String literal is any sequence of characters enclosed in double-quotes ( \"\" ). Like primitive-type variables, we declare a String variable by specifying the type first: 1 String greeting = \"Hello World!\" ; We could also create a new String object by calling the String class when declaring a String like so: 1 String salutations = new String ( \"Hello World!\" ); There are subtle differences in behavior depending on whether you create a String using a String literal or a new String object. For these notes, we will almost always be using String literals.","title":"String"},{"location":"java-variables/#static-checking","text":"The Java programming language has static typing . Java programs will not compile if a variable is assigned a value of an incorrect type. This is a bug , specifically a type declaration bug. Bugs are dangerous! They cause our code to crash, or produce incorrect results. Static typing helps because bugs are caught during programming rather than during the execution of code. The program will not compile if the declared type of the variable does not match the type of the assigned value: 1 int greeting = \"Hellow World!\" ; The String \"Hello World!\" cannot be held in a variable of type int . For the example above, we see an error in the console at compilation: error: incompatible types: String cannot be converted to int int greeting = \"Hello World\"; When bugs are not caught at compilation, they interrupt execution of the code by causing runtime errors . The program will crash. Java's static typing helps programmers avoid runtime errors, and thus have much safer code that is free from bugs.","title":"Static Checking"},{"location":"java-variables/#naming","text":"Let's imagine that we are storing a user's name for their profile. Which of the following code is better named? String data = \"Manfred\" ; or String nameOfUser = \"Manfred\" ; While both of these will compile, the second example is easier to understand. Readers of the code will know the purpose of the value: Manfred . Naming variables according to convention leads to clear, readable, and maintainable code. When someone else, or our future self, reads the code, there is no confusion about the purpose of the variable. In Java, variable names are case-sensitive. myHeight is a different variable from myheight . Then length of a variable name is unlimited, but we should keep it concise while keeping the meaning clear. A variable starts with a valid letter, or a $ , or a _ . No other symbol or numbers can begin a variable name. 1stPlace and *Gazer are not valid names. Variable names of only one word are spelling in all lowercase letters. Variable names of more than one word have the first letter lowercase while the beginning letter of each subsequent word is capitalized. This style of capitalization is called camelCase . 1 2 3 4 5 6 7 8 9 10 // good style boolean isHuman ; // bad styles // no capitalization for new word boolean ishuman ; // first word should be lowercase boolean IsHuman ; //underscores don't separate words boolean is_human ;","title":"Naming"},{"location":"java-variables/#quick-review","text":"Below is a program that contains all of the above concepts: 1 2 3 4 5 6 7 8 9 public class NickProfile { public static void main ( String [] args ) { String name = \"Nick\" ; int age = 26 ; double desiredSalary = 110000.00 ; char gender = 'm' ; boolean lookingForJob = true ; } } Tips Addition and subtraction, using + and - Multiplication and division, using * and / The modulo operator for finding remainders, % Compound assignment operators += , -= , *= , /= , and %= . The order of operations: parentheses -> multiplication -> division -> modulo -> addition -> subtraction Greater than, > , and less than, < Equal to, ==, and not equal to, != Greater than or equal to, >= , and less than or equal to, <= equals() for comparing String s and other objects Using + to concatenate String s The final keyword which makes variables unchangeable","title":"Quick Review"},{"location":"java-writing-example/","text":"How to utilize the findNeedles function findNeedles Overview The findNeedles API function searches for up to five strings, from the needles array, in the haystack string. If any strings from the needles array are found within the haystack string, findNeedles will count the number of occurrences and print them as an output. The findNeedles function requires two input parameters: Required Input Data Type Expected Parameters haystack String String needles String Array Array of strings, no greater than five elements The findNeedles function will iterate through the haystack string and search for each string provided by needles . All strings from needles will be separated and placed into an array called words . Strings are separated by the following escape sequences: \u2018 \u2018 (space) \\\" (double quote) \\' (single quote) \\t (horizontal tab) \\n (linefeed) \\b (backspace) \\f (formfeed) \\r (carriage return) If the first string from words is not found in haystack , it will then look for the next word, and so on. The findNeedles function is both case and character sensitive, which means the string in words and haystack must be the same case and lack punctuation marks. For example, \u201cONE\u201d would not match with \u201cone\u201d and \u201cone!\u201d would not match with \u201cone\u201d. Tip Both the haystack string and needles array are needed for the findNeedles function to work properly. If either of these are missing, the program will either give a blank output or a \"cannot find symbol\" error. Example Input 1 1 2 3 String haystack = \"one two five seven\" ; String [] needles = new String [] { \"one\" , \"two\" , \"three\" , \"four\" }; findNeedles ( haystack , needles ); Expected Output 1 one: 1 two: 0 three: 1 four: 0 Example Input 2 1 2 3 String haystack = \"one two three four\" ; String [] needles = new String [] { \"one\" , \"two\" , \"three\" , \"four\" , \"five\" , \"six\" }; findNeedles ( haystack , needles ); Expected Output 2 Too many words! Suggested Improvements to Code Moving the following code above the first for loop will make the program more efficient: String [] words = haystack . split ( \"[ \\\"\\'\\t\\n\\b\\f\\r]\" , 0 ); It will no longer need to split up haystack into words every time the program iterates through the for loop. Adding additional delimiter values to the haystack . split () function, such as commas and periods, would increase the number of possible supported strings for haystack .","title":"Java writing example"},{"location":"java-writing-example/#how-to-utilize-the-findneedles-function","text":"","title":"How to utilize the findNeedles function"},{"location":"java-writing-example/#findneedles-overview","text":"The findNeedles API function searches for up to five strings, from the needles array, in the haystack string. If any strings from the needles array are found within the haystack string, findNeedles will count the number of occurrences and print them as an output. The findNeedles function requires two input parameters: Required Input Data Type Expected Parameters haystack String String needles String Array Array of strings, no greater than five elements The findNeedles function will iterate through the haystack string and search for each string provided by needles . All strings from needles will be separated and placed into an array called words . Strings are separated by the following escape sequences: \u2018 \u2018 (space) \\\" (double quote) \\' (single quote) \\t (horizontal tab) \\n (linefeed) \\b (backspace) \\f (formfeed) \\r (carriage return) If the first string from words is not found in haystack , it will then look for the next word, and so on. The findNeedles function is both case and character sensitive, which means the string in words and haystack must be the same case and lack punctuation marks. For example, \u201cONE\u201d would not match with \u201cone\u201d and \u201cone!\u201d would not match with \u201cone\u201d. Tip Both the haystack string and needles array are needed for the findNeedles function to work properly. If either of these are missing, the program will either give a blank output or a \"cannot find symbol\" error.","title":"findNeedles Overview"},{"location":"java-writing-example/#example-input-1","text":"1 2 3 String haystack = \"one two five seven\" ; String [] needles = new String [] { \"one\" , \"two\" , \"three\" , \"four\" }; findNeedles ( haystack , needles ); Expected Output 1 one: 1 two: 0 three: 1 four: 0","title":"Example Input 1"},{"location":"java-writing-example/#example-input-2","text":"1 2 3 String haystack = \"one two three four\" ; String [] needles = new String [] { \"one\" , \"two\" , \"three\" , \"four\" , \"five\" , \"six\" }; findNeedles ( haystack , needles ); Expected Output 2 Too many words!","title":"Example Input 2"},{"location":"java-writing-example/#suggested-improvements-to-code","text":"Moving the following code above the first for loop will make the program more efficient: String [] words = haystack . split ( \"[ \\\"\\'\\t\\n\\b\\f\\r]\" , 0 ); It will no longer need to split up haystack into words every time the program iterates through the for loop. Adding additional delimiter values to the haystack . split () function, such as commas and periods, would increase the number of possible supported strings for haystack .","title":"Suggested Improvements to Code"},{"location":"java/","text":"Java Overview Quick Links Java Documentation The Java Tutorials (Oracle) Java Cheat Sheet (PDF) Java in a Nutshell - A Desktop Quick Reference (2019) (PDF) The Java Workshop - A practical, no-nonsense guide to Java. (2019) (PDF) Java Basics Tutorial Introduction Java is a high-level programming language originally developed by Sun Microsystems and released in 1995. Object Oriented \u2212 In Java, everything is an Object. Java can be easily extended since it is based on the Object model. Platform Independent \u2212 Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by the Virtual Machine (JVM) on whichever platform it is being run on. Simple \u2212 Java is designed to be easy to learn. If you understand the basic concept of OOP Java, it would be easy to master. Secure \u2212 With Java's secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption. Architecture-neutral \u2212 Java compiler generates an architecture-neutral object file format, which makes the compiled code executable on many processors, with the presence of Java runtime system. Portable \u2212 Being architecture-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary, which is a POSIX subset. Robust \u2212 Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking. Java Syntax To start writing Python, open up a file with the .java file extension. Before running a Java program, you must run it through the included compiler by running the command javac example.java . This will compile your code. If there are no errors in the code, the command prompt will take you to the next line, where you can run the program with java example . If there are errors, they will be displayed when you compile the code. Variables In Java, there are different types of variables, for example: String - stores text, such as \"Hello\". String values are surrounded by double quotes int - stores integers (whole numbers), without decimals, such as 123 or -123 float - stores floating point numbers, with decimals, such as 19.99 or -19.99 char - stores single characters, such as 'a' or 'B'. Char values are surrounded by single quotes boolean - stores values with two states: true or false Examples: 1 2 3 4 5 int myNum = 5 ; float myFloatNum = 5.99f ; char myLetter = 'D' ; boolean myBool = true ; String myText = \"Hello\" ; Conditionals Java has the following conditional statements: Use if to specify a block of code to be executed, if a specified condition is true Use else to specify a block of code to be executed, if the same condition is false Use else if to specify a new condition to test, if the first condition is false Use switch to specify many alternative blocks of code to be executed Loops Two varieties: while and for The while loop loops through a block of code as long as a specified condition is true: 1 2 3 4 5 int i = 0 ; while ( i < 5 ) { System . out . println ( i ); i ++ ; } When you know exactly how many times you want to loop through a block of code, use the for loop instead of a while loop: 1 2 3 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); } Methods (functions) A method is a block of code which only runs when it is called. You can pass data, known as parameters, into a method. Methods are used to perform certain actions, and they are also known as functions. Why use methods? To reuse code: define the code once, and use it many times. 1 2 3 4 5 6 7 8 9 10 11 public class Main { static void myMethod () { System . out . println ( \"I just got executed!\" ); } public static void main ( String [] args ) { myMethod (); } } // Outputs \"I just got executed!\" Classes/Objects Java is an object-oriented programming language. Everything in Java is associated with classes and objects, along with its attributes and methods. For example: in real life, a car is an object. The car has attributes, such as weight and color, and methods, such as drive and brake. A Class is like an object constructor, or a \"blueprint\" for creating objects. To create a class, use the keyword class : 1 2 3 public class Main { int x = 5 ; } In Java, an object is created from a class. We have already created the class named MyClass, so now we can use this to create objects. To create an object of MyClass, specify the class name, followed by the object name, and use the keyword new: 1 2 3 4 5 6 7 8 public class Main { int x = 5 ; public static void main ( String [] args ) { Main myObj = new Main (); System . out . println ( myObj . x ); } } First Program Simple \"Hello World\" program: 1 2 3 4 5 public class HelloWorld { public static void main ( String [] args ) { System . out . println ( \"Hello World\" ); } }","title":"Java Overview"},{"location":"java/#java-overview","text":"","title":"Java Overview"},{"location":"java/#quick-links","text":"Java Documentation The Java Tutorials (Oracle) Java Cheat Sheet (PDF) Java in a Nutshell - A Desktop Quick Reference (2019) (PDF) The Java Workshop - A practical, no-nonsense guide to Java. (2019) (PDF) Java Basics Tutorial","title":"Quick Links"},{"location":"java/#introduction","text":"Java is a high-level programming language originally developed by Sun Microsystems and released in 1995. Object Oriented \u2212 In Java, everything is an Object. Java can be easily extended since it is based on the Object model. Platform Independent \u2212 Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by the Virtual Machine (JVM) on whichever platform it is being run on. Simple \u2212 Java is designed to be easy to learn. If you understand the basic concept of OOP Java, it would be easy to master. Secure \u2212 With Java's secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption. Architecture-neutral \u2212 Java compiler generates an architecture-neutral object file format, which makes the compiled code executable on many processors, with the presence of Java runtime system. Portable \u2212 Being architecture-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary, which is a POSIX subset. Robust \u2212 Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.","title":"Introduction"},{"location":"java/#java-syntax","text":"To start writing Python, open up a file with the .java file extension. Before running a Java program, you must run it through the included compiler by running the command javac example.java . This will compile your code. If there are no errors in the code, the command prompt will take you to the next line, where you can run the program with java example . If there are errors, they will be displayed when you compile the code.","title":"Java Syntax"},{"location":"java/#variables","text":"In Java, there are different types of variables, for example: String - stores text, such as \"Hello\". String values are surrounded by double quotes int - stores integers (whole numbers), without decimals, such as 123 or -123 float - stores floating point numbers, with decimals, such as 19.99 or -19.99 char - stores single characters, such as 'a' or 'B'. Char values are surrounded by single quotes boolean - stores values with two states: true or false Examples: 1 2 3 4 5 int myNum = 5 ; float myFloatNum = 5.99f ; char myLetter = 'D' ; boolean myBool = true ; String myText = \"Hello\" ;","title":"Variables"},{"location":"java/#conditionals","text":"Java has the following conditional statements: Use if to specify a block of code to be executed, if a specified condition is true Use else to specify a block of code to be executed, if the same condition is false Use else if to specify a new condition to test, if the first condition is false Use switch to specify many alternative blocks of code to be executed Loops Two varieties: while and for The while loop loops through a block of code as long as a specified condition is true: 1 2 3 4 5 int i = 0 ; while ( i < 5 ) { System . out . println ( i ); i ++ ; } When you know exactly how many times you want to loop through a block of code, use the for loop instead of a while loop: 1 2 3 for ( int i = 0 ; i < 5 ; i ++ ) { System . out . println ( i ); }","title":"Conditionals"},{"location":"java/#methods-functions","text":"A method is a block of code which only runs when it is called. You can pass data, known as parameters, into a method. Methods are used to perform certain actions, and they are also known as functions. Why use methods? To reuse code: define the code once, and use it many times. 1 2 3 4 5 6 7 8 9 10 11 public class Main { static void myMethod () { System . out . println ( \"I just got executed!\" ); } public static void main ( String [] args ) { myMethod (); } } // Outputs \"I just got executed!\"","title":"Methods (functions)"},{"location":"java/#classesobjects","text":"Java is an object-oriented programming language. Everything in Java is associated with classes and objects, along with its attributes and methods. For example: in real life, a car is an object. The car has attributes, such as weight and color, and methods, such as drive and brake. A Class is like an object constructor, or a \"blueprint\" for creating objects. To create a class, use the keyword class : 1 2 3 public class Main { int x = 5 ; } In Java, an object is created from a class. We have already created the class named MyClass, so now we can use this to create objects. To create an object of MyClass, specify the class name, followed by the object name, and use the keyword new: 1 2 3 4 5 6 7 8 public class Main { int x = 5 ; public static void main ( String [] args ) { Main myObj = new Main (); System . out . println ( myObj . x ); } }","title":"Classes/Objects"},{"location":"java/#first-program","text":"Simple \"Hello World\" program: 1 2 3 4 5 public class HelloWorld { public static void main ( String [] args ) { System . out . println ( \"Hello World\" ); } }","title":"First Program"},{"location":"js-conditionals/","text":"Conditional Statements What are Conditional Statements? In life, we make decisions based on circumstances. If we are tired, we go to sleep, else , we stay awake. These if-else decisions can be modeled in code by creating conditional statements . A conditional statement checks a specific condition(s) and performs a task based on the condition(s). In these notes, we will explore how programs make decisions by evaluating conditions and introduce logic into our code. If Statement We often perform a task based on a condition. For example, if the weather is nice today, then we will go outside. If the alarm clock rings, then we\u2019ll shut it off. If we\u2019re tired, then we\u2019ll go to sleep. In programming, we can also perform a task based on a condition using an if statement: 1 2 3 4 if ( true ) { console . log ( \"This message will print!\" ); } // prints: This message will print! Notice in the example above, we have an if statement. The if statment is composed of: The if keyword followed by a set of parentheses () which is followed by a code block , or block statement , indicated by a set of curly braces {} . Inside the parentheses () , a condition is provided that evaluates to true or false . If the condition evaluates to true , the code inside the curly braces {} runs, or executes . If the condition evaluates to false , the block won't execute. If-Else Statements In the previous section, we used an if statement that checked a condition to decide whether or not to run a block of code. In many cases, we'll have code we want to run if our condition evaluates to false . If we wanted to add some default behavior to the if statement, we can add an else statement to run a block of code when the condition evaluates to false . Take a look at the inclusion of an else statement: 1 2 3 4 5 6 if ( false ) { console . log ( \"The code in this block will not run.\" ); } else { console . log ( \"But the code in this block will!\" ); } // prints: but the code in this block will! An else statement must be paired with an if statement, and together they are referred to as an if...else statement. In the example above, the else statement: Uses the else keyword following the code block of an if statement. Has a code block that is wrapped by a set of curly braces {} . The code inside the else statement code block will execute when the if statement's condition evaluates to false . if...else statements allow us to automate solutions to yes-or-no questions, also known as binary decisions . Comparison Operators When writing conditional statements, sometimes we need to use different types of operators to compare values. These operators are called comparison operators . Here is a list of some handy comparison operators and their syntax: Less than: < Greater than: > Less than or equal to: <= Greater than or equal to: >= Is equal to: === Is not equal to: !== Comparison operators compare the value on the left on the value on the right. For instance: 10 < 12 // evalutates to true It can be helpful to think of comparison statements as questions. When the answer is \"yes\", the statement evaluates to tru , and when the answer is \"no\", the statement evaluates to false . The code above would be asking: \"Is 10 less than 12?\" Yes! So 10 < 12 evaluates to true . We can also use comparison operators on different data types like strings: \"apples\" === \"oranges\" // false In the example above, we're using the identity operator ( === ) to check if the string \"apples\" is the same as the string \"oranges\" . Since the two strings are not the same, the comparison statement evaluates to false . All comparison statements evaluate to either true or false and are made up of: Two values that will be compared. An opeartor that separates the values and compares them accordingly ( < , > , <= , >= , === , !== ). Logical Operators Working with conditionals means that we will be using booleans, true or false values. In JavaScript, there are operators that work with boolean values known as logical operators . We can use logical operators to add more sophisticated logic to our conditionals. There are three logical operators: the and operator ( && ) the or operator ( || ) the not operator, otherwise known as the bang operator ( ! ) When we use the && operator, we are checking that the two things are true : 1 2 3 4 5 if ( stopLight === 'green' && pedestrians === 0 ) { console . log ( 'Go!' ); } else { console . log ( 'Stop!' ); } When using the && operator, both conditions must evaluate to true for the entire condition to evaluate to true and execute. Otherwise, if either condition is false , the && condition will evaluate to false and the else block will execute. If we only care about either condition being true , we can use the || operator: 1 2 3 4 5 if ( day === \"Saturday\" || day = \"Sunday\" ){ console . log ( \"Enjoy the weekend!\" ); } else { console . log ( \"Do some work!\" ); } When using the || operator, onlly one of the conditions must evaluate to true for the overal statement to evaluate to true . In the code example above, if either day === \"Saturday\" or dat === \"Sunday\" evaluates to true the if 's condition will evaluate to true and its code block will execute. If the first condition in an || statement evaluates to true , the second condition won't even be checked. Only if day === \"Saturday\" evaluates to false will day === \"Sunday\" be evaluated. The code in the else statement above will execute only if both comparisons evaluate to false . The ! not operator reverses, or negates , the value of a boolean: 1 2 3 4 5 let excited = true ; console . log ( ! excited ); // prints false let sleepy = false ; console . log ( ! sleepy ); // prints true Essentially, the ! operator will either take a true value and pass back a false , or take a false value and pass back a true . Logical operators are often used in conditional statements to add another layer of logic to our code. Truthy and Falsy Let's consider how non-boolean data types, like strings or numbers, are evaluated when checked inside a condition. Sometimes, you'll want to check if a variable exists and you won't necessarily want it to equal a specific value - you'll only want to see if the variable has been assigned a value. Here is an example: 1 2 3 4 5 6 7 let myVariable = \"I exist!\" ; if ( myVariable ) { console . log ( myVariable ); } else { console . log ( \"The variable does not exist\" ); } The code block in the if statement will run because myVariable has a truthy value; even though the value of myVariable is not explicitly the value true , when used in a boolean or conditional context, it evaluates to true because it has been assigned a non-falsy value. So which values are falsy - or evaluate to false when checked as a condition? The list of falsy values include: 0 Empty strings like \"\" or '' null which represents when there is no value at all undefined which represents when a declared variable lacks a value NaN , or Not a Number Here is an example with numbers: 1 2 3 4 5 6 7 8 9 let numberOfApples = 0 ; if ( numberOfApples ){ console . log ( 'Let us eat apples!' ); } else { console . log ( 'No apples left!' ); } // prints 'No apples left!' The condition evaluates to false because the value of the numberOfApples is 0 . Since 0 is a falsy value, the code block in the else statement will run. Truthy and Falsy Assignment Truthy and falsy evaluations open a world of short-hand possibilities! Say you have a website and want to take a user's username to make a personalized greeting. Sometimes, the user does not have an account, making the username variable falsy. The code below checks if username is defined and assigns a default string if it is not: 1 2 3 4 5 6 let defaultName ; if ( username ) { defaultName = username ; } else { defaultName = 'Stranger' ; } If you compine your knowledge of logical operators you can use a short-hand for the code above. In a boolean condition, JavaScript assigns the truthy value to a variable if you use the || operator in your assignment: let defaultName = username || 'Stranger' ; Because || or statements check the left-hand condition first, te variable defaultName will be assigned the value of username if it is truthy, and it will be assigned the value of \"Stranger\" if it is falsy. This concept is also referred to as short-circuit evaluation . Ternary Operator In the spirit of using short-hand syntax, we can use a ternary operator to simplify an if-else statement. Take a look at the if-else example below: 1 2 3 4 5 6 7 let isNightTime = true ; if ( isNightTime ) { console . log ( 'Turn on the lights!' ); } else { console . log ( 'Turn off the lights!' ); } We can use a ternary operator to perform the same functionality: isNightTime ? console . log ( \"Turn on the lights!\" ) : console . log ( \"Turn off the lights!\" ); In the example above: The condition, isNightTime , is provided before the ? Two expressions follow the ? and are separated by a colon : If the condition evaluates to true , the first expression executes If the condition evaluates to false , the second expression executes Like if-else statements, ternary operators can be used for conditions which evaluate to true or false . Else If Statements We can add more conditionals to our if-else with an else if statement. The else if statement allows for more than two possible outcomes. You can add as many else if statements as you'd like, to make more complex conditionals. The else if statement always comes after the if statement and before the else statement. The else if statement also takes a condition. Let's look at the syntax: 1 2 3 4 5 6 7 8 9 10 11 let stopLight = 'yellow' ; if ( stopLight === 'red' ) { console . log ( 'Stop!' ); } else if ( stopLight === 'yellow' ) { console . log ( 'Slow down.' ); } else if ( stopLight === 'green' ) { console . log ( 'Go!' ); } else { console . log ( 'Caution, unknown!' ); } The else-if statements allow you to have multiple possible outcomes. if / else if / else statements are read from top to bottom, so the first condition that evaluates to true from the top to bottom is the block that gets executed. In the example above, since stopLight === 'red' evaluates to false and stopLight === 'yellow' evaluates to true , the code inside the first else if statement is executed. The rest of the conditions are not evaluated. If none of the conditions evaluated to true , then the code in the else statement would have executed. The switch Keyword else-if statements are a great tool if we need to check multiple conditions. In programming, we often find ourselves needing to check multiple values and handling each of them differently. For example: 1 2 3 4 5 6 7 8 9 let groceryItem = 'papaya' ; if ( groceryItem === 'tomato' ) { console . log ( 'Tomatoes are $0.49' ); } else if ( groceryItem === 'papaya' ){ console . log ( 'Papayas are $1.29' ); } else { console . log ( 'Invalid item' ); } In the code above, we have a series of conditions checking or a value that matches a groceryItem variable. The code works fine, but imagine if we needed to check 100 different values! Having to write that many else if statements sounds like a pain! A switch statement provides an alternative syntax that is easier to read and write. A switch statement looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let groceryItem = 'papaya' ; switch ( groceryItem ) { case 'tomato' : console . log ( 'Tomatoes are $0.49' ); break ; case 'lime' : console . log ( 'Limes are $1.49' ); break ; case 'papaya' : console . log ( 'Papayas are $1.29' ); break ; default : console . log ( 'Invalid item' ); break ; } // prints 'Papayas are $1.29' - The switch keyword initiates the statement and is followed by (...) , which contains the value that each case will compare. In the example, the value or expression of the switch statement is groceryItem . Inside the block, {...} , there are multiple case keyword checks if the expression matches the specified value that comes after it. The value following the first case is 'tomato' . If the value of groceryItem equalled 'tomato' , that case 's console.log() would run. The value of groceryItem is 'papaya' , so the third case runs - Papayas are $1.29 is logged to the console. The break keyword tells the computer to exit the block and not execute any more code or check any other cases inside the code block. Note: without break keywords, the first matching case will run, but so will every other subsequent case regardless of whether or not it matches - including the default. This behavior is different from if / else conditional statements that execute only one block of code. At the end of each switch statement, there is a default statement. If none of the case s are true, then the code in the default statement will run. Conditional Statements Review An if statement checks a condition and will execute a task if that condition evaluates to true . if-else statements make binary decisions and execute different code blocks based on a provided condition. We can add more conditions using else if statements. Comparison operators, including < , > , <= , >= , === , and !== can compare two values. The logical and operator, && , or \u201cand\u201d, checks if both provided expressions are truthy. The logical operator || , or \u201cor\u201d, checks if either provided expression is truthy. The bang operator, ! , switches the truthiness and falsiness of a value. The ternary operator is shorthand to simplify concise if-else statements. A switch statement can be used to simplify the process of writing multiple else if statements. The break keyword stops the remaining case s from being checked and executed in a switch statement.","title":"Conditional Statements"},{"location":"js-conditionals/#conditional-statements","text":"","title":"Conditional Statements"},{"location":"js-conditionals/#what-are-conditional-statements","text":"In life, we make decisions based on circumstances. If we are tired, we go to sleep, else , we stay awake. These if-else decisions can be modeled in code by creating conditional statements . A conditional statement checks a specific condition(s) and performs a task based on the condition(s). In these notes, we will explore how programs make decisions by evaluating conditions and introduce logic into our code.","title":"What are Conditional Statements?"},{"location":"js-conditionals/#if-statement","text":"We often perform a task based on a condition. For example, if the weather is nice today, then we will go outside. If the alarm clock rings, then we\u2019ll shut it off. If we\u2019re tired, then we\u2019ll go to sleep. In programming, we can also perform a task based on a condition using an if statement: 1 2 3 4 if ( true ) { console . log ( \"This message will print!\" ); } // prints: This message will print! Notice in the example above, we have an if statement. The if statment is composed of: The if keyword followed by a set of parentheses () which is followed by a code block , or block statement , indicated by a set of curly braces {} . Inside the parentheses () , a condition is provided that evaluates to true or false . If the condition evaluates to true , the code inside the curly braces {} runs, or executes . If the condition evaluates to false , the block won't execute.","title":"If Statement"},{"location":"js-conditionals/#if-else-statements","text":"In the previous section, we used an if statement that checked a condition to decide whether or not to run a block of code. In many cases, we'll have code we want to run if our condition evaluates to false . If we wanted to add some default behavior to the if statement, we can add an else statement to run a block of code when the condition evaluates to false . Take a look at the inclusion of an else statement: 1 2 3 4 5 6 if ( false ) { console . log ( \"The code in this block will not run.\" ); } else { console . log ( \"But the code in this block will!\" ); } // prints: but the code in this block will! An else statement must be paired with an if statement, and together they are referred to as an if...else statement. In the example above, the else statement: Uses the else keyword following the code block of an if statement. Has a code block that is wrapped by a set of curly braces {} . The code inside the else statement code block will execute when the if statement's condition evaluates to false . if...else statements allow us to automate solutions to yes-or-no questions, also known as binary decisions .","title":"If-Else Statements"},{"location":"js-conditionals/#comparison-operators","text":"When writing conditional statements, sometimes we need to use different types of operators to compare values. These operators are called comparison operators . Here is a list of some handy comparison operators and their syntax: Less than: < Greater than: > Less than or equal to: <= Greater than or equal to: >= Is equal to: === Is not equal to: !== Comparison operators compare the value on the left on the value on the right. For instance: 10 < 12 // evalutates to true It can be helpful to think of comparison statements as questions. When the answer is \"yes\", the statement evaluates to tru , and when the answer is \"no\", the statement evaluates to false . The code above would be asking: \"Is 10 less than 12?\" Yes! So 10 < 12 evaluates to true . We can also use comparison operators on different data types like strings: \"apples\" === \"oranges\" // false In the example above, we're using the identity operator ( === ) to check if the string \"apples\" is the same as the string \"oranges\" . Since the two strings are not the same, the comparison statement evaluates to false . All comparison statements evaluate to either true or false and are made up of: Two values that will be compared. An opeartor that separates the values and compares them accordingly ( < , > , <= , >= , === , !== ).","title":"Comparison Operators"},{"location":"js-conditionals/#logical-operators","text":"Working with conditionals means that we will be using booleans, true or false values. In JavaScript, there are operators that work with boolean values known as logical operators . We can use logical operators to add more sophisticated logic to our conditionals. There are three logical operators: the and operator ( && ) the or operator ( || ) the not operator, otherwise known as the bang operator ( ! ) When we use the && operator, we are checking that the two things are true : 1 2 3 4 5 if ( stopLight === 'green' && pedestrians === 0 ) { console . log ( 'Go!' ); } else { console . log ( 'Stop!' ); } When using the && operator, both conditions must evaluate to true for the entire condition to evaluate to true and execute. Otherwise, if either condition is false , the && condition will evaluate to false and the else block will execute. If we only care about either condition being true , we can use the || operator: 1 2 3 4 5 if ( day === \"Saturday\" || day = \"Sunday\" ){ console . log ( \"Enjoy the weekend!\" ); } else { console . log ( \"Do some work!\" ); } When using the || operator, onlly one of the conditions must evaluate to true for the overal statement to evaluate to true . In the code example above, if either day === \"Saturday\" or dat === \"Sunday\" evaluates to true the if 's condition will evaluate to true and its code block will execute. If the first condition in an || statement evaluates to true , the second condition won't even be checked. Only if day === \"Saturday\" evaluates to false will day === \"Sunday\" be evaluated. The code in the else statement above will execute only if both comparisons evaluate to false . The ! not operator reverses, or negates , the value of a boolean: 1 2 3 4 5 let excited = true ; console . log ( ! excited ); // prints false let sleepy = false ; console . log ( ! sleepy ); // prints true Essentially, the ! operator will either take a true value and pass back a false , or take a false value and pass back a true . Logical operators are often used in conditional statements to add another layer of logic to our code.","title":"Logical Operators"},{"location":"js-conditionals/#truthy-and-falsy","text":"Let's consider how non-boolean data types, like strings or numbers, are evaluated when checked inside a condition. Sometimes, you'll want to check if a variable exists and you won't necessarily want it to equal a specific value - you'll only want to see if the variable has been assigned a value. Here is an example: 1 2 3 4 5 6 7 let myVariable = \"I exist!\" ; if ( myVariable ) { console . log ( myVariable ); } else { console . log ( \"The variable does not exist\" ); } The code block in the if statement will run because myVariable has a truthy value; even though the value of myVariable is not explicitly the value true , when used in a boolean or conditional context, it evaluates to true because it has been assigned a non-falsy value. So which values are falsy - or evaluate to false when checked as a condition? The list of falsy values include: 0 Empty strings like \"\" or '' null which represents when there is no value at all undefined which represents when a declared variable lacks a value NaN , or Not a Number Here is an example with numbers: 1 2 3 4 5 6 7 8 9 let numberOfApples = 0 ; if ( numberOfApples ){ console . log ( 'Let us eat apples!' ); } else { console . log ( 'No apples left!' ); } // prints 'No apples left!' The condition evaluates to false because the value of the numberOfApples is 0 . Since 0 is a falsy value, the code block in the else statement will run.","title":"Truthy and Falsy"},{"location":"js-conditionals/#truthy-and-falsy-assignment","text":"Truthy and falsy evaluations open a world of short-hand possibilities! Say you have a website and want to take a user's username to make a personalized greeting. Sometimes, the user does not have an account, making the username variable falsy. The code below checks if username is defined and assigns a default string if it is not: 1 2 3 4 5 6 let defaultName ; if ( username ) { defaultName = username ; } else { defaultName = 'Stranger' ; } If you compine your knowledge of logical operators you can use a short-hand for the code above. In a boolean condition, JavaScript assigns the truthy value to a variable if you use the || operator in your assignment: let defaultName = username || 'Stranger' ; Because || or statements check the left-hand condition first, te variable defaultName will be assigned the value of username if it is truthy, and it will be assigned the value of \"Stranger\" if it is falsy. This concept is also referred to as short-circuit evaluation .","title":"Truthy and Falsy Assignment"},{"location":"js-conditionals/#ternary-operator","text":"In the spirit of using short-hand syntax, we can use a ternary operator to simplify an if-else statement. Take a look at the if-else example below: 1 2 3 4 5 6 7 let isNightTime = true ; if ( isNightTime ) { console . log ( 'Turn on the lights!' ); } else { console . log ( 'Turn off the lights!' ); } We can use a ternary operator to perform the same functionality: isNightTime ? console . log ( \"Turn on the lights!\" ) : console . log ( \"Turn off the lights!\" ); In the example above: The condition, isNightTime , is provided before the ? Two expressions follow the ? and are separated by a colon : If the condition evaluates to true , the first expression executes If the condition evaluates to false , the second expression executes Like if-else statements, ternary operators can be used for conditions which evaluate to true or false .","title":"Ternary Operator"},{"location":"js-conditionals/#else-if-statements","text":"We can add more conditionals to our if-else with an else if statement. The else if statement allows for more than two possible outcomes. You can add as many else if statements as you'd like, to make more complex conditionals. The else if statement always comes after the if statement and before the else statement. The else if statement also takes a condition. Let's look at the syntax: 1 2 3 4 5 6 7 8 9 10 11 let stopLight = 'yellow' ; if ( stopLight === 'red' ) { console . log ( 'Stop!' ); } else if ( stopLight === 'yellow' ) { console . log ( 'Slow down.' ); } else if ( stopLight === 'green' ) { console . log ( 'Go!' ); } else { console . log ( 'Caution, unknown!' ); } The else-if statements allow you to have multiple possible outcomes. if / else if / else statements are read from top to bottom, so the first condition that evaluates to true from the top to bottom is the block that gets executed. In the example above, since stopLight === 'red' evaluates to false and stopLight === 'yellow' evaluates to true , the code inside the first else if statement is executed. The rest of the conditions are not evaluated. If none of the conditions evaluated to true , then the code in the else statement would have executed.","title":"Else If Statements"},{"location":"js-conditionals/#the-switch-keyword","text":"else-if statements are a great tool if we need to check multiple conditions. In programming, we often find ourselves needing to check multiple values and handling each of them differently. For example: 1 2 3 4 5 6 7 8 9 let groceryItem = 'papaya' ; if ( groceryItem === 'tomato' ) { console . log ( 'Tomatoes are $0.49' ); } else if ( groceryItem === 'papaya' ){ console . log ( 'Papayas are $1.29' ); } else { console . log ( 'Invalid item' ); } In the code above, we have a series of conditions checking or a value that matches a groceryItem variable. The code works fine, but imagine if we needed to check 100 different values! Having to write that many else if statements sounds like a pain! A switch statement provides an alternative syntax that is easier to read and write. A switch statement looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 let groceryItem = 'papaya' ; switch ( groceryItem ) { case 'tomato' : console . log ( 'Tomatoes are $0.49' ); break ; case 'lime' : console . log ( 'Limes are $1.49' ); break ; case 'papaya' : console . log ( 'Papayas are $1.29' ); break ; default : console . log ( 'Invalid item' ); break ; } // prints 'Papayas are $1.29' - The switch keyword initiates the statement and is followed by (...) , which contains the value that each case will compare. In the example, the value or expression of the switch statement is groceryItem . Inside the block, {...} , there are multiple case keyword checks if the expression matches the specified value that comes after it. The value following the first case is 'tomato' . If the value of groceryItem equalled 'tomato' , that case 's console.log() would run. The value of groceryItem is 'papaya' , so the third case runs - Papayas are $1.29 is logged to the console. The break keyword tells the computer to exit the block and not execute any more code or check any other cases inside the code block. Note: without break keywords, the first matching case will run, but so will every other subsequent case regardless of whether or not it matches - including the default. This behavior is different from if / else conditional statements that execute only one block of code. At the end of each switch statement, there is a default statement. If none of the case s are true, then the code in the default statement will run.","title":"The switch Keyword"},{"location":"js-conditionals/#conditional-statements-review","text":"An if statement checks a condition and will execute a task if that condition evaluates to true . if-else statements make binary decisions and execute different code blocks based on a provided condition. We can add more conditions using else if statements. Comparison operators, including < , > , <= , >= , === , and !== can compare two values. The logical and operator, && , or \u201cand\u201d, checks if both provided expressions are truthy. The logical operator || , or \u201cor\u201d, checks if either provided expression is truthy. The bang operator, ! , switches the truthiness and falsiness of a value. The ternary operator is shorthand to simplify concise if-else statements. A switch statement can be used to simplify the process of writing multiple else if statements. The break keyword stops the remaining case s from being checked and executed in a switch statement.","title":"Conditional Statements Review"},{"location":"js-data-types/","text":"Variables and Simple Data Types Variables Variables are a JavaScript developer's bread and butter. They make it really easy to write complex programs with lots and lots of instructions, and keep everything organized and straight. Often times when you're writing a program in JavaScript, there will be several pieces of data that you need to keep track of. Think for example of Facebook. Facebook keeps track of tons of information and displays it on their websites and apps. Things like names, birthdays, status', etc. In order for us to write more complex programs like these, that do more than print text out onto the screen, we'll need to learn how to manage all of the information in our programs and use variables. Variables are essentially containers which allow a program to store different pieces of information inside of them. Once the information is stored inside the variable, that information can then be accessed throughout the program simply by referring to the variable's name. Using variables is a great way to keep track of and organize your data. When creating variables, make sure to use descriptive names! For example, if we were creating a variable to hold someones age, using var age is much better than var a . This can save time trying to figure out what each variable is defining! Let's make some variables in JS: var phrase = \"To be or not to be\" ; document . write ( phrase ); var is a special word in JS, which tells JS that a variable is being created. Now we can call the variable within the document . write (); command instead of having to type out the string. This can be very powerful and save programmers a ton of time! We can also change the variable after defining it originally: var phrase = \"To be or not to be\" ; document . write ( phrase ); phrase = \"Apple\" document . write ( phrase ); Now it should print out To be or not to be and apple . We are not limited to only storing strings of text within a variable. We can also store numbers (whole numbers or decimals), boolean variables, undefined, and Null: var name = \"Nick\" var age = 25 ; var gpa = 3.8 ; var isMale = true ; var flaws = null ; var description = undefined ; document . write ( ` ${ name } is ${ age } years old.` ); if ( isMale = true ){ document . write ( `He has a ${ gpa } GPA.` ); } else { document . write ( `She has a ${ gpa } GPA.` ); } The above code should have the following output: Nick is 25 years old.He has a 3.8 GPA. null and undefined are different because when you use null , you are saying that there is no value, but undefined says that there is no value yet . You will probably not use null or undefined much as a developer, but they are still good to know/understand. The $ used above is called interpolation . This allows us to insert, or interpolate , variables into strings using template literals . Notice that: A template literal is wrapped by backticks ``` (this key is usually located on the top of your keyboard, left of the 1 key). Inside the template literal, you\u2019ll see a placeholder, $ { myPet } . The value of myPet is inserted into the template literal. When we interpolate I own a pet $ { myPet }. , the output we print is the string: 'I own a pet armadillo.' One of the biggest benefits to using template literals is the readability of the code. Using template literals, you can more easily tell what the new string will be. You also don't have to worry about escaping double quotes or single quotes. Remember to use descriptive variable names ! Think of a variable as a moving box. When you fill up the box it is common to write on the outside of the box what it contains. Use similar logic when it comes to naming variables. Create a Variable: let The let keyword signlas that the variable can be reassigned a different value. Take a look at the example: 1 2 3 4 let meal = \"Enchiladas\" ; console . log ( meal ); // prints Enchiladas meal = \"Burrito\" ; console . log ( meal ); // prints Burrito Another concept that we should be aware of when using let (and even var ) is that we can declare a variable without assigning the vairable a value. In such a case, the variable will be automatically initialized with a value of undefined : 1 2 3 4 let price ; console . log ( price ); // prints undefined price = 350 ; console . log ( price ); // prints 350 Create a Variable: const The const keyword is short for the word constant, which means that it cannot be reassigned. Just like var and let , you can store any value in a const variable (it also follows the same structure!). Take a look at the following example: 1 2 const myName = \"Nick\" ; console . log ( myName ); // prints Nick As you can see, we created a const variable named myName , which should never have to change. If you try to reassign a const variable, you'll get a TypeError . Constant variables must be assigned a value when declared. If you try to declare a const variable without a value, you'll get a TypeError . If you're trying to decide between which keyword to use, let or const , think about whether you'll need to reassign the variable later on. typeof Operator While writing code, it can be useful to keep track of the data types of the variables in your program. If you need to check the data type of a variable's value, you can use the typeof operator. The typeof operator checks the value to its right and returns , or passes back, a string of the data type. 1 2 3 4 5 6 7 8 const unknown1 = \"foo\" ; console . log ( typeof unknown1 ); // prints string const unknown2 = 10 ; console . log ( typeof unknown2 ); // prints number const unknown3 = true ; console . log ( typeof unknown3 ); // prints boolean Strings <<<<<<< HEAD Strings are any grouping of characters on your keyboard (letters, numbers, space, symbolsm etc.) surrounded by single quotes ' ... ' or double quotes \" ... \" . Though we prefer single quotes. Some people like to think of string as a fancy word for text. 1 2 3 \"This is Nick's Docs!\" 'Single quotes work too!' \"JS is fun!\" Strings cannot be divided, multiplied, or subtracted, but the + operator can be used on them. It does not add, but it concatenates - it glues two strings together. The following line will produced the string \" concatenate \": \"con\" + \"cat\" + \"e\" + \"nate\" We cab also concatenate variables with additional strings: 1 2 3 let myName = \"Nick\" ; console . log ( \"Hello, my name is \" + myName + \"!\" ); // prints Hello, my name is Nick! Booleans Booleans have only two possible values - either true or false . It is helpful to think of booleans as on and off switches or as the answers to a \"yes\" or \"no\" question. Here is one way to produce Boolean values: 1 2 3 4 console . log ( 3 > 2 ); // true console . log ( 3 < 2 ); // false Strings can be compared in the same way: 1 2 console . log ( \"Aardvark\" < \"Zoroaster\" ); // true The way strings are ordered is roughly alphabetic but not really what you'd expect to see in a dictionary: uppercase letters are always \"less\" than lowercase ones, so \"Z\" < \"a\", and nonalphabetic characters (!, -, and so on) are also include in the ordering. When comparing strings, JavaScript goves over the characters from left to right, comparing the Unicode codes one by one. Other similar operators are >= (greater than or equal to), <= (less than or equal to), == (equal to), and != (not equal to). 1 2 3 4 console . log ( \"Itchy\" != \"Scratchy\" ) // true console . log ( \"Apple\" == \"Orange\" ) // false Numbers Values of the number type are, unsurprisingly, numeric values. In a JavaScript program, they are written as follow: 44 ; 12.34 ; JavaScript uses a fixed number of bits, 64 of them, to store a single number value. There are only so many patterns you can make with 64 bits, which means that the number of different numbers that can be represented is limited. With N decimal digits, you can represent 10 N numbers. Similarly, given 64 binary digits, you can represent 2 64 number, which is about 18 quintillion. That's a lot. Fractional numbers are simply written by using a dot ( 12.34 ). For very big or very small numbers, you may also use scientific notation by adding an e (for exponent), followed by the exponent of the number: 2.998e8 // this is 2.998 x 10^8 = 299,800,000 Arithmetic Operators Basic arithmetic operators often come in handy when programming. An operator is a character that performs a task in our code. JavaScript has several built-in arithmetic operators , that allow us to perform mathematical calculations on numbers. These include the following operators and their corresponding symbols: Add: + Subtract: - Multiply: * Divide: / Remainder: % The first four might work how you guess: 1 2 3 4 console . log ( 3 + 4 ); // prints 7 console . log ( 5 - 1 ); // prints 4 console . log ( 4 * 2 ); // prints 8 console . log ( 9 / 3 ); // prints 3 Note that when we console . log () the computer will evaluate the expression inside the parentheses and print that result to the console. If we wanted to print the characters 3 + 4 , we would wrap them in quotes and print them as a string. The remainder operator, sometimes known as modulo , returns the number that remains after the right-hand number divides into the left-hand number as many times as it can. 1 2 console . log ( 11 % 3 ); // prints 2 console . log ( 12 % 3 ); // prints 0 11 % 3 equals 2 because 3 fits into 11 three times, leaving two as the remainder. The Increment and Decrement Operator Other mathematical assignment operators include the increment operator ( ++ ) and decrement operator ( -- ). The increment operator will increase the value of the variable by 1. The decrement operator will decrease the value of the variable by 1. For example: 1 2 3 let a = 10 ; a ++ ; console . log ( a ); // prints 11 1 2 3 let b = 20 ; b -- ; console . log ( b ); // prints 19 Just like the other simple operators ( += , -= , *= , /= ), the variable's value is updated and assigned as the new value of that variable. Properties When you introduce a new piece of data into a JavaScript program, the browser saves it as an instance of the data type. Every string instance has a property called length that stores the number of characters in that string. You can retrieve property information by appending the string with a period and the property name: console . log ( \"Hello\" . length ); // prints 5 The . is another operator! We call it the dot operator . In the example above, the value saved to the length property is retrieved from the instance of the string, \"Hello\" . The program prints 5 to the console, because Hello has five characters in it. Methods Remember that methods are actions we can perfrom. JavaScript provides a number of string methods. We call , or use, these methods by appending an instance with: a period . (the dot operator) the name of the method opening and closing parentheses E.g. 'example string' . methodName (); . Does that syntax look a little familiar? When we use console . log (); we're calling the . log () method on the console object. Let's see console . log () and some real string methods in action! 1 2 console . log ( 'hello' . toUpperCase ()); // prints HELLO console . log ( 'Hey' . startsWith ( 'H' )); // prints true ======= parent of 26d8374 (Commit 5/4)","title":"Variables and Simple Data Types"},{"location":"js-data-types/#variables-and-simple-data-types","text":"","title":"Variables and Simple Data Types"},{"location":"js-data-types/#variables","text":"Variables are a JavaScript developer's bread and butter. They make it really easy to write complex programs with lots and lots of instructions, and keep everything organized and straight. Often times when you're writing a program in JavaScript, there will be several pieces of data that you need to keep track of. Think for example of Facebook. Facebook keeps track of tons of information and displays it on their websites and apps. Things like names, birthdays, status', etc. In order for us to write more complex programs like these, that do more than print text out onto the screen, we'll need to learn how to manage all of the information in our programs and use variables. Variables are essentially containers which allow a program to store different pieces of information inside of them. Once the information is stored inside the variable, that information can then be accessed throughout the program simply by referring to the variable's name. Using variables is a great way to keep track of and organize your data. When creating variables, make sure to use descriptive names! For example, if we were creating a variable to hold someones age, using var age is much better than var a . This can save time trying to figure out what each variable is defining! Let's make some variables in JS: var phrase = \"To be or not to be\" ; document . write ( phrase ); var is a special word in JS, which tells JS that a variable is being created. Now we can call the variable within the document . write (); command instead of having to type out the string. This can be very powerful and save programmers a ton of time! We can also change the variable after defining it originally: var phrase = \"To be or not to be\" ; document . write ( phrase ); phrase = \"Apple\" document . write ( phrase ); Now it should print out To be or not to be and apple . We are not limited to only storing strings of text within a variable. We can also store numbers (whole numbers or decimals), boolean variables, undefined, and Null: var name = \"Nick\" var age = 25 ; var gpa = 3.8 ; var isMale = true ; var flaws = null ; var description = undefined ; document . write ( ` ${ name } is ${ age } years old.` ); if ( isMale = true ){ document . write ( `He has a ${ gpa } GPA.` ); } else { document . write ( `She has a ${ gpa } GPA.` ); } The above code should have the following output: Nick is 25 years old.He has a 3.8 GPA. null and undefined are different because when you use null , you are saying that there is no value, but undefined says that there is no value yet . You will probably not use null or undefined much as a developer, but they are still good to know/understand. The $ used above is called interpolation . This allows us to insert, or interpolate , variables into strings using template literals . Notice that: A template literal is wrapped by backticks ``` (this key is usually located on the top of your keyboard, left of the 1 key). Inside the template literal, you\u2019ll see a placeholder, $ { myPet } . The value of myPet is inserted into the template literal. When we interpolate I own a pet $ { myPet }. , the output we print is the string: 'I own a pet armadillo.' One of the biggest benefits to using template literals is the readability of the code. Using template literals, you can more easily tell what the new string will be. You also don't have to worry about escaping double quotes or single quotes. Remember to use descriptive variable names ! Think of a variable as a moving box. When you fill up the box it is common to write on the outside of the box what it contains. Use similar logic when it comes to naming variables.","title":"Variables"},{"location":"js-data-types/#create-a-variable-let","text":"The let keyword signlas that the variable can be reassigned a different value. Take a look at the example: 1 2 3 4 let meal = \"Enchiladas\" ; console . log ( meal ); // prints Enchiladas meal = \"Burrito\" ; console . log ( meal ); // prints Burrito Another concept that we should be aware of when using let (and even var ) is that we can declare a variable without assigning the vairable a value. In such a case, the variable will be automatically initialized with a value of undefined : 1 2 3 4 let price ; console . log ( price ); // prints undefined price = 350 ; console . log ( price ); // prints 350","title":"Create a Variable: let"},{"location":"js-data-types/#create-a-variable-const","text":"The const keyword is short for the word constant, which means that it cannot be reassigned. Just like var and let , you can store any value in a const variable (it also follows the same structure!). Take a look at the following example: 1 2 const myName = \"Nick\" ; console . log ( myName ); // prints Nick As you can see, we created a const variable named myName , which should never have to change. If you try to reassign a const variable, you'll get a TypeError . Constant variables must be assigned a value when declared. If you try to declare a const variable without a value, you'll get a TypeError . If you're trying to decide between which keyword to use, let or const , think about whether you'll need to reassign the variable later on.","title":"Create a Variable: const"},{"location":"js-data-types/#typeof-operator","text":"While writing code, it can be useful to keep track of the data types of the variables in your program. If you need to check the data type of a variable's value, you can use the typeof operator. The typeof operator checks the value to its right and returns , or passes back, a string of the data type. 1 2 3 4 5 6 7 8 const unknown1 = \"foo\" ; console . log ( typeof unknown1 ); // prints string const unknown2 = 10 ; console . log ( typeof unknown2 ); // prints number const unknown3 = true ; console . log ( typeof unknown3 ); // prints boolean","title":"typeof Operator"},{"location":"js-data-types/#strings","text":"<<<<<<< HEAD Strings are any grouping of characters on your keyboard (letters, numbers, space, symbolsm etc.) surrounded by single quotes ' ... ' or double quotes \" ... \" . Though we prefer single quotes. Some people like to think of string as a fancy word for text. 1 2 3 \"This is Nick's Docs!\" 'Single quotes work too!' \"JS is fun!\" Strings cannot be divided, multiplied, or subtracted, but the + operator can be used on them. It does not add, but it concatenates - it glues two strings together. The following line will produced the string \" concatenate \": \"con\" + \"cat\" + \"e\" + \"nate\" We cab also concatenate variables with additional strings: 1 2 3 let myName = \"Nick\" ; console . log ( \"Hello, my name is \" + myName + \"!\" ); // prints Hello, my name is Nick!","title":"Strings"},{"location":"js-data-types/#booleans","text":"Booleans have only two possible values - either true or false . It is helpful to think of booleans as on and off switches or as the answers to a \"yes\" or \"no\" question. Here is one way to produce Boolean values: 1 2 3 4 console . log ( 3 > 2 ); // true console . log ( 3 < 2 ); // false Strings can be compared in the same way: 1 2 console . log ( \"Aardvark\" < \"Zoroaster\" ); // true The way strings are ordered is roughly alphabetic but not really what you'd expect to see in a dictionary: uppercase letters are always \"less\" than lowercase ones, so \"Z\" < \"a\", and nonalphabetic characters (!, -, and so on) are also include in the ordering. When comparing strings, JavaScript goves over the characters from left to right, comparing the Unicode codes one by one. Other similar operators are >= (greater than or equal to), <= (less than or equal to), == (equal to), and != (not equal to). 1 2 3 4 console . log ( \"Itchy\" != \"Scratchy\" ) // true console . log ( \"Apple\" == \"Orange\" ) // false","title":"Booleans"},{"location":"js-data-types/#numbers","text":"Values of the number type are, unsurprisingly, numeric values. In a JavaScript program, they are written as follow: 44 ; 12.34 ; JavaScript uses a fixed number of bits, 64 of them, to store a single number value. There are only so many patterns you can make with 64 bits, which means that the number of different numbers that can be represented is limited. With N decimal digits, you can represent 10 N numbers. Similarly, given 64 binary digits, you can represent 2 64 number, which is about 18 quintillion. That's a lot. Fractional numbers are simply written by using a dot ( 12.34 ). For very big or very small numbers, you may also use scientific notation by adding an e (for exponent), followed by the exponent of the number: 2.998e8 // this is 2.998 x 10^8 = 299,800,000","title":"Numbers"},{"location":"js-data-types/#arithmetic-operators","text":"Basic arithmetic operators often come in handy when programming. An operator is a character that performs a task in our code. JavaScript has several built-in arithmetic operators , that allow us to perform mathematical calculations on numbers. These include the following operators and their corresponding symbols: Add: + Subtract: - Multiply: * Divide: / Remainder: % The first four might work how you guess: 1 2 3 4 console . log ( 3 + 4 ); // prints 7 console . log ( 5 - 1 ); // prints 4 console . log ( 4 * 2 ); // prints 8 console . log ( 9 / 3 ); // prints 3 Note that when we console . log () the computer will evaluate the expression inside the parentheses and print that result to the console. If we wanted to print the characters 3 + 4 , we would wrap them in quotes and print them as a string. The remainder operator, sometimes known as modulo , returns the number that remains after the right-hand number divides into the left-hand number as many times as it can. 1 2 console . log ( 11 % 3 ); // prints 2 console . log ( 12 % 3 ); // prints 0 11 % 3 equals 2 because 3 fits into 11 three times, leaving two as the remainder.","title":"Arithmetic Operators"},{"location":"js-data-types/#the-increment-and-decrement-operator","text":"Other mathematical assignment operators include the increment operator ( ++ ) and decrement operator ( -- ). The increment operator will increase the value of the variable by 1. The decrement operator will decrease the value of the variable by 1. For example: 1 2 3 let a = 10 ; a ++ ; console . log ( a ); // prints 11 1 2 3 let b = 20 ; b -- ; console . log ( b ); // prints 19 Just like the other simple operators ( += , -= , *= , /= ), the variable's value is updated and assigned as the new value of that variable.","title":"The Increment and Decrement Operator"},{"location":"js-data-types/#properties","text":"When you introduce a new piece of data into a JavaScript program, the browser saves it as an instance of the data type. Every string instance has a property called length that stores the number of characters in that string. You can retrieve property information by appending the string with a period and the property name: console . log ( \"Hello\" . length ); // prints 5 The . is another operator! We call it the dot operator . In the example above, the value saved to the length property is retrieved from the instance of the string, \"Hello\" . The program prints 5 to the console, because Hello has five characters in it.","title":"Properties"},{"location":"js-data-types/#methods","text":"Remember that methods are actions we can perfrom. JavaScript provides a number of string methods. We call , or use, these methods by appending an instance with: a period . (the dot operator) the name of the method opening and closing parentheses E.g. 'example string' . methodName (); . Does that syntax look a little familiar? When we use console . log (); we're calling the . log () method on the console object. Let's see console . log () and some real string methods in action! 1 2 console . log ( 'hello' . toUpperCase ()); // prints HELLO console . log ( 'Hey' . startsWith ( 'H' )); // prints true ======= parent of 26d8374 (Commit 5/4)","title":"Methods"},{"location":"js-functions/","text":"Functions What are Functions? When first learning how to calculate the area of a rectangle, there\u2019s a sequence of steps to calculate the correct answer: Measure the width of the rectangle. Measure the height of the rectangle. Multiply the width and height of the rectangle. With practice, you can calculate the area of the rectangle without being instructed with these three steps every time. We can calculate the area of one rectangle with the following code: 1 2 3 4 const width = 10 ; const height = 6 ; const area = width * height ; console . log ( area ); // Output: 60 Imagine being asked to calculate the area of three different rectangles: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Area of the first rectangle const width1 = 10 ; const height1 = 6 ; const area1 = width1 * height1 ; // Area of the second rectangle const width2 = 4 ; const height2 = 9 ; const area2 = width2 * height2 ; // Area of the third rectangle const width3 = 10 ; const height3 = 10 ; const area3 = width3 * height3 ; In programming, we often use code to perform a specific task multiple times. Instead of rewriting the same code, we can group a block of code together and associate it with one task, then we can reuse that block of code whenever we need to perform the task again. We achieve this by creating a function . A function is a reusable block of code that groups together a sequence of statements to perform a specific task. In these notes, we will learn how to create and use functions, and how they can be used to create clearer and more concise code. In JS, there are many was to create a function. One way to create a unction is by using a function declaration . Just like how a variable declaration binds a function to a name, or an identifier . Take a look at the anatomy of a function declaration below: function greetWorld (){ console . log ( \"Hello, World!\" ); } A function declaration consists of: The function keyword. The name of the function, or its identifier, followed by parentheses. A function body, or the block of statements required to perform a specific task, enclosed in the function's curly brackets, {} . Parameters and Arguments Some functions can take inputs and use the inputs to perform a task. When declaring a function, we can specify its parameters . Parameters allow functions to accept input(s) and perform a task using the input(s). We use parameters as placeholders for information that will be passed to the function when it is called. Let's observe how to specify parametes in our function declaration: function calculateArea ( width , height ) { console . log ( width * height ); } In the code above, calculateArea() computes the area of a rectangle based on two inputs, width and height . The parameters are specified between the parenthesis as width and height , and inside the function body, they act like regular variables. width and height act as placeholders for values that will be multiplied together. When calling a function that has parameters, we specify the values in the parentheses that follow the function name (in the example above: calculateArea() ). The values that are passed to the function when it is called are called arguments . Arguments can be passed to the function as values or variables. calculateArea ( 10 , 6 ); In the function above, the number 10 is passed as the width and 6 is passed as the height . Notice that the order in which arguments are passed and assigned follows the order that the parameters are declared. const rectWidth = 10 ; const rectHeight = 6 ; calculateArea ( rectWidth , rectHeight ); The variables rectWidth and rectHeight are initialized with the values for the height and width of the rectangle before being used in the function call. By using parameters, calculateArea() can be reused to compute the area of any rectangle! Let's create an example function that takes an argument and prints out a message using the argument: function sayHello ( name ) { console . log ( \"Hello, \" + name + \"!\" ); } sayHello ( \"Nick\" ); This code would have the output Hello, Nick! . We can pass any name as the argument for the sayHello() function and it would print accordingly. Default Parameters We can also set default parameters for arguments in a function. Default parameters allow parameters to have a predetermined value in case there is no argument passed into the function or if the argument is undefined when called. function greeting ( name = 'stranger' ) { console . log ( `Hello, ${ name } !` ); } greeting ( 'Nick' ); // Output: Hello, Nick! greeting (); // Output: Hello, stranger! In the code above, we set a default parameter by using a = operator to assign the string 'stranger' . This ensures that if a argument is not passed to the function, the function will display the default message instead of erroring out. Return When a function is called, the computer will run through the function's code and evaluate the result of calling the function. By default that resulting value is undefined . function rectangleArea ( width , height ) { let area = width * height ; } console . log ( rectangleArea ( 5 , 7 )); // Prints undefined In the code example above, we defined our function to calculate the area of the width and height parameter. Then rectangleArea() is invoked with eh arguments 5 and 7 . But when we went to print the results we got undefined . Did we write our function wrong? No! In fact, the function worked fine, and the computer did compute the area as 35 , but we didn't capture it. We are able to capture it with the return keyword! function rectangleArea ( width , height ) { let area = width * height ; return area ; } To pass back information from the return call, we use a return statement. To create a return statement, we use the return keyword followed by the value that we wish to return. Like we saw above, if the value is omitted, undefined is returned instead. When a return statement is used in a function body, the execution of the function is stopped and the code that follows it will not be executed. Look at the example below: function rectangleArea ( width , height ) { if ( width < 0 || height < 0 ) { return 'You need positive integers to calculate area!' ; } return width * height ; } If an argument for width or height is less than 0 , then rectangleArea() will return 'You need positive integers to calculate area!' . The second return statement width * height will not run. The return keyword is powerful because it allows functions to produce an output. We can then save the output to a variable for later use. Helper Functions We can also use the return value of a function inside another function. These functions being called within another function are often referred to as helper functions . Since each function is carrying out a specific task, it makes our code easier to read and debug if necessary. If we wanted to define a function that converts the temperature from Celsius to Fahrenheit, we could write two functions like: function multiplyByNineFifths ( number ) { return number * ( 9 / 5 ); }; function getFahrenheit ( celsius ) { return multiplyByNineFifths ( celsius ) + 32 ; }; getFahrenheit ( 15 ); // Returns 59 In the example above: getFahrenheit() is called and 15 is passed as an argument. The code block inside of getFahrenheit() calls multiplyByNineFifths() and passes 15 as an argument. multiplyByNineFifths() takes the argument of 15 for the number parameter. The code block inside of multiplyByNineFifths() function multiplies 15 by (9/5) , which evaluates to 27 . 27 is returned back to the function call in getFahrenheit() . getFahrenheit() continues to execute. It adds 32 to 27 , which evaluates to 59 . Finally, 59 is returned back to the function call getFahrenheit(15) . We can use functions to section off small bits of logic or tasks, then use them when we need to. Writing helper functions can help take large and difficult tasks and break them into smaller and more manageable tasks.","title":"Functions"},{"location":"js-functions/#functions","text":"","title":"Functions"},{"location":"js-functions/#what-are-functions","text":"When first learning how to calculate the area of a rectangle, there\u2019s a sequence of steps to calculate the correct answer: Measure the width of the rectangle. Measure the height of the rectangle. Multiply the width and height of the rectangle. With practice, you can calculate the area of the rectangle without being instructed with these three steps every time. We can calculate the area of one rectangle with the following code: 1 2 3 4 const width = 10 ; const height = 6 ; const area = width * height ; console . log ( area ); // Output: 60 Imagine being asked to calculate the area of three different rectangles: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // Area of the first rectangle const width1 = 10 ; const height1 = 6 ; const area1 = width1 * height1 ; // Area of the second rectangle const width2 = 4 ; const height2 = 9 ; const area2 = width2 * height2 ; // Area of the third rectangle const width3 = 10 ; const height3 = 10 ; const area3 = width3 * height3 ; In programming, we often use code to perform a specific task multiple times. Instead of rewriting the same code, we can group a block of code together and associate it with one task, then we can reuse that block of code whenever we need to perform the task again. We achieve this by creating a function . A function is a reusable block of code that groups together a sequence of statements to perform a specific task. In these notes, we will learn how to create and use functions, and how they can be used to create clearer and more concise code. In JS, there are many was to create a function. One way to create a unction is by using a function declaration . Just like how a variable declaration binds a function to a name, or an identifier . Take a look at the anatomy of a function declaration below: function greetWorld (){ console . log ( \"Hello, World!\" ); } A function declaration consists of: The function keyword. The name of the function, or its identifier, followed by parentheses. A function body, or the block of statements required to perform a specific task, enclosed in the function's curly brackets, {} .","title":"What are Functions?"},{"location":"js-functions/#parameters-and-arguments","text":"Some functions can take inputs and use the inputs to perform a task. When declaring a function, we can specify its parameters . Parameters allow functions to accept input(s) and perform a task using the input(s). We use parameters as placeholders for information that will be passed to the function when it is called. Let's observe how to specify parametes in our function declaration: function calculateArea ( width , height ) { console . log ( width * height ); } In the code above, calculateArea() computes the area of a rectangle based on two inputs, width and height . The parameters are specified between the parenthesis as width and height , and inside the function body, they act like regular variables. width and height act as placeholders for values that will be multiplied together. When calling a function that has parameters, we specify the values in the parentheses that follow the function name (in the example above: calculateArea() ). The values that are passed to the function when it is called are called arguments . Arguments can be passed to the function as values or variables. calculateArea ( 10 , 6 ); In the function above, the number 10 is passed as the width and 6 is passed as the height . Notice that the order in which arguments are passed and assigned follows the order that the parameters are declared. const rectWidth = 10 ; const rectHeight = 6 ; calculateArea ( rectWidth , rectHeight ); The variables rectWidth and rectHeight are initialized with the values for the height and width of the rectangle before being used in the function call. By using parameters, calculateArea() can be reused to compute the area of any rectangle! Let's create an example function that takes an argument and prints out a message using the argument: function sayHello ( name ) { console . log ( \"Hello, \" + name + \"!\" ); } sayHello ( \"Nick\" ); This code would have the output Hello, Nick! . We can pass any name as the argument for the sayHello() function and it would print accordingly.","title":"Parameters and Arguments"},{"location":"js-functions/#default-parameters","text":"We can also set default parameters for arguments in a function. Default parameters allow parameters to have a predetermined value in case there is no argument passed into the function or if the argument is undefined when called. function greeting ( name = 'stranger' ) { console . log ( `Hello, ${ name } !` ); } greeting ( 'Nick' ); // Output: Hello, Nick! greeting (); // Output: Hello, stranger! In the code above, we set a default parameter by using a = operator to assign the string 'stranger' . This ensures that if a argument is not passed to the function, the function will display the default message instead of erroring out.","title":"Default Parameters"},{"location":"js-functions/#return","text":"When a function is called, the computer will run through the function's code and evaluate the result of calling the function. By default that resulting value is undefined . function rectangleArea ( width , height ) { let area = width * height ; } console . log ( rectangleArea ( 5 , 7 )); // Prints undefined In the code example above, we defined our function to calculate the area of the width and height parameter. Then rectangleArea() is invoked with eh arguments 5 and 7 . But when we went to print the results we got undefined . Did we write our function wrong? No! In fact, the function worked fine, and the computer did compute the area as 35 , but we didn't capture it. We are able to capture it with the return keyword! function rectangleArea ( width , height ) { let area = width * height ; return area ; } To pass back information from the return call, we use a return statement. To create a return statement, we use the return keyword followed by the value that we wish to return. Like we saw above, if the value is omitted, undefined is returned instead. When a return statement is used in a function body, the execution of the function is stopped and the code that follows it will not be executed. Look at the example below: function rectangleArea ( width , height ) { if ( width < 0 || height < 0 ) { return 'You need positive integers to calculate area!' ; } return width * height ; } If an argument for width or height is less than 0 , then rectangleArea() will return 'You need positive integers to calculate area!' . The second return statement width * height will not run. The return keyword is powerful because it allows functions to produce an output. We can then save the output to a variable for later use.","title":"Return"},{"location":"js-functions/#helper-functions","text":"We can also use the return value of a function inside another function. These functions being called within another function are often referred to as helper functions . Since each function is carrying out a specific task, it makes our code easier to read and debug if necessary. If we wanted to define a function that converts the temperature from Celsius to Fahrenheit, we could write two functions like: function multiplyByNineFifths ( number ) { return number * ( 9 / 5 ); }; function getFahrenheit ( celsius ) { return multiplyByNineFifths ( celsius ) + 32 ; }; getFahrenheit ( 15 ); // Returns 59 In the example above: getFahrenheit() is called and 15 is passed as an argument. The code block inside of getFahrenheit() calls multiplyByNineFifths() and passes 15 as an argument. multiplyByNineFifths() takes the argument of 15 for the number parameter. The code block inside of multiplyByNineFifths() function multiplies 15 by (9/5) , which evaluates to 27 . 27 is returned back to the function call in getFahrenheit() . getFahrenheit() continues to execute. It adds 32 to 27 , which evaluates to 59 . Finally, 59 is returned back to the function call getFahrenheit(15) . We can use functions to section off small bits of logic or tasks, then use them when we need to. Writing helper functions can help take large and difficult tasks and break them into smaller and more manageable tasks.","title":"Helper Functions"},{"location":"js/","text":"JavaScript Basics Quick Links You Don't Know JS Yet: Get Started (Online Book) Eloquent JavaScript (Online Book) JavaScript: Notes for Professionals (PDF) Interactive JS CheatSheet JavaScript and JQuery - Interactive Front-End Web Development (PDF) Introduction JavaScript, often abbreviated as JS, is a scripting or programming language that allows you to implement complex features on web pages - every time a web page does mroe than just sit there and display static information for you to look at - displaying timely content updates, interactive maps, animated 2D/3D graphics, etc. - you can bet that JavaScript is probably involved. Most modern webpages are a mix of HTML, CSS, and JavaScript. Setup and Hello World! Whenever we are writing JS, we can either write the code directly inside the HTML file or we can create a separate JS file that we link into the HTML. To start, we are going to be writing the JS directly inside the HTML file. We are going to use a basic HTML file titled index.html . We will work directly inside a < script > tag and open the .html file inside a browser. Saving the file and refreshing the browser should show any updates that have been made. Below is the index.html file we will be working with: 1 2 3 4 5 6 7 8 9 < html > < head > < meta charset = \"UTF-8\" > < title > JavaScript Testing </ title > </ head > < body > <!-- JavaScript Code goes here inside a <script> tag --> </ body > </ html > Now that we have the basic HTML file ready to go, let's insert the following JS: 1 2 3 4 5 6 < script type = \"text/javascript\" > // This alert ( \"Hello World!\" ); // This writes text to the screen document . write ( \"Hello World!\" ); </ script > The above document . write ( \"\" ) command is the most basic way to write something to the screen. The alert ( \"\" ) command will display text in a dialog box that pops up on the screen. Linking a seperate JS file into HTML can be helpful for organization and is a simple process. Create another file in the same directory as the index.html file and name it something like script.js . You can name it whatever you want, it just needs to end with the file type .js . To link the .js file into the HTML file, we will add the following code into the < head > tag: 1 2 3 4 5 6 7 8 9 10 < html > < head > < meta charset = \"UTF-8\" > < title > JavaScript Testing </ title > < script src = \"script.js\" ></ script > </ head > < body > </ body > </ html > Functionally, including the JS as a file or directly inside the HTML file are functionally the same. Writing HTML in JavaScript Let's start with a blank HTML file, like the one from above, that links to an outside JS file. In that JS file, let's add the following: 1 2 document . write ( \"<h2 style='color:blue;'>JavaScript Rules!</h2>\" ); document . write ( \"<hr/>\" ); The document command refers to the HTML document that the entire file is linked to. The write () command let's us write whatever we want to the HTML document. We can write plain text or actual HTML tags (like the example above). Moving the < script > tag within the HTML file will determine where that JS will write the HTML.","title":"JavaScript Basics"},{"location":"js/#javascript-basics","text":"","title":"JavaScript Basics"},{"location":"js/#quick-links","text":"You Don't Know JS Yet: Get Started (Online Book) Eloquent JavaScript (Online Book) JavaScript: Notes for Professionals (PDF) Interactive JS CheatSheet JavaScript and JQuery - Interactive Front-End Web Development (PDF)","title":"Quick Links"},{"location":"js/#introduction","text":"JavaScript, often abbreviated as JS, is a scripting or programming language that allows you to implement complex features on web pages - every time a web page does mroe than just sit there and display static information for you to look at - displaying timely content updates, interactive maps, animated 2D/3D graphics, etc. - you can bet that JavaScript is probably involved. Most modern webpages are a mix of HTML, CSS, and JavaScript.","title":"Introduction"},{"location":"js/#setup-and-hello-world","text":"Whenever we are writing JS, we can either write the code directly inside the HTML file or we can create a separate JS file that we link into the HTML. To start, we are going to be writing the JS directly inside the HTML file. We are going to use a basic HTML file titled index.html . We will work directly inside a < script > tag and open the .html file inside a browser. Saving the file and refreshing the browser should show any updates that have been made. Below is the index.html file we will be working with: 1 2 3 4 5 6 7 8 9 < html > < head > < meta charset = \"UTF-8\" > < title > JavaScript Testing </ title > </ head > < body > <!-- JavaScript Code goes here inside a <script> tag --> </ body > </ html > Now that we have the basic HTML file ready to go, let's insert the following JS: 1 2 3 4 5 6 < script type = \"text/javascript\" > // This alert ( \"Hello World!\" ); // This writes text to the screen document . write ( \"Hello World!\" ); </ script > The above document . write ( \"\" ) command is the most basic way to write something to the screen. The alert ( \"\" ) command will display text in a dialog box that pops up on the screen. Linking a seperate JS file into HTML can be helpful for organization and is a simple process. Create another file in the same directory as the index.html file and name it something like script.js . You can name it whatever you want, it just needs to end with the file type .js . To link the .js file into the HTML file, we will add the following code into the < head > tag: 1 2 3 4 5 6 7 8 9 10 < html > < head > < meta charset = \"UTF-8\" > < title > JavaScript Testing </ title > < script src = \"script.js\" ></ script > </ head > < body > </ body > </ html > Functionally, including the JS as a file or directly inside the HTML file are functionally the same.","title":"Setup and Hello World!"},{"location":"js/#writing-html-in-javascript","text":"Let's start with a blank HTML file, like the one from above, that links to an outside JS file. In that JS file, let's add the following: 1 2 document . write ( \"<h2 style='color:blue;'>JavaScript Rules!</h2>\" ); document . write ( \"<hr/>\" ); The document command refers to the HTML document that the entire file is linked to. The write () command let's us write whatever we want to the HTML document. We can write plain text or actual HTML tags (like the example above). Moving the < script > tag within the HTML file will determine where that JS will write the HTML.","title":"Writing HTML in JavaScript"},{"location":"notes/","text":"Programming Notes Notes by Language C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures Python Python Basics Variables and Simple Data Types Lists Working with Lists If Statements Dictionaries User Input and while Loops Functions Classes Random Programs Java Java Overview Java Basics Variables Classes Conditionals/Control Flow Arrays Loops String Methods Access, Encapsulation, & Scope Inheritance & Polymorphism Debugging 2D Arrays JavaScript JavaScript Basics Variables and Simple Data Types Conditional Statements Functions SQL SQL Basics Joins and Other Query Types SQL Random Problems Random Notes APIs Django","title":"Notes Overview"},{"location":"notes/#programming-notes","text":"","title":"Programming Notes"},{"location":"notes/#notes-by-language","text":"C C Basics Arrays Functions Command Line Arguments Variables and Scope Algorithms Memory Data Structures Python Python Basics Variables and Simple Data Types Lists Working with Lists If Statements Dictionaries User Input and while Loops Functions Classes Random Programs Java Java Overview Java Basics Variables Classes Conditionals/Control Flow Arrays Loops String Methods Access, Encapsulation, & Scope Inheritance & Polymorphism Debugging 2D Arrays JavaScript JavaScript Basics Variables and Simple Data Types Conditional Statements Functions SQL SQL Basics Joins and Other Query Types SQL Random Problems","title":"Notes by Language"},{"location":"notes/#random-notes","text":"APIs Django","title":"Random Notes"},{"location":"portfolio/","text":"Nicholas Platt's Portfolio Resume Portfolio Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types. SoccerFront (2020-Present) is a soccer live score web application that I built using Nodejs, Expressjs, HTML, CSS, and JavaScript. Soccerfront pulls data from the API-FOOTBALL API and displays the information in a easy to use live score table and league table (standings) view. Currently, over 20 leagues/cups are supported! This is an ongoing project and new features will be added sporadically. Images Custom Keyboard PCB with Switch Slot Callouts Table Example Instruction Example Graphic Example About Me Click Here Contact Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Main Portfolio"},{"location":"portfolio/#nicholas-platts-portfolio","text":"","title":"Nicholas Platt's Portfolio"},{"location":"portfolio/#resume","text":"","title":"Resume"},{"location":"portfolio/#portfolio","text":"Installation Guide Example - Firefox (2018) The goal of this guide is to inform a user to properly download, install, setup, and personalize Mozilla Firefox. This guide includes an overview of Mozilla Firefox, a how-to for proper setup, general use instructions, and personalization run through. Screenshots are also included to aid the user for ease of reading. This document was created in a technical writing class I took at University of Maryland Global Campus in 2018. Release Notes Example - Firefox (2020) Release notes from the most recent Firefox 75.0 release on April, 07 2020. As a product evolves over time, having a historical log of these changes, improvements, and fixes helps tell your users what has changed and how it affects the overall program. The wording from these release notes were taken from Mozilla's release notes page and reformatted to what might be sent out to users in an email form. Multiple pages of reference materials were included in a single document to show basic changes to advanced developer changes. User Guide Example - Google Chrome (2020) User Guides/Manuals are extremely important for professional communication of business goals/features. User guides can include instructions, tips, FAQs, images, videos, etc., depending on what information is deemed most critical for efficient use of the program. In this User Guide example, I go over basic functionality of Google Chrome. Installation, initial setup, personalization, and advanced use are discussed in detail for all user types. SoccerFront (2020-Present) is a soccer live score web application that I built using Nodejs, Expressjs, HTML, CSS, and JavaScript. Soccerfront pulls data from the API-FOOTBALL API and displays the information in a easy to use live score table and league table (standings) view. Currently, over 20 leagues/cups are supported! This is an ongoing project and new features will be added sporadically.","title":"Portfolio"},{"location":"portfolio/#images","text":"Custom Keyboard PCB with Switch Slot Callouts Table Example Instruction Example Graphic Example","title":"Images"},{"location":"portfolio/#about-me","text":"Click Here","title":"About Me"},{"location":"portfolio/#contact","text":"Nicholas Platt nickplatt4@gmail.com (909)224-4200 LinkedIn","title":"Contact"},{"location":"py-classes/","text":"Classes Object-oriented programming (OOP) is one of the most effective approaches to writing software. In OOP you write classes that represent real-world things and situations, and you create objects based on these classes. When you write a class, you define the general behavior that a whole category of objects can have. When you create individual objects from the class, each object is automatically equipped with the genearl behavior; you can then give each object whatever unique traits you desire. You'll be amazed how well real-world situations can be modeled with object-oriented programming. Making an object from a class is called instantiation , and you work with instances of a class. On this page, we'll write classes and create instances of those classes. We will specify the kind of information that will be stored in instances, and we'll define actions that can be taken with these instances. We'll also write classes that extend the functionality of existing classes, so similar classes can share code efficiently. We'll store our classes in modules and import classes written by other programmers into our program files. Understanding object-oriented programming will help us see the world as a programmer does. It'll help us really know our code, not just what's happening line by line, but also the bigger picture behind it. Knowing the logic behind classes will train us to think logically so we can write programs that effectively address almost any problem we encounter. Creating and Using a Class You can model almost anything using classes. Let's start by writing a simple class, Dog , that represents a dog - not one dog in particular, but any dog. What do we know about pet dogs? Well, they all have a name and age. We also know that most dogs sit and roll over. Those two pieces of information (name and age) and those two behaviors (sit and roll over) will go in our Dog class because they're common to most dogs. This class will tell Python how to make an object representing a dog. After our class is written, we'll use it to make individual instances, each of which represent one specific dog. Creating the Dog Class Each instance created from the Dog class will store a name and an age , and we'll give each dog the ability to sit () and roll_over () : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) There's a lot to notice here, but don't worry. You'll see this structure throughout this page and have lot's of time to get used to it. On line 1, we define a classed called Dog . By convention, capitalized names refer to classes in Python. There are no parenthesis in the class deinition because we're creating this class from scratch. On line 2, we write a docstring describing what this class does. The __init__() Method A function that's part of a class is a method . Everything you learned about functions applies to methods as well; the only practical difference for now is the way we'll call methods. The __init__ () method on line 4 is a special method that Python runs automatically whenever we create a new instance based on the Dog class. This method has two leading underscores and two trailing underscores, a convention that helps prevent Python's default method names from conflicting with your method names. Make sure to use two underscores on each side of __init__ () . If you use just one on each side, the method won't be called automatically when you use your class, which can result in errors that are difficult to identify. We define the __init__() method to have three parameters: self , name , and age . The self parameter is required in the method definition, and it must come first before the other parameters. It must be included in the definition because when Python cals this method later (to create an instance of Dog ), the method call will automatically pass the self argument. Every method call associated with an instance automatically passes self , which is a reference to the instance itself; it gives the individual instance access to the attributes and methods in the class. When we make an instance of Dog , Python will call the __init__() method from the Dog class. We'll pass Dog() a name and an age as arguments; self is passed automatically, so we don't need to pass it. Whenever we want to make an instance from the Dog class, we'll provide values for only the last two parameters, name and age . The two variables defined on line 6/7 each have the prefix self . Any varibale prefixed with self is available to every method in the class, and we'll also be able to access these variables through any instance created from the class. The line self . name = name takes the value associated with the parameter name and assigns it to the variable name , which is then attached to the instance being created. The same process happens with self . age = age . Variables that are accessible through instances like this are called attributes . The Dog class has two other methods defined: sit() and roll_over() (line 9 & 13). Because these methods don't need additional information to run, we just define them to have one parameter, self . The instances we create later will have access to these methods. In other words, they'll be able to sit and roll over. For now, sit() and roll_over() don't do much. They simply print a message saying the dog is sitting or rolling over. But the concept can be extended to realistic situations: if this class were part of an actual computer game, these messages would contain code to make an animated dog sit and roll over. If this class was written to control a robot, these methods would direct movements that cause a robotic doc to sit and roll over. Making an Instance from a Class Think of a class as a set of instructions for how to make an instance. The class Dog is a set of instructions that tells Python how to make individual instances representing specific dogs. Let's make an instance representing a specific dog: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) print ( f \"My dog's name is { my_dog . name } .\" ) print ( f \"My dog is { my_dog . age } years old.\" ) The Dog class we're using here is the same from the previous example. On line 17 we tell Python to create a dog whose name is 'Willie' and whose age is 6 . When Python reads this line, it calls the __init__() method in Dog with the arguments 'Willie' and 6 . The __init__() method creates an instance representing this particular dog and sets the name and age attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable my_dog . The naming convention is helpful here: we can usually assume that a capitalized name like Dog refers to a class, and a lowercase name like my_dog refers to a single instance created from a class. Accessing Attributes To acces the attributes of an instance, you use dot notation. On line 19, we access the value of my_dog 's name by writing: my_dog . name Dot notaion is used often in Python. This syntax demonstrates how Python finds an attribute's value. Here Python looks at the instance my_dog and then finds the attribute name associated with my_dog . This is the same attribute referred to as self . name in the class Dog . On line 20 we use the same approach to work with the attribute age . The output is a summary of what we know about my_dog : My dog's name is Willie. My dog is 6 years old. Calling Methods After we create an instance from the class Dog , we can use dot notation to call any method defined in Dog . Let's make our dog sit and roll over: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) my_dog . sit () my_dog . roll_over () To call a method, give the name of the instance (in this case, my_dog ) and the method you want to call, separated by a dot. When Python reads my_dog . sit () , it looks for the method sit() in the class Dog and runs that code. Python interprets the line my_dog . roll_over () in the same way. Now Willie does what we tell him to: Willie is now sitting. Willie rolled over! This syntax is quite useful. When attributes and methods have been given appropriately descriptive names like name , age , sit() , and roll_over() , we can easily infer what a block of code, even one we've never seen before, is supposed to do. Creating Multiple Instances You can create as many instances from a class as you need. Let's create a second dog called your_dog : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) your_dog = Dog ( 'Lucy' , 3 ) print ( f \"My dog's name is { my_dog . name } .\" ) print ( f \"My dog is { my_dog . age } years old.\" ) my_dog . sit () print ( f \" \\n Your dog's name is { your_dog . name } .\" ) print ( f \"Your dog is { your_dog . age } years old.\" ) your_dog . sit () In this example we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own set of attributes, capable of the same set of actions: My dog's name is Willie. My dog is 6 years old. Willie is now sitting. Your dog's name is Lucy. Your dog is 3 years old. Lucy is now sitting. Even if We used the same name and age for the second dog, Python would still create a separate instance from the Dog class. You can make as many instances from one class as you need, as long as you give each instance a unique variable name or it occupies a unique spot in a list or dictionary. Working with Classes and Instances You can use classes to represent many real-word situations. Once you write a class, you'll spend most of your time working with instances created from that class. One of the first tasks you'll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways. The Car Class Let's write a new class representing a car. Our class will store information about the kind of car we're working with, and it will have a method that summarizes this information: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Intiialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) On line 4 in the Car class, we define the __init__() method with the self parameter first, just like we did before with our Dog class. We also give in three other parameters: make , model , and year . The __init__() method takes in these parameters and assigns them to the attributes that will be associated with instances made from this class. When we make a new Car instance, we'll need to specify a make, model, and year for our instance. On line 10 we define a method called get_descriptive_name () that puts a car's year , make , and model into one string neatly describing the car. This will spare us from having to print each attribute's value individually. To work with the attribute values in this method, we use self . make , self . model and self . year . On line 15 we make an instance from the Car class and assign it to the variable my_new_car . Then we call get_descriptive_name() to show what kind of car we have: 2020 Audi A4 To make the class more interesting, let's add an attribute that changes over time. We'll add an attribute that stores the car's overall mileage. Setting a Default Value for an Attribute When an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the __init__() method, where they are assigned a default value. Let's add an attribute called odometer_reading that always starts with a value of 0 . We'll also add a method read_odometer() that helps us read each car's odometer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Intiialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): \"\"\"Print a statement showing the car's mileage.\"\"\" print ( f \"This car has { self . odometer_reading } miles on it.\" ) my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . read_odometer () This time when Python calls the __init__() method to create a new instance, it stores the make, model, and year values as attributes like it did in the previous example. Then Python creates a new attribute called odometer_reading and sets its initial value to 0 (line 9). We also have a new method called read_odometer() on line 16 that makes it easy to read a car's mileage. Our car starts with a mileage of 0: 2020 Audi A4 This car has 0 miles on it. Not many cars are sold with exactly 0 miles on the odometer, so we need a way to change the value of this attribute. Modifying Attribute Values You can change an attribute's value in three ways: Change the value directly through an instance Set the value through a method Increment the value through a method Modifying an Attribute's Value Directly The simplest way to modify the value of an attribute is to access the attribute directly through an instance. Here we set the odometer reading to 23 directly: 1 2 3 4 5 6 7 8 class Car : -- snip -- my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . odometer_reading = 23 my_new_car . read_odometer () On line 7 we use dot notation to access the car's odometer_reading attribute and set its value directly. This line tells Python to take the instance my_new_car , find the attribute odomerter_reading associated with it, and set the value of that attribute to 23: 2020 Audi A4 This car has 23 miles on it. Sometimes you'll want to access attributes directly like this, but other times you'll want to write a method that updates the value for you. Modifying an Attribute's Value Through a Method It can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally. Here's an example showing a method called update_odometer() : 1 2 3 4 5 6 7 8 9 10 11 12 class Car : -- snip -- def update_odometer ( self , milage ): \"\"\"Set the odometer reading to a given value.\"\"\" self . odometer_reading = milage my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . update_odometer ( 23 ) my_new_car . read_odometer () The only modification to Car is the addition of update_odometer() on line 4. This method takes in a mileage value and assigns it to self . odometer_reading . On line 11 we call update_odometer() and give it 23 as an argument (corresponding to the mileage parameter in the method definition). It sets the odometer reading to 23 , and read_odometer() prints the reading: 2020 Audi A4 This car has 23 miles on it. We can extend the method update_odometer() to do additional work every time the odometer reading is modified. Let's add a little logic to make sure no one tries to roll back the odometer reading: 1 2 3 4 5 6 7 8 9 10 11 12 class Car : -- snip -- def update_odometer ( self , mileage ): \"\"\" Set the odometer reading to a given value. Reject the change if it atempts to roll the odometer back. \"\"\" if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) Now update_odometer() checks that the new reading makes sense before modifying the attribute. If the new mileage, mileage , is greater than or equal to the existing mileage, self . odometer_reading , you can update the odometer reading to the new mileage (line 9). If the new mileage is less than the existing mileage, you'll get a warning that you can't roll back an odometer (line 12). Incrementing an Attribute's Value Through a Method Sometimes you'll want to increment an attribute's value by a certain amount rather than set an entirely new value. Say we buy a used car and put 100 miles on it between the time we buy it and the time we register it. Here's a method that allows us to pass this incremental amount and add that value to the odometer reading: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Car : -- snip -- def update_odometer ( self , mileage ): -- snip -- def increment_odometer ( self , miles ): \"\"\"Add the given amount to the odometer reading.\"\"\" self . odometer_reading += miles my_used_car = Car ( 'subaru' , 'outback' , 2016 ) print ( my_used_car . get_descriptive_name ()) my_used_car . update_odometer ( 23_500 ) my_used_car . read_odometer () my_used_car . update_odometer ( 100 ) my_used_car . read_odometer () This new method increment_odometer() at line 7 takes in a number of miles and adds this value to self . odometer_reading . On line 11 we create a used car, my_used_car . We set its odomoer to 23,500 by calling update_odometer() and passing it 23_500 on line 14. On line 16 we call increment_odometer() and pass it 100 to add the 100 miles that we drove between buying the car and registering it: 2015 Subaru Outback This car has 23500 miles on it. This car has 23600 miles on it. You can easily modify this method to reject negative increments so no one uses this function to roll back an odometer. Inheritance You don't always have to start from scratch when writing a class. If the class you're writing is a specialized version of another class you wrote, you can use inheritance . When one class inherits from another, it takes on the attributes and methods of the first class. The original class is called the parent class , and the new class is the child class . The child class can inherit any or all of the attributes and methods of its parent class, but it's also free to define new attributes and methods of its own. The __init__() Method for a Child Class When you're writing a new class based on an existing class, you'll often want to call the __init__() method from the parent class. This will initialize any attributes that were defined in the parent __init__() method and make them available in the child class. As an example, let's model an electric car. An electric car is just a specific kind of car, so we can base our new ElectricCar class on the Car class we wrote earlier. Then we'll only have to write code for the attributes and behavior specific to electric cars. Let's start by making a simple version of the ElectricCar class, which does everythin the Car class does: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): print ( f \"This car has { self . odometer_reading } miles on it.\" ) def update_odometer ( self , mileage ): if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) def increment_odometer ( self , miles ): self . odometer_reading += miles class ElectricCar ( Car ): \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Initialize attributes of the parent class.\"\"\" super () . __init__ ( make , model , year ) my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) On line 1 we start with Car . When you create a child class, the parent class must be part of the current file and must appear before the child class in the file. On line 25 we define the child class, ElectricCar . The name of the parent class must be included in the parentheses in the defintion of a child class. The __init__() method on line 28 takes in the information required to make a Car instance. The super() function on line 30 is a special function that allows you to call a method from the parent class. This line tells Python to call the __init__() method from Car , which gives and ElectricCar instance all the attributes fefined in that method. The name super comes from a convention of calling the parent class a superclass and the child class a subclass . We test whether inheritence is working properly by trying to create an electric car with the same kind of information we'd provide when making a regular car. On line 32 we make an instance of the ElectricCar class and assign it to my_tesla . This line calls the __init__() method defined in ElectricCar , which in turn tells Python to call the __init__() method defined in the parent class Car . We provide the arguments 'tesla' , 'model s' , and 2019 . Aside from __init__() , there are no attributes or methods yet that are particular to an electric car. At this point we're just making sure the car has the appropriate Car behaviors: 2019 Tesla Model S The ElectricCar instance works just like an instance of Car , so now we can begin defining attributes and methods specific to electric cars. Defining Attributes and Methods for the Child Class Once you have a child class that inherits from a parent class, you can add any new attributes and methods necessary to differentiate the child class from the parent class. Let's add an attribute that's specific to electric cars (a battery, for example) and a method to report on this attribute. We'll store the battery size and write a method that print a description of the battery: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Car : --- snip --- class ElectricCar ( Car ): \"\"\"Represents aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery_size = 75 def describe_battery ( self ): \"\"\"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . describe_battery () On line 13 we add a new attribute self . battery_size and set its initial value to 75 . This attribute will be associated with all instances created from the ElectricCar class but won't be associated with any instances of Car . We also add a method called describe_battery() that prints information about the battery on line 15. When we call this method, we get a description that is clearly specific to an electric car: 2019 Tesla Model S This car has a 75-kWh battery. There's no limit to how much you can specialize the ElectricCar class. You can add as many attributes and methods as you need to model an electric car to whatever degree of accuracy you need. An attribute or method that could belong to any car, rather than one that's specific to an electric car, should be added to the Car class instead of the ElectricCar class. Then anyone who uses the Car class will have that functionality available as well, and the ElectricCar class wil only contain code for the information and behavior specific to electric vehicles. Overriding Methods from the Parent Class You can override any method from the parent class that doesn't fit what you're trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class. Say the class Car had a method called fill_gas_tank () . This method is meaningless for an all-electric vehicle, so you might want to override this method. Here is one way to do that: 1 2 3 4 5 6 class ElectricCar ( Car ): -- snip -- def fill_gas_tank ( self ): \"\"\"Electric cars don't have gas tanks.\"\"\" print ( \"This car doesn't need a gas tank!\" ) Now if someone tries to call fill_gas_tank() with an electric car, Python will ignore the method fill_gas_tank() in Car and run this code instead. When you use inheritence, you can make your child classes retain what you need and override anything you don't need from the parent class. Instances as Attributes When modeling something from the real world in code, you may find that you're adding more and more detail to a class. You'll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together. For example, if we continue adding detail to the ElectricCar class, we might notice that we're adding many attributes and methods specific to the car's battery. When we see this happening, we can stop and move those attributes and methods to a separate class called Battery . Then we can use a Battery instance as an attribute in the ElectricCar class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Car : -- snip -- class Battery : \"\"\"A simple attempt to model a battery for an electric car.\"\"\" def __init__ ( self , battery_size = 75 ): \"\"\"Initialize the battery's attributes.\"\"\" self . battery_size = battery_size def describe_battery ( self ): \"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) class ElectricCar ( Car ): \"represents aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery = Battery () my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . battery . describe_battery () On line 4 we define a new class called class Battery that doesn't inherit from any other class. The __init__ () method on line 7 has one parameter battery_size , in addition to self . This is an optional parameter that sets the battery's size to 75 if no value is provided. The method describe_battery () has been moved to this class as well (line 11). In the ElectricCar class, we now add an attribute called self . battery (line 24). This line tells Python to create a new instance of Battery (with a default size of 75 because we're not specifying a value) and assign that instance to the attribute self.battery . This will happen every time the __init__ () method is called; and ElectricCar instance will now have a Battery instance created automatically. We create an electric car and assign it to the variable my_tesla . When we want to describe the battery, we need to work through the car's battery attribute: 1 my_tesla . batter . describe_battery () This line tells Python to look at the instance of my_tesla , find its battery attribute, and call the method describe_battery() that's associated with the Battery instance stored in the attribute. The output is identical to what we saw previously: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Car : -- snip -- class Battery : -- snip -- def get_range ( self ): \"\"\"Print a statement about the range this battery provides.\"\"\" if self . battery_size == 75 : range = 260 elif self . battery_size == 100 : range = 315 class ElectricCar ( Car ): -- snip -- my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . battery . describe_battery () my_tesla . battery . get_range () The new method get_range() on line 7, performs some simple analysis. If the battery's capacity is 75 kWh, get_range() sets the range to 260 miles, and if the capacity is 100 kWh, it sets the range to 315 miles. It then reports this value. When we want to use this method, we again have to call it through the car's battery attribute on line 21. The output tells us the range of the car based on its battery size: 2019 Tesla Model S This car has a 75-kWh battery. This car can go about 260 mile son a full charge. Modeling Real-World Objects","title":"Classes"},{"location":"py-classes/#classes","text":"Object-oriented programming (OOP) is one of the most effective approaches to writing software. In OOP you write classes that represent real-world things and situations, and you create objects based on these classes. When you write a class, you define the general behavior that a whole category of objects can have. When you create individual objects from the class, each object is automatically equipped with the genearl behavior; you can then give each object whatever unique traits you desire. You'll be amazed how well real-world situations can be modeled with object-oriented programming. Making an object from a class is called instantiation , and you work with instances of a class. On this page, we'll write classes and create instances of those classes. We will specify the kind of information that will be stored in instances, and we'll define actions that can be taken with these instances. We'll also write classes that extend the functionality of existing classes, so similar classes can share code efficiently. We'll store our classes in modules and import classes written by other programmers into our program files. Understanding object-oriented programming will help us see the world as a programmer does. It'll help us really know our code, not just what's happening line by line, but also the bigger picture behind it. Knowing the logic behind classes will train us to think logically so we can write programs that effectively address almost any problem we encounter.","title":"Classes"},{"location":"py-classes/#creating-and-using-a-class","text":"You can model almost anything using classes. Let's start by writing a simple class, Dog , that represents a dog - not one dog in particular, but any dog. What do we know about pet dogs? Well, they all have a name and age. We also know that most dogs sit and roll over. Those two pieces of information (name and age) and those two behaviors (sit and roll over) will go in our Dog class because they're common to most dogs. This class will tell Python how to make an object representing a dog. After our class is written, we'll use it to make individual instances, each of which represent one specific dog.","title":"Creating and Using a Class"},{"location":"py-classes/#creating-the-dog-class","text":"Each instance created from the Dog class will store a name and an age , and we'll give each dog the ability to sit () and roll_over () : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) There's a lot to notice here, but don't worry. You'll see this structure throughout this page and have lot's of time to get used to it. On line 1, we define a classed called Dog . By convention, capitalized names refer to classes in Python. There are no parenthesis in the class deinition because we're creating this class from scratch. On line 2, we write a docstring describing what this class does.","title":"Creating the Dog Class"},{"location":"py-classes/#the-__init__-method","text":"A function that's part of a class is a method . Everything you learned about functions applies to methods as well; the only practical difference for now is the way we'll call methods. The __init__ () method on line 4 is a special method that Python runs automatically whenever we create a new instance based on the Dog class. This method has two leading underscores and two trailing underscores, a convention that helps prevent Python's default method names from conflicting with your method names. Make sure to use two underscores on each side of __init__ () . If you use just one on each side, the method won't be called automatically when you use your class, which can result in errors that are difficult to identify. We define the __init__() method to have three parameters: self , name , and age . The self parameter is required in the method definition, and it must come first before the other parameters. It must be included in the definition because when Python cals this method later (to create an instance of Dog ), the method call will automatically pass the self argument. Every method call associated with an instance automatically passes self , which is a reference to the instance itself; it gives the individual instance access to the attributes and methods in the class. When we make an instance of Dog , Python will call the __init__() method from the Dog class. We'll pass Dog() a name and an age as arguments; self is passed automatically, so we don't need to pass it. Whenever we want to make an instance from the Dog class, we'll provide values for only the last two parameters, name and age . The two variables defined on line 6/7 each have the prefix self . Any varibale prefixed with self is available to every method in the class, and we'll also be able to access these variables through any instance created from the class. The line self . name = name takes the value associated with the parameter name and assigns it to the variable name , which is then attached to the instance being created. The same process happens with self . age = age . Variables that are accessible through instances like this are called attributes . The Dog class has two other methods defined: sit() and roll_over() (line 9 & 13). Because these methods don't need additional information to run, we just define them to have one parameter, self . The instances we create later will have access to these methods. In other words, they'll be able to sit and roll over. For now, sit() and roll_over() don't do much. They simply print a message saying the dog is sitting or rolling over. But the concept can be extended to realistic situations: if this class were part of an actual computer game, these messages would contain code to make an animated dog sit and roll over. If this class was written to control a robot, these methods would direct movements that cause a robotic doc to sit and roll over.","title":"The __init__() Method"},{"location":"py-classes/#making-an-instance-from-a-class","text":"Think of a class as a set of instructions for how to make an instance. The class Dog is a set of instructions that tells Python how to make individual instances representing specific dogs. Let's make an instance representing a specific dog: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) print ( f \"My dog's name is { my_dog . name } .\" ) print ( f \"My dog is { my_dog . age } years old.\" ) The Dog class we're using here is the same from the previous example. On line 17 we tell Python to create a dog whose name is 'Willie' and whose age is 6 . When Python reads this line, it calls the __init__() method in Dog with the arguments 'Willie' and 6 . The __init__() method creates an instance representing this particular dog and sets the name and age attributes using the values we provided. Python then returns an instance representing this dog. We assign that instance to the variable my_dog . The naming convention is helpful here: we can usually assume that a capitalized name like Dog refers to a class, and a lowercase name like my_dog refers to a single instance created from a class.","title":"Making an Instance from a Class"},{"location":"py-classes/#accessing-attributes","text":"To acces the attributes of an instance, you use dot notation. On line 19, we access the value of my_dog 's name by writing: my_dog . name Dot notaion is used often in Python. This syntax demonstrates how Python finds an attribute's value. Here Python looks at the instance my_dog and then finds the attribute name associated with my_dog . This is the same attribute referred to as self . name in the class Dog . On line 20 we use the same approach to work with the attribute age . The output is a summary of what we know about my_dog : My dog's name is Willie. My dog is 6 years old.","title":"Accessing Attributes"},{"location":"py-classes/#calling-methods","text":"After we create an instance from the class Dog , we can use dot notation to call any method defined in Dog . Let's make our dog sit and roll over: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) my_dog . sit () my_dog . roll_over () To call a method, give the name of the instance (in this case, my_dog ) and the method you want to call, separated by a dot. When Python reads my_dog . sit () , it looks for the method sit() in the class Dog and runs that code. Python interprets the line my_dog . roll_over () in the same way. Now Willie does what we tell him to: Willie is now sitting. Willie rolled over! This syntax is quite useful. When attributes and methods have been given appropriately descriptive names like name , age , sit() , and roll_over() , we can easily infer what a block of code, even one we've never seen before, is supposed to do.","title":"Calling Methods"},{"location":"py-classes/#creating-multiple-instances","text":"You can create as many instances from a class as you need. Let's create a second dog called your_dog : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Dog : \"\"\"A simple attempt to model a dog.\"\"\" def __init__ ( self , name , age ): \"\"\"Initialized name and age attributes.\"\"\" self . name = name self . age = age def sit ( self ): \"\"\"Simulate a dog sitting in response to a command.\"\"\" print ( f \" { self . name } is now sitting.\" ) def roll_over ( self ): \"\"\"Simulate rolling over in response to a command.\"\"\" print ( f \" { self . name } rolled over!\" ) my_dog = Dog ( 'Willie' , 6 ) your_dog = Dog ( 'Lucy' , 3 ) print ( f \"My dog's name is { my_dog . name } .\" ) print ( f \"My dog is { my_dog . age } years old.\" ) my_dog . sit () print ( f \" \\n Your dog's name is { your_dog . name } .\" ) print ( f \"Your dog is { your_dog . age } years old.\" ) your_dog . sit () In this example we create a dog named Willie and a dog named Lucy. Each dog is a separate instance with its own set of attributes, capable of the same set of actions: My dog's name is Willie. My dog is 6 years old. Willie is now sitting. Your dog's name is Lucy. Your dog is 3 years old. Lucy is now sitting. Even if We used the same name and age for the second dog, Python would still create a separate instance from the Dog class. You can make as many instances from one class as you need, as long as you give each instance a unique variable name or it occupies a unique spot in a list or dictionary.","title":"Creating Multiple Instances"},{"location":"py-classes/#working-with-classes-and-instances","text":"You can use classes to represent many real-word situations. Once you write a class, you'll spend most of your time working with instances created from that class. One of the first tasks you'll want to do is modify the attributes associated with a particular instance. You can modify the attributes of an instance directly or write methods that update attributes in specific ways.","title":"Working with Classes and Instances"},{"location":"py-classes/#the-car-class","text":"Let's write a new class representing a car. Our class will store information about the kind of car we're working with, and it will have a method that summarizes this information: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Intiialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) On line 4 in the Car class, we define the __init__() method with the self parameter first, just like we did before with our Dog class. We also give in three other parameters: make , model , and year . The __init__() method takes in these parameters and assigns them to the attributes that will be associated with instances made from this class. When we make a new Car instance, we'll need to specify a make, model, and year for our instance. On line 10 we define a method called get_descriptive_name () that puts a car's year , make , and model into one string neatly describing the car. This will spare us from having to print each attribute's value individually. To work with the attribute values in this method, we use self . make , self . model and self . year . On line 15 we make an instance from the Car class and assign it to the variable my_new_car . Then we call get_descriptive_name() to show what kind of car we have: 2020 Audi A4 To make the class more interesting, let's add an attribute that changes over time. We'll add an attribute that stores the car's overall mileage.","title":"The Car Class"},{"location":"py-classes/#setting-a-default-value-for-an-attribute","text":"When an instance is created, attributes can be defined without being passed in as parameters. These attributes can be defined in the __init__() method, where they are assigned a default value. Let's add an attribute called odometer_reading that always starts with a value of 0 . We'll also add a method read_odometer() that helps us read each car's odometer: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Intiialize attributes to describe a car.\"\"\" self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): \"\"\"Return a neatly formatted descriptive name.\"\"\" long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): \"\"\"Print a statement showing the car's mileage.\"\"\" print ( f \"This car has { self . odometer_reading } miles on it.\" ) my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . read_odometer () This time when Python calls the __init__() method to create a new instance, it stores the make, model, and year values as attributes like it did in the previous example. Then Python creates a new attribute called odometer_reading and sets its initial value to 0 (line 9). We also have a new method called read_odometer() on line 16 that makes it easy to read a car's mileage. Our car starts with a mileage of 0: 2020 Audi A4 This car has 0 miles on it. Not many cars are sold with exactly 0 miles on the odometer, so we need a way to change the value of this attribute.","title":"Setting a Default Value for an Attribute"},{"location":"py-classes/#modifying-attribute-values","text":"You can change an attribute's value in three ways: Change the value directly through an instance Set the value through a method Increment the value through a method","title":"Modifying Attribute Values"},{"location":"py-classes/#modifying-an-attributes-value-directly","text":"The simplest way to modify the value of an attribute is to access the attribute directly through an instance. Here we set the odometer reading to 23 directly: 1 2 3 4 5 6 7 8 class Car : -- snip -- my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . odometer_reading = 23 my_new_car . read_odometer () On line 7 we use dot notation to access the car's odometer_reading attribute and set its value directly. This line tells Python to take the instance my_new_car , find the attribute odomerter_reading associated with it, and set the value of that attribute to 23: 2020 Audi A4 This car has 23 miles on it. Sometimes you'll want to access attributes directly like this, but other times you'll want to write a method that updates the value for you.","title":"Modifying an Attribute's Value Directly"},{"location":"py-classes/#modifying-an-attributes-value-through-a-method","text":"It can be helpful to have methods that update certain attributes for you. Instead of accessing the attribute directly, you pass the new value to a method that handles the updating internally. Here's an example showing a method called update_odometer() : 1 2 3 4 5 6 7 8 9 10 11 12 class Car : -- snip -- def update_odometer ( self , milage ): \"\"\"Set the odometer reading to a given value.\"\"\" self . odometer_reading = milage my_new_car = Car ( 'audi' , 'a4' , 2020 ) print ( my_new_car . get_descriptive_name ()) my_new_car . update_odometer ( 23 ) my_new_car . read_odometer () The only modification to Car is the addition of update_odometer() on line 4. This method takes in a mileage value and assigns it to self . odometer_reading . On line 11 we call update_odometer() and give it 23 as an argument (corresponding to the mileage parameter in the method definition). It sets the odometer reading to 23 , and read_odometer() prints the reading: 2020 Audi A4 This car has 23 miles on it. We can extend the method update_odometer() to do additional work every time the odometer reading is modified. Let's add a little logic to make sure no one tries to roll back the odometer reading: 1 2 3 4 5 6 7 8 9 10 11 12 class Car : -- snip -- def update_odometer ( self , mileage ): \"\"\" Set the odometer reading to a given value. Reject the change if it atempts to roll the odometer back. \"\"\" if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) Now update_odometer() checks that the new reading makes sense before modifying the attribute. If the new mileage, mileage , is greater than or equal to the existing mileage, self . odometer_reading , you can update the odometer reading to the new mileage (line 9). If the new mileage is less than the existing mileage, you'll get a warning that you can't roll back an odometer (line 12).","title":"Modifying an Attribute's Value Through a Method"},{"location":"py-classes/#incrementing-an-attributes-value-through-a-method","text":"Sometimes you'll want to increment an attribute's value by a certain amount rather than set an entirely new value. Say we buy a used car and put 100 miles on it between the time we buy it and the time we register it. Here's a method that allows us to pass this incremental amount and add that value to the odometer reading: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Car : -- snip -- def update_odometer ( self , mileage ): -- snip -- def increment_odometer ( self , miles ): \"\"\"Add the given amount to the odometer reading.\"\"\" self . odometer_reading += miles my_used_car = Car ( 'subaru' , 'outback' , 2016 ) print ( my_used_car . get_descriptive_name ()) my_used_car . update_odometer ( 23_500 ) my_used_car . read_odometer () my_used_car . update_odometer ( 100 ) my_used_car . read_odometer () This new method increment_odometer() at line 7 takes in a number of miles and adds this value to self . odometer_reading . On line 11 we create a used car, my_used_car . We set its odomoer to 23,500 by calling update_odometer() and passing it 23_500 on line 14. On line 16 we call increment_odometer() and pass it 100 to add the 100 miles that we drove between buying the car and registering it: 2015 Subaru Outback This car has 23500 miles on it. This car has 23600 miles on it. You can easily modify this method to reject negative increments so no one uses this function to roll back an odometer.","title":"Incrementing an Attribute's Value Through a Method"},{"location":"py-classes/#inheritance","text":"You don't always have to start from scratch when writing a class. If the class you're writing is a specialized version of another class you wrote, you can use inheritance . When one class inherits from another, it takes on the attributes and methods of the first class. The original class is called the parent class , and the new class is the child class . The child class can inherit any or all of the attributes and methods of its parent class, but it's also free to define new attributes and methods of its own.","title":"Inheritance"},{"location":"py-classes/#the-__init__-method-for-a-child-class","text":"When you're writing a new class based on an existing class, you'll often want to call the __init__() method from the parent class. This will initialize any attributes that were defined in the parent __init__() method and make them available in the child class. As an example, let's model an electric car. An electric car is just a specific kind of car, so we can base our new ElectricCar class on the Car class we wrote earlier. Then we'll only have to write code for the attributes and behavior specific to electric cars. Let's start by making a simple version of the ElectricCar class, which does everythin the Car class does: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Car : \"\"\"A simple attempt to represent a car.\"\"\" def __init__ ( self , make , model , year ): self . make = make self . model = model self . year = year self . odometer_reading = 0 def get_descriptive_name ( self ): long_name = f \" { self . year } { self . make } { self . model } \" return long_name . title () def read_odometer ( self ): print ( f \"This car has { self . odometer_reading } miles on it.\" ) def update_odometer ( self , mileage ): if mileage >= self . odometer_reading : self . odometer_reading = mileage else : print ( \"You can't roll back an odometer!\" ) def increment_odometer ( self , miles ): self . odometer_reading += miles class ElectricCar ( Car ): \"\"\"Represent aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\"Initialize attributes of the parent class.\"\"\" super () . __init__ ( make , model , year ) my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) On line 1 we start with Car . When you create a child class, the parent class must be part of the current file and must appear before the child class in the file. On line 25 we define the child class, ElectricCar . The name of the parent class must be included in the parentheses in the defintion of a child class. The __init__() method on line 28 takes in the information required to make a Car instance. The super() function on line 30 is a special function that allows you to call a method from the parent class. This line tells Python to call the __init__() method from Car , which gives and ElectricCar instance all the attributes fefined in that method. The name super comes from a convention of calling the parent class a superclass and the child class a subclass . We test whether inheritence is working properly by trying to create an electric car with the same kind of information we'd provide when making a regular car. On line 32 we make an instance of the ElectricCar class and assign it to my_tesla . This line calls the __init__() method defined in ElectricCar , which in turn tells Python to call the __init__() method defined in the parent class Car . We provide the arguments 'tesla' , 'model s' , and 2019 . Aside from __init__() , there are no attributes or methods yet that are particular to an electric car. At this point we're just making sure the car has the appropriate Car behaviors: 2019 Tesla Model S The ElectricCar instance works just like an instance of Car , so now we can begin defining attributes and methods specific to electric cars.","title":"The __init__() Method for a Child Class"},{"location":"py-classes/#defining-attributes-and-methods-for-the-child-class","text":"Once you have a child class that inherits from a parent class, you can add any new attributes and methods necessary to differentiate the child class from the parent class. Let's add an attribute that's specific to electric cars (a battery, for example) and a method to report on this attribute. We'll store the battery size and write a method that print a description of the battery: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Car : --- snip --- class ElectricCar ( Car ): \"\"\"Represents aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery_size = 75 def describe_battery ( self ): \"\"\"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . describe_battery () On line 13 we add a new attribute self . battery_size and set its initial value to 75 . This attribute will be associated with all instances created from the ElectricCar class but won't be associated with any instances of Car . We also add a method called describe_battery() that prints information about the battery on line 15. When we call this method, we get a description that is clearly specific to an electric car: 2019 Tesla Model S This car has a 75-kWh battery. There's no limit to how much you can specialize the ElectricCar class. You can add as many attributes and methods as you need to model an electric car to whatever degree of accuracy you need. An attribute or method that could belong to any car, rather than one that's specific to an electric car, should be added to the Car class instead of the ElectricCar class. Then anyone who uses the Car class will have that functionality available as well, and the ElectricCar class wil only contain code for the information and behavior specific to electric vehicles.","title":"Defining Attributes and Methods for the Child Class"},{"location":"py-classes/#overriding-methods-from-the-parent-class","text":"You can override any method from the parent class that doesn't fit what you're trying to model with the child class. To do this, you define a method in the child class with the same name as the method you want to override in the parent class. Python will disregard the parent class method and only pay attention to the method you define in the child class. Say the class Car had a method called fill_gas_tank () . This method is meaningless for an all-electric vehicle, so you might want to override this method. Here is one way to do that: 1 2 3 4 5 6 class ElectricCar ( Car ): -- snip -- def fill_gas_tank ( self ): \"\"\"Electric cars don't have gas tanks.\"\"\" print ( \"This car doesn't need a gas tank!\" ) Now if someone tries to call fill_gas_tank() with an electric car, Python will ignore the method fill_gas_tank() in Car and run this code instead. When you use inheritence, you can make your child classes retain what you need and override anything you don't need from the parent class.","title":"Overriding Methods from the Parent Class"},{"location":"py-classes/#instances-as-attributes","text":"When modeling something from the real world in code, you may find that you're adding more and more detail to a class. You'll find that you have a growing list of attributes and methods and that your files are becoming lengthy. In these situations, you might recognize that part of one class can be written as a separate class. You can break your large class into smaller classes that work together. For example, if we continue adding detail to the ElectricCar class, we might notice that we're adding many attributes and methods specific to the car's battery. When we see this happening, we can stop and move those attributes and methods to a separate class called Battery . Then we can use a Battery instance as an attribute in the ElectricCar class: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Car : -- snip -- class Battery : \"\"\"A simple attempt to model a battery for an electric car.\"\"\" def __init__ ( self , battery_size = 75 ): \"\"\"Initialize the battery's attributes.\"\"\" self . battery_size = battery_size def describe_battery ( self ): \"Print a statement describing the battery size.\"\"\" print ( f \"This car has a { self . battery_size } -kWh battery.\" ) class ElectricCar ( Car ): \"represents aspects of a car, specific to electric vehicles.\"\"\" def __init__ ( self , make , model , year ): \"\"\" Initialize attributes of the parent class. Then initialize attributes specific to an electric car. \"\"\" super () . __init__ ( make , model , year ) self . battery = Battery () my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . battery . describe_battery () On line 4 we define a new class called class Battery that doesn't inherit from any other class. The __init__ () method on line 7 has one parameter battery_size , in addition to self . This is an optional parameter that sets the battery's size to 75 if no value is provided. The method describe_battery () has been moved to this class as well (line 11). In the ElectricCar class, we now add an attribute called self . battery (line 24). This line tells Python to create a new instance of Battery (with a default size of 75 because we're not specifying a value) and assign that instance to the attribute self.battery . This will happen every time the __init__ () method is called; and ElectricCar instance will now have a Battery instance created automatically. We create an electric car and assign it to the variable my_tesla . When we want to describe the battery, we need to work through the car's battery attribute: 1 my_tesla . batter . describe_battery () This line tells Python to look at the instance of my_tesla , find its battery attribute, and call the method describe_battery() that's associated with the Battery instance stored in the attribute. The output is identical to what we saw previously: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Car : -- snip -- class Battery : -- snip -- def get_range ( self ): \"\"\"Print a statement about the range this battery provides.\"\"\" if self . battery_size == 75 : range = 260 elif self . battery_size == 100 : range = 315 class ElectricCar ( Car ): -- snip -- my_tesla = ElectricCar ( 'tesla' , 'model s' , 2019 ) print ( my_tesla . get_descriptive_name ()) my_tesla . battery . describe_battery () my_tesla . battery . get_range () The new method get_range() on line 7, performs some simple analysis. If the battery's capacity is 75 kWh, get_range() sets the range to 260 miles, and if the capacity is 100 kWh, it sets the range to 315 miles. It then reports this value. When we want to use this method, we again have to call it through the car's battery attribute on line 21. The output tells us the range of the car based on its battery size: 2019 Tesla Model S This car has a 75-kWh battery. This car can go about 260 mile son a full charge.","title":"Instances as Attributes"},{"location":"py-classes/#modeling-real-world-objects","text":"","title":"Modeling Real-World Objects"},{"location":"py-data-types/","text":"Variables and Simple Data Types Variables Let's go back to the first program and use a variable. To do this, we simply add a new line at the beginning of the file and modify the second line: 1 2 message = \"Hello Python World!\" print ( message ) We have now created a variable named message . Every variable is connected to a value , which is the information associated with that variable. In this case the value is the Hello Python World! text. Adding a variable makes a little more work for the Python interpreter. When it processes the first line, it associates the variable message with the Hello Python World! text. When it reaches the second line, it prints the value associated with message to the screen. Naming and Using Variables When you're using variables in Python, you need to adhere to a few rules and guidelines. breaking some of these rules will cause errors; other guidelines just help you write code that's easier to read and understand. Be sure to keep the following variable rules in mind: Variable names can contain only letters, numbers and underscores. They can start with a letter or underscore, but not with a number. Spaces are not allowed in variable names, underscores should be used instead. Avoid using Python keywords and function names as variable names that serve a particular programmatic purpose. This could cause many different problems. Variable names should be short but descripitve. For example, name is better than n . Be careful when using the lowercase l and the uppercase letter O because they could be confused with the numbers 1 and 0 . Strings Because most programs define and gather some sort of data, and then do something useful with it, it helps to classify different types of data. The first data type we'll look at is the string . Strings are quite simple at first glance, but you can use them in many different ways. A string is a series of characters. Anything inside quotes is considered a string in Python, and you can use single or double quotes around your strings like this: 1 2 \"This is a string\" 'This is also a string' This flexibility allows you to use quotes and apostrophes within your strings: 1 'I told my friend, \"Python is my favorite language!\"' Changing Case in a String with Methods One of the simplest tasks you can do with strings is change the case of the words in a string: 1 2 name = \"ada lovelace\" print ( name . title ()) In the above example, the variable name refers to the lowercase string ada lovelace / The method title () appears after the variable in the print () call. A method is an action that Python can perform on a piece of data. The dot (.) after name in name . title () tells Python to make the title() method act on the variable name . The title () method changes each word to title case, where each word begins with a capital letter. This is useful because you'll often want to think of a name as a piece of information. For example, you might want to program the input values of Ada . ADA , and ada as the same name, and display them all as Ada . Several other useful methods are available for dealing with case as well. For example, you can change a string to all uppercase or all lowercase letters like this: 1 2 3 name = \"Ada Lovelace\" print ( name . upper ()) print ( name . lower ()) This will display the following: ADA LOVELACE ada lovelace Using Variables in Strings In some situations, you may want to use a variable's name inside a string. For example, you might want two variables to represent a first name and a last name respectively, and then want to combine those values to display someone's full name: 1 2 3 4 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" print ( full_name ) To insert a variable's value into a string, place the letter f immediately before the opening quoatation mark. Put braces around the name or names of any variable you want to use inside the string. Python will replace each variable with its value when the string is displayed. These strings are called f-strings . The f is for format , because Python formats the string by replaceing the name of any variable in braces with its value. You can do a lot with f-strings. For example, you can use f-strings to compose complete messages using the information associated with a variable: 1 2 3 4 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" print ( f \"Hello, { full_name . title () } !\" ) The above code would display the following: Hello, Ada Lovelace! We can actually make this even simpler, by assigning the entire message to a variable: 1 2 3 4 5 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" message = f \"Hello, { full_name . title () } !\" print ( message ) The final print() call is much simpler in this case. f-string compatibility f-strings were first introduced in Python 3.6. If you are using Python 3.5 or earlier, you must use the format () method rather than the above f syntax. To use format () , list the variables you want to use in the string inside the parentheses following format. Each variable is referred to by a set of braces; the braces will be filled by the values listed in parentheses in the order provided: 1 full_name = \" {} {} \" . format ( first_name , last_name ) Adding Whitespace to Strings with Tabs or Newlines In programming, whitespace refers to any nonprinting character, such as spaces, tabs, and end-of-line symbols. You can use whitespace to organize your output so it's easier for users to read. To add a tab to your text, use the character combination \\t . To add a newline in a string, use the character combination \\n . You can also combine tabs and newlines in a single string. The string \\n\\t tells Python to move to a new line and start the next line with a tab. Stripping Whitespace Extra whitespace can be confusing in your programs. To programmers, 'python' and 'python ' look pretty much the same, but to a program, they are two different strings. Puthon detects the extra space in 'python ' and considers it significant unless you tell it otherwise. It is important to think about whitespace, because often you'll want to compare two strings to determine whether they are the same. For example, one important instance might involve checking people's usernames when they login to a website. Extra whitespace can be confusing in much simpler situations as well. Fortunately, Python makes it simple to eliminate extraneous whitespace from data that people enter. Python can look for extra whitespace on the right and left sides of a string. To ensure that no whitespace exists at the right end of a string, use the rstrip () method. 1 2 3 4 5 6 7 favorite_language = 'python ' favorite_language >>> 'python ' favorite_language . rstrip () >>> 'python' Running the above code with the rstrip () method does not permanently remove the whitespace at the end of the string. If the code was run again without the rstrip () , the extra whitespace would appear again. Avoiding Syntax Errors with Strings One kind of error that you mught see with some regularity is a syntax error. A syntax error occurs when Python doesn't recognize a section of your program as valid Python code. For example, if you use an apostrophe within single quotes, you will produce an error. This happens because Python interprets everything between the first single quote and the apostrophe as a string. Luckily, Python will let you know where the error is located and will try it's best to say what the problem is. Sometimes, the error is straight forward, but sometimes, it will require additional research to find a solution. Numbers Numbers are used quite often in programming to keep score in games, represent data in visualizations, store information in web applications, and so on. Python treats numbers in several different ways. Let's first take a look at how Python manages integers, because they are the simplest to work with: You can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) integers in Python. 1 2 3 4 5 6 7 8 9 10 11 >>> 2 + 3 5 >>> 3 - 2 1 >>> 2 * 3 6 >>> 3 / 2 1.5 In a terminal session, Python simply returns the result of the operation. Python uses two multiplication symbols to represent exponents: 1 2 3 4 5 6 7 8 >>> 3 ** 2 9 >>> 3 ** 3 27 >>> 10 ** 6 1000000 Python supports the order of operations too, so you can use multiple operations in one expression. You can also use parentheses to modify the order of operations so Python can evaluate your expression in the order you specify. For example: 1 2 3 4 5 >>> 2 + 3 * 4 14 >>> ( 2 + 3 ) * 4 20 Floats Python calls any number with a decimal point a float . This term is used in most programming languages (like in C ), and it refers to the fact that a decimal point can appear at any position in a number. Every programming language must be carefully designed to properly manage decimal numbers so numbers behave appropriately no matter where the decimal point appears. For the most part, you cnas use decimals without worrying how they behave. Simply enter the numbers you want to use, and Python will most likely do what you expect: 1 2 3 4 5 >>> 0.1 + 0.1 0.2 >>> 0.2 * 0.2 0.4 But beware, sometimes you will get an arbitrary number of decimals in your answer: 1 2 3 4 5 >>> 0.2 + 0.1 0.3000000000000004 >>> 0.3 * 0.1 0.3000000000000004 This happens in all languages and is of little concern. Python tries to find a way to represent the result as precisely as possible, which is sometimes difficult given how computers have to represent numbers internally. Integers and Floats When you divide any two numbers, even if they are integers that result in a whole number, you'll always get a float: 1 2 >>> 4 / 2 2.0 If you mix an integer and a float in any operation, you'll get a float as well. Python defaults to a float in any operation that uses a float, even if the output is a whole number. Underscores in Numbers When you're writing long numbers, you can group digits using underscores to make large numbers more readable in code: 1 universe_age = 14_000_000_000 When you print a number that was defined with underscores, Python only prints the digits. Even if the numbers are not grouped in threes, Python will still ignore the underscores. This feature works for both integers and floats, but only in Python 3.6 and later. Multiple Assignment You can assign values to more than one variable using just a single line. This can help shorten your programs and make them easier to read; you'll use this technique most often when initializing a set of number. For example, here is how you can initialize the variables x , y , and z to zero: 1 x , y , z = 0 , 0 , 0 You need to separate the variable names with commas, and do the same with the values, and Python will assign each value to its respectively positioned variable. As long as the number of values matches the number of variables, Python will match them up correctly. Constants A constant is like a variable whose value stays the same throughout the life of a program. Python doesn't have built-in constant types, but Python programmers use all capital letters to indicate a variable should be treated as a constant and never be changed: 1 MAX_CONNECTIONS = 5000 Comments Comments are an extremely useful feature in most programming languages. Adding a hash mark (#) indicates a comment. Anything following a hash mark in your code is ignored by the Python interpreter until a new line of code is detected. Comments should be written throughout your program to help whoever is reading it understand what does what.","title":"Variables and Simple Data Types"},{"location":"py-data-types/#variables-and-simple-data-types","text":"","title":"Variables and Simple Data Types"},{"location":"py-data-types/#variables","text":"Let's go back to the first program and use a variable. To do this, we simply add a new line at the beginning of the file and modify the second line: 1 2 message = \"Hello Python World!\" print ( message ) We have now created a variable named message . Every variable is connected to a value , which is the information associated with that variable. In this case the value is the Hello Python World! text. Adding a variable makes a little more work for the Python interpreter. When it processes the first line, it associates the variable message with the Hello Python World! text. When it reaches the second line, it prints the value associated with message to the screen.","title":"Variables"},{"location":"py-data-types/#naming-and-using-variables","text":"When you're using variables in Python, you need to adhere to a few rules and guidelines. breaking some of these rules will cause errors; other guidelines just help you write code that's easier to read and understand. Be sure to keep the following variable rules in mind: Variable names can contain only letters, numbers and underscores. They can start with a letter or underscore, but not with a number. Spaces are not allowed in variable names, underscores should be used instead. Avoid using Python keywords and function names as variable names that serve a particular programmatic purpose. This could cause many different problems. Variable names should be short but descripitve. For example, name is better than n . Be careful when using the lowercase l and the uppercase letter O because they could be confused with the numbers 1 and 0 .","title":"Naming and Using Variables"},{"location":"py-data-types/#strings","text":"Because most programs define and gather some sort of data, and then do something useful with it, it helps to classify different types of data. The first data type we'll look at is the string . Strings are quite simple at first glance, but you can use them in many different ways. A string is a series of characters. Anything inside quotes is considered a string in Python, and you can use single or double quotes around your strings like this: 1 2 \"This is a string\" 'This is also a string' This flexibility allows you to use quotes and apostrophes within your strings: 1 'I told my friend, \"Python is my favorite language!\"'","title":"Strings"},{"location":"py-data-types/#changing-case-in-a-string-with-methods","text":"One of the simplest tasks you can do with strings is change the case of the words in a string: 1 2 name = \"ada lovelace\" print ( name . title ()) In the above example, the variable name refers to the lowercase string ada lovelace / The method title () appears after the variable in the print () call. A method is an action that Python can perform on a piece of data. The dot (.) after name in name . title () tells Python to make the title() method act on the variable name . The title () method changes each word to title case, where each word begins with a capital letter. This is useful because you'll often want to think of a name as a piece of information. For example, you might want to program the input values of Ada . ADA , and ada as the same name, and display them all as Ada . Several other useful methods are available for dealing with case as well. For example, you can change a string to all uppercase or all lowercase letters like this: 1 2 3 name = \"Ada Lovelace\" print ( name . upper ()) print ( name . lower ()) This will display the following: ADA LOVELACE ada lovelace","title":"Changing Case in a String with Methods"},{"location":"py-data-types/#using-variables-in-strings","text":"In some situations, you may want to use a variable's name inside a string. For example, you might want two variables to represent a first name and a last name respectively, and then want to combine those values to display someone's full name: 1 2 3 4 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" print ( full_name ) To insert a variable's value into a string, place the letter f immediately before the opening quoatation mark. Put braces around the name or names of any variable you want to use inside the string. Python will replace each variable with its value when the string is displayed. These strings are called f-strings . The f is for format , because Python formats the string by replaceing the name of any variable in braces with its value. You can do a lot with f-strings. For example, you can use f-strings to compose complete messages using the information associated with a variable: 1 2 3 4 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" print ( f \"Hello, { full_name . title () } !\" ) The above code would display the following: Hello, Ada Lovelace! We can actually make this even simpler, by assigning the entire message to a variable: 1 2 3 4 5 first_name = \"ada\" last_name = \"lovelace\" full_name = f \" { first_name } { last_name } \" message = f \"Hello, { full_name . title () } !\" print ( message ) The final print() call is much simpler in this case. f-string compatibility f-strings were first introduced in Python 3.6. If you are using Python 3.5 or earlier, you must use the format () method rather than the above f syntax. To use format () , list the variables you want to use in the string inside the parentheses following format. Each variable is referred to by a set of braces; the braces will be filled by the values listed in parentheses in the order provided: 1 full_name = \" {} {} \" . format ( first_name , last_name )","title":"Using Variables in Strings"},{"location":"py-data-types/#adding-whitespace-to-strings-with-tabs-or-newlines","text":"In programming, whitespace refers to any nonprinting character, such as spaces, tabs, and end-of-line symbols. You can use whitespace to organize your output so it's easier for users to read. To add a tab to your text, use the character combination \\t . To add a newline in a string, use the character combination \\n . You can also combine tabs and newlines in a single string. The string \\n\\t tells Python to move to a new line and start the next line with a tab.","title":"Adding Whitespace to Strings with Tabs or Newlines"},{"location":"py-data-types/#stripping-whitespace","text":"Extra whitespace can be confusing in your programs. To programmers, 'python' and 'python ' look pretty much the same, but to a program, they are two different strings. Puthon detects the extra space in 'python ' and considers it significant unless you tell it otherwise. It is important to think about whitespace, because often you'll want to compare two strings to determine whether they are the same. For example, one important instance might involve checking people's usernames when they login to a website. Extra whitespace can be confusing in much simpler situations as well. Fortunately, Python makes it simple to eliminate extraneous whitespace from data that people enter. Python can look for extra whitespace on the right and left sides of a string. To ensure that no whitespace exists at the right end of a string, use the rstrip () method. 1 2 3 4 5 6 7 favorite_language = 'python ' favorite_language >>> 'python ' favorite_language . rstrip () >>> 'python' Running the above code with the rstrip () method does not permanently remove the whitespace at the end of the string. If the code was run again without the rstrip () , the extra whitespace would appear again.","title":"Stripping Whitespace"},{"location":"py-data-types/#avoiding-syntax-errors-with-strings","text":"One kind of error that you mught see with some regularity is a syntax error. A syntax error occurs when Python doesn't recognize a section of your program as valid Python code. For example, if you use an apostrophe within single quotes, you will produce an error. This happens because Python interprets everything between the first single quote and the apostrophe as a string. Luckily, Python will let you know where the error is located and will try it's best to say what the problem is. Sometimes, the error is straight forward, but sometimes, it will require additional research to find a solution.","title":"Avoiding Syntax Errors with Strings"},{"location":"py-data-types/#numbers","text":"Numbers are used quite often in programming to keep score in games, represent data in visualizations, store information in web applications, and so on. Python treats numbers in several different ways. Let's first take a look at how Python manages integers, because they are the simplest to work with: You can add ( + ), subtract ( - ), multiply ( * ) and divide ( / ) integers in Python. 1 2 3 4 5 6 7 8 9 10 11 >>> 2 + 3 5 >>> 3 - 2 1 >>> 2 * 3 6 >>> 3 / 2 1.5 In a terminal session, Python simply returns the result of the operation. Python uses two multiplication symbols to represent exponents: 1 2 3 4 5 6 7 8 >>> 3 ** 2 9 >>> 3 ** 3 27 >>> 10 ** 6 1000000 Python supports the order of operations too, so you can use multiple operations in one expression. You can also use parentheses to modify the order of operations so Python can evaluate your expression in the order you specify. For example: 1 2 3 4 5 >>> 2 + 3 * 4 14 >>> ( 2 + 3 ) * 4 20","title":"Numbers"},{"location":"py-data-types/#floats","text":"Python calls any number with a decimal point a float . This term is used in most programming languages (like in C ), and it refers to the fact that a decimal point can appear at any position in a number. Every programming language must be carefully designed to properly manage decimal numbers so numbers behave appropriately no matter where the decimal point appears. For the most part, you cnas use decimals without worrying how they behave. Simply enter the numbers you want to use, and Python will most likely do what you expect: 1 2 3 4 5 >>> 0.1 + 0.1 0.2 >>> 0.2 * 0.2 0.4 But beware, sometimes you will get an arbitrary number of decimals in your answer: 1 2 3 4 5 >>> 0.2 + 0.1 0.3000000000000004 >>> 0.3 * 0.1 0.3000000000000004 This happens in all languages and is of little concern. Python tries to find a way to represent the result as precisely as possible, which is sometimes difficult given how computers have to represent numbers internally.","title":"Floats"},{"location":"py-data-types/#integers-and-floats","text":"When you divide any two numbers, even if they are integers that result in a whole number, you'll always get a float: 1 2 >>> 4 / 2 2.0 If you mix an integer and a float in any operation, you'll get a float as well. Python defaults to a float in any operation that uses a float, even if the output is a whole number.","title":"Integers and Floats"},{"location":"py-data-types/#underscores-in-numbers","text":"When you're writing long numbers, you can group digits using underscores to make large numbers more readable in code: 1 universe_age = 14_000_000_000 When you print a number that was defined with underscores, Python only prints the digits. Even if the numbers are not grouped in threes, Python will still ignore the underscores. This feature works for both integers and floats, but only in Python 3.6 and later.","title":"Underscores in Numbers"},{"location":"py-data-types/#multiple-assignment","text":"You can assign values to more than one variable using just a single line. This can help shorten your programs and make them easier to read; you'll use this technique most often when initializing a set of number. For example, here is how you can initialize the variables x , y , and z to zero: 1 x , y , z = 0 , 0 , 0 You need to separate the variable names with commas, and do the same with the values, and Python will assign each value to its respectively positioned variable. As long as the number of values matches the number of variables, Python will match them up correctly.","title":"Multiple Assignment"},{"location":"py-data-types/#constants","text":"A constant is like a variable whose value stays the same throughout the life of a program. Python doesn't have built-in constant types, but Python programmers use all capital letters to indicate a variable should be treated as a constant and never be changed: 1 MAX_CONNECTIONS = 5000","title":"Constants"},{"location":"py-data-types/#comments","text":"Comments are an extremely useful feature in most programming languages. Adding a hash mark (#) indicates a comment. Anything following a hash mark in your code is ignored by the Python interpreter until a new line of code is detected. Comments should be written throughout your program to help whoever is reading it understand what does what.","title":"Comments"},{"location":"py-dictionaries/","text":"Dictionaries Understanding dictionaries allows you to model a variety of real-world objects more accurately. For example, we could create a dictionary representing a person and then store as much information as we want about that person. You can store their name, location, age, profession, and any other aspect of a person you can describe. We can store any two kinds of information that can be matched up, such as a list of words and their meanings, a list of people's names and their favorite numbers, a list of mountains and their elevations, etc. A Simple Dictionary Consider a game featuring aliens that can have different colors and point values. This simple dictionary stores information about a particular alien: 1 2 3 4 alien_0 = { 'color' : 'green' , 'points' : 5 } print ( alien_0 [ 'color' ]) print ( alien_0 [ 'points' ]) The dictionary alien_0 stores the alien's color and point value. The last two lines access and display that information, as shown here: green 5 As with most new programming concepts, using dictionaries takes practice. Once you've worked with dictionaries for a bit, you'll soon see how effectively they can model real-world situations. Working with Dictionaries A dictionary in Python is a collection of key-value pairs . Each key is connected to a value, and you can use a key to access the value associated with that key. A key's value can be a number, a string, a list, or even another dictionary. In fact, you can use any object that you can create in Python as a value in a dictionary. In Python, a dictionary is wrapped in braces, { }, with a series of key-value pairs inside the braces, as shown in the earlier example: alien_0 = { 'color' : 'green' , 'points' : 5 } A key-value pair is a set of values associated with each other. When you provide a key, Python returns the value associated with that key. Every key is connected to its value by a colon, and individual key-value pairs are separated by commas. You can store as many key-value pairs as you want in a dictionary. The simplest dictionary has exactly one key-value pair, as shown in this modified version of the alien_0 dictionary: alien_0 = { 'color' : 'green' } This dictionary stores one piece of information about alien_0 , namely the alien's color. The string 'color' is a key in this dictionary, and its associated value is 'green' . Accessing Values in a Dictionary To get the value associated with a key, give the name of the dictionary and then place the key inside a set of square brackets, as shown here: 1 2 alien_0 = { 'color' : 'green' } print ( alien_0 [ 'color' ]) This returns the value associated with the key 'color' from the dictionary alien_0 : green You can have an ulimited number of key-value pairs in a dictionary. For example, here's the original alien_0 dictionary with two key-value pairs: alien_0 = { 'color' : 'green' , 'points' : 5 } Now you can access either the color or the point value of alien_0 . If a player shoots down this alien, you can look up how many points they should earn using code like this: 1 2 3 4 alien_0 = { 'color' : 'green' , 'points' : 5 } new_points = alien_0 [ 'points' ] print ( f \"You just earned { new_points } points!\" ) Once the dictionary has been defined, the code on line 3 pulls the value associated with the key 'points' from the dictionary. This value is then assigned to the variable 'new_points' . The code on line 4 then prints a statement about how many points the player just earned. Adding New Key-Value Pairs Dictionaries are dynamic structures, and you can add new key-value pairs to a dictionary at any time. For example, to add a new key-value pair, you would give the name of the dictionary followed by the new key in square brackets along with the new value. Let's add two new pieces to the alien_0 dictionary: the alien's x- and y- coordinates, which will help us display the alien in a particular position on the screen. Let's place the alien on the left edge of the screen, 25 pixels down from the top. Because screen coordinates usually start at the upper-left corner of the screen, we'll place the alien on the left edge of the screen by setting the x-coordinate to 0 and 25 pixels from the top by setting the y-coordinate to positive 25: 1 2 3 4 5 6 alien_0 = { 'color' : 'green' , 'points' : '5' } print ( alien_0 ) alien_0 [ 'x_position' ] = 0 alien_0 [ 'y_position' ] = 25 print ( alien_0 ) We start by defining the same dictionary that we have been working with. We then print this dictionary, displaying a snapshot of its information. On line 4, we add a new key-value pair to the dictionary: key 'x_position' and a value of 0 . We do the same for key 'y_position' on the next line. Finally, when we print the modified dictionary, we see the two additional key-value pairs: {'color': 'green', 'points': '5'} {'color': 'green', 'points': '5', 'x_position': 0, 'y_position': 25} The final version of the dictionary contains four key-value pairs. Starting with an Empty Dictionary It's sometimes convenient, or even necessary, to start with an empty dictionary and then add each new item to it. To start filling an empty dictionary, define a dictionary with an empty set of braces and then add each key-value pair on its own line. For example, here's how to build the alien_0 dictionary using this approach: 1 2 3 4 5 6 alien_0 = {} alien_0 [ 'color' ] = 'green' alien_0 [ 'points' ] = '5' print ( alien_0 ) Here we define an empty alien_0 dictionary, and then add color and point values to it. The result is the dictionary we have been usinging in previous examples: {'color': 'green', 'points': '5'} Typically, you'll use empty dictionaries when storing user-supplied data in a dictionary or when you write code that generates a large number of key-value pairs automatically. Modifying Values ina Dictionary To modify a value in a dictionary, give the name of the dictionary with the key in square brackets and then the new value you want associated with that key. For example, consider an alien that changes from green to yellow as a game progresses: 1 2 3 4 5 alien_0 = { 'color' : 'green' } print ( f \"The alien is { alien_0 [ 'color' ] } .\" ) alien_0 [ 'color' ] = 'yellow' print ( f \"The alien is now { alien_0 [ 'color' ] } .\" ) We first define a dictionary for alien_0 that contains only the aliens color; then we change the value associated with the key 'color' to 'yellow' . The output shows that the alien has indeed changed from green to yellow: The alien is green. The alien is now yellow. For a more interesting example, let's track the position of an alien that can move at different speeds. We'll sotre a value representing the alien's current speed and then use it to determine how far to the right the alien should move: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 alien_0 = { 'x_position' : 0 , 'y_position' : 25 , 'speed' : 'medium' } print ( f \"Original position: { alien_0 [ 'x_position' ] } \" ) # Move the alien to the right. # Determine how far to move the alien based on its current speed. if alien_0 [ 'speed' ] == 'slow' : x_increment = 1 elif alien_0 [ 'speed' ] == 'medium' : x_increment = 2 else : # This must be a fast alien. x_increment = 3 # The new position is the old position plus the increment. alien_0 [ 'x_position' ] = alien_0 [ 'x_position' ] + x_increment print ( f \"New position: { alien_0 [ 'x_position' ] } \" ) We start by defining an alien with an initial x and y position, and a speed of 'medium' . We also print the original value of x_position to see how far the alien moves to the right. On line 5, an if - elif - else chain determins how far the alien should move to the right and assigns this value to the variable x_increment . If the alien's speed is 'slow' , it moves one unit, if it is 'medium' , it moves two, and if it is 'fast' , it moves three. Once the increment has been calculated, it is added to the value of x_position on line 13 and the result is stored in the dictionary's x_position . Because this is a medium-speed alien, its position shifts two units to the right: Original position: 0 New position: 2 This technique is pretty cool: by changing one value in the alien's dictionary, you can change the overall behavior of the alien. For example, to turn this medium-speed alien into a fast alien, you would add the line: alien_0 [ 'speed' ] = 'fast' The if-elif-else block would then assign a larger value to x_increment the next time the code runs. Removing Key-Value Pairs When you no longer need a piece of information that is stored ina dictionary, you can you the del statement to completely remove a key-value pair. All del needs is the name of the dictionary and the key that you want to remove. For example, let's remove the key 'points' from the alien_0 dictionary along with its value: 1 2 3 4 5 alien_0 = { 'color' : 'green' , 'points' : 5 } print ( alien_0 ) del alien_0 [ 'points' ] print ( alien_0 ) The code on line 4 tells Python to delete the key 'points' from the dictionary alien_0 and to remove the value associated with that key as well. The output shows that the key 'points' and its value of 5 are deleted from the dictionary, and the rest is unaffected: {'color': 'green', 'points': 5} {'color': 'green'} A Dictionary of Similar Objects The previous example involved storing different kinds of information about one object, an alien in a game. You can also use a dictionary to store one kind of information about many objects. For example, a dictionary of a group of people's favorite programming language. A dictionary for this could look like: 1 2 3 4 5 6 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } As you can see, we've broken a larger dictionary into several lines (mainly for better readability). Each key is the name of a person and each value is their favorite language. When you know you'll need more than one line to define a dictionary, press ENTER after the opening brace. Then indent the next line one tab, and write your first key-value pair, followed by a comma. Once you have finished defining the dictionary, add a closing brace on a new line after the last key-value pair and indent it one level so it aligns with the keys in the dictionary. It's good practice to include a comma after the last key-value pair, just in case you want to add more in the future. To use this dictionary, given the name of a person, you can easily look up their favorite language: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } language = favorite_languages [ 'sarah' ] . title () print ( f \"Sarah's favorite langugage is { language } .\" ) To see which language Sarah chose, we ask for the value at: favorite_languages [ 'sarah' ] We use this syntax to pull Sarah's favorite language from the dictionary (line 8) and assign it to the variable language . Creating a new variable here makes for a much cleaner print () call. The output shows Sarah's favorite Language: Sarah's favorite langugage is C. Using get () to Access Values Using keys in square brackets to retrieve the value you're interested in from a dictionary might cause one potential problem: if the key you ask for doesn't exist, you'll get an error. Let's see what happens when you ask for the point value of an alien that doesn't have a point value set: 1 2 alien_0 = { 'color' : 'green' , 'speed' : 'slow' } print ( alien_0 [ 'points' ]) This results in a traceback, showing a KeyError: KeyError Traceback (most recent call last) <ipython-input-9-3914d637e9f3> in <module> 1 alien_0 = {'color': 'green', 'speed': 'slow'} ----> 2 print(alien_0['points']) KeyError: 'points' For dictionaries, we can use the get () method to set a default value that will be returned if the requested key doesn't exist. The get () method requires a key as a first argument. As a second optional argument, you can pass the value to be returned if the key doesn't exist: 1 2 3 4 alien_0 = { 'color' : 'green' , 'speed' : 'slow' } point_value = alien_0 . get ( 'points' , 'No point value assigned.' ) print ( point_value ) If the key 'points' exists in the dictionary, you'll get corresponding value. If it doesn't, you get the default value. In this case, points doesn't exist, and we get a clean message instead of an error: No point value assigned. If there's a chance the key you're asking for might not exist, consider using the get () method instead of the square bracket notation. Looping Through a Dictionary A single Python dictionary can contain just a few key-value pairs or millions of pairs. Because a dictionary can contain large amounts of data, Python lets you loop through a dictionary. Dictionaries can be used to store information in a variety of ways; therefore, several different ways exist to loop through them. You can loop through all of a dictionary's key-value pairs, through its keys, or its values. Looping Through All Key-Value Pairs Before we explore the different approaches to looping, let's consider a new dictionary designed to store information about a user on website. The following dictionary would store one person's username, first name, and last name: 1 2 3 4 5 user_0 = { 'username' : 'efermi' 'first' : 'enrico' 'last' : 'fermi' } You can access any single piece of information about user_0 based on what you've already learned in this chapter. But what if you wanted to see everything stored in this user's dictionary? To do so, you could loop through the dictionary using a for loop. 1 2 3 4 5 6 7 8 9 user_0 = { 'username' : 'efermi' , 'first' : 'enrico' , 'last' : 'fermi' , } for key , value in user_0 . items (): print ( f \" \\n Key: { key } \" ) print ( f \"Value: { value } \" ) As shown on line 7, to write a for loop for a dictionary, you create names for the two variables that will hold the key and value in each key-value pair. You can choose any names you want for these two variables. This code would work just as well if you had used abbreviated for the variable names, like this: for k , v in user_0 . items () The second half of the for statement on line 7 includes the name of the dictionary followed by the method items() , which returns a list of key-value pairs. The for loop then assigns each of these pairs to the two vairbales provided. In the preceding example, we use the variables to print each key (line 8), followed by the associated value (line 9). The \"\\n\" in the first print () call ensures that a blank line is inserted bfore each key-value pair in the output: Key: username Value: efermi Key: first Value: enrico Key: last Value: fermi Looping through all key-value pairs works particularly well for dictionaries like the favorite_languages example from above , which stores the same kind of information for many different keys. If you loop through the favorite_languages dictionary, you get the name of each person in the dictionary and their favorite programming language. Because the keys always refer to a person's name and the value is always language, we'll use the variables name and language in the loop, instead of key and value . This will make it easier to follow what's happening inside the loop: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name , language in favorite_languages . items (): print ( f \" { name . title () } 's favorite language is { language . title () } !\" ) The code on line 8 tells Python to loop through each key-value pair in the dictionary. As it works through each pair the key is assigned to the variable name , and the value is assigned to the variable language . These descriptive names make it much easier to see what the print () call on line 9 is doing. Now, in just a few lines of code, we can display all the information from the poll: Jen's favorite language is Python! Sarah's favorite language is C! Edward's favorite language is Ruby! Phil's favorite language is Python! This type of looping would work just as well if our dictionary stored the results from polling a thousand or even a million people. Looping Through All The Keys in a Dictionary The keys() method is useful when you don't need to work with all of the values in a dictionary. Let's loop through the favorite_languages dictionary and print the names of everyone who answered: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name in favorite_languages . keys (): print ( name . title ()) The code on line 8 tells Python to pull all the keys from the dictionary favorite_languages and assign them one at a time to the variable name . The output shows the names of everyone who answered: Jen Sarah Edward Phil Looping through the keys is actually the default behavior when looping through a dictionary, so this code would have exactly the same output if you wrote: for name in favorite_languages : rather than: for name in favorite_languages . keys (): You can choose to use the keys() method explicitly if it makes your code easier to read, or you can omit it if you wish. You can access the value associated with any key you care about inside the loop by using the current key. Let's print a message to a couple of friends about the languages they chose. We'll loop through the names in the dictionary as we did previously, but when the name matches on of our friends, we'll display a message about their favorite language: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } friends = [ 'phil' , 'sarah' ] for name in favorite_languages . keys (): print ( f \"Hi, { name . title () } .\" ) if name in friends : language = favorite_languages [ name ] . title () print ( f \" \\t { name . title () } , I see you love { language } !\" ) On line 8 we make a list of friends that we want to print a message to. Inside the loop, we print each person's name. Then on line 12 we check whether the name we're working with is in the list friends . If it is, we determine the person's favorite language using the name of the dictionary and the current value of name as the key (line 13). We then print a special greeting, including a reference to their language of choice. Everyone's name is printed, but our friends receive a special message: Hi, Jen. Hi, Sarah. Sarah, I see you love C! Hi, Edward. Hi, Phil. Phil, I see you love Python! You can also use the keys() method to find out if a particular person was polled. This time, let's find out if Erin took the poll: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } if 'erin' not in favorite_languages . keys (): print ( \"Erin, please take our poll!\" ) The keys() method isn't just for looping: it actually returns a list of all the keys, and the code on line 8 simply checks if 'erin' is in the list. Because she is not, a message is printed inviting her to take the poll. Looping Through a Dictionary's Keys in a Particular Order Starting in Python 3.7, looping through a dictionary returns the items in the same order they were inserted. Sometimes, though, you'll want to loop through a dictionary in a different order. One way to do this is to sort the keys as they're retunred in the for loop. You can use the sorted () function to get a copy of the keys in order: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name in sorted ( favorite_languages . keys ()): print ( f \" { name . title () } , thank you for taking the poll.\" ) This for statement is like other for statements except that we've wrapped the sorted () function around the dictionary . keys () method. This tells Python to list all keys in the dictionary and sort that list before looping through it. The output shows everyone who took the poll, with the names displayed in order: Edward, thank you for taking the poll. Jen, thank you for taking the poll. Phil, thank you for taking the poll. Sarah, thank you for taking the poll. Looping Through All Values in a Dictionary If you are primarily interested in the values that a dictionary contains, you can use the values () method to return a list of values without any keys. For example, say we simply want a list of all languages chosen in our programming language poll without the name of the person who chose each language: 1 2 3 4 5 6 7 8 9 10 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } print ( \"The following languages have been mentioned:\" ) for language in favorite_languages . values (): print ( language . title ()) The for statement here pulls each value from the dictionary and assigns it to the variable language . When these values are printed, we get a list of all chosen languages: The following languages have been mentioned: Python C Ruby Python This approach pulls all the values from the dictionary without checking for repeats. That might work fine with a small number of values, but in a poll with a large number of respondents, this would result in a very repetitive list. To see each language chosen without repitionm we can use a set. A set is a collection in which each item must be unique. We can use the following for loop in place of the one used above: for language in set ( favorite_languages . values ()): When you wrap set () around a list that contains duplicate items, Python identifies the unique items in the list and build a set from those items. The result is a nonrepetitive list of languages that have been menetioned: The following languages have been mentioned: C Ruby Python Nesting Sometimes you'll want to store multiple dictionaries in a list, or a list of items as a value in a dictionary. This is called nesting . You can nest dictionaries inside a list, a list of items inside a dictionary, or even a dictionary inside another dictionary. Nesting is a powerful feature, as the following examples will demonstrate. A List of Dictionaries The alien_0 dictionary contains a variety of information about one alien, but it has no room to store information about a second alien, much less a full screen of aliens. How can you managae a fleet of aliens? One way is to make a list of aliens in which each alien is a dictionary of information about that alien. For example, the following code builds a list of three aliens: 1 2 3 4 5 6 7 8 alien_0 = { 'color' : 'green' , 'points' : 5 } alien_1 = { 'color' : 'yellow' , 'points' : 10 } alien_2 = { 'color' : 'red' , 'points' : 15 } aliens = [ alien_0 , alien_1 , alien_2 ] for alien in aliens : print ( alien ) We first create three dictionaries, each representing a different alien. On line 5 we store each of these dictionaries in a list called aliens . Finally, we loop through the list and print out each alien: {'color': 'green', 'points': 5} {'color': 'yellow', 'points': 10} {'color': 'red', 'points': 15} A more realistic example would involve more than three alies with code that automatically generates each alien. In the following example we use range () to create a fleet of 30 aliens: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Make an empty list for storing aliens aliens = [] # Make 30 green aliens. for alien_number in range ( 30 ): new_alien = { 'color' : 'green' , 'points' : 5 , 'speed' : 'slow' } aliens . append ( new_alien ) # Show the first 5 aliens. for alien in aliens [: 5 ]: print ( alien ) print ( \"...\" ) # Show how many aliens have been created. print ( f \"Total number of aliens: { len ( aliens ) } \" ) This example befins with an empty list to hold all of the aliens that will created. At line 5 range () returns a series of numbers, which just tells Python how many times we want the loop to repeat. Each time the loop runs we create a new alien (line 6) and then append each new alien to the list aliens (line 7). On line 10 we us a slice to print the first five aliens, and then on line 15 we print the length of the list to prove we've actually generated the full fleet of 30 aliens: {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} ... Total number of aliens: 30 These aliens all have the same characteristics, but Python considers each one a separate object, which allows us to modify each alien individually. How might you work with a group of aliens like this? Imagine that one aspect of a game has some aliens changing color and moving faster as the game progress. When it's time to change colors, we can use a for loop and an if statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Make an empty list for storing aliens aliens = [] # Make 30 green aliens. for alien_number in range ( 30 ): new_alien = { 'color' : 'green' , 'points' : 5 , 'speed' : 'slow' } aliens . append ( new_alien ) for alien in aliens [: 3 ]: if alien [ 'color' ] == 'green' : alien [ 'color' ] = 'yellow' alien [ 'speed' ] = 'medium' alien [ 'points' ] = '10' # Show the first 5 aliens. for alien in aliens [: 5 ]: print ( alien ) print ( \"...\" ) Because we want to modify the first three aliens, we loop through a slice that includes only the first three aliens. All of the aliens are green now but that won't always be the case, so we write an if statement to make sure we're only modifying green aliens. If the alien is green, we change the color to 'yellow' , the speed to 'medium' , and the point value to 10 , as shown in the following output: {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} ... You could expand this loop by adding an elif block that turns yellow aliens into red, fast-moving ones worth 15 points each. Without showing the entire program again, that loop would look like this: 1 2 3 4 5 6 7 8 9 for alien in aliens [: 3 ]: if alien [ 'color' ] == 'green' : alien [ 'color' ] = 'yellow' alien [ 'speed' ] = 'medium' alien [ 'points' ] = '10' elif alien [ 'color' ] == 'yellow' : alien [ 'color' ] = 'red' alien [ 'speed' ] = 'fast' alien [ 'points' ] = 15 It's common to store a number of dictionaries in a list when each dictionary contains many kinds of information about one subject. For example, you might create a dictionary for each user on a website and store the individual dictionaries in a list called users . All of the dictionaries in the list should have an identical structure so you can loop through the list and work with each dictionary object in the same way. A List in a Dictionary Rather than putting a dictionary inside a list, it's sometimes useful to put a list inside a dictionary. For example, consider how you might describe a pizza that someone is ordering. If you were to use only a list, all you could really store is a list of the pizza's toppings. With a dictionary, a list of toppings can be just one aspect of the pizza you're describing. In the following example, two kinds of information are stored for each pizza: a type of crust and a list of toppings. The list of toppings is a value associated with the key 'toppings' . To use the items in the list, we give the name of the dictionary and the key 'toppings' , as we would any value in the dictionary. Instead of returning a single value, we get a list of toppings: 1 2 3 4 5 6 7 8 9 10 11 12 # Store information about a pizza being ordered. pizza = { 'crust' : 'thick' , 'toppings' : [ 'mushrooms' , 'extra cheese' ], } # Summarize the order. print ( f \"You ordered a { pizza [ 'crust' ] } -crust pizza \" \"with the following toppings:\" ) for topping in pizza [ 'toppings' ]: print ( \" \\t \" + topping ) We begin on line 2 with a dictionary that holds information about a pizza that has been ordered. One key in the dictionary is 'crust' , and the associated value is the string 'thick' . The next key, 'toppings' , has a list as its value that stores all the requested toppings. On line 8 we summarize the order before building the pizza. When you need to break up a long ling in a print () call, choose an appropriate point at which to break the line being printed and quotation mark. Indent the next line, add an opening quotation mark, and continue the string. Python will automatically combine all of the strings it finds inside the parentheses. To print the toppings, we write a for loop on line 10. To access the list of toppings, we use the key 'toppings' , and Python grabs the list of toppings from the dictionary. The following output summarizes the pizza that we plan to build: You ordered a thick-crust pizza with the following toppings: mushrooms extra cheese You can nest a list inside a dictionary any time you want more than one value to be associated with a single key in a dictionary. In the earlier example of favorite programming languages, if we were to store each person's responses in a list, people could choose more than one favorite language. When we loop through the dictionary, the value associated with each person would be a list of languages rather than a single language. Inside the dictionary's for loop, we use another for loop to run through the list of languages associated with each person: 1 2 3 4 5 6 7 8 9 10 11 favorite_languages = { 'jen' : [ 'python' , 'ruby' ], 'sarah' : [ 'c' ], 'edward' : [ 'ruby' , 'go' ], 'phil' : [ 'python' , 'haskell' ], } for name , languages in favorite_languages . items (): print ( f \" \\n { name . title () } 's favorite languages are:\" ) for language in languages : print ( f \" \\t { language . title () } \" ) As you can see on line 1, the value associated with each name is now a list. Notice that some people have one favorite language and others have multiple favorites. When we loop through the dictionary on line 8, we use the variable name languages to hold each value from the dictionary, because we know that each value will be a list. Inside the main dictionary loop, we use another for loop (line 10) to run through each persons list of favorite languages. Now each person can list as many favorite languages as they like: Jen's favorite languages are: Python Ruby Sarah's favorite languages are: C Edward's favorite languages are: Ruby Go Phil's favorite languages are: Python Haskell To refine this program even further, you can ad an if statement at the beginning of the dictionary's for loop to see whether each person has more than one favorite language by examining the value of len ( languages ) . If a person has more than one favoriem the output would stay the same. If the person has only one favorite language, you could change the wording to reflect that. For example, you could say \"Sarah's favorite language is C.\" A Dictionary in a Dictionary You can nest a dictionary inside another dictionary, b ut your code can get complicated quickly when you do. For example, if you have several users for a website, each with a unique username, you can use the usernames as the keys in a dictionary. You can then store information about each user by using a dictionary as the value associated with their username. In the following listing, we store three pieces of information about each user: their first name, last name, and location. We'll access this information by looping through the usernames and the dictionary of information associated with each username: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 users = { 'aeinstein' : { 'first' : 'albert' , 'last' : 'einstein' , 'location' : 'princeton' , }, 'mcurie' : { 'first' : 'marie' , 'last' : 'curie' , 'location' : 'paris' , }, } for username , user_info in users . items (): print ( f \" \\n Username: { username } \" ) full_name = f \" { user_info [ 'first' ] } { user_info [ 'last' ] } \" location = user_info [ 'location' ] print ( f \" \\t Full name: { full_name . title () } \" ) print ( f \" \\t Location: { location . title () } \" ) We first define a dictionary called users with two keys: one each for the usernames 'aeinstein' and 'mcurie' . The value associated with each key is a dictionary that includes each user's first name, last name, and location. On line 14 we loop through the users dictionary. Python assigns each key to the variable username , and the dictionary associated with each username is assigned to the variable user_info . Once inside the main dictionary loop, we print the user-name at line 15. On line 16 we start accessing the inner dictionary. The variable user_info , which contains the dictionary of user information, has three keys: 'first' , 'last' , and 'location' . We use each key to generate a neatly formated full name and location for each person, and then print a summary of what we know about each user: Username: aeinstein Full name: Albert Einstein Location: Princeton Username: mcurie Full name: Marie Curie Location: Paris Notice that the structure of each user's dictionary is identical. Although not required by Python, this structure makes nested dictionaries easier to work with. If each user's dictionary had different keys, the code inside the for loop would be more complicated.","title":"Dictionaries"},{"location":"py-dictionaries/#dictionaries","text":"Understanding dictionaries allows you to model a variety of real-world objects more accurately. For example, we could create a dictionary representing a person and then store as much information as we want about that person. You can store their name, location, age, profession, and any other aspect of a person you can describe. We can store any two kinds of information that can be matched up, such as a list of words and their meanings, a list of people's names and their favorite numbers, a list of mountains and their elevations, etc.","title":"Dictionaries"},{"location":"py-dictionaries/#a-simple-dictionary","text":"Consider a game featuring aliens that can have different colors and point values. This simple dictionary stores information about a particular alien: 1 2 3 4 alien_0 = { 'color' : 'green' , 'points' : 5 } print ( alien_0 [ 'color' ]) print ( alien_0 [ 'points' ]) The dictionary alien_0 stores the alien's color and point value. The last two lines access and display that information, as shown here: green 5 As with most new programming concepts, using dictionaries takes practice. Once you've worked with dictionaries for a bit, you'll soon see how effectively they can model real-world situations.","title":"A Simple Dictionary"},{"location":"py-dictionaries/#working-with-dictionaries","text":"A dictionary in Python is a collection of key-value pairs . Each key is connected to a value, and you can use a key to access the value associated with that key. A key's value can be a number, a string, a list, or even another dictionary. In fact, you can use any object that you can create in Python as a value in a dictionary. In Python, a dictionary is wrapped in braces, { }, with a series of key-value pairs inside the braces, as shown in the earlier example: alien_0 = { 'color' : 'green' , 'points' : 5 } A key-value pair is a set of values associated with each other. When you provide a key, Python returns the value associated with that key. Every key is connected to its value by a colon, and individual key-value pairs are separated by commas. You can store as many key-value pairs as you want in a dictionary. The simplest dictionary has exactly one key-value pair, as shown in this modified version of the alien_0 dictionary: alien_0 = { 'color' : 'green' } This dictionary stores one piece of information about alien_0 , namely the alien's color. The string 'color' is a key in this dictionary, and its associated value is 'green' .","title":"Working with Dictionaries"},{"location":"py-dictionaries/#accessing-values-in-a-dictionary","text":"To get the value associated with a key, give the name of the dictionary and then place the key inside a set of square brackets, as shown here: 1 2 alien_0 = { 'color' : 'green' } print ( alien_0 [ 'color' ]) This returns the value associated with the key 'color' from the dictionary alien_0 : green You can have an ulimited number of key-value pairs in a dictionary. For example, here's the original alien_0 dictionary with two key-value pairs: alien_0 = { 'color' : 'green' , 'points' : 5 } Now you can access either the color or the point value of alien_0 . If a player shoots down this alien, you can look up how many points they should earn using code like this: 1 2 3 4 alien_0 = { 'color' : 'green' , 'points' : 5 } new_points = alien_0 [ 'points' ] print ( f \"You just earned { new_points } points!\" ) Once the dictionary has been defined, the code on line 3 pulls the value associated with the key 'points' from the dictionary. This value is then assigned to the variable 'new_points' . The code on line 4 then prints a statement about how many points the player just earned.","title":"Accessing Values in a Dictionary"},{"location":"py-dictionaries/#adding-new-key-value-pairs","text":"Dictionaries are dynamic structures, and you can add new key-value pairs to a dictionary at any time. For example, to add a new key-value pair, you would give the name of the dictionary followed by the new key in square brackets along with the new value. Let's add two new pieces to the alien_0 dictionary: the alien's x- and y- coordinates, which will help us display the alien in a particular position on the screen. Let's place the alien on the left edge of the screen, 25 pixels down from the top. Because screen coordinates usually start at the upper-left corner of the screen, we'll place the alien on the left edge of the screen by setting the x-coordinate to 0 and 25 pixels from the top by setting the y-coordinate to positive 25: 1 2 3 4 5 6 alien_0 = { 'color' : 'green' , 'points' : '5' } print ( alien_0 ) alien_0 [ 'x_position' ] = 0 alien_0 [ 'y_position' ] = 25 print ( alien_0 ) We start by defining the same dictionary that we have been working with. We then print this dictionary, displaying a snapshot of its information. On line 4, we add a new key-value pair to the dictionary: key 'x_position' and a value of 0 . We do the same for key 'y_position' on the next line. Finally, when we print the modified dictionary, we see the two additional key-value pairs: {'color': 'green', 'points': '5'} {'color': 'green', 'points': '5', 'x_position': 0, 'y_position': 25} The final version of the dictionary contains four key-value pairs.","title":"Adding New Key-Value Pairs"},{"location":"py-dictionaries/#starting-with-an-empty-dictionary","text":"It's sometimes convenient, or even necessary, to start with an empty dictionary and then add each new item to it. To start filling an empty dictionary, define a dictionary with an empty set of braces and then add each key-value pair on its own line. For example, here's how to build the alien_0 dictionary using this approach: 1 2 3 4 5 6 alien_0 = {} alien_0 [ 'color' ] = 'green' alien_0 [ 'points' ] = '5' print ( alien_0 ) Here we define an empty alien_0 dictionary, and then add color and point values to it. The result is the dictionary we have been usinging in previous examples: {'color': 'green', 'points': '5'} Typically, you'll use empty dictionaries when storing user-supplied data in a dictionary or when you write code that generates a large number of key-value pairs automatically.","title":"Starting with an Empty Dictionary"},{"location":"py-dictionaries/#modifying-values-ina-dictionary","text":"To modify a value in a dictionary, give the name of the dictionary with the key in square brackets and then the new value you want associated with that key. For example, consider an alien that changes from green to yellow as a game progresses: 1 2 3 4 5 alien_0 = { 'color' : 'green' } print ( f \"The alien is { alien_0 [ 'color' ] } .\" ) alien_0 [ 'color' ] = 'yellow' print ( f \"The alien is now { alien_0 [ 'color' ] } .\" ) We first define a dictionary for alien_0 that contains only the aliens color; then we change the value associated with the key 'color' to 'yellow' . The output shows that the alien has indeed changed from green to yellow: The alien is green. The alien is now yellow. For a more interesting example, let's track the position of an alien that can move at different speeds. We'll sotre a value representing the alien's current speed and then use it to determine how far to the right the alien should move: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 alien_0 = { 'x_position' : 0 , 'y_position' : 25 , 'speed' : 'medium' } print ( f \"Original position: { alien_0 [ 'x_position' ] } \" ) # Move the alien to the right. # Determine how far to move the alien based on its current speed. if alien_0 [ 'speed' ] == 'slow' : x_increment = 1 elif alien_0 [ 'speed' ] == 'medium' : x_increment = 2 else : # This must be a fast alien. x_increment = 3 # The new position is the old position plus the increment. alien_0 [ 'x_position' ] = alien_0 [ 'x_position' ] + x_increment print ( f \"New position: { alien_0 [ 'x_position' ] } \" ) We start by defining an alien with an initial x and y position, and a speed of 'medium' . We also print the original value of x_position to see how far the alien moves to the right. On line 5, an if - elif - else chain determins how far the alien should move to the right and assigns this value to the variable x_increment . If the alien's speed is 'slow' , it moves one unit, if it is 'medium' , it moves two, and if it is 'fast' , it moves three. Once the increment has been calculated, it is added to the value of x_position on line 13 and the result is stored in the dictionary's x_position . Because this is a medium-speed alien, its position shifts two units to the right: Original position: 0 New position: 2 This technique is pretty cool: by changing one value in the alien's dictionary, you can change the overall behavior of the alien. For example, to turn this medium-speed alien into a fast alien, you would add the line: alien_0 [ 'speed' ] = 'fast' The if-elif-else block would then assign a larger value to x_increment the next time the code runs.","title":"Modifying Values ina  Dictionary"},{"location":"py-dictionaries/#removing-key-value-pairs","text":"When you no longer need a piece of information that is stored ina dictionary, you can you the del statement to completely remove a key-value pair. All del needs is the name of the dictionary and the key that you want to remove. For example, let's remove the key 'points' from the alien_0 dictionary along with its value: 1 2 3 4 5 alien_0 = { 'color' : 'green' , 'points' : 5 } print ( alien_0 ) del alien_0 [ 'points' ] print ( alien_0 ) The code on line 4 tells Python to delete the key 'points' from the dictionary alien_0 and to remove the value associated with that key as well. The output shows that the key 'points' and its value of 5 are deleted from the dictionary, and the rest is unaffected: {'color': 'green', 'points': 5} {'color': 'green'}","title":"Removing Key-Value Pairs"},{"location":"py-dictionaries/#a-dictionary-of-similar-objects","text":"The previous example involved storing different kinds of information about one object, an alien in a game. You can also use a dictionary to store one kind of information about many objects. For example, a dictionary of a group of people's favorite programming language. A dictionary for this could look like: 1 2 3 4 5 6 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } As you can see, we've broken a larger dictionary into several lines (mainly for better readability). Each key is the name of a person and each value is their favorite language. When you know you'll need more than one line to define a dictionary, press ENTER after the opening brace. Then indent the next line one tab, and write your first key-value pair, followed by a comma. Once you have finished defining the dictionary, add a closing brace on a new line after the last key-value pair and indent it one level so it aligns with the keys in the dictionary. It's good practice to include a comma after the last key-value pair, just in case you want to add more in the future. To use this dictionary, given the name of a person, you can easily look up their favorite language: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } language = favorite_languages [ 'sarah' ] . title () print ( f \"Sarah's favorite langugage is { language } .\" ) To see which language Sarah chose, we ask for the value at: favorite_languages [ 'sarah' ] We use this syntax to pull Sarah's favorite language from the dictionary (line 8) and assign it to the variable language . Creating a new variable here makes for a much cleaner print () call. The output shows Sarah's favorite Language: Sarah's favorite langugage is C.","title":"A Dictionary of Similar Objects"},{"location":"py-dictionaries/#using-get-to-access-values","text":"Using keys in square brackets to retrieve the value you're interested in from a dictionary might cause one potential problem: if the key you ask for doesn't exist, you'll get an error. Let's see what happens when you ask for the point value of an alien that doesn't have a point value set: 1 2 alien_0 = { 'color' : 'green' , 'speed' : 'slow' } print ( alien_0 [ 'points' ]) This results in a traceback, showing a KeyError: KeyError Traceback (most recent call last) <ipython-input-9-3914d637e9f3> in <module> 1 alien_0 = {'color': 'green', 'speed': 'slow'} ----> 2 print(alien_0['points']) KeyError: 'points' For dictionaries, we can use the get () method to set a default value that will be returned if the requested key doesn't exist. The get () method requires a key as a first argument. As a second optional argument, you can pass the value to be returned if the key doesn't exist: 1 2 3 4 alien_0 = { 'color' : 'green' , 'speed' : 'slow' } point_value = alien_0 . get ( 'points' , 'No point value assigned.' ) print ( point_value ) If the key 'points' exists in the dictionary, you'll get corresponding value. If it doesn't, you get the default value. In this case, points doesn't exist, and we get a clean message instead of an error: No point value assigned. If there's a chance the key you're asking for might not exist, consider using the get () method instead of the square bracket notation.","title":"Using get() to Access Values"},{"location":"py-dictionaries/#looping-through-a-dictionary","text":"A single Python dictionary can contain just a few key-value pairs or millions of pairs. Because a dictionary can contain large amounts of data, Python lets you loop through a dictionary. Dictionaries can be used to store information in a variety of ways; therefore, several different ways exist to loop through them. You can loop through all of a dictionary's key-value pairs, through its keys, or its values.","title":"Looping Through a Dictionary"},{"location":"py-dictionaries/#looping-through-all-key-value-pairs","text":"Before we explore the different approaches to looping, let's consider a new dictionary designed to store information about a user on website. The following dictionary would store one person's username, first name, and last name: 1 2 3 4 5 user_0 = { 'username' : 'efermi' 'first' : 'enrico' 'last' : 'fermi' } You can access any single piece of information about user_0 based on what you've already learned in this chapter. But what if you wanted to see everything stored in this user's dictionary? To do so, you could loop through the dictionary using a for loop. 1 2 3 4 5 6 7 8 9 user_0 = { 'username' : 'efermi' , 'first' : 'enrico' , 'last' : 'fermi' , } for key , value in user_0 . items (): print ( f \" \\n Key: { key } \" ) print ( f \"Value: { value } \" ) As shown on line 7, to write a for loop for a dictionary, you create names for the two variables that will hold the key and value in each key-value pair. You can choose any names you want for these two variables. This code would work just as well if you had used abbreviated for the variable names, like this: for k , v in user_0 . items () The second half of the for statement on line 7 includes the name of the dictionary followed by the method items() , which returns a list of key-value pairs. The for loop then assigns each of these pairs to the two vairbales provided. In the preceding example, we use the variables to print each key (line 8), followed by the associated value (line 9). The \"\\n\" in the first print () call ensures that a blank line is inserted bfore each key-value pair in the output: Key: username Value: efermi Key: first Value: enrico Key: last Value: fermi Looping through all key-value pairs works particularly well for dictionaries like the favorite_languages example from above , which stores the same kind of information for many different keys. If you loop through the favorite_languages dictionary, you get the name of each person in the dictionary and their favorite programming language. Because the keys always refer to a person's name and the value is always language, we'll use the variables name and language in the loop, instead of key and value . This will make it easier to follow what's happening inside the loop: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name , language in favorite_languages . items (): print ( f \" { name . title () } 's favorite language is { language . title () } !\" ) The code on line 8 tells Python to loop through each key-value pair in the dictionary. As it works through each pair the key is assigned to the variable name , and the value is assigned to the variable language . These descriptive names make it much easier to see what the print () call on line 9 is doing. Now, in just a few lines of code, we can display all the information from the poll: Jen's favorite language is Python! Sarah's favorite language is C! Edward's favorite language is Ruby! Phil's favorite language is Python! This type of looping would work just as well if our dictionary stored the results from polling a thousand or even a million people.","title":"Looping Through All Key-Value Pairs"},{"location":"py-dictionaries/#looping-through-all-the-keys-in-a-dictionary","text":"The keys() method is useful when you don't need to work with all of the values in a dictionary. Let's loop through the favorite_languages dictionary and print the names of everyone who answered: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name in favorite_languages . keys (): print ( name . title ()) The code on line 8 tells Python to pull all the keys from the dictionary favorite_languages and assign them one at a time to the variable name . The output shows the names of everyone who answered: Jen Sarah Edward Phil Looping through the keys is actually the default behavior when looping through a dictionary, so this code would have exactly the same output if you wrote: for name in favorite_languages : rather than: for name in favorite_languages . keys (): You can choose to use the keys() method explicitly if it makes your code easier to read, or you can omit it if you wish. You can access the value associated with any key you care about inside the loop by using the current key. Let's print a message to a couple of friends about the languages they chose. We'll loop through the names in the dictionary as we did previously, but when the name matches on of our friends, we'll display a message about their favorite language: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } friends = [ 'phil' , 'sarah' ] for name in favorite_languages . keys (): print ( f \"Hi, { name . title () } .\" ) if name in friends : language = favorite_languages [ name ] . title () print ( f \" \\t { name . title () } , I see you love { language } !\" ) On line 8 we make a list of friends that we want to print a message to. Inside the loop, we print each person's name. Then on line 12 we check whether the name we're working with is in the list friends . If it is, we determine the person's favorite language using the name of the dictionary and the current value of name as the key (line 13). We then print a special greeting, including a reference to their language of choice. Everyone's name is printed, but our friends receive a special message: Hi, Jen. Hi, Sarah. Sarah, I see you love C! Hi, Edward. Hi, Phil. Phil, I see you love Python! You can also use the keys() method to find out if a particular person was polled. This time, let's find out if Erin took the poll: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } if 'erin' not in favorite_languages . keys (): print ( \"Erin, please take our poll!\" ) The keys() method isn't just for looping: it actually returns a list of all the keys, and the code on line 8 simply checks if 'erin' is in the list. Because she is not, a message is printed inviting her to take the poll.","title":"Looping Through All The Keys in a Dictionary"},{"location":"py-dictionaries/#looping-through-a-dictionarys-keys-in-a-particular-order","text":"Starting in Python 3.7, looping through a dictionary returns the items in the same order they were inserted. Sometimes, though, you'll want to loop through a dictionary in a different order. One way to do this is to sort the keys as they're retunred in the for loop. You can use the sorted () function to get a copy of the keys in order: 1 2 3 4 5 6 7 8 9 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } for name in sorted ( favorite_languages . keys ()): print ( f \" { name . title () } , thank you for taking the poll.\" ) This for statement is like other for statements except that we've wrapped the sorted () function around the dictionary . keys () method. This tells Python to list all keys in the dictionary and sort that list before looping through it. The output shows everyone who took the poll, with the names displayed in order: Edward, thank you for taking the poll. Jen, thank you for taking the poll. Phil, thank you for taking the poll. Sarah, thank you for taking the poll.","title":"Looping Through a Dictionary's Keys in a Particular Order"},{"location":"py-dictionaries/#looping-through-all-values-in-a-dictionary","text":"If you are primarily interested in the values that a dictionary contains, you can use the values () method to return a list of values without any keys. For example, say we simply want a list of all languages chosen in our programming language poll without the name of the person who chose each language: 1 2 3 4 5 6 7 8 9 10 favorite_languages = { 'jen' : 'python' , 'sarah' : 'c' , 'edward' : 'ruby' , 'phil' : 'python' , } print ( \"The following languages have been mentioned:\" ) for language in favorite_languages . values (): print ( language . title ()) The for statement here pulls each value from the dictionary and assigns it to the variable language . When these values are printed, we get a list of all chosen languages: The following languages have been mentioned: Python C Ruby Python This approach pulls all the values from the dictionary without checking for repeats. That might work fine with a small number of values, but in a poll with a large number of respondents, this would result in a very repetitive list. To see each language chosen without repitionm we can use a set. A set is a collection in which each item must be unique. We can use the following for loop in place of the one used above: for language in set ( favorite_languages . values ()): When you wrap set () around a list that contains duplicate items, Python identifies the unique items in the list and build a set from those items. The result is a nonrepetitive list of languages that have been menetioned: The following languages have been mentioned: C Ruby Python","title":"Looping Through All Values in a Dictionary"},{"location":"py-dictionaries/#nesting","text":"Sometimes you'll want to store multiple dictionaries in a list, or a list of items as a value in a dictionary. This is called nesting . You can nest dictionaries inside a list, a list of items inside a dictionary, or even a dictionary inside another dictionary. Nesting is a powerful feature, as the following examples will demonstrate.","title":"Nesting"},{"location":"py-dictionaries/#a-list-of-dictionaries","text":"The alien_0 dictionary contains a variety of information about one alien, but it has no room to store information about a second alien, much less a full screen of aliens. How can you managae a fleet of aliens? One way is to make a list of aliens in which each alien is a dictionary of information about that alien. For example, the following code builds a list of three aliens: 1 2 3 4 5 6 7 8 alien_0 = { 'color' : 'green' , 'points' : 5 } alien_1 = { 'color' : 'yellow' , 'points' : 10 } alien_2 = { 'color' : 'red' , 'points' : 15 } aliens = [ alien_0 , alien_1 , alien_2 ] for alien in aliens : print ( alien ) We first create three dictionaries, each representing a different alien. On line 5 we store each of these dictionaries in a list called aliens . Finally, we loop through the list and print out each alien: {'color': 'green', 'points': 5} {'color': 'yellow', 'points': 10} {'color': 'red', 'points': 15} A more realistic example would involve more than three alies with code that automatically generates each alien. In the following example we use range () to create a fleet of 30 aliens: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Make an empty list for storing aliens aliens = [] # Make 30 green aliens. for alien_number in range ( 30 ): new_alien = { 'color' : 'green' , 'points' : 5 , 'speed' : 'slow' } aliens . append ( new_alien ) # Show the first 5 aliens. for alien in aliens [: 5 ]: print ( alien ) print ( \"...\" ) # Show how many aliens have been created. print ( f \"Total number of aliens: { len ( aliens ) } \" ) This example befins with an empty list to hold all of the aliens that will created. At line 5 range () returns a series of numbers, which just tells Python how many times we want the loop to repeat. Each time the loop runs we create a new alien (line 6) and then append each new alien to the list aliens (line 7). On line 10 we us a slice to print the first five aliens, and then on line 15 we print the length of the list to prove we've actually generated the full fleet of 30 aliens: {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} ... Total number of aliens: 30 These aliens all have the same characteristics, but Python considers each one a separate object, which allows us to modify each alien individually. How might you work with a group of aliens like this? Imagine that one aspect of a game has some aliens changing color and moving faster as the game progress. When it's time to change colors, we can use a for loop and an if statement to change the color of the aliens. For example, to change the first three aliens to yellow, medium-speed aliens worth 10 points each, we could do this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Make an empty list for storing aliens aliens = [] # Make 30 green aliens. for alien_number in range ( 30 ): new_alien = { 'color' : 'green' , 'points' : 5 , 'speed' : 'slow' } aliens . append ( new_alien ) for alien in aliens [: 3 ]: if alien [ 'color' ] == 'green' : alien [ 'color' ] = 'yellow' alien [ 'speed' ] = 'medium' alien [ 'points' ] = '10' # Show the first 5 aliens. for alien in aliens [: 5 ]: print ( alien ) print ( \"...\" ) Because we want to modify the first three aliens, we loop through a slice that includes only the first three aliens. All of the aliens are green now but that won't always be the case, so we write an if statement to make sure we're only modifying green aliens. If the alien is green, we change the color to 'yellow' , the speed to 'medium' , and the point value to 10 , as shown in the following output: {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'yellow', 'points': '10', 'speed': 'medium'} {'color': 'green', 'points': 5, 'speed': 'slow'} {'color': 'green', 'points': 5, 'speed': 'slow'} ... You could expand this loop by adding an elif block that turns yellow aliens into red, fast-moving ones worth 15 points each. Without showing the entire program again, that loop would look like this: 1 2 3 4 5 6 7 8 9 for alien in aliens [: 3 ]: if alien [ 'color' ] == 'green' : alien [ 'color' ] = 'yellow' alien [ 'speed' ] = 'medium' alien [ 'points' ] = '10' elif alien [ 'color' ] == 'yellow' : alien [ 'color' ] = 'red' alien [ 'speed' ] = 'fast' alien [ 'points' ] = 15 It's common to store a number of dictionaries in a list when each dictionary contains many kinds of information about one subject. For example, you might create a dictionary for each user on a website and store the individual dictionaries in a list called users . All of the dictionaries in the list should have an identical structure so you can loop through the list and work with each dictionary object in the same way.","title":"A List of Dictionaries"},{"location":"py-dictionaries/#a-list-in-a-dictionary","text":"Rather than putting a dictionary inside a list, it's sometimes useful to put a list inside a dictionary. For example, consider how you might describe a pizza that someone is ordering. If you were to use only a list, all you could really store is a list of the pizza's toppings. With a dictionary, a list of toppings can be just one aspect of the pizza you're describing. In the following example, two kinds of information are stored for each pizza: a type of crust and a list of toppings. The list of toppings is a value associated with the key 'toppings' . To use the items in the list, we give the name of the dictionary and the key 'toppings' , as we would any value in the dictionary. Instead of returning a single value, we get a list of toppings: 1 2 3 4 5 6 7 8 9 10 11 12 # Store information about a pizza being ordered. pizza = { 'crust' : 'thick' , 'toppings' : [ 'mushrooms' , 'extra cheese' ], } # Summarize the order. print ( f \"You ordered a { pizza [ 'crust' ] } -crust pizza \" \"with the following toppings:\" ) for topping in pizza [ 'toppings' ]: print ( \" \\t \" + topping ) We begin on line 2 with a dictionary that holds information about a pizza that has been ordered. One key in the dictionary is 'crust' , and the associated value is the string 'thick' . The next key, 'toppings' , has a list as its value that stores all the requested toppings. On line 8 we summarize the order before building the pizza. When you need to break up a long ling in a print () call, choose an appropriate point at which to break the line being printed and quotation mark. Indent the next line, add an opening quotation mark, and continue the string. Python will automatically combine all of the strings it finds inside the parentheses. To print the toppings, we write a for loop on line 10. To access the list of toppings, we use the key 'toppings' , and Python grabs the list of toppings from the dictionary. The following output summarizes the pizza that we plan to build: You ordered a thick-crust pizza with the following toppings: mushrooms extra cheese You can nest a list inside a dictionary any time you want more than one value to be associated with a single key in a dictionary. In the earlier example of favorite programming languages, if we were to store each person's responses in a list, people could choose more than one favorite language. When we loop through the dictionary, the value associated with each person would be a list of languages rather than a single language. Inside the dictionary's for loop, we use another for loop to run through the list of languages associated with each person: 1 2 3 4 5 6 7 8 9 10 11 favorite_languages = { 'jen' : [ 'python' , 'ruby' ], 'sarah' : [ 'c' ], 'edward' : [ 'ruby' , 'go' ], 'phil' : [ 'python' , 'haskell' ], } for name , languages in favorite_languages . items (): print ( f \" \\n { name . title () } 's favorite languages are:\" ) for language in languages : print ( f \" \\t { language . title () } \" ) As you can see on line 1, the value associated with each name is now a list. Notice that some people have one favorite language and others have multiple favorites. When we loop through the dictionary on line 8, we use the variable name languages to hold each value from the dictionary, because we know that each value will be a list. Inside the main dictionary loop, we use another for loop (line 10) to run through each persons list of favorite languages. Now each person can list as many favorite languages as they like: Jen's favorite languages are: Python Ruby Sarah's favorite languages are: C Edward's favorite languages are: Ruby Go Phil's favorite languages are: Python Haskell To refine this program even further, you can ad an if statement at the beginning of the dictionary's for loop to see whether each person has more than one favorite language by examining the value of len ( languages ) . If a person has more than one favoriem the output would stay the same. If the person has only one favorite language, you could change the wording to reflect that. For example, you could say \"Sarah's favorite language is C.\"","title":"A List in a Dictionary"},{"location":"py-dictionaries/#a-dictionary-in-a-dictionary","text":"You can nest a dictionary inside another dictionary, b ut your code can get complicated quickly when you do. For example, if you have several users for a website, each with a unique username, you can use the usernames as the keys in a dictionary. You can then store information about each user by using a dictionary as the value associated with their username. In the following listing, we store three pieces of information about each user: their first name, last name, and location. We'll access this information by looping through the usernames and the dictionary of information associated with each username: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 users = { 'aeinstein' : { 'first' : 'albert' , 'last' : 'einstein' , 'location' : 'princeton' , }, 'mcurie' : { 'first' : 'marie' , 'last' : 'curie' , 'location' : 'paris' , }, } for username , user_info in users . items (): print ( f \" \\n Username: { username } \" ) full_name = f \" { user_info [ 'first' ] } { user_info [ 'last' ] } \" location = user_info [ 'location' ] print ( f \" \\t Full name: { full_name . title () } \" ) print ( f \" \\t Location: { location . title () } \" ) We first define a dictionary called users with two keys: one each for the usernames 'aeinstein' and 'mcurie' . The value associated with each key is a dictionary that includes each user's first name, last name, and location. On line 14 we loop through the users dictionary. Python assigns each key to the variable username , and the dictionary associated with each username is assigned to the variable user_info . Once inside the main dictionary loop, we print the user-name at line 15. On line 16 we start accessing the inner dictionary. The variable user_info , which contains the dictionary of user information, has three keys: 'first' , 'last' , and 'location' . We use each key to generate a neatly formated full name and location for each person, and then print a summary of what we know about each user: Username: aeinstein Full name: Albert Einstein Location: Princeton Username: mcurie Full name: Marie Curie Location: Paris Notice that the structure of each user's dictionary is identical. Although not required by Python, this structure makes nested dictionaries easier to work with. If each user's dictionary had different keys, the code inside the for loop would be more complicated.","title":"A Dictionary in a Dictionary"},{"location":"py-functions/","text":"Functions On this page we'll learn how to write functions , which are named blocks of code that are designed to do one specific job. When you want to perform a particular task that you've defined in a function, you call the function responsible for it. If you need to perform that task multiple times throughout your program, you don't need to type all the code for the same task again and again; you just call the function dedicated to handling that task, and the call tells Python to run the code inside the function. You'll find that using functions makes your programs easier to write, read, test, and fix. We will also learn ways to pass information to functions. We will learn how to write certain functions whose primary job is to display information and other functions desinged to process data and return a value or a set of values. Finally, we will cover how to store functions in separate files called modules to help organize our main program files. Defining a Function Here is a simple function named greet_user() that prints a greeting: 1 2 3 4 def greet_user (): \"\"\"Display a simple greeting.\"\"\" print ( \"Hello!\" ) greet_user () This example shows the simplest structure of a function. The code on line 1 uses the keyword def to inform Python that you're defining a function. This is the function definition , which tells Python the name of the function and, if applicable, what kind of information the function needs to do its job. The parentheses hold that information. In this case, the name of the function is greet_user() , and it needs no information to do its job, so its parentheses are empty. (Even so, the parentheses are required.) Finally, the definition ends in a colon. An indented lines that follow def greet_user (): make up the body of the function. The text on line 2 is a comment called a docstring , which describes what the function does. Docstrings are enclosed in triple quotes, which Python looks for when it generates documentaion for the functions in your programs. The line print ( \"Hello!\" ) on line 3 is the only line of actual code in the body of this function, so greet_user() has just one job: print ( \"Hello!\" ) . When you want to use this function, you call it. A function call tells Python to execute the code in the function. To call a function, you write the name of the function, followed by any necessary information in parentheses, as shown on line 4. Because no information is needed here, calling our function is as simple as entering greet_user() . As expected, it prints Hello! . Passing Information to a Function Modified slightly, the function greet_user() can not only tell the user Hello! but also greet them by name. For the function to do this, you enter username in the parentheses of the function's definition at def greet_user () . By adding username here you allow the function to accept any value of username you specify. The function now expects you to provide a value for username each time you call it. When you call greet_user() , you can pass it a name, such as 'jesse' , inside the parentheses: 1 2 3 4 5 def greet_user ( username ): \"\"\"Display a simple greeting.\"\"\" print ( f \"Hello, { username . title () } !\" ) greet_user ( 'jesse' ) Entering greet_user ( 'jesse' ) calls greet_user () and give the function the information it needs to execute the print () call. The function acceptsthe name you passed it and displays the greeting for that name: Hello, Jesse! Arguments and Parameters In the preceding greet_user() function, we defined greet_user() to require a value for the variable username . Once we called the function and gave it the information (a person's name), it printed the right greeting. The variable username in the definition of greet_user() is an example of a parameter , a piece of information the function needs to do its job. The value 'jesse' is reet_user ( 'jesse' ) is an example of an argument . An argument is a piece of information that's passed from a function call to a function. When we call the function, we place the value we want the function to work with in the parenthese. In this case the argument 'jesse' was passed to the function greet_user() , and the value was assigned to the parameter username . Passing Arguments Because a function definition can have multiple parameters, a function call may need multiple arguments. You can pass arguments to your functions in a number of ways. You can use positional arguments , which need to be in the same order as the parameters were written; keyword arguements , where each argument consists of a variable name and a value; and lists and dictionaries of values. Positional Arguments When you call a function, Python must match each argument in the function call with a parameter in the function definition. The simplest way to do this is baased on the order of the arguments provided. Values matched up this way are called positional arguments . To see how this works, consider a function that displays information about pets. The function tells us what kind of animal each pet is and the pet's name, as shown here: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'hamster' , 'harry' ) The definition shows that this function needs a type of animal and the animal's name (line 1). When we call describe_pet() , we need to provide an animal type and a name, in that order. For example, in the function call, the argument 'hamster' is assigned to the parameter animal_type and the argument 'harry' is assigned to the parameter pet_name (line 6). In the function body, these two parameters are used to display information about the pet being described. The output describes a hamster named Harry: I have a hamster. My hamster's name is Harry. Multiple Function Calls You can call a function as many times as needed. Describing a second, different pet requires just one more call to describe_pet() : 1 2 3 4 5 6 7 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'hamster' , 'harry' ) describe_pet ( 'dog' , 'willie' ) The only change above was to line 7. In the second function call, we pass describe_pet() the arguments 'dog' and 'willie' . As with the previous set of arguments we used, Python matches 'dog' with the parameter animal_type and 'willie' with the parameter pet_name . As before, the function does its job, but this time it also prints the values for a Dog named Willie: I have a hamster. My hamster's name is Harry. I have a dog. My dog's name is Willie. Calling a function multiple times is a very efficient way to work. The code describing a pet is written once in the function. Then, anytime you want to describe a new pet, you call the function with the new pet's information. Even if the code for describing a pet were to expand to ten lines, you could still describe a new pet in just one line by calling the function again. You can use as many positional arguments as you need in your functions. Python works through the arguments you provide when calling the function and matches each one with the corresponding parameter in the function's definition. Order Matters in Positional Arguments You can get unexpected results if you mix up the order of the arguments in a function call when using positional arguments: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'harry' , 'hamster' ) In the above function, we list the name first and the type of animal second. Because the argument 'harry' is listed first this time, that value is assigned to the parameter animal_type . Likewise, 'hamster' is assigned to pet_name . Now we have a \"harry\" named \"Hamster\": I have a harry. My harry's name is Hamster. If you get funny results like this, check to make sure the order of the arguments in your function call matches the order of the parameters in the function's definition. Keyword Arguments A keyword argument is a name-value pair that you pass to a function. You directly associate the name of the value within the argument, so when you pass the argument to the function, there's no confusion (you won't end up with a harry named Hamster). Keyword arguments free you from having to worry about correctly ordering your arguments in the function call, and they clarify the role of each value in the function call. Let's rewrite the program from above using keyword arguments to call describe_pet() : 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) The function describe_pet() hasn't changed, but when we call the function, we explicitly tell Python which parameter each argument should be matched with. When Python reads the function call, it knows to assign the argument 'hamster' to the parameter animal_type and the argument 'harry' to pet_name . The output correctly shows that we have a hamster named Harry. The order of keyword arguments doesn't matter because Python knows where each value should go. The following two function calls are equivalent: 1 2 describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) Default Values When writing a function, you can define a default value for each parameter. If an argument for a parameter is proivided in the function call, Python uses the argument value. If not, it uses the parameter's default value. So when you define a default value for a parameter, you can exclude the corresponding argument you'd usually write in the function call. Using default values can simplify your function calls and clarify the ways in which your functions are typically used. For example, if you notice that most of the calls to describe_pet() are being used to describe dogs, you can set the default value of animal_type to 'dog' . Now anyone calling describe_pet() for a dog can omit that information: 1 2 3 4 5 6 def describe_pet ( pet_name , animal_type = 'dog' ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( pet_name = 'willie' ) We changed the definition of describe_pet() to include a default value, 'dog' , for animal_type . Now when the function is called with no animal_type specified, Python knows to use the value 'dog' for this parameter: I have a dog. My dog's name is Willie. Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet's name. Python still interprets this as a positional argument, so if the function is called with just the pet's name, that argument will match up with the first parameter listed in the function's definition. This is the reason the first parameter needs to be pet_name . The simplest way to use this function now is to provide just a dog's name in the function call: describe_pet ( 'willie' ) This function call would have the same output as the previous example. The only argument provided is 'willie' , so it is matched up with the first parameter in the definition, pet_name . Because no argument is provided for animal_type , Python uses the default value 'dog' . To describe an animal other than a dog, you could use a function call like this: describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) Because an explicit argument for animal_type is provoided, Python will ignore the parameter's default value. Note on default values When you use default values, any parameter with a default value needs to be listed after all the parameters that don't have default values. This allows Python to continue interpreting positional arguments correctly. Equivalent Function Calls Because positional arguments, keyword arguments, and default values can all be used together, often you'll have several equivalent ways to call a function. Consider the following definition for describe_pet() with one default value provided: def describe_pet ( pet_name , animal_type = 'dog' ): With this definition, an argument always needs to be provided for pet_name , and this value can be provided using the positional or keyword format. If the animal being described is not a dog, an argument for animal_type mist be included in the call, and this argument can also be specified using the positional or keyword format. All the follwoing calls would work for this function: 1 2 3 4 5 6 7 8 # A dog named Willie. describe_pet ( 'willie' ) describe_pet ( pet_name = 'willie' ) # A hamster named Harry. describe_pet ( 'harry' , 'hamster' ) describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) Each of these function calls would have the same output as the previous examples. It doesn't really matter which calling style you use. As long as your function calls produce the output you want, just use the style you find easiest to understand. Avoiding Argument Errors When you start to use functions, don't be surprides if you encounter errors about unmatched arguments. Unmatched arguments occur when you provide fewer or more arguments than a function needs to do its wor. For example, here's what happens if we try to call describe_pet() with no arguments: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet () Python recognizes that some information is missing from the function call, and the traceback tells us that: TypeError Traceback (most recent call last) File <\"pets.py\">, line 6, in <module> 4 print(f\"My {animal_type}'s name is {pet_name.title()}.\") 5 ----> 6 describe_pet() TypeError: describe_pet() missing 2 required positional arguments: 'animal_type' and 'pet_name' The traceback tells us the location of the problem (line 6), allowing us to look back and see that something went wrong in our function call. Next, the offending function call is written out for us to see. Finally, the traceback tells us the call is missing two arguments and reports the names of the missing arguments. If this function were in a separate file, we could probably rewrite the call correctly without having to open that file and read the function code. Python is helpful in that it reads the function's code for us and tells us the names of the argument we need to provide. This is another motivation for giving your variables and functions descriptive names. If you do, Pythons error messages will be more useful to you and anyone else who might use your code. If you provide too many arguments, you should get a similar traceback that cal help you correctly match your function call to the function definition. Return Values A function doesn't always have to display its output directly. Instead, it can process some data and then reutn a value or set of values. The value the function returns is called a return value . The return statement takes a value from inside a function and sends it back to the line that called the function. Return values allow you to move much of your program's grunt work into functions, which can simplify the body of your program. Returning a Simple Value Let's look at a function that takes a first and last name, and returns a neatly formatted name: 1 2 3 4 5 6 7 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, fully formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'jimi' , 'hendrix' ) print ( musician ) The defintion of get_formatted_name() takes as parameters a first and last name (line 1). The function combines these two names, adds a space between them, and assigns the result to full_name (line 3). The value of full_name is converted to title case, and then returned to the calling line at line 4. When you call a function that returns a value, you need to provide a variable that the return value can be assigned to. In this case, the returned value is assigned to the variable musician on line 6. The output shows a neatly formatted name made up of the parts of a person's name: Jimi Hendrix This might seem like a lot of work to get a neatly formatted name when we could have just written: print ( \"Jimi Hendrix\" ) But when you consider working with a large program that needs to store many first and last names separately, functions like get_formatted_name() become very useful. You store first and last names separately and then call this function whenever you want to display a full name. Making an Argument Optional Sometimes it makes sense to make an argument optional so that people using the function can choose to provide extra information only if they want to. You can use default values to make an argument optional. For example, say we want to exapand get_formatted_name() to handle middle names as well. A first attempt to include middle names might look like this: 1 2 3 4 5 6 7 def get_formatted_name ( first_name , middle_name , last_name ): \"\"\"Return a full name, fully formatted.\"\"\" full_name = f \" { first_name } { middle_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'john' , 'lee' 'hooker' ) print ( musician ) This function works when given a first, middle, and last name. The function takes in all three parts of a name and then builds a string out of them. The function adds spaces where appropriate and converts the full name to title case: John Lee Hooker But middle names aren't always needed, and this function as written would not work if you tried to call it with only a first name and a last name. To make a middle name optional, we can give the middle_name argument an empty default valuye and ignore the argument unless a user provides a value. To make get_formatted_name() work without a middle name, we set the default value of middle_name to an empty string and move it to the end of list of parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 def get_formatted_name ( first_name , last_name , middle_name = '' ): \"\"\"Return a full name, neatly formatted.\"\"\" if middle_name : full_name = f \" { first_name } { middle_name } { last_name } \" else : full_name = f \" { first_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'jimi' , 'hendrix' ) print ( musician ) musician = get_formatted_name ( 'john' , 'hooker' , 'lee' ) print ( musician ) In this example, the name is built from three possible parts. Because there's always a first and last name, these parameters are listed first in the function's definition. The middle name is optional, so it's listed last in the definition, and its default value is an empty string (line 1). In the body of the function, we check to see if a middle name has been provided. Python interprets non-empty strings as True , so if middle_name evaluates to True if a middle name argument is in the function call (line 3). If a middle name is provided, the first, middle, and last names are combined to form a full name. This name is then changed to title case and returned to the function call line where it's assigned to the variable musician and printed. If no middle name is provided, the empty string fails the if test and the else block runs (line 5). The full name is made with just a dirst and last name, and the formatted name is returned to the calling line where it's assigned to musician and printed. Calling this function with a first and last name is straightforward. If we're using a middle name, however, we have to make sure the middle name is the last argument passed so Python will match up the positional arguments correctly (line 12). This modified version of our function works for people with just a first and last name, and it works for people who have a middle name as well: Jimi Hendrix John Lee Hooker Optional values allow functions to handle a wide range of use cases while letting function calls remain as simple as possible. Returning a Dictionary A function can return any kind of value you need it to, including more complicated data structures like lists and dictionaries. For example, the following function takes in parts of a name and returns a dictionary representing a person: 1 2 3 4 5 6 7 def build_person ( first_name , last_name ): \"\"\"Return a dictionary of information about a person.\"\"\" person = { 'first' : first_name , 'last' : last_name } return person musician = build_person ( 'jimi' , 'hendrix' ) print ( musician ) The function build_person() takes in a first and last name, and puts these values into a dictionary (line 3). The value of first_name is stored with the key 'first' , and the value of last_name is stored with the key 'last' . The entire dictionary representing the person is returned at line 4. The return value is printed on the final line with the original two pieces of textual information now stored in a dictionary: {'first': 'jimi', 'last': 'hendrix'} This function takes in a simple textual information and puts it into a more meaningful data structure that lets you work with the information beyond just printing it. The strings 'jimi' and 'hendrix' are now labeled as a first name and last name. You can easily extend this function to accept optional values like a middle name, an age, an occupation, or any other information you want to store about a person. For example, the following change allows you to store a person's age as well: 1 2 3 4 5 6 7 8 9 def build_person ( first_name , last_name , age = None ): \"\"\"Return a dictionary of information about a person.\"\"\" person = { 'first' : first_name , 'last' : last_name } if age : person [ 'age' ] = age return person musician = build_person ( 'jimi' , 'hendrix' , age = 27 ) print ( musician ) We add a new optional parameter age to the function definition and assign the parameter the special value None , which is used when a variable has no specific value assigned to it. You can think of None as a placeholder value. In conditional tests, None evaluates to False . If the function call includes a value fo age , that value is stored in the dictionary. This function always stores a person's name, but it can also be modified to store any other information you want about a person. Using a Function with a while Loop You can use functions with all the Python structures you've learned about so far. For example, let's use the get_formatted_name() function with a while loop to greet users more formally. Here's a first attempt at greeting people using their first and last names: 1 2 3 4 5 6 7 8 9 10 11 12 13 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, neatly formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () # This is an infinite loop! while True : print ( \" \\n Please tell me your name:\" ) f_name = input ( \"First name: \" ) l_name = input ( \"Last name: \" ) formatted_name = get_formatted_name ( f_name , l_name ) print ( f \" \\n Hello, { formatted_name } !\" ) For this example, we use a simple version of get_formatted_name() that doesn't involve middle names. The while loop asks the user to enter their name, and we prompt for their first and last name separately (line 8). But there's one problem with this while loop: We haven't defined a quit condition. Where do you put a quit condition when you ask for a series of input? We want the user to be able to quit as easily as possible, so each prompt should offer a way to quit. The break statement offers a straightforward way to exit the loop at either prompt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, neatly formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () # This is an infinite loop! while True : print ( \" \\n Please tell me your name:\" ) print ( \"(enter 'q' at any time to quit)\" ) f_name = input ( \"First name: \" ) if f_name == 'q' : break l_name = input ( \"Last name: \" ) if l_name == 'q' : break formatted_name = get_formatted_name ( f_name , l_name ) print ( f \" \\n Hello, { formatted_name } !\" ) We add a message that informs the user how to quit, and then we break out of the loop if the user enters the quit value at either prompt. Now the program will continue greeting people until someone enters 'q' for either name: Please tell me your name: (enter 'q' at any time to quit) First name: Nick Last name: Platt Hello, Nick Platt! Please tell me your name: (enter 'q' at any time to quit) First name: q Passing a List You'll often find it useful to pass a list to a function, whether it's a list of names, numbers, or more complex objects, such as dictionaries. When you pass a list to a function, the function gets direct access to the contents of the list. Let's use functions to make working with lists more efficient. Say we have a list of users and want to print a greeting to each. The following example sends a list of names to a function called greet_users() , which greets each person in the list individually: 1 2 3 4 5 6 7 8 def greet_users ( names ): \"\"\"Print a simple greeting to each user in the list.\"\"\" for name in names : msg = f \"Hello, { name . title () } !\" print ( msg ) usernames = [ 'hannah' , 'ty' , 'margot' ] greet_users ( usernames ) We define greet_users() so it expects a list of names, which it assigns to the parameter names . The function loops through the list it receives and prints a greeting to each user. On line 7, we define a list of users and then pass the list usernames to greet_users() in our function call: Hello, Hannah! Hello, Ty! Hello, Margot! This is the output we wanted. Every user sees a personalized greeting, and you can call the function any time you want to greet a specific set of users. Modifying a List in a Function When you pass a list to a function, the function can modify the list. Any changes made to the list inside the function's body are permanent, allowing you to work efficiently even when you're dealing with large amounts of data. Consider a company that creates 3D printed models of designs that users submit. Designs that need to be printed are stored in a list, and after being printed they're moved to a separate list. The following code does this without using functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Start with some designs that need to be printed. unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] # Simulate printing each design, until none are left. # Move each design to completed_models after printing. while unprinted_designs : current_design = unprinted_designs . pop () print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) # Display all completed models. print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) This program starts with a list of designs that need to be printed and an empty list called completed_models that each design will be moved to after it has been printed. As long as designs remain unprinted_designs , the while loop simulates printing each design by removing a design from the end of the list, storing it in current_design , and displaying a message that current design is being printed. It then adds the design to the list of completed models. When the loop is finished running, a list of designs that have been printed is displayed: Printing model: dodecahedron Printing model: robot pendant Printing model: phone case The following models have been printed: dodecahedron robot pendant phone case We can reorganize this code by writing two functions, each of which does one specific job. Most of the code won't change; we're just making it more carefully structured. The first function will handle printing the designs, and the second will summarize the prints that have been made: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def print_models ( unprinted_designs , completed_models ): \"\"\" Simulate printing each design, until none are left. Move each design to completed_models after printing. \"\"\" while unprinted_designs : current_design = unprinted_designs . pop () print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) def show_completed_models ( completed_models ): \"\"\"Show all the models that were printed.\"\"\" print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] print_models ( unprinted_designs , completed_models ) show_completed_models ( completed_models ) On line 1 we define the function print_models() with two parameters: a list of designs that need to be printed and a list of completed models. Given these two lists, the function simulates printing each design by emptying the list of unprinted designs and filling up the list of completed models. On line 10 we define the function show_completed_models() with one parameter: the list of completed models. Given this list, show_completed_models() displays the name of each model that was printed. This program has the same output as the version without functions, but the code is much more organized. The code that does most of the work has been moved to two separate functions, which makes the main part of the program easier to understand. Look at the body of the program to see how much easier it is to understand what this program is doing: 1 2 3 4 5 unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] print_models ( unprinted_designs , completed_models ) show_completed_models ( completed_models ) We set up a list of unprinted designs and an empty list that will hold the completed models. Then, because we've already defined our two functions, all we have to do is call them and pass them the right arguments. We call print_models() and pass it the two lists it needs; as expected, print_models() simulates printing the designs. Then we call show_completed_models() and pass it the list of completed models so it can report the models that have been printed. The descriptive function names allow others to read this code and understand it, even without comments. This program is easier to extend and maintain than the version without functions. If we need to print more designs later on, we can simply call print_models() again. If we realize the printing code needs to be modified, we can change the code once, and our changes will take place everywhere the function is called. This technique is more efficient than having to update code separately in several places in the program. This example also demonstrates the idea that every function should have one specific job. The first function prints each design, and the second displays the completed models. This is more beneficial than using one function to do both jobs. If you're writing a function and notice the function is doing too many different tasks, try to split the code into two functions. Remember that you can always call a function from another function, which can be helpful when splitting a complex task into a series of steps. Preventing a Function from Modifying a List Sometimes you'll want to prevent a function from modifying a list. For example, say that you start with a list of unprinted designs and write a function to move them to a list of completed models, as in the previous example. You may decide that even though you've printed all the designs, you want to keep the original list of unprinted designs for your records. But because you moved all the desing names out of unprinted_designs , the list is now empty, and the empty list is the only version you have; the original is gone. In this case, you can address this issue by passing the function a copy of the list, not the original. Any changes the function makes to the list will affect only the copy, leaving the original list intact. You can send a copy of a list to a function like this: function_name ( list_name [:]) Ths slice notation [:] makes a copy of the list to send to the function. If we didn't want to empty the list of unprinted desings in printing_models.py , we could call print_models() like this: print_models ( unprinted_designs [:], completed_models ) The function print_models() can do its work because it still receives the names of all unprinted designs. But this time it uses a copy of the original unprinted desings list, not the actual unprinted_designs list. The list completed_models will fill up with the names of printed models like it did before, but original list of unprinted designs will be unaffected by the function. Even though you can preserve the contents of a list by passing a copy of it to your functions, you should pass the original list to functions unless you have a specific reason to pass a copy. It's more efficient for a function to work with an existing list to avoid using the time and memory needed to make a separate copy, especially when you're working with large lists. Passing an Arbitrary Number of Arguments Sometimes you won't know ahead of time how many arguments a function needs to accept. Fortunately, Python allows a function to collect an arbitrary number of arguments from the calling statement. For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can't know ahead of time how many toppings a person will want. The function in the following example has one parameter, *toppings , but this parameter collects as many arguments as the calling line provides: 1 2 3 4 5 6 def make_pizza ( * toppings ): \"\"\"Print the list of toppings that have been requested.\"\"\" print ( toppings ) make_pizza ( 'pepperoni' ) make_pizza ( 'mushrooms' , 'green peppers' , 'extra cheese' ) The asterisk ( * ) in the parameter name *toppings tells Python to make an empty tuple called toppings and pack whatever values it receives into this tuple. The print () call in the function body produces output showing that Python can handle a function call with one value and a call with three values. It treats the different calls similarly. Note that Python packs the arguments into a tuple, even if the function receives only one value: ('pepperoni',) ('mushrooms', 'green peppers', 'extra cheese') Now we can replace the print() call with a loop that runs through the list of toppings and describes the pizza being ordered: 1 2 3 4 5 6 7 8 def make_pizza ( * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( \" \\n Making a pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) make_pizza ( 'pepperoni' ) make_pizza ( 'mushrooms' , \"green peppers\" , \"extra cheese\" ) The function responds appropriately, whether it receives one value or three values: Making a pizza with the following toppings: - pepperoni Making a pizza with the following toppings: - mushrooms - green peppers - extra cheese This syntax works no matter how many arguments the function receives. Mixing Positional and Arbitrary Arguments If you want a function to accept several different kinds of arguments, the parameter that accepts an arbitrary number of arguments must be placed last in the function definition. Python matches positional and keyword arguments first and then collects any remaining arguments in the final parameter. For example, if the function needs to take in a size for the pizza, that parameter must come before the parameter *toppings : 1 2 3 4 5 6 7 8 def make_pizza ( size , * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( f \" \\n Making a { size } -inch pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) In the function definition, Python assigns the first value it reveives to the parameter size . All other values that come after are stored in the tuple toppings . The function calls include an argument for the size first, followed by as many toppings as needed. Now each pizza has a size and a number of toppings, and each piece of information is printed in the proper place, showing size first and toppings after: Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese Using Arbitrary Keyword Arguments Sometimes you'll want to accept an arbitrary number of arguments, but you won't know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you'll get information about a user, but you're not sure what kind of information you will receive. The function build_profile() in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well: 1 2 3 4 5 6 7 8 def build_profile ( first , last , ** user_info ): \"\"\"Build a dictionary containing everything we know about a user.\"\"\" user_info [ 'first_name' ] = first user_info [ 'last_name' ] = last return user_info user_profile = build_profile ( 'albert' , 'einstein' , location = 'princeton' , field = 'physics' ) print ( user_profile ) The definition of build_profile() expects a first and last name, and then it allows the user to pass in as many name-value pairs as they want. The double asterisks ( ** ) before the parameter **user_info cause Python to create an empty dictionary called user_info and pack whatever name-value pairs it receives into this dictionary. Within the function, you can access the key-value pairs in user_info just as you would for any dictionary. In the body of build_profile() , we add the first and last names to the user_info dictionary because we'll always receive these two pieces of information from the user (line \u00be), and they haven't been placed into the dictionary yet. Then we return the user_info dictionary to the function call line. We call build_profile() , passing it the first name 'albert' , the last name 'einstein' , and the two key-value pairs location = 'princeton' and field = 'physics' . We assign the returned profile to user_profile and print user_profile : {'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'} The returned dictionary contains the user's first and last names and, in this case, the location and field of study as well. The function would work no matter how many additional key-value pairs are provided in the function call. You can mix positional, keyword, and arbitrary values in many different ways when writing your own functions. It's useful to know that all these argument types exist because you'll see them often when you start reading other people's code. It takes practice to learn to use the different types correctly and to know when to use each type. Storing Your Functions in Modules One advantage of functions is the way they separate blocks of code from your main program. By using descriptive names for your functions, your program will be much easier to follow. You can go a step further by storing your function in a separate file called a module and then importing that module into your main program. An import statement tells Python to make the code in a module available in the currently running program file. Storing your functions in a separate file allows you to hide the details of your program's code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written. There are several ways to import a module: Importing an Entire Module To start importing functions, we first need to create a module. A module is a file ending in .py that contains the code you want to import into your program. Let's make a module that contains the function make_pizza() . To make this module, we'll remove everything from the file pizza.py except the function make_pizza() . pizza.py : 1 2 3 4 5 def make_pizza ( size , * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( f \" \\n Making a { size } -inch pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) Now we'll make a separate file called making_pizzas.py in the same directory as pizza.py . This file imports the module we just created and then makes two calls to make_pizza() . making_pizzas.py : 1 2 3 4 import pizza pizza . make_pizza ( 16 , 'pepperoni' ) pizza . make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) When Python reads this file, the line import pizza tells Python to open the file pizza.py and copy all the functions from it into this program. You don't actually see code being copied between files because Python copies the code behind the scenes just before the program runs. All you need to know is that any function defined in pizza.py will now be available in making_pizzas.py . To call a function from an imported module, enter the name of the module you imported, pizza , followed by the name of the function, make_pizza() , separated by a dot (line 3). This code produces the same output as the original program that didn't import a module: Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese This first approach to importing, in which you simply write import followed by the name of the module, makes every function from the module available in your program. If you use this kind of import statement to import an entire module named module_name.py , each function in the module is available through the following syntax: module_name . function_name () Importing Specific Functions You can also import a specific function from a module. Here's the general syntax for this approach: from module_name import function_name You can import as many functions as you want from a module by separating each function's name with a comma: from module_name import function_0 , function_1 , function_2 The making_pizzas.py example would look like this if we want to import just the function we're going to use: 1 2 3 4 from pizza import make_pizza make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) With this syntax, you don't need to use the dot notation when you call a function. Because we've explicitly imported the function make_pizza() in the import statement, we can call it by name when we use the function. Using as to Give a Function an Alias If the name of a function you're importing might conflict with an existing name in your program or if the function name is long, you can use a short, unique alias - an alternate name similar to a nickname for a function. You'll give the function this special nickname when you import the function. Here we give the function make_pizza() an alias, mp() by importing make_pizza as mp . The as keyword renames a function using the alias you provide: 1 2 3 4 from pizza import make_pizza as mp mp ( 16 , 'pepperoni' ) mp ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) The import statement shown here renames the function make_pizza() to mp() in this program. Any time we want to call make_pizza() we can simply write mp() instead, and Python will run the code in make_pizza() while avoiding any confusion with another make_pizza() function you might have written in this program file. The general syntax for providing an alias is: from module_name import function_name as fn Importing All Functions in a Module You can tell Python to import every function in a module by using the asterisk ( * ) operator: 1 2 3 4 from pizza import * make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) The asterisk in the import statement tells Python to copy every function from the module pizza ( pizza.py ) into this program file. Because every function is imported, you can call each function by name without using the dot notation. However, it is best not to use this approach when you're working with larger modules that you didn't write: if the module has a function name that matches an existing name in your project, you can get some unexpected results. Python may see several functions or variables with the same name, and instead of importing all the functions separately, it will overwrite the functions. The best approach is to import the function or functions you want, or import the entire module and use the dot notation. This leads to clear code that's easy to read and understand. I include this section so you'll recognize import statements like the following when you see them in other people's code: from module_name import * Styling Functions You need to keep a few details in mind when you're styling functions. Functions should have descriptive names, and these names should use lowecase letters and underscores. Descriptive names help you and other understand what your code is trying to do. Module names should use these conventions as well. Every function should have a comment that explains concisely what the function does. This comment should appear immediately after the function definition and use the docstring format. In a well-documented function, other programmers can use the function by reading only the description in the docstring. They should be able to trust that the code works as described, and as long as they the name of the function, the arguments it needs, and the kind of value it returns, they should be able to use it in their programs. If you specify a default value for a parameter, no spaces should be used on either side of the equal sign: def function_name ( parameter_0 , parameter_1 = 'default value' ) The same convention should be used for keyword arguments in function calls: function_name ( value_0 , parameter_1 = 'value' ) PEP 8 recommends that you limit lines of code to 79 characters so every line is visible in a reasonably sized editor window. If a set of parameters causes a function's definition to be longer than 79 character, press ENTER after opening parenthesis on the definition line. On the next line, press TAB twice to separate the list of arguments from the body of the function, which will only be indented by one level. Most editors automatically line up any additional lines of parameters to match the indentation you have established on the first line: 1 2 3 4 def function_name ( parameter_0 , parameter_1 , parameter_2 parameter_3 , parameter_4 , parameter_5 ): function body ... If your program or module has more than one function, you can separate each by two blank lines to make it easier to see where one function ends and the next one begins. All import statements should be written at the beginning of a file. The only exception is if you use comments at the beginning of your file to describe the overall program.","title":"Functions"},{"location":"py-functions/#functions","text":"On this page we'll learn how to write functions , which are named blocks of code that are designed to do one specific job. When you want to perform a particular task that you've defined in a function, you call the function responsible for it. If you need to perform that task multiple times throughout your program, you don't need to type all the code for the same task again and again; you just call the function dedicated to handling that task, and the call tells Python to run the code inside the function. You'll find that using functions makes your programs easier to write, read, test, and fix. We will also learn ways to pass information to functions. We will learn how to write certain functions whose primary job is to display information and other functions desinged to process data and return a value or a set of values. Finally, we will cover how to store functions in separate files called modules to help organize our main program files.","title":"Functions"},{"location":"py-functions/#defining-a-function","text":"Here is a simple function named greet_user() that prints a greeting: 1 2 3 4 def greet_user (): \"\"\"Display a simple greeting.\"\"\" print ( \"Hello!\" ) greet_user () This example shows the simplest structure of a function. The code on line 1 uses the keyword def to inform Python that you're defining a function. This is the function definition , which tells Python the name of the function and, if applicable, what kind of information the function needs to do its job. The parentheses hold that information. In this case, the name of the function is greet_user() , and it needs no information to do its job, so its parentheses are empty. (Even so, the parentheses are required.) Finally, the definition ends in a colon. An indented lines that follow def greet_user (): make up the body of the function. The text on line 2 is a comment called a docstring , which describes what the function does. Docstrings are enclosed in triple quotes, which Python looks for when it generates documentaion for the functions in your programs. The line print ( \"Hello!\" ) on line 3 is the only line of actual code in the body of this function, so greet_user() has just one job: print ( \"Hello!\" ) . When you want to use this function, you call it. A function call tells Python to execute the code in the function. To call a function, you write the name of the function, followed by any necessary information in parentheses, as shown on line 4. Because no information is needed here, calling our function is as simple as entering greet_user() . As expected, it prints Hello! .","title":"Defining a Function"},{"location":"py-functions/#passing-information-to-a-function","text":"Modified slightly, the function greet_user() can not only tell the user Hello! but also greet them by name. For the function to do this, you enter username in the parentheses of the function's definition at def greet_user () . By adding username here you allow the function to accept any value of username you specify. The function now expects you to provide a value for username each time you call it. When you call greet_user() , you can pass it a name, such as 'jesse' , inside the parentheses: 1 2 3 4 5 def greet_user ( username ): \"\"\"Display a simple greeting.\"\"\" print ( f \"Hello, { username . title () } !\" ) greet_user ( 'jesse' ) Entering greet_user ( 'jesse' ) calls greet_user () and give the function the information it needs to execute the print () call. The function acceptsthe name you passed it and displays the greeting for that name: Hello, Jesse!","title":"Passing Information to a Function"},{"location":"py-functions/#arguments-and-parameters","text":"In the preceding greet_user() function, we defined greet_user() to require a value for the variable username . Once we called the function and gave it the information (a person's name), it printed the right greeting. The variable username in the definition of greet_user() is an example of a parameter , a piece of information the function needs to do its job. The value 'jesse' is reet_user ( 'jesse' ) is an example of an argument . An argument is a piece of information that's passed from a function call to a function. When we call the function, we place the value we want the function to work with in the parenthese. In this case the argument 'jesse' was passed to the function greet_user() , and the value was assigned to the parameter username .","title":"Arguments and Parameters"},{"location":"py-functions/#passing-arguments","text":"Because a function definition can have multiple parameters, a function call may need multiple arguments. You can pass arguments to your functions in a number of ways. You can use positional arguments , which need to be in the same order as the parameters were written; keyword arguements , where each argument consists of a variable name and a value; and lists and dictionaries of values.","title":"Passing Arguments"},{"location":"py-functions/#positional-arguments","text":"When you call a function, Python must match each argument in the function call with a parameter in the function definition. The simplest way to do this is baased on the order of the arguments provided. Values matched up this way are called positional arguments . To see how this works, consider a function that displays information about pets. The function tells us what kind of animal each pet is and the pet's name, as shown here: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'hamster' , 'harry' ) The definition shows that this function needs a type of animal and the animal's name (line 1). When we call describe_pet() , we need to provide an animal type and a name, in that order. For example, in the function call, the argument 'hamster' is assigned to the parameter animal_type and the argument 'harry' is assigned to the parameter pet_name (line 6). In the function body, these two parameters are used to display information about the pet being described. The output describes a hamster named Harry: I have a hamster. My hamster's name is Harry.","title":"Positional Arguments"},{"location":"py-functions/#multiple-function-calls","text":"You can call a function as many times as needed. Describing a second, different pet requires just one more call to describe_pet() : 1 2 3 4 5 6 7 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'hamster' , 'harry' ) describe_pet ( 'dog' , 'willie' ) The only change above was to line 7. In the second function call, we pass describe_pet() the arguments 'dog' and 'willie' . As with the previous set of arguments we used, Python matches 'dog' with the parameter animal_type and 'willie' with the parameter pet_name . As before, the function does its job, but this time it also prints the values for a Dog named Willie: I have a hamster. My hamster's name is Harry. I have a dog. My dog's name is Willie. Calling a function multiple times is a very efficient way to work. The code describing a pet is written once in the function. Then, anytime you want to describe a new pet, you call the function with the new pet's information. Even if the code for describing a pet were to expand to ten lines, you could still describe a new pet in just one line by calling the function again. You can use as many positional arguments as you need in your functions. Python works through the arguments you provide when calling the function and matches each one with the corresponding parameter in the function's definition.","title":"Multiple Function Calls"},{"location":"py-functions/#order-matters-in-positional-arguments","text":"You can get unexpected results if you mix up the order of the arguments in a function call when using positional arguments: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( 'harry' , 'hamster' ) In the above function, we list the name first and the type of animal second. Because the argument 'harry' is listed first this time, that value is assigned to the parameter animal_type . Likewise, 'hamster' is assigned to pet_name . Now we have a \"harry\" named \"Hamster\": I have a harry. My harry's name is Hamster. If you get funny results like this, check to make sure the order of the arguments in your function call matches the order of the parameters in the function's definition.","title":"Order Matters in Positional Arguments"},{"location":"py-functions/#keyword-arguments","text":"A keyword argument is a name-value pair that you pass to a function. You directly associate the name of the value within the argument, so when you pass the argument to the function, there's no confusion (you won't end up with a harry named Hamster). Keyword arguments free you from having to worry about correctly ordering your arguments in the function call, and they clarify the role of each value in the function call. Let's rewrite the program from above using keyword arguments to call describe_pet() : 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) The function describe_pet() hasn't changed, but when we call the function, we explicitly tell Python which parameter each argument should be matched with. When Python reads the function call, it knows to assign the argument 'hamster' to the parameter animal_type and the argument 'harry' to pet_name . The output correctly shows that we have a hamster named Harry. The order of keyword arguments doesn't matter because Python knows where each value should go. The following two function calls are equivalent: 1 2 describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) describe_pet ( pet_name = 'harry' , animal_type = 'hamster' )","title":"Keyword Arguments"},{"location":"py-functions/#default-values","text":"When writing a function, you can define a default value for each parameter. If an argument for a parameter is proivided in the function call, Python uses the argument value. If not, it uses the parameter's default value. So when you define a default value for a parameter, you can exclude the corresponding argument you'd usually write in the function call. Using default values can simplify your function calls and clarify the ways in which your functions are typically used. For example, if you notice that most of the calls to describe_pet() are being used to describe dogs, you can set the default value of animal_type to 'dog' . Now anyone calling describe_pet() for a dog can omit that information: 1 2 3 4 5 6 def describe_pet ( pet_name , animal_type = 'dog' ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet ( pet_name = 'willie' ) We changed the definition of describe_pet() to include a default value, 'dog' , for animal_type . Now when the function is called with no animal_type specified, Python knows to use the value 'dog' for this parameter: I have a dog. My dog's name is Willie. Note that the order of the parameters in the function definition had to be changed. Because the default value makes it unnecessary to specify a type of animal as an argument, the only argument left in the function call is the pet's name. Python still interprets this as a positional argument, so if the function is called with just the pet's name, that argument will match up with the first parameter listed in the function's definition. This is the reason the first parameter needs to be pet_name . The simplest way to use this function now is to provide just a dog's name in the function call: describe_pet ( 'willie' ) This function call would have the same output as the previous example. The only argument provided is 'willie' , so it is matched up with the first parameter in the definition, pet_name . Because no argument is provided for animal_type , Python uses the default value 'dog' . To describe an animal other than a dog, you could use a function call like this: describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) Because an explicit argument for animal_type is provoided, Python will ignore the parameter's default value. Note on default values When you use default values, any parameter with a default value needs to be listed after all the parameters that don't have default values. This allows Python to continue interpreting positional arguments correctly.","title":"Default Values"},{"location":"py-functions/#equivalent-function-calls","text":"Because positional arguments, keyword arguments, and default values can all be used together, often you'll have several equivalent ways to call a function. Consider the following definition for describe_pet() with one default value provided: def describe_pet ( pet_name , animal_type = 'dog' ): With this definition, an argument always needs to be provided for pet_name , and this value can be provided using the positional or keyword format. If the animal being described is not a dog, an argument for animal_type mist be included in the call, and this argument can also be specified using the positional or keyword format. All the follwoing calls would work for this function: 1 2 3 4 5 6 7 8 # A dog named Willie. describe_pet ( 'willie' ) describe_pet ( pet_name = 'willie' ) # A hamster named Harry. describe_pet ( 'harry' , 'hamster' ) describe_pet ( pet_name = 'harry' , animal_type = 'hamster' ) describe_pet ( animal_type = 'hamster' , pet_name = 'harry' ) Each of these function calls would have the same output as the previous examples. It doesn't really matter which calling style you use. As long as your function calls produce the output you want, just use the style you find easiest to understand.","title":"Equivalent Function Calls"},{"location":"py-functions/#avoiding-argument-errors","text":"When you start to use functions, don't be surprides if you encounter errors about unmatched arguments. Unmatched arguments occur when you provide fewer or more arguments than a function needs to do its wor. For example, here's what happens if we try to call describe_pet() with no arguments: 1 2 3 4 5 6 def describe_pet ( animal_type , pet_name ): \"\"\"Display information about a pet.\"\"\" print ( f \" \\n I have a { animal_type } .\" ) print ( f \"My { animal_type } 's name is { pet_name . title () } .\" ) describe_pet () Python recognizes that some information is missing from the function call, and the traceback tells us that: TypeError Traceback (most recent call last) File <\"pets.py\">, line 6, in <module> 4 print(f\"My {animal_type}'s name is {pet_name.title()}.\") 5 ----> 6 describe_pet() TypeError: describe_pet() missing 2 required positional arguments: 'animal_type' and 'pet_name' The traceback tells us the location of the problem (line 6), allowing us to look back and see that something went wrong in our function call. Next, the offending function call is written out for us to see. Finally, the traceback tells us the call is missing two arguments and reports the names of the missing arguments. If this function were in a separate file, we could probably rewrite the call correctly without having to open that file and read the function code. Python is helpful in that it reads the function's code for us and tells us the names of the argument we need to provide. This is another motivation for giving your variables and functions descriptive names. If you do, Pythons error messages will be more useful to you and anyone else who might use your code. If you provide too many arguments, you should get a similar traceback that cal help you correctly match your function call to the function definition.","title":"Avoiding Argument Errors"},{"location":"py-functions/#return-values","text":"A function doesn't always have to display its output directly. Instead, it can process some data and then reutn a value or set of values. The value the function returns is called a return value . The return statement takes a value from inside a function and sends it back to the line that called the function. Return values allow you to move much of your program's grunt work into functions, which can simplify the body of your program.","title":"Return Values"},{"location":"py-functions/#returning-a-simple-value","text":"Let's look at a function that takes a first and last name, and returns a neatly formatted name: 1 2 3 4 5 6 7 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, fully formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'jimi' , 'hendrix' ) print ( musician ) The defintion of get_formatted_name() takes as parameters a first and last name (line 1). The function combines these two names, adds a space between them, and assigns the result to full_name (line 3). The value of full_name is converted to title case, and then returned to the calling line at line 4. When you call a function that returns a value, you need to provide a variable that the return value can be assigned to. In this case, the returned value is assigned to the variable musician on line 6. The output shows a neatly formatted name made up of the parts of a person's name: Jimi Hendrix This might seem like a lot of work to get a neatly formatted name when we could have just written: print ( \"Jimi Hendrix\" ) But when you consider working with a large program that needs to store many first and last names separately, functions like get_formatted_name() become very useful. You store first and last names separately and then call this function whenever you want to display a full name.","title":"Returning a Simple Value"},{"location":"py-functions/#making-an-argument-optional","text":"Sometimes it makes sense to make an argument optional so that people using the function can choose to provide extra information only if they want to. You can use default values to make an argument optional. For example, say we want to exapand get_formatted_name() to handle middle names as well. A first attempt to include middle names might look like this: 1 2 3 4 5 6 7 def get_formatted_name ( first_name , middle_name , last_name ): \"\"\"Return a full name, fully formatted.\"\"\" full_name = f \" { first_name } { middle_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'john' , 'lee' 'hooker' ) print ( musician ) This function works when given a first, middle, and last name. The function takes in all three parts of a name and then builds a string out of them. The function adds spaces where appropriate and converts the full name to title case: John Lee Hooker But middle names aren't always needed, and this function as written would not work if you tried to call it with only a first name and a last name. To make a middle name optional, we can give the middle_name argument an empty default valuye and ignore the argument unless a user provides a value. To make get_formatted_name() work without a middle name, we set the default value of middle_name to an empty string and move it to the end of list of parameters: 1 2 3 4 5 6 7 8 9 10 11 12 13 def get_formatted_name ( first_name , last_name , middle_name = '' ): \"\"\"Return a full name, neatly formatted.\"\"\" if middle_name : full_name = f \" { first_name } { middle_name } { last_name } \" else : full_name = f \" { first_name } { last_name } \" return full_name . title () musician = get_formatted_name ( 'jimi' , 'hendrix' ) print ( musician ) musician = get_formatted_name ( 'john' , 'hooker' , 'lee' ) print ( musician ) In this example, the name is built from three possible parts. Because there's always a first and last name, these parameters are listed first in the function's definition. The middle name is optional, so it's listed last in the definition, and its default value is an empty string (line 1). In the body of the function, we check to see if a middle name has been provided. Python interprets non-empty strings as True , so if middle_name evaluates to True if a middle name argument is in the function call (line 3). If a middle name is provided, the first, middle, and last names are combined to form a full name. This name is then changed to title case and returned to the function call line where it's assigned to the variable musician and printed. If no middle name is provided, the empty string fails the if test and the else block runs (line 5). The full name is made with just a dirst and last name, and the formatted name is returned to the calling line where it's assigned to musician and printed. Calling this function with a first and last name is straightforward. If we're using a middle name, however, we have to make sure the middle name is the last argument passed so Python will match up the positional arguments correctly (line 12). This modified version of our function works for people with just a first and last name, and it works for people who have a middle name as well: Jimi Hendrix John Lee Hooker Optional values allow functions to handle a wide range of use cases while letting function calls remain as simple as possible.","title":"Making an Argument Optional"},{"location":"py-functions/#returning-a-dictionary","text":"A function can return any kind of value you need it to, including more complicated data structures like lists and dictionaries. For example, the following function takes in parts of a name and returns a dictionary representing a person: 1 2 3 4 5 6 7 def build_person ( first_name , last_name ): \"\"\"Return a dictionary of information about a person.\"\"\" person = { 'first' : first_name , 'last' : last_name } return person musician = build_person ( 'jimi' , 'hendrix' ) print ( musician ) The function build_person() takes in a first and last name, and puts these values into a dictionary (line 3). The value of first_name is stored with the key 'first' , and the value of last_name is stored with the key 'last' . The entire dictionary representing the person is returned at line 4. The return value is printed on the final line with the original two pieces of textual information now stored in a dictionary: {'first': 'jimi', 'last': 'hendrix'} This function takes in a simple textual information and puts it into a more meaningful data structure that lets you work with the information beyond just printing it. The strings 'jimi' and 'hendrix' are now labeled as a first name and last name. You can easily extend this function to accept optional values like a middle name, an age, an occupation, or any other information you want to store about a person. For example, the following change allows you to store a person's age as well: 1 2 3 4 5 6 7 8 9 def build_person ( first_name , last_name , age = None ): \"\"\"Return a dictionary of information about a person.\"\"\" person = { 'first' : first_name , 'last' : last_name } if age : person [ 'age' ] = age return person musician = build_person ( 'jimi' , 'hendrix' , age = 27 ) print ( musician ) We add a new optional parameter age to the function definition and assign the parameter the special value None , which is used when a variable has no specific value assigned to it. You can think of None as a placeholder value. In conditional tests, None evaluates to False . If the function call includes a value fo age , that value is stored in the dictionary. This function always stores a person's name, but it can also be modified to store any other information you want about a person.","title":"Returning a Dictionary"},{"location":"py-functions/#using-a-function-with-a-while-loop","text":"You can use functions with all the Python structures you've learned about so far. For example, let's use the get_formatted_name() function with a while loop to greet users more formally. Here's a first attempt at greeting people using their first and last names: 1 2 3 4 5 6 7 8 9 10 11 12 13 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, neatly formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () # This is an infinite loop! while True : print ( \" \\n Please tell me your name:\" ) f_name = input ( \"First name: \" ) l_name = input ( \"Last name: \" ) formatted_name = get_formatted_name ( f_name , l_name ) print ( f \" \\n Hello, { formatted_name } !\" ) For this example, we use a simple version of get_formatted_name() that doesn't involve middle names. The while loop asks the user to enter their name, and we prompt for their first and last name separately (line 8). But there's one problem with this while loop: We haven't defined a quit condition. Where do you put a quit condition when you ask for a series of input? We want the user to be able to quit as easily as possible, so each prompt should offer a way to quit. The break statement offers a straightforward way to exit the loop at either prompt: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def get_formatted_name ( first_name , last_name ): \"\"\"Return a full name, neatly formatted.\"\"\" full_name = f \" { first_name } { last_name } \" return full_name . title () # This is an infinite loop! while True : print ( \" \\n Please tell me your name:\" ) print ( \"(enter 'q' at any time to quit)\" ) f_name = input ( \"First name: \" ) if f_name == 'q' : break l_name = input ( \"Last name: \" ) if l_name == 'q' : break formatted_name = get_formatted_name ( f_name , l_name ) print ( f \" \\n Hello, { formatted_name } !\" ) We add a message that informs the user how to quit, and then we break out of the loop if the user enters the quit value at either prompt. Now the program will continue greeting people until someone enters 'q' for either name: Please tell me your name: (enter 'q' at any time to quit) First name: Nick Last name: Platt Hello, Nick Platt! Please tell me your name: (enter 'q' at any time to quit) First name: q","title":"Using a Function with a while Loop"},{"location":"py-functions/#passing-a-list","text":"You'll often find it useful to pass a list to a function, whether it's a list of names, numbers, or more complex objects, such as dictionaries. When you pass a list to a function, the function gets direct access to the contents of the list. Let's use functions to make working with lists more efficient. Say we have a list of users and want to print a greeting to each. The following example sends a list of names to a function called greet_users() , which greets each person in the list individually: 1 2 3 4 5 6 7 8 def greet_users ( names ): \"\"\"Print a simple greeting to each user in the list.\"\"\" for name in names : msg = f \"Hello, { name . title () } !\" print ( msg ) usernames = [ 'hannah' , 'ty' , 'margot' ] greet_users ( usernames ) We define greet_users() so it expects a list of names, which it assigns to the parameter names . The function loops through the list it receives and prints a greeting to each user. On line 7, we define a list of users and then pass the list usernames to greet_users() in our function call: Hello, Hannah! Hello, Ty! Hello, Margot! This is the output we wanted. Every user sees a personalized greeting, and you can call the function any time you want to greet a specific set of users.","title":"Passing a List"},{"location":"py-functions/#modifying-a-list-in-a-function","text":"When you pass a list to a function, the function can modify the list. Any changes made to the list inside the function's body are permanent, allowing you to work efficiently even when you're dealing with large amounts of data. Consider a company that creates 3D printed models of designs that users submit. Designs that need to be printed are stored in a list, and after being printed they're moved to a separate list. The following code does this without using functions: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Start with some designs that need to be printed. unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] # Simulate printing each design, until none are left. # Move each design to completed_models after printing. while unprinted_designs : current_design = unprinted_designs . pop () print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) # Display all completed models. print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) This program starts with a list of designs that need to be printed and an empty list called completed_models that each design will be moved to after it has been printed. As long as designs remain unprinted_designs , the while loop simulates printing each design by removing a design from the end of the list, storing it in current_design , and displaying a message that current design is being printed. It then adds the design to the list of completed models. When the loop is finished running, a list of designs that have been printed is displayed: Printing model: dodecahedron Printing model: robot pendant Printing model: phone case The following models have been printed: dodecahedron robot pendant phone case We can reorganize this code by writing two functions, each of which does one specific job. Most of the code won't change; we're just making it more carefully structured. The first function will handle printing the designs, and the second will summarize the prints that have been made: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def print_models ( unprinted_designs , completed_models ): \"\"\" Simulate printing each design, until none are left. Move each design to completed_models after printing. \"\"\" while unprinted_designs : current_design = unprinted_designs . pop () print ( f \"Printing model: { current_design } \" ) completed_models . append ( current_design ) def show_completed_models ( completed_models ): \"\"\"Show all the models that were printed.\"\"\" print ( \" \\n The following models have been printed:\" ) for completed_model in completed_models : print ( completed_model ) unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] print_models ( unprinted_designs , completed_models ) show_completed_models ( completed_models ) On line 1 we define the function print_models() with two parameters: a list of designs that need to be printed and a list of completed models. Given these two lists, the function simulates printing each design by emptying the list of unprinted designs and filling up the list of completed models. On line 10 we define the function show_completed_models() with one parameter: the list of completed models. Given this list, show_completed_models() displays the name of each model that was printed. This program has the same output as the version without functions, but the code is much more organized. The code that does most of the work has been moved to two separate functions, which makes the main part of the program easier to understand. Look at the body of the program to see how much easier it is to understand what this program is doing: 1 2 3 4 5 unprinted_designs = [ 'phone case' , 'robot pendant' , 'dodecahedron' ] completed_models = [] print_models ( unprinted_designs , completed_models ) show_completed_models ( completed_models ) We set up a list of unprinted designs and an empty list that will hold the completed models. Then, because we've already defined our two functions, all we have to do is call them and pass them the right arguments. We call print_models() and pass it the two lists it needs; as expected, print_models() simulates printing the designs. Then we call show_completed_models() and pass it the list of completed models so it can report the models that have been printed. The descriptive function names allow others to read this code and understand it, even without comments. This program is easier to extend and maintain than the version without functions. If we need to print more designs later on, we can simply call print_models() again. If we realize the printing code needs to be modified, we can change the code once, and our changes will take place everywhere the function is called. This technique is more efficient than having to update code separately in several places in the program. This example also demonstrates the idea that every function should have one specific job. The first function prints each design, and the second displays the completed models. This is more beneficial than using one function to do both jobs. If you're writing a function and notice the function is doing too many different tasks, try to split the code into two functions. Remember that you can always call a function from another function, which can be helpful when splitting a complex task into a series of steps.","title":"Modifying a List in a Function"},{"location":"py-functions/#preventing-a-function-from-modifying-a-list","text":"Sometimes you'll want to prevent a function from modifying a list. For example, say that you start with a list of unprinted designs and write a function to move them to a list of completed models, as in the previous example. You may decide that even though you've printed all the designs, you want to keep the original list of unprinted designs for your records. But because you moved all the desing names out of unprinted_designs , the list is now empty, and the empty list is the only version you have; the original is gone. In this case, you can address this issue by passing the function a copy of the list, not the original. Any changes the function makes to the list will affect only the copy, leaving the original list intact. You can send a copy of a list to a function like this: function_name ( list_name [:]) Ths slice notation [:] makes a copy of the list to send to the function. If we didn't want to empty the list of unprinted desings in printing_models.py , we could call print_models() like this: print_models ( unprinted_designs [:], completed_models ) The function print_models() can do its work because it still receives the names of all unprinted designs. But this time it uses a copy of the original unprinted desings list, not the actual unprinted_designs list. The list completed_models will fill up with the names of printed models like it did before, but original list of unprinted designs will be unaffected by the function. Even though you can preserve the contents of a list by passing a copy of it to your functions, you should pass the original list to functions unless you have a specific reason to pass a copy. It's more efficient for a function to work with an existing list to avoid using the time and memory needed to make a separate copy, especially when you're working with large lists.","title":"Preventing a Function from Modifying a List"},{"location":"py-functions/#passing-an-arbitrary-number-of-arguments","text":"Sometimes you won't know ahead of time how many arguments a function needs to accept. Fortunately, Python allows a function to collect an arbitrary number of arguments from the calling statement. For example, consider a function that builds a pizza. It needs to accept a number of toppings, but you can't know ahead of time how many toppings a person will want. The function in the following example has one parameter, *toppings , but this parameter collects as many arguments as the calling line provides: 1 2 3 4 5 6 def make_pizza ( * toppings ): \"\"\"Print the list of toppings that have been requested.\"\"\" print ( toppings ) make_pizza ( 'pepperoni' ) make_pizza ( 'mushrooms' , 'green peppers' , 'extra cheese' ) The asterisk ( * ) in the parameter name *toppings tells Python to make an empty tuple called toppings and pack whatever values it receives into this tuple. The print () call in the function body produces output showing that Python can handle a function call with one value and a call with three values. It treats the different calls similarly. Note that Python packs the arguments into a tuple, even if the function receives only one value: ('pepperoni',) ('mushrooms', 'green peppers', 'extra cheese') Now we can replace the print() call with a loop that runs through the list of toppings and describes the pizza being ordered: 1 2 3 4 5 6 7 8 def make_pizza ( * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( \" \\n Making a pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) make_pizza ( 'pepperoni' ) make_pizza ( 'mushrooms' , \"green peppers\" , \"extra cheese\" ) The function responds appropriately, whether it receives one value or three values: Making a pizza with the following toppings: - pepperoni Making a pizza with the following toppings: - mushrooms - green peppers - extra cheese This syntax works no matter how many arguments the function receives.","title":"Passing an Arbitrary Number of Arguments"},{"location":"py-functions/#mixing-positional-and-arbitrary-arguments","text":"If you want a function to accept several different kinds of arguments, the parameter that accepts an arbitrary number of arguments must be placed last in the function definition. Python matches positional and keyword arguments first and then collects any remaining arguments in the final parameter. For example, if the function needs to take in a size for the pizza, that parameter must come before the parameter *toppings : 1 2 3 4 5 6 7 8 def make_pizza ( size , * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( f \" \\n Making a { size } -inch pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) In the function definition, Python assigns the first value it reveives to the parameter size . All other values that come after are stored in the tuple toppings . The function calls include an argument for the size first, followed by as many toppings as needed. Now each pizza has a size and a number of toppings, and each piece of information is printed in the proper place, showing size first and toppings after: Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese","title":"Mixing Positional and Arbitrary Arguments"},{"location":"py-functions/#using-arbitrary-keyword-arguments","text":"Sometimes you'll want to accept an arbitrary number of arguments, but you won't know ahead of time what kind of information will be passed to the function. In this case, you can write functions that accept as many key-value pairs as the calling statement provides. One example involves building user profiles: you know you'll get information about a user, but you're not sure what kind of information you will receive. The function build_profile() in the following example always takes in a first and last name, but it accepts an arbitrary number of keyword arguments as well: 1 2 3 4 5 6 7 8 def build_profile ( first , last , ** user_info ): \"\"\"Build a dictionary containing everything we know about a user.\"\"\" user_info [ 'first_name' ] = first user_info [ 'last_name' ] = last return user_info user_profile = build_profile ( 'albert' , 'einstein' , location = 'princeton' , field = 'physics' ) print ( user_profile ) The definition of build_profile() expects a first and last name, and then it allows the user to pass in as many name-value pairs as they want. The double asterisks ( ** ) before the parameter **user_info cause Python to create an empty dictionary called user_info and pack whatever name-value pairs it receives into this dictionary. Within the function, you can access the key-value pairs in user_info just as you would for any dictionary. In the body of build_profile() , we add the first and last names to the user_info dictionary because we'll always receive these two pieces of information from the user (line \u00be), and they haven't been placed into the dictionary yet. Then we return the user_info dictionary to the function call line. We call build_profile() , passing it the first name 'albert' , the last name 'einstein' , and the two key-value pairs location = 'princeton' and field = 'physics' . We assign the returned profile to user_profile and print user_profile : {'location': 'princeton', 'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein'} The returned dictionary contains the user's first and last names and, in this case, the location and field of study as well. The function would work no matter how many additional key-value pairs are provided in the function call. You can mix positional, keyword, and arbitrary values in many different ways when writing your own functions. It's useful to know that all these argument types exist because you'll see them often when you start reading other people's code. It takes practice to learn to use the different types correctly and to know when to use each type.","title":"Using Arbitrary Keyword Arguments"},{"location":"py-functions/#storing-your-functions-in-modules","text":"One advantage of functions is the way they separate blocks of code from your main program. By using descriptive names for your functions, your program will be much easier to follow. You can go a step further by storing your function in a separate file called a module and then importing that module into your main program. An import statement tells Python to make the code in a module available in the currently running program file. Storing your functions in a separate file allows you to hide the details of your program's code and focus on its higher-level logic. It also allows you to reuse functions in many different programs. When you store your functions in separate files, you can share those files with other programmers without having to share your entire program. Knowing how to import functions also allows you to use libraries of functions that other programmers have written. There are several ways to import a module:","title":"Storing Your Functions in Modules"},{"location":"py-functions/#importing-an-entire-module","text":"To start importing functions, we first need to create a module. A module is a file ending in .py that contains the code you want to import into your program. Let's make a module that contains the function make_pizza() . To make this module, we'll remove everything from the file pizza.py except the function make_pizza() . pizza.py : 1 2 3 4 5 def make_pizza ( size , * toppings ): \"\"\"Summarize the pizza we are about to make.\"\"\" print ( f \" \\n Making a { size } -inch pizza with the following toppings:\" ) for topping in toppings : print ( f \"- { topping } \" ) Now we'll make a separate file called making_pizzas.py in the same directory as pizza.py . This file imports the module we just created and then makes two calls to make_pizza() . making_pizzas.py : 1 2 3 4 import pizza pizza . make_pizza ( 16 , 'pepperoni' ) pizza . make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) When Python reads this file, the line import pizza tells Python to open the file pizza.py and copy all the functions from it into this program. You don't actually see code being copied between files because Python copies the code behind the scenes just before the program runs. All you need to know is that any function defined in pizza.py will now be available in making_pizzas.py . To call a function from an imported module, enter the name of the module you imported, pizza , followed by the name of the function, make_pizza() , separated by a dot (line 3). This code produces the same output as the original program that didn't import a module: Making a 16-inch pizza with the following toppings: - pepperoni Making a 12-inch pizza with the following toppings: - mushrooms - green peppers - extra cheese This first approach to importing, in which you simply write import followed by the name of the module, makes every function from the module available in your program. If you use this kind of import statement to import an entire module named module_name.py , each function in the module is available through the following syntax: module_name . function_name ()","title":"Importing an Entire Module"},{"location":"py-functions/#importing-specific-functions","text":"You can also import a specific function from a module. Here's the general syntax for this approach: from module_name import function_name You can import as many functions as you want from a module by separating each function's name with a comma: from module_name import function_0 , function_1 , function_2 The making_pizzas.py example would look like this if we want to import just the function we're going to use: 1 2 3 4 from pizza import make_pizza make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) With this syntax, you don't need to use the dot notation when you call a function. Because we've explicitly imported the function make_pizza() in the import statement, we can call it by name when we use the function.","title":"Importing Specific Functions"},{"location":"py-functions/#using-as-to-give-a-function-an-alias","text":"If the name of a function you're importing might conflict with an existing name in your program or if the function name is long, you can use a short, unique alias - an alternate name similar to a nickname for a function. You'll give the function this special nickname when you import the function. Here we give the function make_pizza() an alias, mp() by importing make_pizza as mp . The as keyword renames a function using the alias you provide: 1 2 3 4 from pizza import make_pizza as mp mp ( 16 , 'pepperoni' ) mp ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) The import statement shown here renames the function make_pizza() to mp() in this program. Any time we want to call make_pizza() we can simply write mp() instead, and Python will run the code in make_pizza() while avoiding any confusion with another make_pizza() function you might have written in this program file. The general syntax for providing an alias is: from module_name import function_name as fn","title":"Using as to Give a Function an Alias"},{"location":"py-functions/#importing-all-functions-in-a-module","text":"You can tell Python to import every function in a module by using the asterisk ( * ) operator: 1 2 3 4 from pizza import * make_pizza ( 16 , 'pepperoni' ) make_pizza ( 12 , 'mushrooms' , 'green peppers' , 'extra cheese' ) The asterisk in the import statement tells Python to copy every function from the module pizza ( pizza.py ) into this program file. Because every function is imported, you can call each function by name without using the dot notation. However, it is best not to use this approach when you're working with larger modules that you didn't write: if the module has a function name that matches an existing name in your project, you can get some unexpected results. Python may see several functions or variables with the same name, and instead of importing all the functions separately, it will overwrite the functions. The best approach is to import the function or functions you want, or import the entire module and use the dot notation. This leads to clear code that's easy to read and understand. I include this section so you'll recognize import statements like the following when you see them in other people's code: from module_name import *","title":"Importing All Functions in a Module"},{"location":"py-functions/#styling-functions","text":"You need to keep a few details in mind when you're styling functions. Functions should have descriptive names, and these names should use lowecase letters and underscores. Descriptive names help you and other understand what your code is trying to do. Module names should use these conventions as well. Every function should have a comment that explains concisely what the function does. This comment should appear immediately after the function definition and use the docstring format. In a well-documented function, other programmers can use the function by reading only the description in the docstring. They should be able to trust that the code works as described, and as long as they the name of the function, the arguments it needs, and the kind of value it returns, they should be able to use it in their programs. If you specify a default value for a parameter, no spaces should be used on either side of the equal sign: def function_name ( parameter_0 , parameter_1 = 'default value' ) The same convention should be used for keyword arguments in function calls: function_name ( value_0 , parameter_1 = 'value' ) PEP 8 recommends that you limit lines of code to 79 characters so every line is visible in a reasonably sized editor window. If a set of parameters causes a function's definition to be longer than 79 character, press ENTER after opening parenthesis on the definition line. On the next line, press TAB twice to separate the list of arguments from the body of the function, which will only be indented by one level. Most editors automatically line up any additional lines of parameters to match the indentation you have established on the first line: 1 2 3 4 def function_name ( parameter_0 , parameter_1 , parameter_2 parameter_3 , parameter_4 , parameter_5 ): function body ... If your program or module has more than one function, you can separate each by two blank lines to make it easier to see where one function ends and the next one begins. All import statements should be written at the beginning of a file. The only exception is if you use comments at the beginning of your file to describe the overall program.","title":"Styling Functions"},{"location":"py-if-statements/","text":"If Statements Python often involves examining a set of conditions and deciding which action to take based on those conditions. Python's if statement allows you to examine the current state of a program and respond appropriately to that state. A Simple Example The following short example shows how if tests let you respond to special situations correctly. Imagine you have a list of cars and you want to print out the name of each car. Car names are proper names, so the names of most cars should be printed in title case. However, the value 'bmw' should be printed in all uppercase. The following code loops through a list of car names and looks for the value 'bmw' . Whenever the value is 'bmw' , it's printed in uppercase instead of title case. 1 2 3 4 5 6 7 cars = [ 'audi' , 'bmw' , 'subaru' , 'toyota' ] for car in cars : if car == 'bmw' : print ( car . upper ()) else : print ( car . title ()) The loop in this example first checks to see if the current value of car is 'bmw' . If it is, the value is printed in all uppercase. If the value of car is anything other than 'bmw' , it's printed in title case: Audi BMW Subaru Toyota Conditional Tests At the heart of every if statement is an expression that canbe evaluated as True or False and is called a conditional test . Python uses the values True and False to decide whether the code in an if statement should be executed. If a conditional test evaluates to True , Python executes the code following the if statement. If the test evaluates to False , Python ignores the code following the if statement. Checking for Equality Most conditional tests compare the current value of a variable to a specific value of interest. The simplest conditional test checks whether the value of a variable is equal to the value of interest: 1 2 car = 'bmw' car == 'bmw' True The code at line 1 sets the value of car to 'bmw' using a single equal sign, as you've seen many times already. The code at line 2 checks whether the value of car is 'bmw' using a double equal sign ( == ). This equality operator returns True if the values on the left and right side of the operator match, and False if they don't match. The values in this example match, so Python returns True . When the value of car is anything other than 'bmw' , this test returns False . 1 2 car = 'audi' car == 'bmw' False A single equal sign is really a statment; you might read the code at line one as \"Set the value of car equal to 'audi' \". On the other side, a double equal sign, like the one on line 2, asks a question: \"Is the vale of car equal to 'bmw' ?\" Most programming languages use equal signs in this way. Ignoring Case When Checking for Equality Testing for equality is case sensitive in Python. For example, ywo values with different capitalization are not considered equal: 1 2 car = 'Audi' car == 'audi' False If case matters, this behavior is advantageous. But if case doesn't matter and instead you just want to test the value of a variable, you can convert the variable's value to lowercase before doing the comparison: 1 2 car = 'Audi' car . lower () == 'audi' True This test would return True no matter how the value 'Audi' is formatted because the test is now case insensitive. The lower () function doesn't change the value that was originally stored in car , so you can do this kind of comparison without affecting the original variable: 1 2 car = 'Audi' car . lower () == 'audi' True 1 car 'Audi' At the first line 1, we assigned the capitalized string 'Audi' to the variable car . At line 2, we convert the value of car to lowercase and compare the lowercase value to the string 'audi' . The two strings match, so Python returns True . When we check what is stored in car again, we can see that it has not been affected by the lower () method. Websites enforce certain rules for the data that users enter in a manner similar to this. For example, a site might use a conditional test like this to ensure that every user has a truly unique username, not just a variation on the capitalization of another person's username. When someone submits a username, that new username is converted to lowercase and compared to the lowercase versions of all existing usernames. During this check, a username like 'John' will be rejected if any variation of 'john' is already in use. Checking for Inequality When you want to determine whether two values are not equal, you can combine an exclamation point and an equal sign (!=). The exclamation point represents not , as it does in many programming languages. Let's use another if statement to examine how to use the inequality operator. We'll store a requested pizza topping in a variable and then print a message if the person did not order anchovies: 1 2 3 4 requested_topping = 'mushrooms' if requested_topping != 'anchovies' : print ( \"Hold the anchovies!\" ) The code on line 3 compares the value of requested_topping to the value anchovies . If these two values do not match, Python returns True and executes the code following the if statement. If the two values match, Python returns False and does not run the code following the if statement. Because the value of requested_topping is not anchovies , the print () function is executed: Hold the anchovies! Most of the conditional expressions you write will test for equality, but sometimes you'll find it more efficient to test for inequality. Numerical Comparisons Testing numerical values is pretty straightforward. For example, the following code checks whether a person is 18 years old: 1 2 age = '18' age == '18' True You can also test to see if two numbers are not equal. For example, the following code prints a message if the given answer is not correct: 1 2 3 4 answer = 17 if answer != 42 : print ( \"That is not the correct answer. Please try again!\" ) The conditional test at line 3 passes, because the value of answer (17) is not equal to 42. Because the test passes, the indented code block is executed. You can include various mathematical comparisons in your conditional statements as well, such as less than, less than or equal to, greater than, and greater than or equal to. Checking Multiple Conditions You may want to check multiple conditions at the same time. For example, sometimes you might need two conditions to be True to take an action. Other times you might be satisfied with just one condition being True . The keywords and and or can help you in these situations. Using and to Check Multiple Conditions To check whether two conditions are both True simultaneously, use the keyword and to combine the two conditional tests; if each test passes, the overall expression evaluates to True . If either test fails or if both tests fail, the expression evaluates to False . For example, you can check whether two people are both over 21 using the following test: 1 2 3 age_0 = 22 age_1 = 18 age_0 >= 21 and age_1 >= 21 False On line 1, we define two ages, age_0 and age_1 . On line 3, we check whether both ages are 21 or older. The test on the left passes, but the one on the right fails, so the overall conditional expression evaluates to False . 1 2 age_1 = 22 age_0 >= 21 and age_1 >= 21 True On line 1, we change age_1 to 22. The value of age_1 is now greater than 21, so both individual tests pass, causing the overal conditional expression to evaluate as True . To improve readability, you can use parentheses around the individual tests, but they are not required. If you use parentheses, your test would look like this: 1 ( age_0 >= 21 ) and ( age_1 >= 21 ) Using or to Check Multiple Conditions The keyword or allows you to check multiple conditions as well, but it passes when either or both of the individual test pass. As or expression fails onl when both individual tests fail. Let's consider two ages again, but this time we'll look for only one person to be over 21: age_0 = 22 age_1 = 18 age_0 >= 21 or age_1 >= 21 True We start with two variables again at line 1. Because the test for age_0 at line 3 passes, the overall expression evaluates to True . age_0 = 18 age_0 >= 21 or age_1 >= 21 We now lowe age_0 to 18. In the test at line 2, both tests now fail and the overall expression evaluates to False . Checking Whether a Value Is in a List Sometimes it is important to check whether a list contains a certain value before taking an action. For example, you might want to check whether a new username already exists in a list of current usernames before completeing someone's registration on a webstie. In a mapping project, you might want to check whether a submitted location already exists in a list of known locations. To find out whether a particular value is already in a list, use the keyword in . Let's consider some code you might write for a pizzeria. We'll make a list of toppings a customer has requested for a pizza and then check whether certain toppings are in the list. requested_toppings = [ 'mushrooms' , 'onions' , 'pineapple' ] 'mushrooms' in requested_toppings True 'pepperoni' in requested_toppings False We told Python to check for the existence of 'mushrooms' and 'pepperoni' in the list requested_toppings . This technique is quite powerful because you can create a list of essential values, and then easily check whether the value you're testing matches one of the values in the list. Checking Whether a Value is Not in a List Other times, it's important to know if a value does not appear in a list. You can use the keyword not in this situation. For example, consider a list of users who are banned from commenting in a forum. You can check whether a user has been banned before allowing that user to submit a comment: 1 2 3 4 5 banned_users = [ 'andrew' , 'carolina' , 'david' ] user = 'marie' if user not in banned_users : print ( f \" { user . title () } , you can post a response if you wish.\" ) The code on line 4 reads quite clearly. If the value of user is not in the list of banned_users , Python returns True and execites the indented line. The user 'marie' is not in the list banned_users , so she sees a message inviting her to post a response: Marie, you can post a response if you wish. Boolean Expressions A Boolean expression is just another name for a condtitional test. A Boolean value is either True or False , just like the value of a conditional expression after it has been evaluated. Boolean values are often used to keep track of certain conditions, such as whether a game is running or whether a user can edit certain content on a website. game_active = True can_edit = False if Statements When you understand conditional tests, you can start writing if statements. Several different kinds of if statments exist, and your choice of which to use depends on the number of conditions you need to test. You saw several examples of if statments in the discussion about conditional tests, but now let's dif deeper into the topic. Simple if Statements The simplest kind of if statment has one test and one action: if conditional_test : do something You can put any conditional test in the first line and just about any action in the indented block following the test. If the condtional test evaluates to True , Python executes the code following the if statement. If the test evaluates to False , Python ignores the code following the if statement. Let's say we have a variable representing a person's age, and we want to know if that person is old enough to vote. The following code tests whether the person can vote: 1 2 3 age = 19 if age >= 18 : print ( \"You are old enough to vote!\" ) On line 2, Python checks to see whether the value of age is greater than or equal to 18. It is, so Python executes the indented print () call on line 3: You are old enough to vote! Indentation plays the same role in if statements as it did in for loops. All indented lines after an if statement will be executed if the test passes, and the entire block if indented lines will be ignored if the test does not pass. You can have as many lines of code as you want in the block following the #!py if` statement. Let's add another line of output if the person is old enough to vote, asking if the individual has registered to vote yet: 1 2 3 4 age = 19 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registeredto vote yet?\" ) The conditional test passes, and both print () calls are indented, so both lines are printed: You are old enough to vote! Have you registered to vote yet? If the value of age is less than 18, this program would produce no output. if else Statements Often, you'll want to take one action when a conditional test passes and a different action in all other cases. Python's if else syntax makes this possible. An if else block is similar to a simple if statement, but the else statement allows you to define an action or set of actions that are executed when the conditional test fails. We'll display the same message we had previously if the person is old enough to vote, but this time we'll add a message for anyone who is not old enough to vote: 1 2 3 4 5 6 7 age = 17 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registeredto vote yet?\" ) else : print ( \"Sorry, you are too younng to vote.\" ) print ( \"Please register as soon as you turn 18!\" ) If the conditional test on line 2 passes, the first block of indented print () calls are executed. If the test evaluates to False , the else block on line 5 is executed. Because age is less than 18 this time, the conditional test fails and the code in the else block is executed. This code works because it only has two possible situations to evaluate: a person is either old enough to vote or not old enough to vote. The if - else structure works well in situation in which you want Python to always execute one of two possible actions. In a simple if - else chain like this, one of the two actions will always be executed. The if - elif - else Chain Often, you'll need to test more than two possible situations, and to evaluate these you can use Python's if - elif - else syntax. Python executes only one block in an if - elif - else chain. It runs each conditional test in order until one passes. When a test passes, the code following that test is executed and Python skips the rest of the test. Many real-world situations involve more than two possible conditions. For example, consider an amusement park that charges different rates for different age groups: Admission for anyone under age 4 is free. Admission for anyone between the ages of 4 and 18 is $25. Admission for anyone age 18 or older is $40. How can we use an if statement to determine a person's admission rate? The following code tests for the age group of a person and then prints an admission price message: 1 2 3 4 5 6 7 8 age = 12 if age < 4 : print ( \"Your admission cost is $0.\" ) elif age < 18 : print ( \"Your admission cost is $25.\" ) else : print ( \"Your admission cost is $40.\" ) The if test on line 3 tests whether a person is under 4 years old. If the test passes, an appropriate message is printed an Python skips the rest of the tests. The elif code on line 5 is really another if test, which runs only if the previous test fails. At this point in the chain, we know the person is at least 4 years old because the first test failed. If the person is under 18, an appropriate message is printed and Python skips the else block. If both the if and elif tests fail, Python runs the code in the else block on line 7. In this example, the test on line 3 evaluates to False , so its code block is not executed. However, the second test evaluates to True (12 is less than 18) so its code is executed. The output is one sentence, informing the user of the admission cost: Your admission cost is $25. Any age greater than 17 would cause the first two tests to fail. In these situations, the else block would be executed and the admission price would be $40. Rather than printing the admission price within the if - elif - else block, it would be more concise to just set the price inside the if - elif - else chain and then have a simple print () call that runs after the chain has been evaluated: 1 2 3 4 5 6 7 8 9 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 else : price = 40 print ( f \"Your admission cost is $ { price } .\" ) Lines 4, 6, and 8 set the value of price according to the person's age, as in the previous example. After the price is set by the if - elif - else chain, a separate unindented print () call line 9 uses this value to display a message reporting the person's admission price. This code produces the same output as the previous example, but the purpose of the if - elif - else chain is narrower. Instead of determining a price and displaying a message, it simply determines the admission price. In addition to being more efficient, this revised code is easier to modify than the original approach. To change the text of the output message, you would need to change only one print () call rather than three separate print () calls. We can also get user input for age by using a int ( input ()) call in line 1 as follows: age = int ( input ( \"What is your age? \\n \" )) Note : we must use int ( input ) instead of just input () because it will error out when mathematical checks ( < ) are used on a string. Setting the input and an int will make the mathematical checks function correctly. Using Multiple elif Blocks You can use as many elif blocks in your code as you like. For example, if the amusement park were to implement a discount for seniors, you could add one more conditional test to the code to determine whether someone qualified for the senior discount. Let's say anyone 65 or older pays half the regular admission, or $20: 1 2 3 4 5 6 7 8 9 10 11 12 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 elif age < 65 : price = 40 else : price = 20 print ( f \"Your admission cost is $ { price } .\" ) Most of this code is unchanged. The second elif block on line 7 now checks to make sure a person is less than 65 before assigning them the full admission rate of $40. Notice that the value assigned in the else block on line 9 needs to be changed to $20, because the only ages that make it to this block are people 65 or older. Omitting the else Block Python does not require an else block at the end of an if - lif chain. Sometimes an else block is useful; sometimes it is clearer to use an additional elif statement that catches the specific condition of interest: 1 2 3 4 5 6 7 8 9 10 11 12 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 elif age < 65 : price = 40 elif age >= 65 : price = 20 print ( f \"Your admission cost is $ { price } .\" ) The extra elif block on line 9 assigns a price of $20 when the person is 65 or older, which is a bit clearer than the general else block. With this change, every block of code must pass a specific test in order to be executed. The else block is a catchall statement. It matches any condition that wasn't matched by a sepcific if or elif test, and that can sometimes include invalid or even malicious data. If you have a specific final confition you are testing for, consider using a file elif block and omit the else block. As a result, you'll gain extra confidence that your code will run only under the correct conditions. Testing Multiple Conditions The if - elif - else chain is powerful, but it's only appropriate to use it when you just need one test to pass. As soon as Python finds one test that passes, it skips the rest of the tests. This behavior is beneficial, because it's efficient and allows you to test for one specific condition. However, sometimes it is important to check all of the conditions of interest. In this case, you should use a series of simple if statments with no elif or else blocks. This technique makes sense when more than one condition should be True . Let's reconsider the pizzeria example. If someone requests a two-topping pizza, you'll need to be sure to include both toppings on their pizza: 1 2 3 4 5 6 7 8 9 10 requested_toppings = [ 'mushrooms' , 'extra cheese' ] if 'mushrooms' in requested_toppings : print ( \"Adding mushrooms.\" ) if 'pepperoni' in requested_toppings : print ( \"Adding pepperoni.\" ) if 'extra cheese' in requested_toppings : print ( \"Adding extra cheese.\" ) print ( \" \\n Finished making your pizza!\" ) We start with a list containing the requested toppings. The if statement at line 3 checks to see whether the person requested mushrooms on their pizza. If so, a message is printed confirming the topping. The test for pepperoni on like 5 is another simple if statement, not an elif or else statement, so this test runs regardless of whether the previous test passed or not. The code on like 7 checks whether extra cheese was requested regardless of the results of the first two tests. These three independent tests are executed every time this program is run. Because every condition in this example is evaluated, bot mushrooms and extra cheese are added to the pizza: Adding mushrooms. Adding extra cheese. Finished making your pizza! This code would not work properly if we used an if - elif - else block, because the code would stop working after only one test passes. In summary, if you want only one block of code to run, use an if - elif - else chain. If more than one code of block needs to run, use a series of independent if statements. Using if Statements with Lists You can do some interesting work when you combine lists and if statements. You can watch for special values that need to be treated differently than other values in the list. You can manage changing conditions efficiently, such as the availability of certain items i a restaurant throughout a shift. You can also begin to prove that your code works as you expect it to in all possible situations. Checking for Special Items Earlier, we covered how to handle a special value like 'bmw', which needed to be printed in a different format than other values in the list. Now that we have a basic understanding of conditional tests and if statements, let's take a closer look at how you can watch for special values in a list and handle those values appropriately. Let's continue with the pizzeria example. The pizzeria displays a message whenever a topping is added to your pizza, as it's being made. The code for this action can be written very efficiently by making a list of toppings the customer has requested and using a loop to announce each topping as it's added to the pizza: 1 2 3 4 5 6 requested_toppings = [ 'mushrooms' , 'green peppers' , 'extra cheese' ] for requested_topping in requested_toppings : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) The output is straightforward because the code is just a simple for loop: Adding mushrooms. Adding green peppers. Adding extra cheese. Finished making your pizza! But what if the pizzeria runs out of green peppers? An if statement inside the for loop can handle this situation appropriately: 1 2 3 4 5 6 7 8 9 requested_toppings = [ 'mushrooms' , 'green peppers' , 'extra cheese' ] for requested_topping in requested_toppings : if requested_topping == 'green peppers' : print ( \"Sorry, we are out of green peppers right now.\" ) else : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) This time we check each requested item before adding it to the pizza. The code at line 4 checks to see if the person requested green peppers. If so, we display a message that we are out of green peppers. The else block on line 6 ensures that all other toppings are added to the pizza. Checking that a List is Not Empty We've made a simple assumption about every list we've worked with so far; we've assumed that each list has at least one item in it. Soon we'll let users provide the information that's stored in a list, so we won't be able to assume that a list has any items in it each time a loop is run. In this situation, it's useful to check whether a list is empty before running a for loop. As an example, let's check whether the list of requested toppings is empty before building the pizza. If the list is empty, we'll prompt the use and make sure they want a plain pizza. If the list is not empty, we'll build the pizza just as we did in the previous examples: 1 2 3 4 5 6 7 8 requested_toppings = [] if requested_toppings : for requested_topping in requested_toppings : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) else : print ( \"Are you sure you want a plain pizza?\" ) This time we start out with an empty list. Instead of jumping right into the for loop, we do a quick check on line 3. When the name of a list is used in an if statement, Python returns True if the list contains at least one item; an empty list evaluates to False . If requested_toppings passes the conditional test, we run the same for loop we used in the previous example. If the conditional test fails, we print a message asking the customer if they really want a plain pizza with no toppings. Using Multiple Lists People will ask for just about anything, especially when it comes to pizza toppings. What if a customer wants french fries on their pizza? You can use lists and if statements to make sure your input makes sense before you act on it. Let's watch out for unusual topping requests before we build a pizza. The following example defines two lists. The first is a list of available toppings at the pizzeria, and the second is the list of toppings that the user has requested. This time, each item in requested_toppings is checked against the list of available toppings before it is added to the pizza: 1 2 3 4 5 6 7 8 9 10 11 available_toppings = [ 'mushrooms' , 'olives' , 'green peppers' , 'pepperoni' , 'pineapple' , 'extra cheese' ] requested_toppings = [ 'mushrooms' , 'french fries' , 'extra cheese' ] for requested_topping in requested_toppings : if requested_topping in available_toppings : print ( f \"Adding { requested_topping } .\" ) else : print ( f \"Sorry, we don't have { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) On line 1, we defined a list of available toppings. Next, on line 3, we created a list of requested toppings from the customer (Note the unusual request for 'french fries'). On line 5, we loop through the list of requested toppings. Inside the loop, we first check to see if each requested topping is actually in the list of available toppings. If it is, we add the topping to the pizza. If the requested topping is not available, we run the else block and print a message saying that the topping is not available.","title":"If Statements"},{"location":"py-if-statements/#if-statements","text":"Python often involves examining a set of conditions and deciding which action to take based on those conditions. Python's if statement allows you to examine the current state of a program and respond appropriately to that state.","title":"If Statements"},{"location":"py-if-statements/#a-simple-example","text":"The following short example shows how if tests let you respond to special situations correctly. Imagine you have a list of cars and you want to print out the name of each car. Car names are proper names, so the names of most cars should be printed in title case. However, the value 'bmw' should be printed in all uppercase. The following code loops through a list of car names and looks for the value 'bmw' . Whenever the value is 'bmw' , it's printed in uppercase instead of title case. 1 2 3 4 5 6 7 cars = [ 'audi' , 'bmw' , 'subaru' , 'toyota' ] for car in cars : if car == 'bmw' : print ( car . upper ()) else : print ( car . title ()) The loop in this example first checks to see if the current value of car is 'bmw' . If it is, the value is printed in all uppercase. If the value of car is anything other than 'bmw' , it's printed in title case: Audi BMW Subaru Toyota","title":"A Simple Example"},{"location":"py-if-statements/#conditional-tests","text":"At the heart of every if statement is an expression that canbe evaluated as True or False and is called a conditional test . Python uses the values True and False to decide whether the code in an if statement should be executed. If a conditional test evaluates to True , Python executes the code following the if statement. If the test evaluates to False , Python ignores the code following the if statement.","title":"Conditional Tests"},{"location":"py-if-statements/#checking-for-equality","text":"Most conditional tests compare the current value of a variable to a specific value of interest. The simplest conditional test checks whether the value of a variable is equal to the value of interest: 1 2 car = 'bmw' car == 'bmw' True The code at line 1 sets the value of car to 'bmw' using a single equal sign, as you've seen many times already. The code at line 2 checks whether the value of car is 'bmw' using a double equal sign ( == ). This equality operator returns True if the values on the left and right side of the operator match, and False if they don't match. The values in this example match, so Python returns True . When the value of car is anything other than 'bmw' , this test returns False . 1 2 car = 'audi' car == 'bmw' False A single equal sign is really a statment; you might read the code at line one as \"Set the value of car equal to 'audi' \". On the other side, a double equal sign, like the one on line 2, asks a question: \"Is the vale of car equal to 'bmw' ?\" Most programming languages use equal signs in this way.","title":"Checking for Equality"},{"location":"py-if-statements/#ignoring-case-when-checking-for-equality","text":"Testing for equality is case sensitive in Python. For example, ywo values with different capitalization are not considered equal: 1 2 car = 'Audi' car == 'audi' False If case matters, this behavior is advantageous. But if case doesn't matter and instead you just want to test the value of a variable, you can convert the variable's value to lowercase before doing the comparison: 1 2 car = 'Audi' car . lower () == 'audi' True This test would return True no matter how the value 'Audi' is formatted because the test is now case insensitive. The lower () function doesn't change the value that was originally stored in car , so you can do this kind of comparison without affecting the original variable: 1 2 car = 'Audi' car . lower () == 'audi' True 1 car 'Audi' At the first line 1, we assigned the capitalized string 'Audi' to the variable car . At line 2, we convert the value of car to lowercase and compare the lowercase value to the string 'audi' . The two strings match, so Python returns True . When we check what is stored in car again, we can see that it has not been affected by the lower () method. Websites enforce certain rules for the data that users enter in a manner similar to this. For example, a site might use a conditional test like this to ensure that every user has a truly unique username, not just a variation on the capitalization of another person's username. When someone submits a username, that new username is converted to lowercase and compared to the lowercase versions of all existing usernames. During this check, a username like 'John' will be rejected if any variation of 'john' is already in use.","title":"Ignoring Case When Checking for Equality"},{"location":"py-if-statements/#checking-for-inequality","text":"When you want to determine whether two values are not equal, you can combine an exclamation point and an equal sign (!=). The exclamation point represents not , as it does in many programming languages. Let's use another if statement to examine how to use the inequality operator. We'll store a requested pizza topping in a variable and then print a message if the person did not order anchovies: 1 2 3 4 requested_topping = 'mushrooms' if requested_topping != 'anchovies' : print ( \"Hold the anchovies!\" ) The code on line 3 compares the value of requested_topping to the value anchovies . If these two values do not match, Python returns True and executes the code following the if statement. If the two values match, Python returns False and does not run the code following the if statement. Because the value of requested_topping is not anchovies , the print () function is executed: Hold the anchovies! Most of the conditional expressions you write will test for equality, but sometimes you'll find it more efficient to test for inequality.","title":"Checking for Inequality"},{"location":"py-if-statements/#numerical-comparisons","text":"Testing numerical values is pretty straightforward. For example, the following code checks whether a person is 18 years old: 1 2 age = '18' age == '18' True You can also test to see if two numbers are not equal. For example, the following code prints a message if the given answer is not correct: 1 2 3 4 answer = 17 if answer != 42 : print ( \"That is not the correct answer. Please try again!\" ) The conditional test at line 3 passes, because the value of answer (17) is not equal to 42. Because the test passes, the indented code block is executed. You can include various mathematical comparisons in your conditional statements as well, such as less than, less than or equal to, greater than, and greater than or equal to.","title":"Numerical Comparisons"},{"location":"py-if-statements/#checking-multiple-conditions","text":"You may want to check multiple conditions at the same time. For example, sometimes you might need two conditions to be True to take an action. Other times you might be satisfied with just one condition being True . The keywords and and or can help you in these situations.","title":"Checking Multiple Conditions"},{"location":"py-if-statements/#using-and-to-check-multiple-conditions","text":"To check whether two conditions are both True simultaneously, use the keyword and to combine the two conditional tests; if each test passes, the overall expression evaluates to True . If either test fails or if both tests fail, the expression evaluates to False . For example, you can check whether two people are both over 21 using the following test: 1 2 3 age_0 = 22 age_1 = 18 age_0 >= 21 and age_1 >= 21 False On line 1, we define two ages, age_0 and age_1 . On line 3, we check whether both ages are 21 or older. The test on the left passes, but the one on the right fails, so the overall conditional expression evaluates to False . 1 2 age_1 = 22 age_0 >= 21 and age_1 >= 21 True On line 1, we change age_1 to 22. The value of age_1 is now greater than 21, so both individual tests pass, causing the overal conditional expression to evaluate as True . To improve readability, you can use parentheses around the individual tests, but they are not required. If you use parentheses, your test would look like this: 1 ( age_0 >= 21 ) and ( age_1 >= 21 )","title":"Using and to Check Multiple Conditions"},{"location":"py-if-statements/#using-or-to-check-multiple-conditions","text":"The keyword or allows you to check multiple conditions as well, but it passes when either or both of the individual test pass. As or expression fails onl when both individual tests fail. Let's consider two ages again, but this time we'll look for only one person to be over 21: age_0 = 22 age_1 = 18 age_0 >= 21 or age_1 >= 21 True We start with two variables again at line 1. Because the test for age_0 at line 3 passes, the overall expression evaluates to True . age_0 = 18 age_0 >= 21 or age_1 >= 21 We now lowe age_0 to 18. In the test at line 2, both tests now fail and the overall expression evaluates to False .","title":"Using or to Check Multiple Conditions"},{"location":"py-if-statements/#checking-whether-a-value-is-in-a-list","text":"Sometimes it is important to check whether a list contains a certain value before taking an action. For example, you might want to check whether a new username already exists in a list of current usernames before completeing someone's registration on a webstie. In a mapping project, you might want to check whether a submitted location already exists in a list of known locations. To find out whether a particular value is already in a list, use the keyword in . Let's consider some code you might write for a pizzeria. We'll make a list of toppings a customer has requested for a pizza and then check whether certain toppings are in the list. requested_toppings = [ 'mushrooms' , 'onions' , 'pineapple' ] 'mushrooms' in requested_toppings True 'pepperoni' in requested_toppings False We told Python to check for the existence of 'mushrooms' and 'pepperoni' in the list requested_toppings . This technique is quite powerful because you can create a list of essential values, and then easily check whether the value you're testing matches one of the values in the list.","title":"Checking Whether a Value Is in a List"},{"location":"py-if-statements/#checking-whether-a-value-is-not-in-a-list","text":"Other times, it's important to know if a value does not appear in a list. You can use the keyword not in this situation. For example, consider a list of users who are banned from commenting in a forum. You can check whether a user has been banned before allowing that user to submit a comment: 1 2 3 4 5 banned_users = [ 'andrew' , 'carolina' , 'david' ] user = 'marie' if user not in banned_users : print ( f \" { user . title () } , you can post a response if you wish.\" ) The code on line 4 reads quite clearly. If the value of user is not in the list of banned_users , Python returns True and execites the indented line. The user 'marie' is not in the list banned_users , so she sees a message inviting her to post a response: Marie, you can post a response if you wish.","title":"Checking Whether a Value is Not in a List"},{"location":"py-if-statements/#boolean-expressions","text":"A Boolean expression is just another name for a condtitional test. A Boolean value is either True or False , just like the value of a conditional expression after it has been evaluated. Boolean values are often used to keep track of certain conditions, such as whether a game is running or whether a user can edit certain content on a website. game_active = True can_edit = False","title":"Boolean Expressions"},{"location":"py-if-statements/#if-statements_1","text":"When you understand conditional tests, you can start writing if statements. Several different kinds of if statments exist, and your choice of which to use depends on the number of conditions you need to test. You saw several examples of if statments in the discussion about conditional tests, but now let's dif deeper into the topic.","title":"if Statements"},{"location":"py-if-statements/#simple-if-statements","text":"The simplest kind of if statment has one test and one action: if conditional_test : do something You can put any conditional test in the first line and just about any action in the indented block following the test. If the condtional test evaluates to True , Python executes the code following the if statement. If the test evaluates to False , Python ignores the code following the if statement. Let's say we have a variable representing a person's age, and we want to know if that person is old enough to vote. The following code tests whether the person can vote: 1 2 3 age = 19 if age >= 18 : print ( \"You are old enough to vote!\" ) On line 2, Python checks to see whether the value of age is greater than or equal to 18. It is, so Python executes the indented print () call on line 3: You are old enough to vote! Indentation plays the same role in if statements as it did in for loops. All indented lines after an if statement will be executed if the test passes, and the entire block if indented lines will be ignored if the test does not pass. You can have as many lines of code as you want in the block following the #!py if` statement. Let's add another line of output if the person is old enough to vote, asking if the individual has registered to vote yet: 1 2 3 4 age = 19 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registeredto vote yet?\" ) The conditional test passes, and both print () calls are indented, so both lines are printed: You are old enough to vote! Have you registered to vote yet? If the value of age is less than 18, this program would produce no output.","title":"Simple if Statements"},{"location":"py-if-statements/#if-else-statements","text":"Often, you'll want to take one action when a conditional test passes and a different action in all other cases. Python's if else syntax makes this possible. An if else block is similar to a simple if statement, but the else statement allows you to define an action or set of actions that are executed when the conditional test fails. We'll display the same message we had previously if the person is old enough to vote, but this time we'll add a message for anyone who is not old enough to vote: 1 2 3 4 5 6 7 age = 17 if age >= 18 : print ( \"You are old enough to vote!\" ) print ( \"Have you registeredto vote yet?\" ) else : print ( \"Sorry, you are too younng to vote.\" ) print ( \"Please register as soon as you turn 18!\" ) If the conditional test on line 2 passes, the first block of indented print () calls are executed. If the test evaluates to False , the else block on line 5 is executed. Because age is less than 18 this time, the conditional test fails and the code in the else block is executed. This code works because it only has two possible situations to evaluate: a person is either old enough to vote or not old enough to vote. The if - else structure works well in situation in which you want Python to always execute one of two possible actions. In a simple if - else chain like this, one of the two actions will always be executed.","title":"if else Statements"},{"location":"py-if-statements/#the-if-elif-else-chain","text":"Often, you'll need to test more than two possible situations, and to evaluate these you can use Python's if - elif - else syntax. Python executes only one block in an if - elif - else chain. It runs each conditional test in order until one passes. When a test passes, the code following that test is executed and Python skips the rest of the test. Many real-world situations involve more than two possible conditions. For example, consider an amusement park that charges different rates for different age groups: Admission for anyone under age 4 is free. Admission for anyone between the ages of 4 and 18 is $25. Admission for anyone age 18 or older is $40. How can we use an if statement to determine a person's admission rate? The following code tests for the age group of a person and then prints an admission price message: 1 2 3 4 5 6 7 8 age = 12 if age < 4 : print ( \"Your admission cost is $0.\" ) elif age < 18 : print ( \"Your admission cost is $25.\" ) else : print ( \"Your admission cost is $40.\" ) The if test on line 3 tests whether a person is under 4 years old. If the test passes, an appropriate message is printed an Python skips the rest of the tests. The elif code on line 5 is really another if test, which runs only if the previous test fails. At this point in the chain, we know the person is at least 4 years old because the first test failed. If the person is under 18, an appropriate message is printed and Python skips the else block. If both the if and elif tests fail, Python runs the code in the else block on line 7. In this example, the test on line 3 evaluates to False , so its code block is not executed. However, the second test evaluates to True (12 is less than 18) so its code is executed. The output is one sentence, informing the user of the admission cost: Your admission cost is $25. Any age greater than 17 would cause the first two tests to fail. In these situations, the else block would be executed and the admission price would be $40. Rather than printing the admission price within the if - elif - else block, it would be more concise to just set the price inside the if - elif - else chain and then have a simple print () call that runs after the chain has been evaluated: 1 2 3 4 5 6 7 8 9 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 else : price = 40 print ( f \"Your admission cost is $ { price } .\" ) Lines 4, 6, and 8 set the value of price according to the person's age, as in the previous example. After the price is set by the if - elif - else chain, a separate unindented print () call line 9 uses this value to display a message reporting the person's admission price. This code produces the same output as the previous example, but the purpose of the if - elif - else chain is narrower. Instead of determining a price and displaying a message, it simply determines the admission price. In addition to being more efficient, this revised code is easier to modify than the original approach. To change the text of the output message, you would need to change only one print () call rather than three separate print () calls. We can also get user input for age by using a int ( input ()) call in line 1 as follows: age = int ( input ( \"What is your age? \\n \" )) Note : we must use int ( input ) instead of just input () because it will error out when mathematical checks ( < ) are used on a string. Setting the input and an int will make the mathematical checks function correctly.","title":"The if-elif-else Chain"},{"location":"py-if-statements/#using-multiple-elif-blocks","text":"You can use as many elif blocks in your code as you like. For example, if the amusement park were to implement a discount for seniors, you could add one more conditional test to the code to determine whether someone qualified for the senior discount. Let's say anyone 65 or older pays half the regular admission, or $20: 1 2 3 4 5 6 7 8 9 10 11 12 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 elif age < 65 : price = 40 else : price = 20 print ( f \"Your admission cost is $ { price } .\" ) Most of this code is unchanged. The second elif block on line 7 now checks to make sure a person is less than 65 before assigning them the full admission rate of $40. Notice that the value assigned in the else block on line 9 needs to be changed to $20, because the only ages that make it to this block are people 65 or older.","title":"Using Multiple elif Blocks"},{"location":"py-if-statements/#omitting-the-else-block","text":"Python does not require an else block at the end of an if - lif chain. Sometimes an else block is useful; sometimes it is clearer to use an additional elif statement that catches the specific condition of interest: 1 2 3 4 5 6 7 8 9 10 11 12 age = 12 if age < 4 : price = 0 elif age < 18 : price = 25 elif age < 65 : price = 40 elif age >= 65 : price = 20 print ( f \"Your admission cost is $ { price } .\" ) The extra elif block on line 9 assigns a price of $20 when the person is 65 or older, which is a bit clearer than the general else block. With this change, every block of code must pass a specific test in order to be executed. The else block is a catchall statement. It matches any condition that wasn't matched by a sepcific if or elif test, and that can sometimes include invalid or even malicious data. If you have a specific final confition you are testing for, consider using a file elif block and omit the else block. As a result, you'll gain extra confidence that your code will run only under the correct conditions.","title":"Omitting the else Block"},{"location":"py-if-statements/#testing-multiple-conditions","text":"The if - elif - else chain is powerful, but it's only appropriate to use it when you just need one test to pass. As soon as Python finds one test that passes, it skips the rest of the tests. This behavior is beneficial, because it's efficient and allows you to test for one specific condition. However, sometimes it is important to check all of the conditions of interest. In this case, you should use a series of simple if statments with no elif or else blocks. This technique makes sense when more than one condition should be True . Let's reconsider the pizzeria example. If someone requests a two-topping pizza, you'll need to be sure to include both toppings on their pizza: 1 2 3 4 5 6 7 8 9 10 requested_toppings = [ 'mushrooms' , 'extra cheese' ] if 'mushrooms' in requested_toppings : print ( \"Adding mushrooms.\" ) if 'pepperoni' in requested_toppings : print ( \"Adding pepperoni.\" ) if 'extra cheese' in requested_toppings : print ( \"Adding extra cheese.\" ) print ( \" \\n Finished making your pizza!\" ) We start with a list containing the requested toppings. The if statement at line 3 checks to see whether the person requested mushrooms on their pizza. If so, a message is printed confirming the topping. The test for pepperoni on like 5 is another simple if statement, not an elif or else statement, so this test runs regardless of whether the previous test passed or not. The code on like 7 checks whether extra cheese was requested regardless of the results of the first two tests. These three independent tests are executed every time this program is run. Because every condition in this example is evaluated, bot mushrooms and extra cheese are added to the pizza: Adding mushrooms. Adding extra cheese. Finished making your pizza! This code would not work properly if we used an if - elif - else block, because the code would stop working after only one test passes. In summary, if you want only one block of code to run, use an if - elif - else chain. If more than one code of block needs to run, use a series of independent if statements.","title":"Testing Multiple Conditions"},{"location":"py-if-statements/#using-if-statements-with-lists","text":"You can do some interesting work when you combine lists and if statements. You can watch for special values that need to be treated differently than other values in the list. You can manage changing conditions efficiently, such as the availability of certain items i a restaurant throughout a shift. You can also begin to prove that your code works as you expect it to in all possible situations.","title":"Using if Statements with Lists"},{"location":"py-if-statements/#checking-for-special-items","text":"Earlier, we covered how to handle a special value like 'bmw', which needed to be printed in a different format than other values in the list. Now that we have a basic understanding of conditional tests and if statements, let's take a closer look at how you can watch for special values in a list and handle those values appropriately. Let's continue with the pizzeria example. The pizzeria displays a message whenever a topping is added to your pizza, as it's being made. The code for this action can be written very efficiently by making a list of toppings the customer has requested and using a loop to announce each topping as it's added to the pizza: 1 2 3 4 5 6 requested_toppings = [ 'mushrooms' , 'green peppers' , 'extra cheese' ] for requested_topping in requested_toppings : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) The output is straightforward because the code is just a simple for loop: Adding mushrooms. Adding green peppers. Adding extra cheese. Finished making your pizza! But what if the pizzeria runs out of green peppers? An if statement inside the for loop can handle this situation appropriately: 1 2 3 4 5 6 7 8 9 requested_toppings = [ 'mushrooms' , 'green peppers' , 'extra cheese' ] for requested_topping in requested_toppings : if requested_topping == 'green peppers' : print ( \"Sorry, we are out of green peppers right now.\" ) else : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) This time we check each requested item before adding it to the pizza. The code at line 4 checks to see if the person requested green peppers. If so, we display a message that we are out of green peppers. The else block on line 6 ensures that all other toppings are added to the pizza.","title":"Checking for Special Items"},{"location":"py-if-statements/#checking-that-a-list-is-not-empty","text":"We've made a simple assumption about every list we've worked with so far; we've assumed that each list has at least one item in it. Soon we'll let users provide the information that's stored in a list, so we won't be able to assume that a list has any items in it each time a loop is run. In this situation, it's useful to check whether a list is empty before running a for loop. As an example, let's check whether the list of requested toppings is empty before building the pizza. If the list is empty, we'll prompt the use and make sure they want a plain pizza. If the list is not empty, we'll build the pizza just as we did in the previous examples: 1 2 3 4 5 6 7 8 requested_toppings = [] if requested_toppings : for requested_topping in requested_toppings : print ( f \"Adding { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) else : print ( \"Are you sure you want a plain pizza?\" ) This time we start out with an empty list. Instead of jumping right into the for loop, we do a quick check on line 3. When the name of a list is used in an if statement, Python returns True if the list contains at least one item; an empty list evaluates to False . If requested_toppings passes the conditional test, we run the same for loop we used in the previous example. If the conditional test fails, we print a message asking the customer if they really want a plain pizza with no toppings.","title":"Checking that a List is Not Empty"},{"location":"py-if-statements/#using-multiple-lists","text":"People will ask for just about anything, especially when it comes to pizza toppings. What if a customer wants french fries on their pizza? You can use lists and if statements to make sure your input makes sense before you act on it. Let's watch out for unusual topping requests before we build a pizza. The following example defines two lists. The first is a list of available toppings at the pizzeria, and the second is the list of toppings that the user has requested. This time, each item in requested_toppings is checked against the list of available toppings before it is added to the pizza: 1 2 3 4 5 6 7 8 9 10 11 available_toppings = [ 'mushrooms' , 'olives' , 'green peppers' , 'pepperoni' , 'pineapple' , 'extra cheese' ] requested_toppings = [ 'mushrooms' , 'french fries' , 'extra cheese' ] for requested_topping in requested_toppings : if requested_topping in available_toppings : print ( f \"Adding { requested_topping } .\" ) else : print ( f \"Sorry, we don't have { requested_topping } .\" ) print ( \" \\n Finished making your pizza!\" ) On line 1, we defined a list of available toppings. Next, on line 3, we created a list of requested toppings from the customer (Note the unusual request for 'french fries'). On line 5, we loop through the list of requested toppings. Inside the loop, we first check to see if each requested topping is actually in the list of available toppings. If it is, we add the topping to the pizza. If the requested topping is not available, we run the else block and print a message saying that the topping is not available.","title":"Using Multiple Lists"},{"location":"py-lists/","text":"Lists What is a List? A list is a collection of items in a particular order. You can make a list that includes the letters of the alphabet, the digits from 0-9, or the names of people in your family. You can put anything into a list, and the items in your list don't have to be related in any particular way. Because a list usually contains more than one element, it's a good idea to make the name of your list plural, such as letters , digits , or names . In Python, square brackets ([ ]) indicate a list, and individual elements in the list are separated by commas. Here is a simple example of a list that contains a few kinds of bicylces: 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces ) If you ask Python to print a list, Python returns its representation of the list, including the square brackets: 1 [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] Because this isn't the output you want your users to see, let's learn how to access the individual items in a list. Accessing Elements in a List Lists are ordered collections, so you can access any element in a list by telling Python the position, or index , of the item desired. To access an elemenet in a list, write the name of the list followed by the index of the item enclosed in square brackets. For example, let's pull out the first bicycle in the list bicycles : 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces [ 0 ]) Index Positions Just like in C, and most other programming languages, index positions start at 0, not 1 . This is usually something that takes some time for beginner programmers to commit to memory. It is also useful to remember that you can count backwards in a list as well, with the last element in a list being located at position [-1]. When you print out a single item from a list, Python will return just that element without square brackets: 1 trek We can also use the . title () method, discussed in variables and simple data types . This will capitalize the first letter of the element: 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces [ 0 ] . title ()) The above example would print out the first element as follows: 1 Trek Using Individual Values from a List You can use individual values from a list just as you would any other variable. For example, you can use f-strings to create a message based on a value from a list. Let's try pulling the first bicycly from the list and composing a message using that value: 1 2 3 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] message = f \"My first bicycle was a { bicycles [ 0 ] . title () } .\" print ( message ) This code would have the following output: My first bicycles was a Trek. Changing, Adding, and Removing Elements Most lists you create will be dynamic, meaning you'll build a list and then add and remove elements from it as your program runs its course. For example, you might create a game in which a player has to shoot aliens out of the sky. You could store the initial set of aliens in a list and then remove an alien from the list each time one is shot down. Each time a new alien appears on the screen, you add it to the list. Your list of aliens will increase and decrease in length throughout the course of the game. Modifying Elements in a List The syntax for modifying an element is similar to the syntax for accessing an element in a list . To change an element, use the name of the list followed by the index of the element you want to change, and then provide the new value you want that item to have. For example, let's say we have a list of motorcycles, and the first item in the list is 'honda' . How would we go about changing the value of the first item? 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) motorcycles [ 0 ] = 'ducati' print ( motorcycles ) The first code set defines the original list, with 'honda' as the first element. The second code set changes the value of the first item ( [0] ) to 'ducati' . The output shows the first item ahs indeed been changed, and the rest of the list stays the same. ['honda', 'yamaha', 'suzuki'] ['ducati', 'yamaha', 'suzuki'] Note: You can change the value of any item in a list, not just the first. Adding Elements to a List You might want to add a new element to a list for many reasons. For example, you might want to make new aliend appear in a game, add new data to a visualization, or add new registered users to a website you've built. Python provides several ways to add new data to existing lists. Appending Elements to the End of a List The simplest way to add a new element to a list is to append the item to the list. When you append an item to a list, the new element is added to the end of the list. Using the same list we had in the previous example, we'll add the new element 'ducati' to the end of the list: 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) motorcycles . append ( 'ducati' ) print ( motorcycles ) The append() method adds 'ducati' to the end of the list without affecting any of the other elements in the list: ['honda', 'yamaha', 'suzuki'] ['honda', 'yamaha', 'suzuki', 'ducati'] The append () method makes it easy to build lists dynamically. For example, you can start with an empty list and then add items to the list using a series of append() calls. Using an empty list, let\u2019s add the elements 'honda' , 'yamaha' , and 'suzuki' to the list: 1 2 3 4 5 6 7 motorcycles = [] motorcycles . append ( 'honda' ) motorcycles . append ( 'yamaha' ) motorcycles . append ( 'suzuki' ) print ( motorcycles ) The resulting list looks exactly the same as the lists in previous examples: ['honda', 'yamaha', 'suzuki'] Building lists this way is very common, because you often won\u2019t know the data your users want to store in a program until after the program is running. To put your users in control, start by defining an empty list that will hold the users\u2019 values. Then append each new value provided to the list you just created. Inserting Elements into a List You can also add a new element at any position in your list by using the insert () method. You do this by specifying the index of the new element and the value of the new item: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] motorcycles . insert ( 0 , 'ducati' ) print ( motorcycles ) The above code inserts the value 'ducati' at position 0 . So running this program will have the following output: ['ducati', 'honda', 'yamaha', 'suzuki'] Removing Elements from a List Often, you'll want to remove an item or a set of items from a list. You can remove an item according to its position in the list or according to its value. Removing an Item using the del Statement If you know the position of the item you want to remove from a list, you can use the del statement. 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) del motorcycles [ 0 ] print ( motorcycles ) The del statement will remove the item at index [0] from the list motorcycles . If you were to run the above code you would get the following result: ['honda', 'yamaha', 'suzuki'] ['yamaha', 'suzuki'] Removing an Item using the pop () Method Sometimes you'll want to use the value of an item after you remove it from a list. For example, you might want to get the x and y position of an alien that was just shot down, so you can draw an explosion at that position. In a web application, you might want to remove a user from a list of active member and then add that user to a list of inactive members. The pop () method removes the last item in a list, but it lets you work with them after removing it. The term pop comes from thinking of a list as a stack of items and popping one item off the top of a stack. In this analogy, the top of a stack corresponds to the end of a list. Let's pop a motorcycle from a list of motorcycles: 1 2 3 4 5 6 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) popped_motorcycle = motorcycles . pop () print ( motorcycles ) print ( popped_motorcycle ) We start by defining and printing the list motorcycles . Next, we pop a value ( suzuki ) from the list and store that value in the variable popped_motorcycle . Finally, we print the lists to show that a value has been successfully removed from the initial list. Then we print the popped list and prove we still have access to it. The above code would yield the following result: ['honda', 'yamaha', 'suzuki'] ['honda', 'yamaha'] suzuki How might this pop () method be useful? Imagine that the motorcycles in the list are store in chronological order according to when we owned them. If this is the case, we can use the pop () method to print a statement about the last motorcycle we bought: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] last_owned = motorcycles . pop () print ( f \"The last motorcycle I owned was a { last_owned . title () } .\" ) The output of the above would be: The last motorcycle I owned was a Suzuki. Popping Items from any Position in a List We can use pop () to remove an item from any position in a list by including the index of the item you want to remove in parenthese: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] first_owned = motorcycles . pop ( 0 ) print ( f \"The first motorcycle I owned was a { first_owned . title () } .\" ) We start by popping the first motorcycle in the list (located at index 0 ), and then we print a message about the motorcycle. The output is a simple sentence describing the first motorcycle owned: The first motorcycle I owned was a Honda Remember that each time we use pop () , the item we were working with is no longer stored in the list. When to use del or pop () When you want to delete an item from a list and not use that item in any way, use the del statement; if you want to use an item as you remove it, use the pop () method. Removing an Item by Value Sometimes you won't know the position of the value you want to remove from a list. If you only know the value of the item you want to remove, you can use the remove () method. For example, let's say we want to remove the value 'ducati' from the list of motorcycles: 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' , 'ducati' ] print ( motorcycles ) motorcycles . remove ( 'ducati' ) print ( motorcycles ) The above code tells Python to find and remove 'ducati' from within the motorcycles list. It would give the following result when ran: ['honda', 'yamaha', 'suzuki', 'ducati'] ['honda', 'yamaha', 'suzuki'] You can also use the remove () method to work with a value that's being removed form a list. Let's remove the value 'ducati' and print a reason for removing it from the list: 1 2 3 4 5 6 7 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' , 'ducati' ] print ( motorcycles ) too_expensive = 'ducati' motorcycles . remove ( too_expensive ) print ( motorcycles ) print ( f \" \\n A { too_expensive . title () } is too expensive for me.\" ) After defining the list on line 1, we assign the value 'ducati' to a variable called too_expensive . We then use this variable to tell Python which value to remove from the list. 'ducati' is removed from the list, but is still accessible through the variable too_expensive , allowing us to print a statement about why we removed 'ducati' from the list of motorcycles. The code above would have the following output: ['honda', 'yamaha', 'suzuki', 'ducati'] ['honda', 'yamaha', 'suzuki'] A Ducati is too expensive for me. Note on remove () The remove() method deletes only the first occurrence of the value you specify. If there\u2019s a possibility the value appears more than once in the list, you\u2019ll need to use a loop to make sure all occurrences of the value are removed. Organizing a List Often, your lists will be created in an unpredictable order, because you can't always control the order in which your users provide their data. Although this is unavoidable in most circumstances, you'll frequently want to present your information in a particular order. Sometimes you'll want to preserve the original order of your list, and other times you'll want to change the original order. Python provides a number of different ways to organize your lists, depending on the situation. Sorting a List Permanently with the sort () Method Python's sort () method makes it relatively easy to sort a list. Imagine we have a list of cars and want to change the order of the list to store them alphabetically. To keep the task simple, let's assume that all the values in the list are lowercase: 1 2 3 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] cars . sort () print ( cars ) The sort () method, shown above changes the order of the list permanently. The cars are now in alphabetical order, and we can never revert to the original order: ['audi', 'bmw', 'subaru', 'toyota'] You can also sort this list in reverse alphabetical order by passing the argument reverse = True to the sort () method. The following example sorts the list of cars in reverse alphabetical order: 1 2 3 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] cars . sort ( reverse = True ) print ( cars ) Sorting a List Temporarily with the sorted () Function To maintain the original order of a list but present it in a sorted order, you can use the sorted () function. The sorted () function lets you display your list in a particular order but doesn't affect the actual order of the list. Let's try this function on the list of cars: 1 2 3 4 5 6 7 8 9 10 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] print ( \"Here is the orginal list:\" ) print ( cars ) print ( \" \\n Here is the sorted list:\" ) print ( sorted ( cars )) print ( \" \\n Here is the original list again:\" ) print ( cars ) This should have the following output: Here is the orginal list: ['bmw', 'audi', 'toyota', 'subaru'] Here is the sorted list: ['audi', 'bmw', 'subaru', 'toyota'] Here is the original list again: ['bmw', 'audi', 'toyota', 'subaru'] Note on Sorting Sorting a list alphabetically is a bit more complicated when all the values are not in lowercase. There are several ways to interpret capital letters when determining a sort order, and specifying the exact order can be more complex than we want to deal with at this time. Printing a List in Reverse Order To reverse the original order of a list, we can use the reverse () method. If we originally stored the list of cars in chronological order according to when we owned them, we could easily rearrange the list into reverse chronological order: 1 2 3 4 5 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] print ( cars ) cars . reverse () print ( cars ) After running this code will will get the following result: ['bmw', 'audi', 'toyota', 'subaru'] ['subaru', 'toyota', 'audi', 'bmw'] The reverse () method changes the order of a list permanently, but you can always simply run the reverse () function again to get back to the original order. Finding the Length of a List You can quickly find the length of a list by using the len () funtion. The list in this example has four items, so the output will be the integer 4: 1 2 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] len ( cars ) Avoiding Index Errors When Working with Lists One type of error is common when you're working with lists for the first time. Let's say we have a list with three items, and you ask for the fourth item: 1 2 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles [ 3 ]) Running this code results in an index error : 1 2 3 4 5 6 7 --------------------------------------------------------------------------- IndexError Traceback ( most recent call last ) < ipython - input - 10 - 9811709 cfb18 > in < module > 1 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] ----> 2 print ( motorcycles [ 3 ]) IndexError : list index out of range Python attempts to give you the item at index 3 , but when it searches the list, there is no item in index 3 in motorcycles . You must remember that indexing starts at 0 in Python. Note on Index Errors If an index error occurs and you can\u2019t figure out how to resolve it, try printing your list or just printing the length of your list. Your list might look much different than you thought it did, especially if it has been managed dynamically by your program. Seeing the actual list, or the exact number of items in your list, can help you sort out such logical errors.","title":"Lists"},{"location":"py-lists/#lists","text":"","title":"Lists"},{"location":"py-lists/#what-is-a-list","text":"A list is a collection of items in a particular order. You can make a list that includes the letters of the alphabet, the digits from 0-9, or the names of people in your family. You can put anything into a list, and the items in your list don't have to be related in any particular way. Because a list usually contains more than one element, it's a good idea to make the name of your list plural, such as letters , digits , or names . In Python, square brackets ([ ]) indicate a list, and individual elements in the list are separated by commas. Here is a simple example of a list that contains a few kinds of bicylces: 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces ) If you ask Python to print a list, Python returns its representation of the list, including the square brackets: 1 [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] Because this isn't the output you want your users to see, let's learn how to access the individual items in a list.","title":"What is a List?"},{"location":"py-lists/#accessing-elements-in-a-list","text":"Lists are ordered collections, so you can access any element in a list by telling Python the position, or index , of the item desired. To access an elemenet in a list, write the name of the list followed by the index of the item enclosed in square brackets. For example, let's pull out the first bicycle in the list bicycles : 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces [ 0 ]) Index Positions Just like in C, and most other programming languages, index positions start at 0, not 1 . This is usually something that takes some time for beginner programmers to commit to memory. It is also useful to remember that you can count backwards in a list as well, with the last element in a list being located at position [-1]. When you print out a single item from a list, Python will return just that element without square brackets: 1 trek We can also use the . title () method, discussed in variables and simple data types . This will capitalize the first letter of the element: 1 2 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] print ( bicylces [ 0 ] . title ()) The above example would print out the first element as follows: 1 Trek","title":"Accessing Elements in a List"},{"location":"py-lists/#using-individual-values-from-a-list","text":"You can use individual values from a list just as you would any other variable. For example, you can use f-strings to create a message based on a value from a list. Let's try pulling the first bicycly from the list and composing a message using that value: 1 2 3 bicylces = [ 'trek' , 'cannondale' , 'redline' , 'specialized' ] message = f \"My first bicycle was a { bicycles [ 0 ] . title () } .\" print ( message ) This code would have the following output: My first bicycles was a Trek.","title":"Using Individual Values from a List"},{"location":"py-lists/#changing-adding-and-removing-elements","text":"Most lists you create will be dynamic, meaning you'll build a list and then add and remove elements from it as your program runs its course. For example, you might create a game in which a player has to shoot aliens out of the sky. You could store the initial set of aliens in a list and then remove an alien from the list each time one is shot down. Each time a new alien appears on the screen, you add it to the list. Your list of aliens will increase and decrease in length throughout the course of the game.","title":"Changing, Adding, and Removing Elements"},{"location":"py-lists/#modifying-elements-in-a-list","text":"The syntax for modifying an element is similar to the syntax for accessing an element in a list . To change an element, use the name of the list followed by the index of the element you want to change, and then provide the new value you want that item to have. For example, let's say we have a list of motorcycles, and the first item in the list is 'honda' . How would we go about changing the value of the first item? 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) motorcycles [ 0 ] = 'ducati' print ( motorcycles ) The first code set defines the original list, with 'honda' as the first element. The second code set changes the value of the first item ( [0] ) to 'ducati' . The output shows the first item ahs indeed been changed, and the rest of the list stays the same. ['honda', 'yamaha', 'suzuki'] ['ducati', 'yamaha', 'suzuki'] Note: You can change the value of any item in a list, not just the first.","title":"Modifying Elements in a List"},{"location":"py-lists/#adding-elements-to-a-list","text":"You might want to add a new element to a list for many reasons. For example, you might want to make new aliend appear in a game, add new data to a visualization, or add new registered users to a website you've built. Python provides several ways to add new data to existing lists.","title":"Adding Elements to a List"},{"location":"py-lists/#appending-elements-to-the-end-of-a-list","text":"The simplest way to add a new element to a list is to append the item to the list. When you append an item to a list, the new element is added to the end of the list. Using the same list we had in the previous example, we'll add the new element 'ducati' to the end of the list: 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) motorcycles . append ( 'ducati' ) print ( motorcycles ) The append() method adds 'ducati' to the end of the list without affecting any of the other elements in the list: ['honda', 'yamaha', 'suzuki'] ['honda', 'yamaha', 'suzuki', 'ducati'] The append () method makes it easy to build lists dynamically. For example, you can start with an empty list and then add items to the list using a series of append() calls. Using an empty list, let\u2019s add the elements 'honda' , 'yamaha' , and 'suzuki' to the list: 1 2 3 4 5 6 7 motorcycles = [] motorcycles . append ( 'honda' ) motorcycles . append ( 'yamaha' ) motorcycles . append ( 'suzuki' ) print ( motorcycles ) The resulting list looks exactly the same as the lists in previous examples: ['honda', 'yamaha', 'suzuki'] Building lists this way is very common, because you often won\u2019t know the data your users want to store in a program until after the program is running. To put your users in control, start by defining an empty list that will hold the users\u2019 values. Then append each new value provided to the list you just created.","title":"Appending Elements to the End of a List"},{"location":"py-lists/#inserting-elements-into-a-list","text":"You can also add a new element at any position in your list by using the insert () method. You do this by specifying the index of the new element and the value of the new item: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] motorcycles . insert ( 0 , 'ducati' ) print ( motorcycles ) The above code inserts the value 'ducati' at position 0 . So running this program will have the following output: ['ducati', 'honda', 'yamaha', 'suzuki']","title":"Inserting Elements into a List"},{"location":"py-lists/#removing-elements-from-a-list","text":"Often, you'll want to remove an item or a set of items from a list. You can remove an item according to its position in the list or according to its value.","title":"Removing Elements from a List"},{"location":"py-lists/#removing-an-item-using-the-del-statement","text":"If you know the position of the item you want to remove from a list, you can use the del statement. 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) del motorcycles [ 0 ] print ( motorcycles ) The del statement will remove the item at index [0] from the list motorcycles . If you were to run the above code you would get the following result: ['honda', 'yamaha', 'suzuki'] ['yamaha', 'suzuki']","title":"Removing an Item using the del Statement"},{"location":"py-lists/#removing-an-item-using-the-pop-method","text":"Sometimes you'll want to use the value of an item after you remove it from a list. For example, you might want to get the x and y position of an alien that was just shot down, so you can draw an explosion at that position. In a web application, you might want to remove a user from a list of active member and then add that user to a list of inactive members. The pop () method removes the last item in a list, but it lets you work with them after removing it. The term pop comes from thinking of a list as a stack of items and popping one item off the top of a stack. In this analogy, the top of a stack corresponds to the end of a list. Let's pop a motorcycle from a list of motorcycles: 1 2 3 4 5 6 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles ) popped_motorcycle = motorcycles . pop () print ( motorcycles ) print ( popped_motorcycle ) We start by defining and printing the list motorcycles . Next, we pop a value ( suzuki ) from the list and store that value in the variable popped_motorcycle . Finally, we print the lists to show that a value has been successfully removed from the initial list. Then we print the popped list and prove we still have access to it. The above code would yield the following result: ['honda', 'yamaha', 'suzuki'] ['honda', 'yamaha'] suzuki How might this pop () method be useful? Imagine that the motorcycles in the list are store in chronological order according to when we owned them. If this is the case, we can use the pop () method to print a statement about the last motorcycle we bought: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] last_owned = motorcycles . pop () print ( f \"The last motorcycle I owned was a { last_owned . title () } .\" ) The output of the above would be: The last motorcycle I owned was a Suzuki.","title":"Removing an Item using the pop() Method"},{"location":"py-lists/#popping-items-from-any-position-in-a-list","text":"We can use pop () to remove an item from any position in a list by including the index of the item you want to remove in parenthese: 1 2 3 4 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] first_owned = motorcycles . pop ( 0 ) print ( f \"The first motorcycle I owned was a { first_owned . title () } .\" ) We start by popping the first motorcycle in the list (located at index 0 ), and then we print a message about the motorcycle. The output is a simple sentence describing the first motorcycle owned: The first motorcycle I owned was a Honda Remember that each time we use pop () , the item we were working with is no longer stored in the list. When to use del or pop () When you want to delete an item from a list and not use that item in any way, use the del statement; if you want to use an item as you remove it, use the pop () method.","title":"Popping Items from any Position in a List"},{"location":"py-lists/#removing-an-item-by-value","text":"Sometimes you won't know the position of the value you want to remove from a list. If you only know the value of the item you want to remove, you can use the remove () method. For example, let's say we want to remove the value 'ducati' from the list of motorcycles: 1 2 3 4 5 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' , 'ducati' ] print ( motorcycles ) motorcycles . remove ( 'ducati' ) print ( motorcycles ) The above code tells Python to find and remove 'ducati' from within the motorcycles list. It would give the following result when ran: ['honda', 'yamaha', 'suzuki', 'ducati'] ['honda', 'yamaha', 'suzuki'] You can also use the remove () method to work with a value that's being removed form a list. Let's remove the value 'ducati' and print a reason for removing it from the list: 1 2 3 4 5 6 7 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' , 'ducati' ] print ( motorcycles ) too_expensive = 'ducati' motorcycles . remove ( too_expensive ) print ( motorcycles ) print ( f \" \\n A { too_expensive . title () } is too expensive for me.\" ) After defining the list on line 1, we assign the value 'ducati' to a variable called too_expensive . We then use this variable to tell Python which value to remove from the list. 'ducati' is removed from the list, but is still accessible through the variable too_expensive , allowing us to print a statement about why we removed 'ducati' from the list of motorcycles. The code above would have the following output: ['honda', 'yamaha', 'suzuki', 'ducati'] ['honda', 'yamaha', 'suzuki'] A Ducati is too expensive for me. Note on remove () The remove() method deletes only the first occurrence of the value you specify. If there\u2019s a possibility the value appears more than once in the list, you\u2019ll need to use a loop to make sure all occurrences of the value are removed.","title":"Removing an Item by Value"},{"location":"py-lists/#organizing-a-list","text":"Often, your lists will be created in an unpredictable order, because you can't always control the order in which your users provide their data. Although this is unavoidable in most circumstances, you'll frequently want to present your information in a particular order. Sometimes you'll want to preserve the original order of your list, and other times you'll want to change the original order. Python provides a number of different ways to organize your lists, depending on the situation.","title":"Organizing a List"},{"location":"py-lists/#sorting-a-list-permanently-with-the-sort-method","text":"Python's sort () method makes it relatively easy to sort a list. Imagine we have a list of cars and want to change the order of the list to store them alphabetically. To keep the task simple, let's assume that all the values in the list are lowercase: 1 2 3 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] cars . sort () print ( cars ) The sort () method, shown above changes the order of the list permanently. The cars are now in alphabetical order, and we can never revert to the original order: ['audi', 'bmw', 'subaru', 'toyota'] You can also sort this list in reverse alphabetical order by passing the argument reverse = True to the sort () method. The following example sorts the list of cars in reverse alphabetical order: 1 2 3 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] cars . sort ( reverse = True ) print ( cars )","title":"Sorting a List Permanently with the sort() Method"},{"location":"py-lists/#sorting-a-list-temporarily-with-the-sorted-function","text":"To maintain the original order of a list but present it in a sorted order, you can use the sorted () function. The sorted () function lets you display your list in a particular order but doesn't affect the actual order of the list. Let's try this function on the list of cars: 1 2 3 4 5 6 7 8 9 10 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] print ( \"Here is the orginal list:\" ) print ( cars ) print ( \" \\n Here is the sorted list:\" ) print ( sorted ( cars )) print ( \" \\n Here is the original list again:\" ) print ( cars ) This should have the following output: Here is the orginal list: ['bmw', 'audi', 'toyota', 'subaru'] Here is the sorted list: ['audi', 'bmw', 'subaru', 'toyota'] Here is the original list again: ['bmw', 'audi', 'toyota', 'subaru'] Note on Sorting Sorting a list alphabetically is a bit more complicated when all the values are not in lowercase. There are several ways to interpret capital letters when determining a sort order, and specifying the exact order can be more complex than we want to deal with at this time.","title":"Sorting a List Temporarily with the sorted() Function"},{"location":"py-lists/#printing-a-list-in-reverse-order","text":"To reverse the original order of a list, we can use the reverse () method. If we originally stored the list of cars in chronological order according to when we owned them, we could easily rearrange the list into reverse chronological order: 1 2 3 4 5 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] print ( cars ) cars . reverse () print ( cars ) After running this code will will get the following result: ['bmw', 'audi', 'toyota', 'subaru'] ['subaru', 'toyota', 'audi', 'bmw'] The reverse () method changes the order of a list permanently, but you can always simply run the reverse () function again to get back to the original order.","title":"Printing a List in Reverse Order"},{"location":"py-lists/#finding-the-length-of-a-list","text":"You can quickly find the length of a list by using the len () funtion. The list in this example has four items, so the output will be the integer 4: 1 2 cars = [ 'bmw' , 'audi' , 'toyota' , 'subaru' ] len ( cars )","title":"Finding the Length of a List"},{"location":"py-lists/#avoiding-index-errors-when-working-with-lists","text":"One type of error is common when you're working with lists for the first time. Let's say we have a list with three items, and you ask for the fourth item: 1 2 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] print ( motorcycles [ 3 ]) Running this code results in an index error : 1 2 3 4 5 6 7 --------------------------------------------------------------------------- IndexError Traceback ( most recent call last ) < ipython - input - 10 - 9811709 cfb18 > in < module > 1 motorcycles = [ 'honda' , 'yamaha' , 'suzuki' ] ----> 2 print ( motorcycles [ 3 ]) IndexError : list index out of range Python attempts to give you the item at index 3 , but when it searches the list, there is no item in index 3 in motorcycles . You must remember that indexing starts at 0 in Python. Note on Index Errors If an index error occurs and you can\u2019t figure out how to resolve it, try printing your list or just printing the length of your list. Your list might look much different than you thought it did, especially if it has been managed dynamically by your program. Seeing the actual list, or the exact number of items in your list, can help you sort out such logical errors.","title":"Avoiding Index Errors When Working with Lists"},{"location":"py-random/","text":"Random Programs Cash In cash.py we will calculate the minimum number of coins required to give a user change. Ex: $ python cash.py Change owed: 0.41 4 We will first ask a user how much changed they are owed and then tell them the minimum number of coins (.25, .10, .05, and .01) with which said change can be made. We will utilized get_float from the CS50 library to get the user's input and print () to output the answer. Remember, if the user provides a non-negative value, our program should reprompt the user for a valid amount again and again until the user complies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from cs50 import get_float while True : dollars = get_float ( \"Change owed: \" ) if dollars >= 0 : break cents = int ( dollars * 100 ) total_coins = 0 for coin in [ 25 , 10 , 5 , 1 ]: total_coins += cents // coin cents %= coin print ( total_coins ) Readability In readability.py we will compute the approximate grade level of given text. Ex: $ python readability.py Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 This is a complete copy of readbility.c , which uses the Coleman-Liau index to output grade level from text, but created using Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from cs50 import get_string text = get_string ( \"Text: \" ) letters = sentences = words = 0 for char in text : if char . isalpha (): letters += 1 if char . isspace (): words += 1 if char in [ '?' , '!' , '.' ]: sentences += 1 words += 1 L = ( letters * 100 ) / words S = ( sentences * 100 ) / words result = int ( round ( 0.0588 * L - 0.296 * S - 15.8 )) if result < 1 : print ( \"Before Grade 1\" ) elif result >= 16 : print ( \"Grade 16+\" ) else : print ( f \"Grade { result } \" ) DNA In this dna.py we will identify a person based on their DNA. DNA, the carrier of genetic information in living things, has been used in criminal justice for decades. But how, exactly, does DNA profiling work? Given a sequence of DNA, how can forensic investigators identify to whom it belongs? Well, DNA is really just a sequence of molecules called nucleotides, arranged into a particular shape (a double helix). Each nucleotide of DNA contains one of four different bases: adenine (A), cytosine (C), guanine (G), or thymine (T). Every human cell has billions of these nucleotides arranged in sequence. Some portions of this sequence (i.e. genome) are the same, or at least very similar, across almost all humans, but other portions of the sequence have a higher genetic diversity and thus vary more across the population. One place where DNA tends to have high genetic diversity is in Short Tandem Repeats (STRs). An STR is a short sequence of DNA bases that tends to repeat consecutively numerous times at specific locations inside of a person\u2019s DNA. The number of times any particular STR repeats varies a lot among individuals. In the DNA samples below, for example, Alice has the STR AGAT repeated four times in her DNA, while Bob has the same STR repeated five times. Alice: CT AGAT AGAT AGAT AGAT GACT A Bob: CT AGAT AGAT AGAT AGAT AGAT T Using multiple STRs, rather than just one, can improve the accuracy of DNA profiling. If the probability that two people have the same number of repeats for a single STR is 5%, and the analyst looks at 10 different STRs, then the probability that two DNA samples match purely by chance is about 1 in 1 quadrillion (assuming all STRs are independent of each other). So if two DNA samples match in the number of repeats for each of the STRs, the analyst can be pretty confident they came from the same person. CODIS, The FBI\u2019s DNA database , uses 20 different STRs as part of its DNA profiling process. What might such a DNA database look like? Well, in its simplest form, you could imagine formatting a DNA database as a CSV file, wherein each row corresponds to an individual, and each column corresponds to a particular STR. name,AGAT,AATG,TATC Alice,28,42,14 Bob,17,22,19 Charlie,36,18,25 The data in the above file would suggest that Alice has the sequence AGAT repeated 28 times consecutively somewhere in her DNA, the sequence AATG repeated 42 times, and TATC repeated 14 times. Bob, meanwhile, has those same three STRs repeated 17 times, 22 times, and 19 times, respectively. And Charlie has those same three STRs repeated 36, 18, and 25 times, respectively. So given a sequence of DNA, how might you identify to whom it belongs? Well, imagine that you looked through the DNA sequence for the longest consecutive sequence of repeated AGAT s and found that the longest sequence was 17 repeats long. If you then found that the longest sequence of AATG is 22 repeats long, and the longest sequence of TATC is 19 repeats long, that would provide pretty good evidence that the DNA was Bob\u2019s. Of course, it\u2019s also possible that once you take the counts for each of the STRs, it doesn\u2019t match anyone in your DNA database, in which case you have no match. In practice, since analysts know on which chromosome and at which location in the DNA an STR will be found, they can localize their search to just a narrow section of DNA. But we\u2019ll ignore that detail for this problem. .zip file for CSV . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 from csv import reader , DictReader from sys import argv if len ( argv ) < 3 : print ( \"usage error, dna.py sequence.txt database.csv\" ) exit () # read the dna sequence from the file with open ( argv [ 2 ]) as dnafile : dnareader = reader ( dnafile ) for row in dnareader : dnalist = row # store it in a string dna = dnalist [ 0 ] # create a dictionary where we will store the sequences we intend to count sequences = {} # extract the sequences from the database into a list with open ( argv [ 1 ]) as peoplefile : people = reader ( peoplefile ) for row in people : dnaSequences = row dnaSequences . pop ( 0 ) break # copy the list in a dictionary where the genes are the keys for item in dnaSequences : sequences [ item ] = 1 # iterate trough the dna sequence, when it finds repetitions of the values from sequence dictionary it counts them for key in sequences : l = len ( key ) tempMax = 0 temp = 0 for i in range ( len ( dna )): # after having counted a sequence it skips at the end of it to avoid counting again while temp > 0 : temp -= 1 continue # if the segment of dna corresponds to the key and there is a repetition of it we start counting if dna [ i : i + l ] == key : while dna [ i - l : i ] == dna [ i : i + l ]: temp += 1 i += l # it compares the value to the previous longest sequence and if it is longer it overrides it if temp > tempMax : tempMax = temp # store the longest sequences in the dictionary using the correspondent key sequences [ key ] += tempMax # open and iterate trough the database of people treating each one like a dictionary so it can compare to the sequences one with open ( argv [ 1 ], newline = '' ) as peoplefile : people = DictReader ( peoplefile ) for person in people : match = 0 # compares the sequences to every person and prints name before leaving the program if there is a match for dna in sequences : if sequences [ dna ] == int ( person [ dna ]): match += 1 if match == len ( sequences ): print ( person [ 'name' ]) exit () print ( \"No match\" )","title":"Random Programs"},{"location":"py-random/#random-programs","text":"","title":"Random Programs"},{"location":"py-random/#cash","text":"In cash.py we will calculate the minimum number of coins required to give a user change. Ex: $ python cash.py Change owed: 0.41 4 We will first ask a user how much changed they are owed and then tell them the minimum number of coins (.25, .10, .05, and .01) with which said change can be made. We will utilized get_float from the CS50 library to get the user's input and print () to output the answer. Remember, if the user provides a non-negative value, our program should reprompt the user for a valid amount again and again until the user complies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from cs50 import get_float while True : dollars = get_float ( \"Change owed: \" ) if dollars >= 0 : break cents = int ( dollars * 100 ) total_coins = 0 for coin in [ 25 , 10 , 5 , 1 ]: total_coins += cents // coin cents %= coin print ( total_coins )","title":"Cash"},{"location":"py-random/#readability","text":"In readability.py we will compute the approximate grade level of given text. Ex: $ python readability.py Text: Congratulations! Today is your day. You're off to Great Places! You're off and away! Grade 3 This is a complete copy of readbility.c , which uses the Coleman-Liau index to output grade level from text, but created using Python. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from cs50 import get_string text = get_string ( \"Text: \" ) letters = sentences = words = 0 for char in text : if char . isalpha (): letters += 1 if char . isspace (): words += 1 if char in [ '?' , '!' , '.' ]: sentences += 1 words += 1 L = ( letters * 100 ) / words S = ( sentences * 100 ) / words result = int ( round ( 0.0588 * L - 0.296 * S - 15.8 )) if result < 1 : print ( \"Before Grade 1\" ) elif result >= 16 : print ( \"Grade 16+\" ) else : print ( f \"Grade { result } \" )","title":"Readability"},{"location":"py-random/#dna","text":"In this dna.py we will identify a person based on their DNA. DNA, the carrier of genetic information in living things, has been used in criminal justice for decades. But how, exactly, does DNA profiling work? Given a sequence of DNA, how can forensic investigators identify to whom it belongs? Well, DNA is really just a sequence of molecules called nucleotides, arranged into a particular shape (a double helix). Each nucleotide of DNA contains one of four different bases: adenine (A), cytosine (C), guanine (G), or thymine (T). Every human cell has billions of these nucleotides arranged in sequence. Some portions of this sequence (i.e. genome) are the same, or at least very similar, across almost all humans, but other portions of the sequence have a higher genetic diversity and thus vary more across the population. One place where DNA tends to have high genetic diversity is in Short Tandem Repeats (STRs). An STR is a short sequence of DNA bases that tends to repeat consecutively numerous times at specific locations inside of a person\u2019s DNA. The number of times any particular STR repeats varies a lot among individuals. In the DNA samples below, for example, Alice has the STR AGAT repeated four times in her DNA, while Bob has the same STR repeated five times. Alice: CT AGAT AGAT AGAT AGAT GACT A Bob: CT AGAT AGAT AGAT AGAT AGAT T Using multiple STRs, rather than just one, can improve the accuracy of DNA profiling. If the probability that two people have the same number of repeats for a single STR is 5%, and the analyst looks at 10 different STRs, then the probability that two DNA samples match purely by chance is about 1 in 1 quadrillion (assuming all STRs are independent of each other). So if two DNA samples match in the number of repeats for each of the STRs, the analyst can be pretty confident they came from the same person. CODIS, The FBI\u2019s DNA database , uses 20 different STRs as part of its DNA profiling process. What might such a DNA database look like? Well, in its simplest form, you could imagine formatting a DNA database as a CSV file, wherein each row corresponds to an individual, and each column corresponds to a particular STR. name,AGAT,AATG,TATC Alice,28,42,14 Bob,17,22,19 Charlie,36,18,25 The data in the above file would suggest that Alice has the sequence AGAT repeated 28 times consecutively somewhere in her DNA, the sequence AATG repeated 42 times, and TATC repeated 14 times. Bob, meanwhile, has those same three STRs repeated 17 times, 22 times, and 19 times, respectively. And Charlie has those same three STRs repeated 36, 18, and 25 times, respectively. So given a sequence of DNA, how might you identify to whom it belongs? Well, imagine that you looked through the DNA sequence for the longest consecutive sequence of repeated AGAT s and found that the longest sequence was 17 repeats long. If you then found that the longest sequence of AATG is 22 repeats long, and the longest sequence of TATC is 19 repeats long, that would provide pretty good evidence that the DNA was Bob\u2019s. Of course, it\u2019s also possible that once you take the counts for each of the STRs, it doesn\u2019t match anyone in your DNA database, in which case you have no match. In practice, since analysts know on which chromosome and at which location in the DNA an STR will be found, they can localize their search to just a narrow section of DNA. But we\u2019ll ignore that detail for this problem. .zip file for CSV . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 from csv import reader , DictReader from sys import argv if len ( argv ) < 3 : print ( \"usage error, dna.py sequence.txt database.csv\" ) exit () # read the dna sequence from the file with open ( argv [ 2 ]) as dnafile : dnareader = reader ( dnafile ) for row in dnareader : dnalist = row # store it in a string dna = dnalist [ 0 ] # create a dictionary where we will store the sequences we intend to count sequences = {} # extract the sequences from the database into a list with open ( argv [ 1 ]) as peoplefile : people = reader ( peoplefile ) for row in people : dnaSequences = row dnaSequences . pop ( 0 ) break # copy the list in a dictionary where the genes are the keys for item in dnaSequences : sequences [ item ] = 1 # iterate trough the dna sequence, when it finds repetitions of the values from sequence dictionary it counts them for key in sequences : l = len ( key ) tempMax = 0 temp = 0 for i in range ( len ( dna )): # after having counted a sequence it skips at the end of it to avoid counting again while temp > 0 : temp -= 1 continue # if the segment of dna corresponds to the key and there is a repetition of it we start counting if dna [ i : i + l ] == key : while dna [ i - l : i ] == dna [ i : i + l ]: temp += 1 i += l # it compares the value to the previous longest sequence and if it is longer it overrides it if temp > tempMax : tempMax = temp # store the longest sequences in the dictionary using the correspondent key sequences [ key ] += tempMax # open and iterate trough the database of people treating each one like a dictionary so it can compare to the sequences one with open ( argv [ 1 ], newline = '' ) as peoplefile : people = DictReader ( peoplefile ) for person in people : match = 0 # compares the sequences to every person and prints name before leaving the program if there is a match for dna in sequences : if sequences [ dna ] == int ( person [ dna ]): match += 1 if match == len ( sequences ): print ( person [ 'name' ]) exit () print ( \"No match\" )","title":"DNA"},{"location":"py-user-input-while-loops/","text":"User Input and while Loops Most programs will require a user's input to function. For a simple example, let's say someone wants to find out whether they're old enough to vote. If you write a program to answer this question, you need to know the user's age before you can provide an answer. The program will need to ask the user to enter, or input , their age; once the program has this input, it can compare it to the voting age to determine if the user is old enough and then report the result. In this chapter you'll learn how to accept user input so your program can then work with it. When your program needs a name, you'll be able to prompt the user for a name. When your program needs a list of names, you'll be able to prompt the user for a name. When your program needs a list of names, you'll be able to prompt the user for a series of names. To do this, you'll use the input () function. We'll also learn how to keep programs running as long as users want them to, so they can enter as much information as they need to; then, your program can work with this information. You'll use Python's while loop to keep programs running as long as certain conditons remain true . How the input () Function Works The input () function pauses your program and waits for the user to enter some text. Once Python receives the user's input, it assigns that input to a variable to make it convenient for you to work with. For example, the following program asks the user to enter some text, then displays that message back to the user: 1 2 message = input ( \"Tell me something, and I will repeat it back to you: \" ) print ( message ) The input () function takes one argument: the prompt , or instructions, that we want to display to the user so they know what to do. In this example when Python runs the first line, the user sees the prompt Tell me something, and I will repeat it back to you: . The program waits while the user enters their response and continues after the user presses ENTER / The response is assigned to the variable message , then print ( message ) displays the input back to the user: Tell me something, and I will repeat it back to you: Hello Everyone! Hello Everyone! Writing Clear Prompts Each time you use the input () function, you should include a clear, easy-to-follow prompt that tells the suer exactly what kind of information you're looking for. Any statment that tells the user what to enter should work. For example: 1 2 name = input ( \"Please enter your name: \" ) print ( f \" \\n Hello, { name } !\" ) Add a space at the end of your prompts (after the colon in the preceding example) to separate the prompt from the user's response and to make it clear to your user where to enter their text. Sometimes you'll want to write a prompt that is longer than one line. For example, you might want to tel the user why you're asking for certain input. You can assign your prompt to a variable and pass that variable to the input () function. This allows you to build your prompt over several lines, then write a clean input () statement. 1 2 3 4 5 prompt = \"If you tell us who you are, we can personalize the messages you see.\" prompt += \" \\n What is your first name? \" name = input ( prompt ) print ( f \" \\n Hello, { name } !\" ) This example shows one way to build a multi-line string. The first line assigns the first part of the message to the variable prompt . In the second line, the operator =+ takes the string that was assigned to prompt and adds the new string onto the end. The above prompt now spans two lines, again with space after the question mark for clarity: If you tell us who you are, we can personalize the messages you see. What is your first name? Nick Hello, Nick! Using int () to Accept Numerical Input When you use the input () function, Python interprets everything the user enters as a string. Consider the following interpreter session, which asks for the user's age: >>> age = input(\"How old are you? \") How old are you? 21 >>> age '21' The user enters the number 21, but when we ask Python for the value of age, it returns '21' , the string representation of the numerical value entered. We know Python interpreted the input as a string because the number is now enclosed in quites. If all you want to do is print the input, this works well. But if you try to use the input as a number, you'll get an error: >>> age = input(\"How old are you? \") How old are you? 21 >>> age >= 18 Traceback (most recent call last): file \"<stdin>\", line 1, in <module> TypeError: unorderable types: str() >= int() When you try to use the input to do a numerical comparison, Python produces an error because it can't compare a string to an integer: the string '21' that's assigned to age can't be compared to the numerical value 18 . We can resolve this by using the int () function, which tells Python to treat the input as a numerica value. We can do this by wrapping the input () statement in an int () : age = int ( input ( \"How old are you? \" )) How do you use the int () function in an actual program? Consider a program that determins whether people are tall enough to ride a roller coaster: 1 2 3 4 5 6 height = int ( input ( \"How tall are you, in inches? \" )) if height >= 48 : print ( \" \\n You're tall enough to ride!\" ) else : print ( \" \\n You're not tall enough to ride!\" ) The program can compare height to 48 because the input () for the height is wrapped in an int () . The Modulo Operator A useful tool for working with numerical information is the modulo operator (%) , which divides one number by another and returns the remainder. For example: 4 % 3 1 or 6 % 3 0 The modulo operator doesn't tell you how many times one number fits into another; it just tells you what the remainder is. When one number is divisible by another number, the remainder is 0, so the modulo operator always returns 0. You can use this fact to determine if a number is even or odd: 1 2 3 4 5 6 number = int ( input ( \"Enter a number, and I'll tell you if it's even or odd: \" )) if number % 2 == 0 : print ( f \" \\n The number { number } is even.\" ) else : print ( f \" \\n The number { number } is odd.\" ) Even numbers are always divisible by two, so if the modulo of a number and two is zero (here, if number % 2 == 0 ) the number is even. Otherwise, it's odd. Enter a number, and I'll tell you if it's even or odd: 5 The number 5 is odd. Introducing while Loops The for loop takes a collection of items and executes a block of code once for each item in a collection. In contrast, the while loop runs as lons as, or while , a certain condition is true. The while Loop in Action You can use a while loop to count up through a series of numbers. For example, the following while loop counts from 1 to 5: 1 2 3 4 current_number = 1 while current_number <= 5 : print ( current_number ) current_number += 1 In the first line, we start counting from 1 by assigning current_number to the value 1 . The while loop is then set to keep running as long as the value of current_number is less than or equal to 5. The code inside the loop prints the value of current_number and then adds 1 to that value with the current_number += 1 . (The += operator is shorthand for current_number = current_number + 1 ). Python repeats the loop as long as the condition current_number <= 5 is true. Each time it loops it will check the value of current_number and add 1 (if less than 5), until it reaches 5. 1 2 3 4 5 The programs you use every day most likely contain while loops. For example, a game needs a while loop to keep running as long as you want to keep playing, and so it can stop running as soon as you ask it to quit. Programs wouldn't be fun to use if they stopped running before we told them to or kept running even after we wanted to quit, so while loops are quite useful. Letting the User Choose When to Quit We can make a program as long as the user wants by putting most of the program inside a while loop. We'll define a quit value and then keep the program running as long as the user has not entered the quit value: 1 2 3 4 5 6 7 prompt = \" \\n Tell me something, and I will repeat it back to you:\" prompt += \" \\n Enter 'quit' to end the program.\" message = \"\" while message != 'quit' : message = input ( prompt ) print ( message ) On line 1, we define a prompt that tells the user their two options: entering a message or entering a quit value (in this case, 'quit'). Then we set up a variable message (line 4) to keep track of whatever value the user enters. We define message as an empty string, \"\", so Python has something to check the first time it reaches the while line. The first time the program runs and Python reaches the while statementm it needs to compare the value of message to quit , but no user input has been entered yet. If Python has nothing to compare, it won't be able to continue running the program. To solve this provlem, we make sure to give message an initial value. Although it's just an empty string, it will make sense to Python and allow it to perform the comparison that makes the while loop work. This while loop (line 5) runs as long as the value of message is not 'quit' . The first time through the loop, message is just an empty string, so Python enters the loop. At message = input ( prompt ) , Python displays the prompt and waits for the user to enter their input. Whatever they enter is assigned to message and printed; then, Python reevaluates the condition in the while statement. As long as the user has not entered the word 'quit' , the prompt is displayed again and Python waits for more input. When the user finally enters 'quit' , Python stops executing the while loop and the program ends: Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. Hello everyone! Hello everyone! Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. Hello again. Hello again. Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. quit quit The progam works well, except that it prints the word 'quit' as if it were an actual message. A simple if test fixes this: if message != 'quit' : print ( message ) Now the program will quit immediately after the input, instead of printing 'quit' . Using a Flag In the previous example, we had the program perform certain tasks while a given condition was true. But what about more complicated programs in which many different events could cause the program to stop running? For example, in a game, several different event can end the game. When the player runs out of ships, their time runs out, or the cities they were supposed to protect are all destroyed, the game should end. It needs to end if any one of these event happen. If many possible events might occur to stop the program, trying to test all these conditions in one while statement becomes complicated and difficult. For a program that should run only as long as many conditions are true, you can define one variable that determines whether or not the entire program is active. This varibale, called a flag , acts as a signal to the program. We can write our programs so they run while the flag is set to True and stop running when any of several events sets the value of the flag to False . As a result, our overall while statement needs to check only one condition: whether or not the flag is currently True . Then, all our other tests (to see if an event has occurred that should set the flag to False ) can be neatly organized in the rest of the program. Let's add a flag to the program from the previous section. This flag, which we'll call active (though you can call it anything), will monitor whether or not the program should continue running: 1 2 3 4 5 6 7 8 9 10 11 prompt = \" \\n Tell me something, and I will repeat it back to you:\" prompt += \" \\n Enter 'quit' to end the program.\" active = True while active : message = input ( prompt ) if message == 'quit' : active = False else : print ( message ) We set the variable active to True on line 4 so the program starts in an active state. Doing so makes the while statement simpler because no comparison is made in the while statement itself; the logic is taken care of in other parts of the program. As long as the active variable remains True , the loop will continue running (line 5). In the if statement inside the while loop, we check the value of message once the user enters their input. If the user enters 'quit' (line 8), we set active to False , and the while loop stops. If the user enters anything other than 'quit' , we print the input as a message. This program has the same output as the previous example where we placed the conditional test directly in the while statement. But now that we have a flag to indicate whether the overal program is in an active state, it would be easy to add more tests (such as elif statements) for events that should cause active to become False . This is useful in complicated programs like games in which there may be many evenet that should each make the program stop running. When any of these events causes the active flag to become False , the main loop will exit, a Game Over message can be displayed, and the player can be given the option to play again. Using break to Exit a Loop To exit a while loop immediately without running any remaining code in the loop, regardless of the results of any conditional test, use the break statement. The break statement directs the flow of your program; you can use it to control which lines of code are executed and which aren't, so the program only executes code that you want it to, when you want it to. For example, consider a program that asks a user about places they've visited. We can stop the while loop in this program by calling a break as soon as the user enters the 'quit' value: 1 2 3 4 5 6 7 8 9 10 prompt = \" \\n Please enter the name of a city you have visited:\" prompt += \" \\n (Enter 'quit' when you are finished.) \" while True : city = input ( prompt ) if city == 'quit' : break else : print ( f \"I'd love to go to { city . title () } !\" ) A loop that starts with a while True (line 4) will run forever unless it reaches a break statement. The loop in this program continues asking the user to enter the names of cities they've been to until they enter 'quit' . When they enter 'quit' , the break statement runs, causing Python to exit the loop: Please enter the name of a city you have visited: (Enter 'quit' when you are finished.) San Francisco I'd love to go to San Francisco! Please enter the name of a city you have visited: (Enter 'quit' when you are finished.) Los Angeles I'd love to go to Los Angeles! Please enter the name of a city you have visited: (Enter 'quit' when you are finished.) quit Note on break You can use the break statement in any of Python's loops. For example, you could use break to quite a for loop that's working through a list or a dictionary. Using continue in a Loop Rather than breaking out of a loop entirely without executing the rest of its code, you can use the continue statement to return to the beginning of the loop based on the result of a conditional test. For example, consider a loop that counts from 1 to 10 but prints only the odd numbers in the range: 1 2 3 4 5 6 7 current_number = 0 while current_number < 10 : current_number += 1 if current_number % 2 == 0 : continue print ( current_number ) First we set current_number to 0. Because it's less than 10, Python enters the while loop. Once inside the loop, we increment the count by 1 (line 3), so the current_number is 1. The if statement then checks the modulo of current_number and 2. If the modulo is 0 (which means current_number is divisible by 2), the continue statement tells Python to ignore the rest of the loop and return to the beginning. If the current number is not divisible by 2, the rest of the loop is executed and Python prints the current number: 1 3 5 7 9 Avoiding Infinite Loops Every while loop needs a way to stop running so it won't continue to run forever. For example, this counting loop should count from 1 to 5: 1 2 3 4 x = 1 while x < 5 : print ( x ) x += 1 But if you accidentally omit the line x += 1 (as shown next), the loop will run forever: 1 2 3 x = 1 while x < 5 : print ( x ) Now the value of x will start at 1 but never change. As a result, the conditional test x <= 5 will always evaluate to True and the while loop will run forever, printing a series of 1s. Every programmer accidentally writes and infinite while loop from time to time, especially when a program's loops have subtle exit conditions. If your program gets stuck in an infinite loop, press CTRL-C or just close the terminal window displaying the program's output. To avoid writing infinite loops, test every while loop and make sure the loop stops when you expect it to. If you want your program to end when the user enters a certain input value, run the program and enter that value. If the program doesn't end, scrutinize the way your program handles the value that should cause the loop to exit. Make sure at least one part of the program can make the loop's condition False or cause it to reach a break statement. Using a while Loop with Lists and Dicitonaries So far, we've worked with only one piece of user information at a time. We received the user's input and then printed the input or a response to it. The next time through the while loop, we'd receive another input value and respond to that. But to keep track of many users and pieces of information, we'll need to use lists and dictionaries with our while loops. A for loop is effective for looping through a lsit, but you shouldn't modify a list inside a for loop because Python will have trouble keeping track of the items in the list. To modify a list as you work through it, use a while loop. Using while loops with lists and dictionaries allow you to collect, store, and organize lots of input to examine and report on later. Moving Items from One List to Another Consider a list of newly registered but unverified users of a website. After we verify these users, how can we move them to a separate list of confirmed users? One way would be to use a while loop to pull users from the list of unconfirmed users as we verify them and then add them to a separate list of confirmed users. Here's what that code might look like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Start with users that need to be verified, # and an empty list to hold confirmed users. unconfirmed_users = [ 'alice' , 'brian' , 'candace' ] confirmed_users = [] # Verify each user until there are no more unconfirmed users. # Move each verified user into the list of confirmed users. while unconfirmed_users : current_user = unconfirmed_users . pop () print ( f \"Verifying user: { current_user . title () } \" ) confirmed_users . append ( current_user ) #Display all confirmed users. print ( \" \\n The following users have been confirmed:\" ) for confirmed_user in confirmed_users : print ( confirmed_user . title ()) We begin with a list of unconfirmed users on line 3 (Alice, Brian, and Candace) and an empty list to hold confirmed users. The while loop on line 8 runs as long as the list unconfirmed_users is not empty. Within this loop, the pop () function (line 9) removes unverified users one at a time from the end of unconfirmed_users . Here, because Candace is te last in the unconfirmed_users list, her name will be the first to be removed, assigned to current_user , and added to the confirmed_users list on line 12. Next is Brian, then Alice. We simulate confirming each user by printing a verification message then adding them to the list of confirmed users. As the list of unconfirmed users shrinks, the list of confirmed users grows. When the list of unconfirmed users is empty, the loop stops and the list of confirmed users in printed: Verifying user: Candace Verifying user: Brian Verifying user: Alice The following users have been confirmed: Candace Brian Alice Removing All Instances of Specific Values from a List In previous notes ( located here ) we used remove () to remove a specific value from a list. The remove () function worked because the value we were interested in appeared only once in the list. But what if you want to remove all instances of a value from a list? Say you have a list of pets with the value 'cat' repeated several times. To remove all instances of that value, you can run a while loop until 'cat' is no longer in the list, as shown here: 1 2 3 4 5 6 7 pets = [ 'dog' , 'cat' , 'dog' , 'goldfish' , 'cat' , 'rabbit' , 'cat' ] print ( pets ) while 'cat' in pets : pets . remove ( 'cat' ) print ( pets ) We start with a list containing multiple instances of 'cat' . After printing the list, Python enters the while loop because it finds the value 'cat' in the list at least once. Once insidethe loop, Python removes the first instance of 'cat' , returns to the while line, and then reenters the loop when it finds that 'cat' is still in the list. It removes each instance of 'cat' until the value is no longer in the list, at which point Python exits the loop and prints the list again: ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat'] ['dog', 'dog', 'goldfish', 'rabbit'] Filling a Dictionary with User Input You can prompt for as much input as you need in each pass through a while loop. Let's make a polling program in which each pass through the loop prompts for the participant's name and response. We'll store the data we gather in a dictionary, because we want to connect each response with a particular user: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 responses = {} # Set a flag to indicate that polling is active polling_active = True while polling_active : # Prompt for the person's name and response. name = input ( \" \\n What is your name? \" ) response = input ( \"Which mountain would you like to climb someday? \" ) # Store the response in the dictionary responses [ name ] = response # Find out if anyone else if going to take the poll. repeat = input ( \"Would you like to let another person respond? (yes/no) \" ) if repeat == 'no' : polling_active = False # Polling is complete. Show the results. print ( \" \\n --- Poll Results ---\" ) for name , response in responses . items (): print ( f \" { name } would like to climb { response } .\" ) The program first defines an empty dictionary ( responses ) and sets a flag ( polling_active ) to indicate that polling is active. As long as polling_active is True , Python will run the code in the while loop. Within the loop, the user is prompted to enter their name and a mountain they'd like to climb (line 8). That information is stored in the responses dictionary (line 12), and the user is asked whether or not to keep the poll running (line 15). If they enter yes, the program enters the while loop again. If they enter no, the polling_active flag is set to False , the while loop stops running, and the final code block at line 20 displays the results of the poll. If you run this program and enter sample resonses, you should see output like this: What is your name? Eric Which mountain would you like to climb someday? Denali Would you like to let another person respond? (yes/ no) yes What is your name? Lynn Which mountain would you like to climb someday? Devil's Thumb Would you like to let another person respond? (yes/ no) no --- Poll Results --- Lynn would like to climb Devil's Thumb. Eric would like to climb Denali.","title":"User Input and while Loops"},{"location":"py-user-input-while-loops/#user-input-and-while-loops","text":"Most programs will require a user's input to function. For a simple example, let's say someone wants to find out whether they're old enough to vote. If you write a program to answer this question, you need to know the user's age before you can provide an answer. The program will need to ask the user to enter, or input , their age; once the program has this input, it can compare it to the voting age to determine if the user is old enough and then report the result. In this chapter you'll learn how to accept user input so your program can then work with it. When your program needs a name, you'll be able to prompt the user for a name. When your program needs a list of names, you'll be able to prompt the user for a name. When your program needs a list of names, you'll be able to prompt the user for a series of names. To do this, you'll use the input () function. We'll also learn how to keep programs running as long as users want them to, so they can enter as much information as they need to; then, your program can work with this information. You'll use Python's while loop to keep programs running as long as certain conditons remain true .","title":"User Input and while Loops"},{"location":"py-user-input-while-loops/#how-the-input-function-works","text":"The input () function pauses your program and waits for the user to enter some text. Once Python receives the user's input, it assigns that input to a variable to make it convenient for you to work with. For example, the following program asks the user to enter some text, then displays that message back to the user: 1 2 message = input ( \"Tell me something, and I will repeat it back to you: \" ) print ( message ) The input () function takes one argument: the prompt , or instructions, that we want to display to the user so they know what to do. In this example when Python runs the first line, the user sees the prompt Tell me something, and I will repeat it back to you: . The program waits while the user enters their response and continues after the user presses ENTER / The response is assigned to the variable message , then print ( message ) displays the input back to the user: Tell me something, and I will repeat it back to you: Hello Everyone! Hello Everyone!","title":"How the input() Function Works"},{"location":"py-user-input-while-loops/#writing-clear-prompts","text":"Each time you use the input () function, you should include a clear, easy-to-follow prompt that tells the suer exactly what kind of information you're looking for. Any statment that tells the user what to enter should work. For example: 1 2 name = input ( \"Please enter your name: \" ) print ( f \" \\n Hello, { name } !\" ) Add a space at the end of your prompts (after the colon in the preceding example) to separate the prompt from the user's response and to make it clear to your user where to enter their text. Sometimes you'll want to write a prompt that is longer than one line. For example, you might want to tel the user why you're asking for certain input. You can assign your prompt to a variable and pass that variable to the input () function. This allows you to build your prompt over several lines, then write a clean input () statement. 1 2 3 4 5 prompt = \"If you tell us who you are, we can personalize the messages you see.\" prompt += \" \\n What is your first name? \" name = input ( prompt ) print ( f \" \\n Hello, { name } !\" ) This example shows one way to build a multi-line string. The first line assigns the first part of the message to the variable prompt . In the second line, the operator =+ takes the string that was assigned to prompt and adds the new string onto the end. The above prompt now spans two lines, again with space after the question mark for clarity: If you tell us who you are, we can personalize the messages you see. What is your first name? Nick Hello, Nick!","title":"Writing Clear Prompts"},{"location":"py-user-input-while-loops/#using-int-to-accept-numerical-input","text":"When you use the input () function, Python interprets everything the user enters as a string. Consider the following interpreter session, which asks for the user's age: >>> age = input(\"How old are you? \") How old are you? 21 >>> age '21' The user enters the number 21, but when we ask Python for the value of age, it returns '21' , the string representation of the numerical value entered. We know Python interpreted the input as a string because the number is now enclosed in quites. If all you want to do is print the input, this works well. But if you try to use the input as a number, you'll get an error: >>> age = input(\"How old are you? \") How old are you? 21 >>> age >= 18 Traceback (most recent call last): file \"<stdin>\", line 1, in <module> TypeError: unorderable types: str() >= int() When you try to use the input to do a numerical comparison, Python produces an error because it can't compare a string to an integer: the string '21' that's assigned to age can't be compared to the numerical value 18 . We can resolve this by using the int () function, which tells Python to treat the input as a numerica value. We can do this by wrapping the input () statement in an int () : age = int ( input ( \"How old are you? \" )) How do you use the int () function in an actual program? Consider a program that determins whether people are tall enough to ride a roller coaster: 1 2 3 4 5 6 height = int ( input ( \"How tall are you, in inches? \" )) if height >= 48 : print ( \" \\n You're tall enough to ride!\" ) else : print ( \" \\n You're not tall enough to ride!\" ) The program can compare height to 48 because the input () for the height is wrapped in an int () .","title":"Using int() to Accept Numerical Input"},{"location":"py-user-input-while-loops/#the-modulo-operator","text":"A useful tool for working with numerical information is the modulo operator (%) , which divides one number by another and returns the remainder. For example: 4 % 3 1 or 6 % 3 0 The modulo operator doesn't tell you how many times one number fits into another; it just tells you what the remainder is. When one number is divisible by another number, the remainder is 0, so the modulo operator always returns 0. You can use this fact to determine if a number is even or odd: 1 2 3 4 5 6 number = int ( input ( \"Enter a number, and I'll tell you if it's even or odd: \" )) if number % 2 == 0 : print ( f \" \\n The number { number } is even.\" ) else : print ( f \" \\n The number { number } is odd.\" ) Even numbers are always divisible by two, so if the modulo of a number and two is zero (here, if number % 2 == 0 ) the number is even. Otherwise, it's odd. Enter a number, and I'll tell you if it's even or odd: 5 The number 5 is odd.","title":"The Modulo Operator"},{"location":"py-user-input-while-loops/#introducing-while-loops","text":"The for loop takes a collection of items and executes a block of code once for each item in a collection. In contrast, the while loop runs as lons as, or while , a certain condition is true.","title":"Introducing while Loops"},{"location":"py-user-input-while-loops/#the-while-loop-in-action","text":"You can use a while loop to count up through a series of numbers. For example, the following while loop counts from 1 to 5: 1 2 3 4 current_number = 1 while current_number <= 5 : print ( current_number ) current_number += 1 In the first line, we start counting from 1 by assigning current_number to the value 1 . The while loop is then set to keep running as long as the value of current_number is less than or equal to 5. The code inside the loop prints the value of current_number and then adds 1 to that value with the current_number += 1 . (The += operator is shorthand for current_number = current_number + 1 ). Python repeats the loop as long as the condition current_number <= 5 is true. Each time it loops it will check the value of current_number and add 1 (if less than 5), until it reaches 5. 1 2 3 4 5 The programs you use every day most likely contain while loops. For example, a game needs a while loop to keep running as long as you want to keep playing, and so it can stop running as soon as you ask it to quit. Programs wouldn't be fun to use if they stopped running before we told them to or kept running even after we wanted to quit, so while loops are quite useful.","title":"The while Loop in Action"},{"location":"py-user-input-while-loops/#letting-the-user-choose-when-to-quit","text":"We can make a program as long as the user wants by putting most of the program inside a while loop. We'll define a quit value and then keep the program running as long as the user has not entered the quit value: 1 2 3 4 5 6 7 prompt = \" \\n Tell me something, and I will repeat it back to you:\" prompt += \" \\n Enter 'quit' to end the program.\" message = \"\" while message != 'quit' : message = input ( prompt ) print ( message ) On line 1, we define a prompt that tells the user their two options: entering a message or entering a quit value (in this case, 'quit'). Then we set up a variable message (line 4) to keep track of whatever value the user enters. We define message as an empty string, \"\", so Python has something to check the first time it reaches the while line. The first time the program runs and Python reaches the while statementm it needs to compare the value of message to quit , but no user input has been entered yet. If Python has nothing to compare, it won't be able to continue running the program. To solve this provlem, we make sure to give message an initial value. Although it's just an empty string, it will make sense to Python and allow it to perform the comparison that makes the while loop work. This while loop (line 5) runs as long as the value of message is not 'quit' . The first time through the loop, message is just an empty string, so Python enters the loop. At message = input ( prompt ) , Python displays the prompt and waits for the user to enter their input. Whatever they enter is assigned to message and printed; then, Python reevaluates the condition in the while statement. As long as the user has not entered the word 'quit' , the prompt is displayed again and Python waits for more input. When the user finally enters 'quit' , Python stops executing the while loop and the program ends: Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. Hello everyone! Hello everyone! Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. Hello again. Hello again. Tell me something, and I will repeat it back to you: Enter 'quit' to end the program. quit quit The progam works well, except that it prints the word 'quit' as if it were an actual message. A simple if test fixes this: if message != 'quit' : print ( message ) Now the program will quit immediately after the input, instead of printing 'quit' .","title":"Letting the User Choose When to Quit"},{"location":"py-user-input-while-loops/#using-a-flag","text":"In the previous example, we had the program perform certain tasks while a given condition was true. But what about more complicated programs in which many different events could cause the program to stop running? For example, in a game, several different event can end the game. When the player runs out of ships, their time runs out, or the cities they were supposed to protect are all destroyed, the game should end. It needs to end if any one of these event happen. If many possible events might occur to stop the program, trying to test all these conditions in one while statement becomes complicated and difficult. For a program that should run only as long as many conditions are true, you can define one variable that determines whether or not the entire program is active. This varibale, called a flag , acts as a signal to the program. We can write our programs so they run while the flag is set to True and stop running when any of several events sets the value of the flag to False . As a result, our overall while statement needs to check only one condition: whether or not the flag is currently True . Then, all our other tests (to see if an event has occurred that should set the flag to False ) can be neatly organized in the rest of the program. Let's add a flag to the program from the previous section. This flag, which we'll call active (though you can call it anything), will monitor whether or not the program should continue running: 1 2 3 4 5 6 7 8 9 10 11 prompt = \" \\n Tell me something, and I will repeat it back to you:\" prompt += \" \\n Enter 'quit' to end the program.\" active = True while active : message = input ( prompt ) if message == 'quit' : active = False else : print ( message ) We set the variable active to True on line 4 so the program starts in an active state. Doing so makes the while statement simpler because no comparison is made in the while statement itself; the logic is taken care of in other parts of the program. As long as the active variable remains True , the loop will continue running (line 5). In the if statement inside the while loop, we check the value of message once the user enters their input. If the user enters 'quit' (line 8), we set active to False , and the while loop stops. If the user enters anything other than 'quit' , we print the input as a message. This program has the same output as the previous example where we placed the conditional test directly in the while statement. But now that we have a flag to indicate whether the overal program is in an active state, it would be easy to add more tests (such as elif statements) for events that should cause active to become False . This is useful in complicated programs like games in which there may be many evenet that should each make the program stop running. When any of these events causes the active flag to become False , the main loop will exit, a Game Over message can be displayed, and the player can be given the option to play again.","title":"Using a Flag"},{"location":"py-user-input-while-loops/#using-break-to-exit-a-loop","text":"To exit a while loop immediately without running any remaining code in the loop, regardless of the results of any conditional test, use the break statement. The break statement directs the flow of your program; you can use it to control which lines of code are executed and which aren't, so the program only executes code that you want it to, when you want it to. For example, consider a program that asks a user about places they've visited. We can stop the while loop in this program by calling a break as soon as the user enters the 'quit' value: 1 2 3 4 5 6 7 8 9 10 prompt = \" \\n Please enter the name of a city you have visited:\" prompt += \" \\n (Enter 'quit' when you are finished.) \" while True : city = input ( prompt ) if city == 'quit' : break else : print ( f \"I'd love to go to { city . title () } !\" ) A loop that starts with a while True (line 4) will run forever unless it reaches a break statement. The loop in this program continues asking the user to enter the names of cities they've been to until they enter 'quit' . When they enter 'quit' , the break statement runs, causing Python to exit the loop: Please enter the name of a city you have visited: (Enter 'quit' when you are finished.) San Francisco I'd love to go to San Francisco! Please enter the name of a city you have visited: (Enter 'quit' when you are finished.) Los Angeles I'd love to go to Los Angeles! Please enter the name of a city you have visited: (Enter 'quit' when you are finished.) quit Note on break You can use the break statement in any of Python's loops. For example, you could use break to quite a for loop that's working through a list or a dictionary.","title":"Using break to Exit a Loop"},{"location":"py-user-input-while-loops/#using-continue-in-a-loop","text":"Rather than breaking out of a loop entirely without executing the rest of its code, you can use the continue statement to return to the beginning of the loop based on the result of a conditional test. For example, consider a loop that counts from 1 to 10 but prints only the odd numbers in the range: 1 2 3 4 5 6 7 current_number = 0 while current_number < 10 : current_number += 1 if current_number % 2 == 0 : continue print ( current_number ) First we set current_number to 0. Because it's less than 10, Python enters the while loop. Once inside the loop, we increment the count by 1 (line 3), so the current_number is 1. The if statement then checks the modulo of current_number and 2. If the modulo is 0 (which means current_number is divisible by 2), the continue statement tells Python to ignore the rest of the loop and return to the beginning. If the current number is not divisible by 2, the rest of the loop is executed and Python prints the current number: 1 3 5 7 9","title":"Using continue in a Loop"},{"location":"py-user-input-while-loops/#avoiding-infinite-loops","text":"Every while loop needs a way to stop running so it won't continue to run forever. For example, this counting loop should count from 1 to 5: 1 2 3 4 x = 1 while x < 5 : print ( x ) x += 1 But if you accidentally omit the line x += 1 (as shown next), the loop will run forever: 1 2 3 x = 1 while x < 5 : print ( x ) Now the value of x will start at 1 but never change. As a result, the conditional test x <= 5 will always evaluate to True and the while loop will run forever, printing a series of 1s. Every programmer accidentally writes and infinite while loop from time to time, especially when a program's loops have subtle exit conditions. If your program gets stuck in an infinite loop, press CTRL-C or just close the terminal window displaying the program's output. To avoid writing infinite loops, test every while loop and make sure the loop stops when you expect it to. If you want your program to end when the user enters a certain input value, run the program and enter that value. If the program doesn't end, scrutinize the way your program handles the value that should cause the loop to exit. Make sure at least one part of the program can make the loop's condition False or cause it to reach a break statement.","title":"Avoiding Infinite Loops"},{"location":"py-user-input-while-loops/#using-a-while-loop-with-lists-and-dicitonaries","text":"So far, we've worked with only one piece of user information at a time. We received the user's input and then printed the input or a response to it. The next time through the while loop, we'd receive another input value and respond to that. But to keep track of many users and pieces of information, we'll need to use lists and dictionaries with our while loops. A for loop is effective for looping through a lsit, but you shouldn't modify a list inside a for loop because Python will have trouble keeping track of the items in the list. To modify a list as you work through it, use a while loop. Using while loops with lists and dictionaries allow you to collect, store, and organize lots of input to examine and report on later.","title":"Using a while Loop with Lists and Dicitonaries"},{"location":"py-user-input-while-loops/#moving-items-from-one-list-to-another","text":"Consider a list of newly registered but unverified users of a website. After we verify these users, how can we move them to a separate list of confirmed users? One way would be to use a while loop to pull users from the list of unconfirmed users as we verify them and then add them to a separate list of confirmed users. Here's what that code might look like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # Start with users that need to be verified, # and an empty list to hold confirmed users. unconfirmed_users = [ 'alice' , 'brian' , 'candace' ] confirmed_users = [] # Verify each user until there are no more unconfirmed users. # Move each verified user into the list of confirmed users. while unconfirmed_users : current_user = unconfirmed_users . pop () print ( f \"Verifying user: { current_user . title () } \" ) confirmed_users . append ( current_user ) #Display all confirmed users. print ( \" \\n The following users have been confirmed:\" ) for confirmed_user in confirmed_users : print ( confirmed_user . title ()) We begin with a list of unconfirmed users on line 3 (Alice, Brian, and Candace) and an empty list to hold confirmed users. The while loop on line 8 runs as long as the list unconfirmed_users is not empty. Within this loop, the pop () function (line 9) removes unverified users one at a time from the end of unconfirmed_users . Here, because Candace is te last in the unconfirmed_users list, her name will be the first to be removed, assigned to current_user , and added to the confirmed_users list on line 12. Next is Brian, then Alice. We simulate confirming each user by printing a verification message then adding them to the list of confirmed users. As the list of unconfirmed users shrinks, the list of confirmed users grows. When the list of unconfirmed users is empty, the loop stops and the list of confirmed users in printed: Verifying user: Candace Verifying user: Brian Verifying user: Alice The following users have been confirmed: Candace Brian Alice","title":"Moving Items from One List to Another"},{"location":"py-user-input-while-loops/#removing-all-instances-of-specific-values-from-a-list","text":"In previous notes ( located here ) we used remove () to remove a specific value from a list. The remove () function worked because the value we were interested in appeared only once in the list. But what if you want to remove all instances of a value from a list? Say you have a list of pets with the value 'cat' repeated several times. To remove all instances of that value, you can run a while loop until 'cat' is no longer in the list, as shown here: 1 2 3 4 5 6 7 pets = [ 'dog' , 'cat' , 'dog' , 'goldfish' , 'cat' , 'rabbit' , 'cat' ] print ( pets ) while 'cat' in pets : pets . remove ( 'cat' ) print ( pets ) We start with a list containing multiple instances of 'cat' . After printing the list, Python enters the while loop because it finds the value 'cat' in the list at least once. Once insidethe loop, Python removes the first instance of 'cat' , returns to the while line, and then reenters the loop when it finds that 'cat' is still in the list. It removes each instance of 'cat' until the value is no longer in the list, at which point Python exits the loop and prints the list again: ['dog', 'cat', 'dog', 'goldfish', 'cat', 'rabbit', 'cat'] ['dog', 'dog', 'goldfish', 'rabbit']","title":"Removing All Instances of Specific Values from a List"},{"location":"py-user-input-while-loops/#filling-a-dictionary-with-user-input","text":"You can prompt for as much input as you need in each pass through a while loop. Let's make a polling program in which each pass through the loop prompts for the participant's name and response. We'll store the data we gather in a dictionary, because we want to connect each response with a particular user: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 responses = {} # Set a flag to indicate that polling is active polling_active = True while polling_active : # Prompt for the person's name and response. name = input ( \" \\n What is your name? \" ) response = input ( \"Which mountain would you like to climb someday? \" ) # Store the response in the dictionary responses [ name ] = response # Find out if anyone else if going to take the poll. repeat = input ( \"Would you like to let another person respond? (yes/no) \" ) if repeat == 'no' : polling_active = False # Polling is complete. Show the results. print ( \" \\n --- Poll Results ---\" ) for name , response in responses . items (): print ( f \" { name } would like to climb { response } .\" ) The program first defines an empty dictionary ( responses ) and sets a flag ( polling_active ) to indicate that polling is active. As long as polling_active is True , Python will run the code in the while loop. Within the loop, the user is prompted to enter their name and a mountain they'd like to climb (line 8). That information is stored in the responses dictionary (line 12), and the user is asked whether or not to keep the poll running (line 15). If they enter yes, the program enters the while loop again. If they enter no, the polling_active flag is set to False , the while loop stops running, and the final code block at line 20 displays the results of the poll. If you run this program and enter sample resonses, you should see output like this: What is your name? Eric Which mountain would you like to climb someday? Denali Would you like to let another person respond? (yes/ no) yes What is your name? Lynn Which mountain would you like to climb someday? Devil's Thumb Would you like to let another person respond? (yes/ no) no --- Poll Results --- Lynn would like to climb Devil's Thumb. Eric would like to climb Denali.","title":"Filling a Dictionary with User Input"},{"location":"py-working-with-lists/","text":"Working with Lists Looping Through an Entire List You'll often want to run through all entries in a list, performing the same task with each item. For example, in a game you might want to move every element on the screen by the same amount, or in a list of numbers you might want to perform the same statistical operation on every element. Or perhaps, you'll want to display each headline from a list of articles on a website. When you want to do the sam eaction with every item in a list, you can use Python's for loop. Let's say we have a list of magician's names, and we want to print out each name in the list. We could do this by retrieving each name from the list individually, but this approach could cause several problems. For one, it would be repetitive to do this with a long list of names. Also, we'd have to change our code each time the list's length changed. A for loop avoids both of these issues by letting Python manage these issues internally. Let's use a for loop to print out each name in a list of magicians: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( magician ) We begin by defining the list ( magicians ). Next, we define a for loop. This line tells Python to pull a name from the list magicians , and associate it with the variable magician . Finally, we tell Python to print the name that's been assigned to magician . Python then repeats these steps for each name in the list. Pseudocode for this may look like: For every magician in the list of magicians print the magician's name The output is a simple printout of each name on the list: alice david carolina A Closer Look at Looping The concept of looping is important because it's one of the most common ways a computer automates repetitive tasks. For example, in a simple look, like the one above in magicians , Python initially reads the first line of the loop: 1 for magician in magicians This line tells Python to retrieve the first value from the list magicians and associate it with the variable magician . The first value is 'alice' . Python then reads the next line: 1 print ( magician ) Python prints the current value of magician , which is still 'alice' . Because the list contains more values, Python returns to the first line of the loop: 1 for magician in magicians Python retrieves the next name in the list, 'david' , and associates that value with the variable magician . Python then executes the line: 1 print ( magician ) Python prints the current value of magician again, which is now 'david' . Python repeats the entire loop once more with the last value in the list 'carolina' . Because no more values are in the list, Python moves on to the next line in the program. In this case nothing comes after the for loop, so the program simply ends. When you're using loops for the first time, keep in mind that the set of steps is repeated once for each item in the list, no matter how many items are in the list. If you have a million items in your list, Python repeats these steps a million times -- and usually very quickly. Also keep in mind when writing your own for loops that you can choose any name you want for the temporary variable that will be associated with each value in the list. However, it's helpful to choose a meaningful name that represents a single item from the list. For example, here's a good way to start a for loop for a list of cats, a list of dogs, and a general list of items: 1 2 3 for cat in cats : for dog in dogs : for item in list_of_items : These naming conventions can help you follow the action being done on each item within a for loop. Using a singular and plural names can help you identify whether a section of code is working with a single element from the list or the entire list. Doing More Work Within a for Loop You can do just about anything with each item in a for loop. Let's build on the previous example by printing a message to each magician, telling them that they performed a great trick: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) The only difference in this code is within the for loop, where we compose a message to each magician, starting with their name. The first time through the loop the value of magician is 'alice' , so Python starts the first message with the name 'alice' . The seond time through the message begins with the next index in the list ( 'david' ). The output should look as follows: Alice, that was a great trick! David, that was a great trick! Carolina, that was a great trick! You can also write as many lines of code as you like in the for loop. Every indented line following the line for magician in magicians is considered inside the loop , and each indented line is executed once for each value in the list. Therefore, you can do as much work as you like with each value in the list. Let's add a second line to our message, telling each magician that we're looking forward to their next trick: 1 2 3 4 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) Because both calls for print () are indented, each line will be executed once for every magician in the list. This will have the output: Alice, that was a great trick! I can't wait to see your next trick, Alice. David, that was a great trick! I can't wait to see your next trick, David. Carolina, that was a great trick! I can't wait to see your next trick, Carolina. Doing Something After a for Loop What happens once a for loop has finished executing? Usually, you'll want to summarize a block of output or move on to other work that your program must accomplish. Any lines of code after the for loop that are not indented are executed once without repition. Let's write a thank you to the group of magicians as a whole for putting on an excellent show. To display this group message after all the individual messages have been printed, we place the thank you message after the for loop without indentation: 1 2 3 4 5 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) print ( \"Thank you, everyone. That was a great magic show!\" ) The first two calls to print () are repeated once for each magician in the list, as you saw earlier. However, because the final line is not indented, it's printed only once: Alice, that was a great trick! I can't wait to see your next trick, Alice. David, that was a great trick! I can't wait to see your next trick, David. Carolina, that was a great trick! I can't wait to see your next trick, Carolina. Thank you, everyone. That was a great magic show! When you're processing data using a for loop, you'll find that this is a good way to summarize an operation that was performed on an entire data set. For example, you might use a for loop to initialize a game by running through a list of characters and displaying each character on the screen. You might then write some additional code after this loop tha displays a Play Now button after all the characters have been drawn to the screen. Avoiding Indentation Errors Python uses indentation to determine how a line, or group of lines, is related to the rest of the program. In the previous examples, the lines that printed messages to individual magicians were part of the for loop because they were indented. Python's use of indentation makes code very easy to read. Basically, it uses whitespace to force you to write neatly formatted code indented at a few different levels. These indentation levels help you gain a general sense of the overall program's organization. As you begin to write code that relies on proper indentation, you'll need to watch for a few common indentation errors . For example, people sometimes indent lines of code that don't need to be indented or forget to indent lines that need to be indented. Seeing examples of these errors now will help you avoid them in the future and correct them when they do appear in your own programs. Let's examine some of the more common indentation errors: Forgetting to Indent Always indent the line after the for statement in a loop. If you forget, Python will remind you: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( magician ) The call to print () above should be indented, but it is not. When Python expects an indented block and does not find one, it lets you know which line it had a problem with. The following is what would be output if you ran the code above: File \"<filename>\", line 3 print(magician) ^ IndentationError: expected an indented block You can usually resolve this kind of indentation error by indenting the line or lines immediately after the for statement. Forgetting to Indent Additional Lines Sometimes your loop will run without any errors but won't produce the expected result. This can happen when you're trying to do several tasks in a loop and you forget to indent some of its lines. For example, this is what happens when we forget to indent the seconf line in the loop that tells each magician we're looking forward to their next trick: 1 2 3 4 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) The second call to print should also be indented, but because Python finds at least one indented line after the for statement, it doen't report an error. As a result, the first print () is executed once for each name in the list, but because the second print () call is not indented, it will only run once. Because the final value associated with magician is 'carolina' , she is the only one who recieves the \"looking forward to the next trick message\": Alice, that was a great trick! David, that was a great trick! Carolina, that was a great trick! I can't wait to see your next trick, Carolina. This is a logical error . The syntax is valid Python code, but the code does not produce the desired result because a problem occurs in its logic. If you expect to see a certain action repeated once for each item in a list and it's only executed once, determine whether you need to simply indent a line or group of lines to remedy the problem. Indenting Unnecessarily If you accidentally indent a line that doesn't need to be indented, Python will inform you about the unexpected indent: 1 2 message = \"Hello Python World!\" print ( message ) We do not need the indent before the print () call, because it is not part of a loop. Python will report the following error: 1 2 3 4 File \"<ipython-input-1-2f2b50073239>\" , line 2 print ( message ) ^ IndentationError : unexpected indent You can avoid unexpected indentation errors by indenting only when you have a specific reason to do so. So far, we have only needed to indent when we used a for loop. Forgetting the Colon The colon at the end of a for statement tells Python to interpret the next line as the start of a loop: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians print ( magician ) Notice that we are missing the colon at the end of line 2. This will cause a syntax error in Python because it will not be able to interpret what we are trying to do. The above code will give you the following error: 1 2 3 4 File \"<ipython-input-2-082d5f15acfa>\" , line 2 for magician in magicians ^ SyntaxError : invalid syntax Making Numerical Lists Many reasons exist to store a set of numbers. For example, you'll need to keep track of the positions of each character in a game, and you might want to keep track of a player's high scores as well. In data visualizations, you'll almost always work with sets of numbers, such as termperatures, distances, population sizes, or latitude and logitude values, among other types of numerical sets. Lists are ideal for storing sets of numbers, and Python provides a vairety of tools to help you work effeciently with lists of numbers. Once you understand how to use these tools effectively, your code will work well even when your lists contain millions of items. Using the range () function Python's range () function makes it easy to generate a series of numbers. For example, you can use the range () function to print a series of numbers like this: 1 2 for value in range ( 1 , 5 ): print ( value ) Although this code looks like it should print numbers from 1 to 5, it does not print the number 5: 1 2 3 4 In this example, range () only prints the numbers 1 through 4. This is another result of the off-by-one behavior you'll often see in programming languages. The range () function causes Python to start counting at the first value you give it, and stops when it reaches the second value you provide. Because it stops at the second value, the output never contains the end value, which would have been 5 in this case. To print the numbers 1 to 5, you would use range ( 1 , 6 ) . If your output is different than what you expect when you're using range () , try adjusting your end value by 1. Using range () to Make a List of Numbers If you want to make a list of numbers you can conver the results of range () directly into a list using the list () function. When you wrap list () around a call to the range () function, the output will be a list of numbers. In the example in the previous section, we simply printed out a series of numbers. We can use the list () function to convert that same set of numbers into a list: 1 2 numbers = list ( range ( 1 , 6 )) print ( numbers ) And this is the result: [1, 2, 3, 4, 5] We can also use the range () function to tell Python to skip numbers in a given range. If you pass a third argument to range () , Python uses that value as a step size when generating numbers. For example, here's how to list the even numbers between 1 and 10: 1 2 even_numbers = list ( range ( 2 , 11 , 2 )) print ( even_numbers ) In this example, the range () function starts with the value 2 and then adds 2 to that value, until it reaches index 11 (the number 10). This will produce the following result: [2, 4, 6, 8, 10] You can create almost any set of numbers you want to using the range () function. For example, consider how you might make a list of the first 10 square numbers (that is, the square of each integer from 1 through 10). In Python, two asterisks ( ** ) represent exponents. Here's how you might put the first 10 square numbers into a list: 1 2 3 4 5 squares = [] for value in range ( 1 , 11 ): square = value ** 2 squares . append ( square ) print ( squares ) We start with an empty list called squares . Next, we tell Python to loop through each value from 1 to 10 using the range () function. Inside the loop, the current value is raised to the second power and assigned to the variable square . Finally, when the loop has finished running, the list of squares is printed: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] To write this code even more precisely, omit the temporary variable square and append each new value directly to the list: 1 2 3 4 squares = [] for value in range ( 1 , 11 ): squares . append ( value ** 2 ) print ( squares ) Sometimes using a temporary value makes our code easier to read; other times it makes the code unecessarily long. Simple Statistics with a List of Numbers A few Python functions are helpful when working with lists of numbers. For example, you can easily find the minimum, maximum, and sum of a list of numbers: 1 2 3 4 digits = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ] print ( min ( digits )) print ( max ( digits )) print ( sum ( digits )) The above code will give you the following result: 0 9 45 List Comprehensions The approach described earlier for generating the list squares consisted of using three or four lines of code. A list comprehension combines the for loop and the creating of new elements into one line, and automatically appends each new element. The following example builds the same list of square numbers you saw earlier but uses a list comprehension: 1 2 squares = [ value ** 2 for value in range ( 1 , 11 )] print ( squares ) To use this syntax, begin with a descriptive name for the list, such as squares . Next open a set of square brackets and define the expression for the values you want to store in the new list. In this example, the expression value ** 2 , which raises the value to the second power. Then, write a for loop to generate the numbers you want to feed into the expression, and close the square brackets. The for loop in this example is for value in range ( 1 , 11 ) , which feeds the values 1 through 10 into the expression value ** 2 . Notice that no colon is used at the end of the for statement. The result is the same list of square numbers you saw earlier: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] Extra Problems Use a for loop to print the numbers 1 to 20 1 2 3 4 numbers = list ( range ( 1 , 21 )) for number in numbers : print ( number ) Make a list from one to one million, and then use min () and max () to make sure your list is complete. Also use the sum () function 1 2 3 4 5 numbers = list ( range ( 1 , 1000001 )) print ( min ( numbers )) print ( max ( numbers )) print ( sum ( numbers )) Use the third argument of the range () function to make a list of the odd numbers from 1 to 20. Use a for () loop to print each number 1 2 3 4 odd_numbers = list ( range ( 1 , 21 , 2 )) for numbers in odd_numbers : print ( numbers ) Make a list of the multiples of 3 from 3 to 30. Use a for () loop to print the numbers in your list 1 2 3 4 multiples = list ( range ( 3 , 31 , 3 )) for numbers in multiples : print ( numbers ) Make a list of the first 10 cubes and use a for loop to print out each value of each cube 1 2 3 4 cubes = [] for value in range ( 1 , 11 ): cubes . append ( value ** 3 ) print ( cubes ) Use a list comprehension to generate a list of the first 10 cubes 1 2 cubes = [ value ** 3 for value in range ( 1 , 11 )] print ( cubes ) Working with Part of a List You are able to work with a specific group of items in a list, which Python calls a slice . Slicing a List To make a slice, you specify the index of the first and last elements you want to work with. As with the range () function, Python stops one item before the second index you specify. To output the first three elements in a list, you would request indices 0 through 3, which would return elements 0, 1, and 2. The following example involves a list of players on a team: 1 2 players = [ 'charles' , 'martina' , 'florence' , 'eli' ] print ( players [ 0 : 3 ]) The code on line 2 prints a slice of that list, including just the values at index 0 - 2. If you omit the first index in a slice, Python automaticaly starts your slice at the beginning of the list. Similarly, if you omit the second index, Python will go from the set starting index through the end of the list. You can also include a third value in the slice brackets, telling Python how many items to skip through while going through the specified range. Looping Through a Slice You can use a slice in a for loop if you want to loop through s subset of the elements in a list. In the next example, we loop through the first three players and print their names as part of a simple roster: 1 2 3 4 5 players = [ 'charles' , 'martina' , 'michael' , 'florence' , 'eli' ] print ( \"Here are the first three players on my team:\" ) for player in players [: 3 ]: print ( player . title ()) Instead of looping through the entire list of players, Python loops through only the first three names. Slices are very useful in a number of situations. For instance, when you're building a web application, you could use slices to display information in a series of pages with an appropriate ammount of information on each page. Copying a List Often, you'll want to start with an existing list and make an entirely new list based on the first one. Let's explore how copying a list works and examine one situation in which copying a list is useful. To copy a list, you can make a slice that include the entire original list by omitting the first and the second index ([:]). This tells Python to make a slice that starts at the first item and ends with the last item, producing a copy of the entire list. Let's copy a list using slice: 1 2 3 4 5 6 7 8 my_foods = [ 'pizza' , 'burgers' , 'steak' ] friend_foods = my_foods [:] print ( \"My favorite foods are:\" ) print ( my_foods ) print ( \" \\n My friend's favorite foods are:\" ) print ( friend_foods ) On the first line we created a list of our favorite foods called my_foods . Next, we made a copy of my_foods in a new list called friend_foods . We created the copy by asking for a slice without specifying an index ([:]). When we print each list, we see that they both contain the same foods: My favorite foods are: ['pizza', 'burgers', 'steak'] My friend's favorite foods are: ['pizza', 'burgers', 'steak'] To prove that we actually have two seperate lists, we'll add a new food to each list and show that each list keeps track of the appropriate person's favorite foods: 1 2 3 4 5 6 7 8 9 10 11 my_foods = [ 'pizza' , 'burgers' , 'steak' ] friend_foods = my_foods [:] my_foods . append ( 'canoli' ) friend_foods . append ( 'ice cream' ) print ( \"My favorite foods are:\" ) print ( my_foods ) print ( \" \\n My friend's favorite foods are:\" ) print ( friend_foods ) Now we get the result: My favorite foods are: ['pizza', 'burgers', 'steak', 'canoli'] My friend's favorite foods are: ['pizza', 'burgers', 'steak', 'ice cream'] Tuples Lists work well for storing collections of items that can change throughout the life of a program. The ability to modify lists is particularly important when you're working with a list of users on a website or a list of characters in a game. However, sometimes you'll want to create a list of items that cannot change. Tuples allow you to do just that. Python refers to values that cannot change as immutable , and an immutable list is called a tuple . Defining a Tuple A tuple looks just like a list except you use parentheses instead of square brackets. Once you define a tuple, you can access individual elements by using each item's index, just as you would for a list. For example, if we have a rectangle that should always be a certain size, we can ensure that its size doesn't change by putting the dimensions into a tuple: 1 2 3 dimensions = ( 200 , 50 ) print ( dimensions [ 0 ]) print ( dimensions [ 1 ]) We define a tuple dimensions in line 1, using parentheses instead of square brackets. Next, we print each element in the tuple individually, using the same syntax we've been using to access elements in a list: 200 50 Let's see what happens if we try to change one of the items in the tuples dimensions: 1 2 dimensions = ( 200 , 50 ) dimensions [ 0 ] = 250 Wehn we try to run the above code we get a \"tuple error\": 1 2 3 4 5 6 TypeError Traceback ( most recent call last ) < ipython - input - 13 - 258 c8b06eee2 > in < module > 1 dimensions = ( 200 , 50 ) ----> 2 dimensions [ 0 ] = 250 TypeError : 'tuple' object does not support item assignment Note on Tuples Tuples are technically defined by the presence of a comma; the parenthes make them look neater and more readable. If you want to define a tuple with one element, you need to include a trailing comma: 1 my_t = ( 3 ,) It doesn't often make sense to build a tuple with one element, but this can happen when tuples are generated automatically. Looping Through All Values in a Tuple You can loop over all the values in a tuple using a for loop, just as you did with a list: 1 2 3 dimensions = ( 200 , 50 ) for dimension in dimensions : print ( dimension ) Python will then return all the elements in the tuple, just as it would for a list. Writing over a Tuple Although you cannot modify a tuple, you can assign a new value to a variable that represents a tuple. So if we wanted to change our dimensions, we could redefine an entire tuple: 1 2 3 4 5 6 7 8 9 dimensions = ( 200 , 50 ) print ( \"Original dimensions:\" ) for dimension in dimensions : print ( dimension ) dimensions = ( 400 , 100 ) print ( \" \\n Modified dimensions:\" ) for dimension in dimensions : print ( dimension ) The code at line 1 defines the original tuple and print the initial dimensions. At line 6, we associate a new tuple with the variable dimensions . We then print the new dimensions at line 7. Python does not return any erros this time, because reassigning a variable is valid: Original dimensions: 200 50 Modified dimensions: 400 100 When compared with lists, tuples are simple data structures. Use them when you want to store a set of values that should not be changed throughout the life of a program.","title":"Working with Lists"},{"location":"py-working-with-lists/#working-with-lists","text":"","title":"Working with Lists"},{"location":"py-working-with-lists/#looping-through-an-entire-list","text":"You'll often want to run through all entries in a list, performing the same task with each item. For example, in a game you might want to move every element on the screen by the same amount, or in a list of numbers you might want to perform the same statistical operation on every element. Or perhaps, you'll want to display each headline from a list of articles on a website. When you want to do the sam eaction with every item in a list, you can use Python's for loop. Let's say we have a list of magician's names, and we want to print out each name in the list. We could do this by retrieving each name from the list individually, but this approach could cause several problems. For one, it would be repetitive to do this with a long list of names. Also, we'd have to change our code each time the list's length changed. A for loop avoids both of these issues by letting Python manage these issues internally. Let's use a for loop to print out each name in a list of magicians: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( magician ) We begin by defining the list ( magicians ). Next, we define a for loop. This line tells Python to pull a name from the list magicians , and associate it with the variable magician . Finally, we tell Python to print the name that's been assigned to magician . Python then repeats these steps for each name in the list. Pseudocode for this may look like: For every magician in the list of magicians print the magician's name The output is a simple printout of each name on the list: alice david carolina","title":"Looping Through an Entire List"},{"location":"py-working-with-lists/#a-closer-look-at-looping","text":"The concept of looping is important because it's one of the most common ways a computer automates repetitive tasks. For example, in a simple look, like the one above in magicians , Python initially reads the first line of the loop: 1 for magician in magicians This line tells Python to retrieve the first value from the list magicians and associate it with the variable magician . The first value is 'alice' . Python then reads the next line: 1 print ( magician ) Python prints the current value of magician , which is still 'alice' . Because the list contains more values, Python returns to the first line of the loop: 1 for magician in magicians Python retrieves the next name in the list, 'david' , and associates that value with the variable magician . Python then executes the line: 1 print ( magician ) Python prints the current value of magician again, which is now 'david' . Python repeats the entire loop once more with the last value in the list 'carolina' . Because no more values are in the list, Python moves on to the next line in the program. In this case nothing comes after the for loop, so the program simply ends. When you're using loops for the first time, keep in mind that the set of steps is repeated once for each item in the list, no matter how many items are in the list. If you have a million items in your list, Python repeats these steps a million times -- and usually very quickly. Also keep in mind when writing your own for loops that you can choose any name you want for the temporary variable that will be associated with each value in the list. However, it's helpful to choose a meaningful name that represents a single item from the list. For example, here's a good way to start a for loop for a list of cats, a list of dogs, and a general list of items: 1 2 3 for cat in cats : for dog in dogs : for item in list_of_items : These naming conventions can help you follow the action being done on each item within a for loop. Using a singular and plural names can help you identify whether a section of code is working with a single element from the list or the entire list.","title":"A Closer Look at Looping"},{"location":"py-working-with-lists/#doing-more-work-within-a-for-loop","text":"You can do just about anything with each item in a for loop. Let's build on the previous example by printing a message to each magician, telling them that they performed a great trick: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) The only difference in this code is within the for loop, where we compose a message to each magician, starting with their name. The first time through the loop the value of magician is 'alice' , so Python starts the first message with the name 'alice' . The seond time through the message begins with the next index in the list ( 'david' ). The output should look as follows: Alice, that was a great trick! David, that was a great trick! Carolina, that was a great trick! You can also write as many lines of code as you like in the for loop. Every indented line following the line for magician in magicians is considered inside the loop , and each indented line is executed once for each value in the list. Therefore, you can do as much work as you like with each value in the list. Let's add a second line to our message, telling each magician that we're looking forward to their next trick: 1 2 3 4 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) Because both calls for print () are indented, each line will be executed once for every magician in the list. This will have the output: Alice, that was a great trick! I can't wait to see your next trick, Alice. David, that was a great trick! I can't wait to see your next trick, David. Carolina, that was a great trick! I can't wait to see your next trick, Carolina.","title":"Doing More Work Within a for Loop"},{"location":"py-working-with-lists/#doing-something-after-a-for-loop","text":"What happens once a for loop has finished executing? Usually, you'll want to summarize a block of output or move on to other work that your program must accomplish. Any lines of code after the for loop that are not indented are executed once without repition. Let's write a thank you to the group of magicians as a whole for putting on an excellent show. To display this group message after all the individual messages have been printed, we place the thank you message after the for loop without indentation: 1 2 3 4 5 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) print ( \"Thank you, everyone. That was a great magic show!\" ) The first two calls to print () are repeated once for each magician in the list, as you saw earlier. However, because the final line is not indented, it's printed only once: Alice, that was a great trick! I can't wait to see your next trick, Alice. David, that was a great trick! I can't wait to see your next trick, David. Carolina, that was a great trick! I can't wait to see your next trick, Carolina. Thank you, everyone. That was a great magic show! When you're processing data using a for loop, you'll find that this is a good way to summarize an operation that was performed on an entire data set. For example, you might use a for loop to initialize a game by running through a list of characters and displaying each character on the screen. You might then write some additional code after this loop tha displays a Play Now button after all the characters have been drawn to the screen.","title":"Doing Something After a for Loop"},{"location":"py-working-with-lists/#avoiding-indentation-errors","text":"Python uses indentation to determine how a line, or group of lines, is related to the rest of the program. In the previous examples, the lines that printed messages to individual magicians were part of the for loop because they were indented. Python's use of indentation makes code very easy to read. Basically, it uses whitespace to force you to write neatly formatted code indented at a few different levels. These indentation levels help you gain a general sense of the overall program's organization. As you begin to write code that relies on proper indentation, you'll need to watch for a few common indentation errors . For example, people sometimes indent lines of code that don't need to be indented or forget to indent lines that need to be indented. Seeing examples of these errors now will help you avoid them in the future and correct them when they do appear in your own programs. Let's examine some of the more common indentation errors:","title":"Avoiding Indentation Errors"},{"location":"py-working-with-lists/#forgetting-to-indent","text":"Always indent the line after the for statement in a loop. If you forget, Python will remind you: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( magician ) The call to print () above should be indented, but it is not. When Python expects an indented block and does not find one, it lets you know which line it had a problem with. The following is what would be output if you ran the code above: File \"<filename>\", line 3 print(magician) ^ IndentationError: expected an indented block You can usually resolve this kind of indentation error by indenting the line or lines immediately after the for statement.","title":"Forgetting to Indent"},{"location":"py-working-with-lists/#forgetting-to-indent-additional-lines","text":"Sometimes your loop will run without any errors but won't produce the expected result. This can happen when you're trying to do several tasks in a loop and you forget to indent some of its lines. For example, this is what happens when we forget to indent the seconf line in the loop that tells each magician we're looking forward to their next trick: 1 2 3 4 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians : print ( f \" { magician . title () } , that was a great trick!\" ) print ( f \"I can't wait to see your next trick, { magician . title () } . \\n \" ) The second call to print should also be indented, but because Python finds at least one indented line after the for statement, it doen't report an error. As a result, the first print () is executed once for each name in the list, but because the second print () call is not indented, it will only run once. Because the final value associated with magician is 'carolina' , she is the only one who recieves the \"looking forward to the next trick message\": Alice, that was a great trick! David, that was a great trick! Carolina, that was a great trick! I can't wait to see your next trick, Carolina. This is a logical error . The syntax is valid Python code, but the code does not produce the desired result because a problem occurs in its logic. If you expect to see a certain action repeated once for each item in a list and it's only executed once, determine whether you need to simply indent a line or group of lines to remedy the problem.","title":"Forgetting to Indent Additional Lines"},{"location":"py-working-with-lists/#indenting-unnecessarily","text":"If you accidentally indent a line that doesn't need to be indented, Python will inform you about the unexpected indent: 1 2 message = \"Hello Python World!\" print ( message ) We do not need the indent before the print () call, because it is not part of a loop. Python will report the following error: 1 2 3 4 File \"<ipython-input-1-2f2b50073239>\" , line 2 print ( message ) ^ IndentationError : unexpected indent You can avoid unexpected indentation errors by indenting only when you have a specific reason to do so. So far, we have only needed to indent when we used a for loop.","title":"Indenting Unnecessarily"},{"location":"py-working-with-lists/#forgetting-the-colon","text":"The colon at the end of a for statement tells Python to interpret the next line as the start of a loop: 1 2 3 magicians = [ 'alice' , 'david' , 'carolina' ] for magician in magicians print ( magician ) Notice that we are missing the colon at the end of line 2. This will cause a syntax error in Python because it will not be able to interpret what we are trying to do. The above code will give you the following error: 1 2 3 4 File \"<ipython-input-2-082d5f15acfa>\" , line 2 for magician in magicians ^ SyntaxError : invalid syntax","title":"Forgetting the Colon"},{"location":"py-working-with-lists/#making-numerical-lists","text":"Many reasons exist to store a set of numbers. For example, you'll need to keep track of the positions of each character in a game, and you might want to keep track of a player's high scores as well. In data visualizations, you'll almost always work with sets of numbers, such as termperatures, distances, population sizes, or latitude and logitude values, among other types of numerical sets. Lists are ideal for storing sets of numbers, and Python provides a vairety of tools to help you work effeciently with lists of numbers. Once you understand how to use these tools effectively, your code will work well even when your lists contain millions of items.","title":"Making Numerical Lists"},{"location":"py-working-with-lists/#using-the-range-function","text":"Python's range () function makes it easy to generate a series of numbers. For example, you can use the range () function to print a series of numbers like this: 1 2 for value in range ( 1 , 5 ): print ( value ) Although this code looks like it should print numbers from 1 to 5, it does not print the number 5: 1 2 3 4 In this example, range () only prints the numbers 1 through 4. This is another result of the off-by-one behavior you'll often see in programming languages. The range () function causes Python to start counting at the first value you give it, and stops when it reaches the second value you provide. Because it stops at the second value, the output never contains the end value, which would have been 5 in this case. To print the numbers 1 to 5, you would use range ( 1 , 6 ) . If your output is different than what you expect when you're using range () , try adjusting your end value by 1.","title":"Using the range() function"},{"location":"py-working-with-lists/#using-range-to-make-a-list-of-numbers","text":"If you want to make a list of numbers you can conver the results of range () directly into a list using the list () function. When you wrap list () around a call to the range () function, the output will be a list of numbers. In the example in the previous section, we simply printed out a series of numbers. We can use the list () function to convert that same set of numbers into a list: 1 2 numbers = list ( range ( 1 , 6 )) print ( numbers ) And this is the result: [1, 2, 3, 4, 5] We can also use the range () function to tell Python to skip numbers in a given range. If you pass a third argument to range () , Python uses that value as a step size when generating numbers. For example, here's how to list the even numbers between 1 and 10: 1 2 even_numbers = list ( range ( 2 , 11 , 2 )) print ( even_numbers ) In this example, the range () function starts with the value 2 and then adds 2 to that value, until it reaches index 11 (the number 10). This will produce the following result: [2, 4, 6, 8, 10] You can create almost any set of numbers you want to using the range () function. For example, consider how you might make a list of the first 10 square numbers (that is, the square of each integer from 1 through 10). In Python, two asterisks ( ** ) represent exponents. Here's how you might put the first 10 square numbers into a list: 1 2 3 4 5 squares = [] for value in range ( 1 , 11 ): square = value ** 2 squares . append ( square ) print ( squares ) We start with an empty list called squares . Next, we tell Python to loop through each value from 1 to 10 using the range () function. Inside the loop, the current value is raised to the second power and assigned to the variable square . Finally, when the loop has finished running, the list of squares is printed: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] To write this code even more precisely, omit the temporary variable square and append each new value directly to the list: 1 2 3 4 squares = [] for value in range ( 1 , 11 ): squares . append ( value ** 2 ) print ( squares ) Sometimes using a temporary value makes our code easier to read; other times it makes the code unecessarily long.","title":"Using range() to Make a List of Numbers"},{"location":"py-working-with-lists/#simple-statistics-with-a-list-of-numbers","text":"A few Python functions are helpful when working with lists of numbers. For example, you can easily find the minimum, maximum, and sum of a list of numbers: 1 2 3 4 digits = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 ] print ( min ( digits )) print ( max ( digits )) print ( sum ( digits )) The above code will give you the following result: 0 9 45","title":"Simple Statistics with a List of Numbers"},{"location":"py-working-with-lists/#list-comprehensions","text":"The approach described earlier for generating the list squares consisted of using three or four lines of code. A list comprehension combines the for loop and the creating of new elements into one line, and automatically appends each new element. The following example builds the same list of square numbers you saw earlier but uses a list comprehension: 1 2 squares = [ value ** 2 for value in range ( 1 , 11 )] print ( squares ) To use this syntax, begin with a descriptive name for the list, such as squares . Next open a set of square brackets and define the expression for the values you want to store in the new list. In this example, the expression value ** 2 , which raises the value to the second power. Then, write a for loop to generate the numbers you want to feed into the expression, and close the square brackets. The for loop in this example is for value in range ( 1 , 11 ) , which feeds the values 1 through 10 into the expression value ** 2 . Notice that no colon is used at the end of the for statement. The result is the same list of square numbers you saw earlier: [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]","title":"List Comprehensions"},{"location":"py-working-with-lists/#extra-problems","text":"Use a for loop to print the numbers 1 to 20 1 2 3 4 numbers = list ( range ( 1 , 21 )) for number in numbers : print ( number ) Make a list from one to one million, and then use min () and max () to make sure your list is complete. Also use the sum () function 1 2 3 4 5 numbers = list ( range ( 1 , 1000001 )) print ( min ( numbers )) print ( max ( numbers )) print ( sum ( numbers )) Use the third argument of the range () function to make a list of the odd numbers from 1 to 20. Use a for () loop to print each number 1 2 3 4 odd_numbers = list ( range ( 1 , 21 , 2 )) for numbers in odd_numbers : print ( numbers ) Make a list of the multiples of 3 from 3 to 30. Use a for () loop to print the numbers in your list 1 2 3 4 multiples = list ( range ( 3 , 31 , 3 )) for numbers in multiples : print ( numbers ) Make a list of the first 10 cubes and use a for loop to print out each value of each cube 1 2 3 4 cubes = [] for value in range ( 1 , 11 ): cubes . append ( value ** 3 ) print ( cubes ) Use a list comprehension to generate a list of the first 10 cubes 1 2 cubes = [ value ** 3 for value in range ( 1 , 11 )] print ( cubes )","title":"Extra Problems"},{"location":"py-working-with-lists/#working-with-part-of-a-list","text":"You are able to work with a specific group of items in a list, which Python calls a slice .","title":"Working with Part of a List"},{"location":"py-working-with-lists/#slicing-a-list","text":"To make a slice, you specify the index of the first and last elements you want to work with. As with the range () function, Python stops one item before the second index you specify. To output the first three elements in a list, you would request indices 0 through 3, which would return elements 0, 1, and 2. The following example involves a list of players on a team: 1 2 players = [ 'charles' , 'martina' , 'florence' , 'eli' ] print ( players [ 0 : 3 ]) The code on line 2 prints a slice of that list, including just the values at index 0 - 2. If you omit the first index in a slice, Python automaticaly starts your slice at the beginning of the list. Similarly, if you omit the second index, Python will go from the set starting index through the end of the list. You can also include a third value in the slice brackets, telling Python how many items to skip through while going through the specified range.","title":"Slicing a List"},{"location":"py-working-with-lists/#looping-through-a-slice","text":"You can use a slice in a for loop if you want to loop through s subset of the elements in a list. In the next example, we loop through the first three players and print their names as part of a simple roster: 1 2 3 4 5 players = [ 'charles' , 'martina' , 'michael' , 'florence' , 'eli' ] print ( \"Here are the first three players on my team:\" ) for player in players [: 3 ]: print ( player . title ()) Instead of looping through the entire list of players, Python loops through only the first three names. Slices are very useful in a number of situations. For instance, when you're building a web application, you could use slices to display information in a series of pages with an appropriate ammount of information on each page.","title":"Looping Through a Slice"},{"location":"py-working-with-lists/#copying-a-list","text":"Often, you'll want to start with an existing list and make an entirely new list based on the first one. Let's explore how copying a list works and examine one situation in which copying a list is useful. To copy a list, you can make a slice that include the entire original list by omitting the first and the second index ([:]). This tells Python to make a slice that starts at the first item and ends with the last item, producing a copy of the entire list. Let's copy a list using slice: 1 2 3 4 5 6 7 8 my_foods = [ 'pizza' , 'burgers' , 'steak' ] friend_foods = my_foods [:] print ( \"My favorite foods are:\" ) print ( my_foods ) print ( \" \\n My friend's favorite foods are:\" ) print ( friend_foods ) On the first line we created a list of our favorite foods called my_foods . Next, we made a copy of my_foods in a new list called friend_foods . We created the copy by asking for a slice without specifying an index ([:]). When we print each list, we see that they both contain the same foods: My favorite foods are: ['pizza', 'burgers', 'steak'] My friend's favorite foods are: ['pizza', 'burgers', 'steak'] To prove that we actually have two seperate lists, we'll add a new food to each list and show that each list keeps track of the appropriate person's favorite foods: 1 2 3 4 5 6 7 8 9 10 11 my_foods = [ 'pizza' , 'burgers' , 'steak' ] friend_foods = my_foods [:] my_foods . append ( 'canoli' ) friend_foods . append ( 'ice cream' ) print ( \"My favorite foods are:\" ) print ( my_foods ) print ( \" \\n My friend's favorite foods are:\" ) print ( friend_foods ) Now we get the result: My favorite foods are: ['pizza', 'burgers', 'steak', 'canoli'] My friend's favorite foods are: ['pizza', 'burgers', 'steak', 'ice cream']","title":"Copying a List"},{"location":"py-working-with-lists/#tuples","text":"Lists work well for storing collections of items that can change throughout the life of a program. The ability to modify lists is particularly important when you're working with a list of users on a website or a list of characters in a game. However, sometimes you'll want to create a list of items that cannot change. Tuples allow you to do just that. Python refers to values that cannot change as immutable , and an immutable list is called a tuple .","title":"Tuples"},{"location":"py-working-with-lists/#defining-a-tuple","text":"A tuple looks just like a list except you use parentheses instead of square brackets. Once you define a tuple, you can access individual elements by using each item's index, just as you would for a list. For example, if we have a rectangle that should always be a certain size, we can ensure that its size doesn't change by putting the dimensions into a tuple: 1 2 3 dimensions = ( 200 , 50 ) print ( dimensions [ 0 ]) print ( dimensions [ 1 ]) We define a tuple dimensions in line 1, using parentheses instead of square brackets. Next, we print each element in the tuple individually, using the same syntax we've been using to access elements in a list: 200 50 Let's see what happens if we try to change one of the items in the tuples dimensions: 1 2 dimensions = ( 200 , 50 ) dimensions [ 0 ] = 250 Wehn we try to run the above code we get a \"tuple error\": 1 2 3 4 5 6 TypeError Traceback ( most recent call last ) < ipython - input - 13 - 258 c8b06eee2 > in < module > 1 dimensions = ( 200 , 50 ) ----> 2 dimensions [ 0 ] = 250 TypeError : 'tuple' object does not support item assignment Note on Tuples Tuples are technically defined by the presence of a comma; the parenthes make them look neater and more readable. If you want to define a tuple with one element, you need to include a trailing comma: 1 my_t = ( 3 ,) It doesn't often make sense to build a tuple with one element, but this can happen when tuples are generated automatically.","title":"Defining a Tuple"},{"location":"py-working-with-lists/#looping-through-all-values-in-a-tuple","text":"You can loop over all the values in a tuple using a for loop, just as you did with a list: 1 2 3 dimensions = ( 200 , 50 ) for dimension in dimensions : print ( dimension ) Python will then return all the elements in the tuple, just as it would for a list.","title":"Looping Through All Values in a Tuple"},{"location":"py-working-with-lists/#writing-over-a-tuple","text":"Although you cannot modify a tuple, you can assign a new value to a variable that represents a tuple. So if we wanted to change our dimensions, we could redefine an entire tuple: 1 2 3 4 5 6 7 8 9 dimensions = ( 200 , 50 ) print ( \"Original dimensions:\" ) for dimension in dimensions : print ( dimension ) dimensions = ( 400 , 100 ) print ( \" \\n Modified dimensions:\" ) for dimension in dimensions : print ( dimension ) The code at line 1 defines the original tuple and print the initial dimensions. At line 6, we associate a new tuple with the variable dimensions . We then print the new dimensions at line 7. Python does not return any erros this time, because reassigning a variable is valid: Original dimensions: 200 50 Modified dimensions: 400 100 When compared with lists, tuples are simple data structures. Use them when you want to store a set of values that should not be changed throughout the life of a program.","title":"Writing over a Tuple"},{"location":"py/","text":"Python Basics Quick Links Python Documentation Python Beginner's Help (PDF) Python Cheat Sheet Learning Python - 5 th Edition (2014) (PDF) Python Crash Course - 2 nd Edition (2019) (PDF) Python Crash Course - Basics Introduction Python is a powerful multiparadigm computer programming language, optimized for programmer productivity, code readability, and software quality. Python is a popular open source programming language used for both standalone programs and scripting applications in a wide variety of domains Python is an excellent and versatile language choice for making complex C operations much simpler: String manipulation Networking Python Syntax To start writing Python, open up a file with the .py file extension. Unlike a C program, which typically has to be compiled before you run it, a Python program can be run without explicitly compiling it first. Variables Python variables have three big differences from C: No type specifier Declared by initialization only Python statements do not need to be ended with semicolons Conditionals All of the old favorites from C are still available for you to use: elif - else if True / False (bool) input() - collects user input Loops Two varieties: while and for 1 2 3 4 counter = 0 while counter < 100 : print ( counter ) counter += 1 1 2 for x in range ( 100 ): print ( x ) Arrays Lists Here is where things really start to get a lot better than C. Python arrays (more appropriately known as lists ) are not fixed in size; they can grow or shrink as needed, and you can always tack extra elements onto your array and splce things in and out easily. 1 nums = [ 1 , 2 , 3 , 4 ] Instead of square bracket syntax, you can also simply use a function to create a list: 1 nums = list () Tuples Tuples are ordered, immutable sets of data; they are great for associating collections of data, sort of like a struct in C, but where those values are unlikely to change. Here is a list of tuples: 1 2 3 4 5 6 presidents = [ ( \"George Washington\" , 1789 ), ( \"John Adams\" , 1797 ), ( \"Thomas Jefferson\" , 1801 ), ( \"James Madison\" , 1809 ) ] This list is iterable as well: 1 2 for prez , year in presidents : print ( \"In {1} , {0} took office\" . format ( prez , year )) Dictionaries Python also has built in support for dictionaries, allowing you to specifiy list indices with words or phrases (keys). 1 2 3 4 5 6 pizzas = { \"cheese\" : 9 , \"pepperoni\" : 10 , \"vegetable\" : 11 , \"buffalo chicken\" : 12 } Functions Python has support fr functions as well. Like variables, we don't need to specifiy the return type of the function (because it doesn't matter), nor the data types of any parameters. All functions are introduced with the def keyword. 1 2 3 4 5 def square ( x ): result = 0 for i in range ( 0 , x ): result += x return result Objects Python is an object-oriented programming language. Objects have properties and methods , or functions that are inherent to the object, and mean nothing outside of it. You must also define methods inside the object. 1 object . method () You define a type of object using the class keyword in Python. Classes require an initialization function, also more-generally known as a constructor , which sets the starting values of the properties of the object. In defining each method of an object, self should be its first parameter, which stipulates on what object the method is called. 1 2 3 4 5 6 7 8 9 10 11 class Student (): def __init__ ( self , name , id ): self . name = name self . id = id def changeID ( self , id ): self . id = id def print ( self ): print ( \" {} - {} \" . format ( self . name , self . id )) Style If you haven't noticed by now, good style is crucial in Python. Tabs and indentation actually matter in this language, and things will not work the way you intend for them to if you disregard styling! First Program 1 print ( \"Hello Python World!\" ) If you compare this to C's first code , you will notice that we no longer need to create a main function or import the <stdio.h> library. Troubleshooting in Python When a program contains a significant error, Python displays a trace-back , which is an error report. Python looks through the file and tries to identify the problem. Check the traceback; it might give you a clue as to what the issue is preventing the program from running. Remember how important syntax is in Python, and every other programming language, and review your code.","title":"Python Basics"},{"location":"py/#python-basics","text":"","title":"Python Basics"},{"location":"py/#quick-links","text":"Python Documentation Python Beginner's Help (PDF) Python Cheat Sheet Learning Python - 5 th Edition (2014) (PDF) Python Crash Course - 2 nd Edition (2019) (PDF) Python Crash Course - Basics","title":"Quick Links"},{"location":"py/#introduction","text":"Python is a powerful multiparadigm computer programming language, optimized for programmer productivity, code readability, and software quality. Python is a popular open source programming language used for both standalone programs and scripting applications in a wide variety of domains Python is an excellent and versatile language choice for making complex C operations much simpler: String manipulation Networking","title":"Introduction"},{"location":"py/#python-syntax","text":"To start writing Python, open up a file with the .py file extension. Unlike a C program, which typically has to be compiled before you run it, a Python program can be run without explicitly compiling it first.","title":"Python Syntax"},{"location":"py/#variables","text":"Python variables have three big differences from C: No type specifier Declared by initialization only Python statements do not need to be ended with semicolons","title":"Variables"},{"location":"py/#conditionals","text":"All of the old favorites from C are still available for you to use: elif - else if True / False (bool) input() - collects user input Loops Two varieties: while and for 1 2 3 4 counter = 0 while counter < 100 : print ( counter ) counter += 1 1 2 for x in range ( 100 ): print ( x )","title":"Conditionals"},{"location":"py/#arrays-lists","text":"Here is where things really start to get a lot better than C. Python arrays (more appropriately known as lists ) are not fixed in size; they can grow or shrink as needed, and you can always tack extra elements onto your array and splce things in and out easily. 1 nums = [ 1 , 2 , 3 , 4 ] Instead of square bracket syntax, you can also simply use a function to create a list: 1 nums = list ()","title":"Arrays Lists"},{"location":"py/#tuples","text":"Tuples are ordered, immutable sets of data; they are great for associating collections of data, sort of like a struct in C, but where those values are unlikely to change. Here is a list of tuples: 1 2 3 4 5 6 presidents = [ ( \"George Washington\" , 1789 ), ( \"John Adams\" , 1797 ), ( \"Thomas Jefferson\" , 1801 ), ( \"James Madison\" , 1809 ) ] This list is iterable as well: 1 2 for prez , year in presidents : print ( \"In {1} , {0} took office\" . format ( prez , year ))","title":"Tuples"},{"location":"py/#dictionaries","text":"Python also has built in support for dictionaries, allowing you to specifiy list indices with words or phrases (keys). 1 2 3 4 5 6 pizzas = { \"cheese\" : 9 , \"pepperoni\" : 10 , \"vegetable\" : 11 , \"buffalo chicken\" : 12 }","title":"Dictionaries"},{"location":"py/#functions","text":"Python has support fr functions as well. Like variables, we don't need to specifiy the return type of the function (because it doesn't matter), nor the data types of any parameters. All functions are introduced with the def keyword. 1 2 3 4 5 def square ( x ): result = 0 for i in range ( 0 , x ): result += x return result","title":"Functions"},{"location":"py/#objects","text":"Python is an object-oriented programming language. Objects have properties and methods , or functions that are inherent to the object, and mean nothing outside of it. You must also define methods inside the object. 1 object . method () You define a type of object using the class keyword in Python. Classes require an initialization function, also more-generally known as a constructor , which sets the starting values of the properties of the object. In defining each method of an object, self should be its first parameter, which stipulates on what object the method is called. 1 2 3 4 5 6 7 8 9 10 11 class Student (): def __init__ ( self , name , id ): self . name = name self . id = id def changeID ( self , id ): self . id = id def print ( self ): print ( \" {} - {} \" . format ( self . name , self . id ))","title":"Objects"},{"location":"py/#style","text":"If you haven't noticed by now, good style is crucial in Python. Tabs and indentation actually matter in this language, and things will not work the way you intend for them to if you disregard styling!","title":"Style"},{"location":"py/#first-program","text":"1 print ( \"Hello Python World!\" ) If you compare this to C's first code , you will notice that we no longer need to create a main function or import the <stdio.h> library.","title":"First Program"},{"location":"py/#troubleshooting-in-python","text":"When a program contains a significant error, Python displays a trace-back , which is an error report. Python looks through the file and tries to identify the problem. Check the traceback; it might give you a clue as to what the issue is preventing the program from running. Remember how important syntax is in Python, and every other programming language, and review your code.","title":"Troubleshooting in Python"},{"location":"rest-soap/","text":"REST vs. SOAP Web Services REST Explained Re presentational S tate T ransfer (REST) is an architectural style that dictates standards for communication between computer systems on the web. When a developer is looking for simplicity, broad language support, better resource management, and statelessness, they go for REST. REST enables users to perform tasks utilizing an HTTP GET, POST, PUT, or DELETE request. REST-based web services can also return data in Command Seperated Value (CSV), JavaScript Object Notation (JSON), and Really Simple Syndication (RSS) data formats. Tip When APIs embrace the styles and constraints of REST, they are said to be RESTful. REST has guiding architectural constraints for an API to be considered RESTful: Client-Server Architecture Statelessness Layered System Cacheability Uniform Design Code on Demand SOAP Explained The S imple O bject A ccess P rotocol (SOAP) is an industrial-grade API solution that works well within most environments. Unlike REST, which is strictly an architectural style, SOAP is an actual protocol. This gives SOAP much greater control over what an API does, from deciding the transport method, enhanced security, etc. SOAP has many benefits including: Extensible Markup Language (XML) control over API (Comes at the cost of increased bandwidth). Transport control (HTTP/TCP/UDP/SMTP). Rigid interaction specifications. Built-in error handling. Quick Comparisons REST SOAP Stateless Stateful Architectural style Web protocol Less bandwidth needed for requests More bandwidth needed due to XML Can make use of SOAP Cannot make use of REST Wide use of data formats (HTML, XML, JSON, etc.) Only works with the XML format Requires use of HTTP Can utilize HTTP, TCP, UDP, and SMTP When to use REST vs. SOAP Deciding whether to use REST or SOAP should come down to determining what your end goal is and who will be using the API. REST and JSON have recently become the go-to for web developers because it consumes less bandwidth, has increased flexibility, and offers easier integration with applications. SOAP definitely still has its uses, specifically for APIs that need asynchronous and stateful operations, such as the financial industry. Answering the following questions can also help determine which web service to use: Who will be consuming the API data? How often will the API change? What types of applications/integrations will the API interact with? What programming language is the API written in?","title":"REST vs. SOAP Web Services"},{"location":"rest-soap/#rest-vs-soap-web-services","text":"","title":"REST vs. SOAP Web Services"},{"location":"rest-soap/#rest-explained","text":"Re presentational S tate T ransfer (REST) is an architectural style that dictates standards for communication between computer systems on the web. When a developer is looking for simplicity, broad language support, better resource management, and statelessness, they go for REST. REST enables users to perform tasks utilizing an HTTP GET, POST, PUT, or DELETE request. REST-based web services can also return data in Command Seperated Value (CSV), JavaScript Object Notation (JSON), and Really Simple Syndication (RSS) data formats. Tip When APIs embrace the styles and constraints of REST, they are said to be RESTful. REST has guiding architectural constraints for an API to be considered RESTful: Client-Server Architecture Statelessness Layered System Cacheability Uniform Design Code on Demand","title":"REST Explained"},{"location":"rest-soap/#soap-explained","text":"The S imple O bject A ccess P rotocol (SOAP) is an industrial-grade API solution that works well within most environments. Unlike REST, which is strictly an architectural style, SOAP is an actual protocol. This gives SOAP much greater control over what an API does, from deciding the transport method, enhanced security, etc. SOAP has many benefits including: Extensible Markup Language (XML) control over API (Comes at the cost of increased bandwidth). Transport control (HTTP/TCP/UDP/SMTP). Rigid interaction specifications. Built-in error handling.","title":"SOAP Explained"},{"location":"rest-soap/#quick-comparisons","text":"REST SOAP Stateless Stateful Architectural style Web protocol Less bandwidth needed for requests More bandwidth needed due to XML Can make use of SOAP Cannot make use of REST Wide use of data formats (HTML, XML, JSON, etc.) Only works with the XML format Requires use of HTTP Can utilize HTTP, TCP, UDP, and SMTP","title":"Quick Comparisons"},{"location":"rest-soap/#when-to-use-rest-vs-soap","text":"Deciding whether to use REST or SOAP should come down to determining what your end goal is and who will be using the API. REST and JSON have recently become the go-to for web developers because it consumes less bandwidth, has increased flexibility, and offers easier integration with applications. SOAP definitely still has its uses, specifically for APIs that need asynchronous and stateful operations, such as the financial industry. Answering the following questions can also help determine which web service to use: Who will be consuming the API data? How often will the API change? What types of applications/integrations will the API interact with? What programming language is the API written in?","title":"When to use REST vs. SOAP"},{"location":"sql-joins-and-other-queries/","text":"SQL Joins and Other Query Types Multi-Table queries with JOIN s Up to now, we've been working with a single table, but entity data in the real world is often broken down into pieces and stored across multiple orthogonal tables using a process known as normalization . Database Normalization Tables that share information about a single entity need to have a primary key that identifies that entity uniquely across the database. One common primary key type is an auto-incrementing integer (because they are space efficient), but it can also be a string, hashed value, so long as it is unique. Using the JOIN clause in a query, we can combine row data across two separate tables using this unique key. The first of the joins that we will introduce is the INNER JOIN . SELECT column , another_table_column , ... FROM mytable INNER JOIN another_table ON mytable . id = another_table . id WHERE condition ( s ) ORDER BY column , ... ASC / DESC LIMIT num_limit OFFSET num_offset ; The INNER JOIN is a process that matches rows from the first table and the second table which have the same key (as defined by the ON constraint) to create a result row with the combined columns from both tables. After the tables are joined, the other clauses we learned previously are then applied. JOIN vs. INNER JOIN You may see queries where the INNER JOIN is written simply as a JOIN . These two are equivalent, but we will continue to refer to these joins as inner-joins because they make the query easier to read once you start using other types of joins. Let's do some exercises where we look at multiple tables. We will use the Movies.csv file from previous examples and a new Boxoffice.csv file with additional movie information. Find the domestic and international sales for each movie: SELECT title , domestic_sales , international_sales FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; Show the sales numbers for each movie that did better internationally rather than domestically: SELECT title , domestic_sales , international_sales FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id WHERE international_sales > domestic_sales ; List all the movies by their ratings in descending order: SELECT title , rating FROM movies JOIN boxoffice on movies . id = boxoffice . movie_id ORDER BY rating DESC ; Outer Joins Depending on how you want to analyze the data, the INNER JOIN might not be sufficient because the resulting table only contains data that belongs in both of the tables. If the two tables have asymmetric data, which can easily happen when data is entered in different stages, then we would have to use a LEFT JOIN , RIGHT JOIN , or FULL JOIN instead to ensure that the data you need is not left out of the results. SELECT column , another_column , ... FROM mytable INNER / LEFT / RIGHT / FULL JOIN another_table ON mytable . id = another_table . matching_id WHERE condition ( s ) ORDER BY column , ... ASC / DESC LIMIT num_limit OFFSET num_offset ; Like the INNER JOIN these three new joins have to specify which column to join the data on. When joining table A to table B, a LEFT JOIN simply includes rows from A regardless of whether a matching row is found in B. the RIGHT JOIN is the same, but reversed, keeping rows in B regardless of whether a match is found in A. Finally, a FULL JOIN simply means that rows from both tables are kept, regardless of whether a matching row exists in the other table. When using any of these new joins, you will likely have to write additional logic to deal with NULL s in the result and constraints. JOINS You might see queries with these joins written as LEFT OUTER JOIN , RIGHT OUTER JOIN , or FULL OUTER JOIN , but the OUTER keyword is really kept for SQL-92 compatibility and these queries are simply equivalent to LEFT JOIN , RIGHT JOIN , and FULL JOIN respectively. For the following exercises we will be using new tables. We will use a table which stores fictional data about Employees in the film studio and their assigned office Buildings . Some of the buildings are new, so they don't have any employees in them yet, but we need to find some information about them regardless. Find the list of all buildings that have employees: SELECT DISTINCT building FROM employees ; Find the list of all buildings and their capacity: SELECT building_name , capacity FROM buildings ; List all buildings and the distinct employee roles in each building (including empty buildings): SELECT DISTINCT building_name , role FROM buildings LEFT JOIN employees on building_name = building ; A short note on NULL s It's always good to reduce the possibility of NULL values in databases because they require special attention when constructing queries, constraints (certain functions behave differently with null values) and when processing the results. An alternative to NULL values in your database is to have data-type appropriate default values , like 0 for numerical data, empty strings for text data, etc. But if your database needs to store incomplete data, then NULL values can be appropriate if the default values will skew later analysics (for example, when taking averages of numerical data). Sometimes, it's also not possible to avoid NULL values, as we saw in the last lesson when outer-joining two tables with asymmetric data. In these cases, you can test a column for NULL values in a WHERE clause by using either the IS NULL or IS NOT NULL constraint. SELECT column , another_column , ... FROM mytable WHERE column IS / IS NOT NULL AND / OR another_condition AND / OR ...; For the following exercises, we will be using the same Employees and Buildings tables from the last exercises. Find the name and role of all employees who have not been assigned to a building: SELECT name , role FROM employees WHERE building IS NULL ; Find the names of the buildings that hold no employees: SELECT DISTINCT building_name FROM buildings LEFT JOIN employees ON building_name = building WHERE role IS NULL ; Queries with Expressions In addition to querying and referencing raw column data with SQL, you can also use expressions to write more complex logic on column calues in a query. These expressions can use mathematical and string functions along with basic arithmetic to transform values when the query is executed, as shown in this physics example: SELECT particle_speed / 2 . 0 AS half_particle_speed FROM physics_data WHERE ABS ( particle_position ) * 10 . 0 > 500 ; Each database has its own supported set of mathematical, string, and date functions that can be used in a query, which you can find in their own respective docs. The use of expressions can save time and extra post-processing of the result data, but can also make the query harder to read, so we recommend that when expressions are used in the SELECT part of the query, that they are also given a descriptive alias using the AS keyword. SELECT col_expression AS expr_description , ... FROM mytable ; In addition to expressions, regular columns and even tables can also have aliases to make them easier to reference in the output and as a part of simplifying more complex queries. SELECT column AS better_column_name , ... FROM a_long_widgets_table_name AS mywidgets INNER JOIN widget_sales ON mywidgets . id = widgets_sales . widget_id ; We are now going to use expressions to transform the BoxOffice data into something easier to understand for the tasks below. We will use the Movies.csv and Boxoffice.csv files for the following exercise: List all movies and their combines sales in millions of dollars: SELECT title , ( domestic_sales + international_sales ) / 1000000 AS gross_sales_millions FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; List all movies and their ratings in percent: SELECT title , rating * 10 AS rating_percent FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; List all movies that we released on even number years SELECT title , year FROM movies WHERE year % 2 = 0 ; Odd Vs. Even Remember that to determine if a SQL value is even or odd, we use the module operator ( % ), which returns the remainder after division of its operands. Since the remainder of an even number divided by 2 is always 0, and the remainder of an odd number divided by 2 is always 1 - this makes modulo an easy way to find even/odd numbers. Queries with Aggregates In addition to the simple expressions from above, SQL also supports the use of aggregate expressions (or functions) that allow you to summarize information about a group of rows of data. With the Pixar database we have been using, aggregate functions can be used to answer questions like, \"How many movies has Pixar produced?\", or \"What is the highest grossing Pixar film each year?\". SELECT AGG_FUNC ( column_or_expression ) AS aggregate_description , ... FROM mytable WHERE constraint_expression ; Without a specified grouping, each aggregate function is going to run on the whole set of result rows and return a single value. And like normal expressionsm giving your aggregate functions an alias ensures that the results will be easier to read and process. Common Aggregate Functions Below are some common aggregate functions that we will be using in fututre exercises: Function Description COUNT(*) COUNT (column) A common function used to count the number of rows in the group is no column name is specified. Otherwise, count the number of rows in the group with non-NULL values in the specified column. MIN (column) Finds the smallest numerical value in the specified column for all rows in the group. MAX (column) Finds the largest numerical value in the specified column for all rows in the group. AVG (column) Finds the average numerical value in the specified column for all rows in the group. SUM (column) Finds the sum of all numerical values in the specified column for the rows in the group. Docs: MySQL , Postgres , SQLite","title":"Joins and Other Query Types"},{"location":"sql-joins-and-other-queries/#sql-joins-and-other-query-types","text":"","title":"SQL Joins and Other Query Types"},{"location":"sql-joins-and-other-queries/#multi-table-queries-with-joins","text":"Up to now, we've been working with a single table, but entity data in the real world is often broken down into pieces and stored across multiple orthogonal tables using a process known as normalization .","title":"Multi-Table queries with JOINs"},{"location":"sql-joins-and-other-queries/#database-normalization","text":"Tables that share information about a single entity need to have a primary key that identifies that entity uniquely across the database. One common primary key type is an auto-incrementing integer (because they are space efficient), but it can also be a string, hashed value, so long as it is unique. Using the JOIN clause in a query, we can combine row data across two separate tables using this unique key. The first of the joins that we will introduce is the INNER JOIN . SELECT column , another_table_column , ... FROM mytable INNER JOIN another_table ON mytable . id = another_table . id WHERE condition ( s ) ORDER BY column , ... ASC / DESC LIMIT num_limit OFFSET num_offset ; The INNER JOIN is a process that matches rows from the first table and the second table which have the same key (as defined by the ON constraint) to create a result row with the combined columns from both tables. After the tables are joined, the other clauses we learned previously are then applied. JOIN vs. INNER JOIN You may see queries where the INNER JOIN is written simply as a JOIN . These two are equivalent, but we will continue to refer to these joins as inner-joins because they make the query easier to read once you start using other types of joins. Let's do some exercises where we look at multiple tables. We will use the Movies.csv file from previous examples and a new Boxoffice.csv file with additional movie information. Find the domestic and international sales for each movie: SELECT title , domestic_sales , international_sales FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; Show the sales numbers for each movie that did better internationally rather than domestically: SELECT title , domestic_sales , international_sales FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id WHERE international_sales > domestic_sales ; List all the movies by their ratings in descending order: SELECT title , rating FROM movies JOIN boxoffice on movies . id = boxoffice . movie_id ORDER BY rating DESC ;","title":"Database Normalization"},{"location":"sql-joins-and-other-queries/#outer-joins","text":"Depending on how you want to analyze the data, the INNER JOIN might not be sufficient because the resulting table only contains data that belongs in both of the tables. If the two tables have asymmetric data, which can easily happen when data is entered in different stages, then we would have to use a LEFT JOIN , RIGHT JOIN , or FULL JOIN instead to ensure that the data you need is not left out of the results. SELECT column , another_column , ... FROM mytable INNER / LEFT / RIGHT / FULL JOIN another_table ON mytable . id = another_table . matching_id WHERE condition ( s ) ORDER BY column , ... ASC / DESC LIMIT num_limit OFFSET num_offset ; Like the INNER JOIN these three new joins have to specify which column to join the data on. When joining table A to table B, a LEFT JOIN simply includes rows from A regardless of whether a matching row is found in B. the RIGHT JOIN is the same, but reversed, keeping rows in B regardless of whether a match is found in A. Finally, a FULL JOIN simply means that rows from both tables are kept, regardless of whether a matching row exists in the other table. When using any of these new joins, you will likely have to write additional logic to deal with NULL s in the result and constraints. JOINS You might see queries with these joins written as LEFT OUTER JOIN , RIGHT OUTER JOIN , or FULL OUTER JOIN , but the OUTER keyword is really kept for SQL-92 compatibility and these queries are simply equivalent to LEFT JOIN , RIGHT JOIN , and FULL JOIN respectively. For the following exercises we will be using new tables. We will use a table which stores fictional data about Employees in the film studio and their assigned office Buildings . Some of the buildings are new, so they don't have any employees in them yet, but we need to find some information about them regardless. Find the list of all buildings that have employees: SELECT DISTINCT building FROM employees ; Find the list of all buildings and their capacity: SELECT building_name , capacity FROM buildings ; List all buildings and the distinct employee roles in each building (including empty buildings): SELECT DISTINCT building_name , role FROM buildings LEFT JOIN employees on building_name = building ;","title":"Outer Joins"},{"location":"sql-joins-and-other-queries/#a-short-note-on-nulls","text":"It's always good to reduce the possibility of NULL values in databases because they require special attention when constructing queries, constraints (certain functions behave differently with null values) and when processing the results. An alternative to NULL values in your database is to have data-type appropriate default values , like 0 for numerical data, empty strings for text data, etc. But if your database needs to store incomplete data, then NULL values can be appropriate if the default values will skew later analysics (for example, when taking averages of numerical data). Sometimes, it's also not possible to avoid NULL values, as we saw in the last lesson when outer-joining two tables with asymmetric data. In these cases, you can test a column for NULL values in a WHERE clause by using either the IS NULL or IS NOT NULL constraint. SELECT column , another_column , ... FROM mytable WHERE column IS / IS NOT NULL AND / OR another_condition AND / OR ...; For the following exercises, we will be using the same Employees and Buildings tables from the last exercises. Find the name and role of all employees who have not been assigned to a building: SELECT name , role FROM employees WHERE building IS NULL ; Find the names of the buildings that hold no employees: SELECT DISTINCT building_name FROM buildings LEFT JOIN employees ON building_name = building WHERE role IS NULL ;","title":"A short note on NULLs"},{"location":"sql-joins-and-other-queries/#queries-with-expressions","text":"In addition to querying and referencing raw column data with SQL, you can also use expressions to write more complex logic on column calues in a query. These expressions can use mathematical and string functions along with basic arithmetic to transform values when the query is executed, as shown in this physics example: SELECT particle_speed / 2 . 0 AS half_particle_speed FROM physics_data WHERE ABS ( particle_position ) * 10 . 0 > 500 ; Each database has its own supported set of mathematical, string, and date functions that can be used in a query, which you can find in their own respective docs. The use of expressions can save time and extra post-processing of the result data, but can also make the query harder to read, so we recommend that when expressions are used in the SELECT part of the query, that they are also given a descriptive alias using the AS keyword. SELECT col_expression AS expr_description , ... FROM mytable ; In addition to expressions, regular columns and even tables can also have aliases to make them easier to reference in the output and as a part of simplifying more complex queries. SELECT column AS better_column_name , ... FROM a_long_widgets_table_name AS mywidgets INNER JOIN widget_sales ON mywidgets . id = widgets_sales . widget_id ; We are now going to use expressions to transform the BoxOffice data into something easier to understand for the tasks below. We will use the Movies.csv and Boxoffice.csv files for the following exercise: List all movies and their combines sales in millions of dollars: SELECT title , ( domestic_sales + international_sales ) / 1000000 AS gross_sales_millions FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; List all movies and their ratings in percent: SELECT title , rating * 10 AS rating_percent FROM movies JOIN boxoffice ON movies . id = boxoffice . movie_id ; List all movies that we released on even number years SELECT title , year FROM movies WHERE year % 2 = 0 ; Odd Vs. Even Remember that to determine if a SQL value is even or odd, we use the module operator ( % ), which returns the remainder after division of its operands. Since the remainder of an even number divided by 2 is always 0, and the remainder of an odd number divided by 2 is always 1 - this makes modulo an easy way to find even/odd numbers.","title":"Queries with Expressions"},{"location":"sql-joins-and-other-queries/#queries-with-aggregates","text":"In addition to the simple expressions from above, SQL also supports the use of aggregate expressions (or functions) that allow you to summarize information about a group of rows of data. With the Pixar database we have been using, aggregate functions can be used to answer questions like, \"How many movies has Pixar produced?\", or \"What is the highest grossing Pixar film each year?\". SELECT AGG_FUNC ( column_or_expression ) AS aggregate_description , ... FROM mytable WHERE constraint_expression ; Without a specified grouping, each aggregate function is going to run on the whole set of result rows and return a single value. And like normal expressionsm giving your aggregate functions an alias ensures that the results will be easier to read and process.","title":"Queries with Aggregates"},{"location":"sql-joins-and-other-queries/#common-aggregate-functions","text":"Below are some common aggregate functions that we will be using in fututre exercises: Function Description COUNT(*) COUNT (column) A common function used to count the number of rows in the group is no column name is specified. Otherwise, count the number of rows in the group with non-NULL values in the specified column. MIN (column) Finds the smallest numerical value in the specified column for all rows in the group. MAX (column) Finds the largest numerical value in the specified column for all rows in the group. AVG (column) Finds the average numerical value in the specified column for all rows in the group. SUM (column) Finds the sum of all numerical values in the specified column for the rows in the group. Docs: MySQL , Postgres , SQLite","title":"Common Aggregate Functions"},{"location":"sql-random/","text":"Random SQL Problems Movies Exercise In the following problems we will be using movies.db . This database is made of of multiple tables: movies, ratings, stars, and directors. We will need to JOIN some of these tables to answer some of the following problems: Write a SQL query to list the titles of all movies released in 2008. Your query should output a table with a single column for the title of each movie. SELECT title FROM movies WHERE year = 2008 ; Write a SQL query to determine the birth year of Emma Stone. Your query should output a table with a single column and a single row (plus optional header) containing Emma Stone\u2019s birth year. You may assume that there is only one person in the database with the name Emma Stone. SELECT birth FROM people WHERE name = 'Emma Stone' ; Write a SQL query to list the titles of all movies with a release date on or after 2018, in alphabetical order. Your query should output a table with a single column for the title of each movie. Movies released in 2018 should be included, as should movies with release dates in the future. SELECT title FROM movies WHERE year >= 2018 ORDER BY title ; Write a SQL query to determine the number of movies with an IMDb rating of 10.0. Your query should output a table with a single column and a single row (plus optional header) containing the number of movies with a 10.0 rating. SELECT COUNT ( * ) AS NumberOfMoviesWith10Rating FROM ratings WHERE rating = 10 ; Write a SQL query to list the titles and release years of all Harry Potter movies, in chronological order. Your query should output a table with two columns, one for the title of each movie and one for the release year of each movie. You may assume that the title of all Harry Potter movies will begin with the words \u201cHarry Potter\u201d, and that if a movie title begins with the words \u201cHarry Potter\u201d, it is a Harry Potter movie. SELECT title , year FROM movies WHERE title LIKE \"Harry Potter%\" ORDER BY year ; Write a SQL query to determine the average rating of all movies released in 2012. Your query should output a table with a single column and a single row (plus optional header) containing the average rating. SELECT AVG ( rating ) FROM ratings JOIN movies ON movies . id = ratings . movie_id WHERE year = 2012 ; Write a SQL query to list all movies released in 2010 and their ratings, in descending order by rating. For movies with the same rating, order them alphabetically by title. Your query should output a table with two columns, one for the title of each movie and one for the rating of each movie. Movies that do not have ratings should not be included in the result. SELECT title , rating FROM movies JOIN ratings on movies . id = ratings . movie_id WHERE year = 2010 ORDER BY rating DESC , title ; Write a SQL query to list the names of all people who starred in Toy Story. Your query should output a table with a single column for the name of each person. You may assume that there is only one movie in the database with the title Toy Story. SELECT name FROM people JOIN stars ON people . id = stars . person_id JOIN movies ON movies . id = stars . movie_id WHERE title = \"Toy Story\" ; Write a SQL query to list the names of all people who starred in a movie released in 2004, ordered by birth year. Your query should output a table with a single column for the name of each person. People with the same birth year may be listed in any order. No need to worry about people who have no birth year listed, so long as those who do have a birth year are listed in order. If a person appeared in more than one movie in 2004, they should only appear in your results once. SELECT DISTINCT name FROM people JOIN stars ON people . id = stars . person_id JOIN movies on movies . id = stars . movie_id WHERE year = 2004 ORDER BY birth ; Write a SQL query to list the names of all people who have directed a movie that received a rating of at least 9.0. Your query should output a table with a single column for the name of each person. SELECT name FROM people JOIN directors ON directors . person_id = people . id JOIN ratings ON directors . movie_id = ratings . movie_id WHERE rating >= 9 . 0 ; Write a SQL query to list the titles of the five highest rated movies (in order) that Chadwick Boseman starred in, starting with the highest rated. Your query should output a table with a single column for the title of each movie. You may assume that there is only one person in the database with the name Chadwick Boseman. SELECT DISTINCT title FROM people JOIN stars ON people . id = stars . person_id JOIN ratings ON ratings . movie_id = stars . movie_id JOIN movies ON movies . id = stars . movie_id WHERE name = \"Chadwick Boseman\" ORDER BY rating DESC LIMIT 5 ; Write a SQL query to list the titles of all movies in which both Johnny Depp and Helena Bonham Carter starred. Your query should output a table with a single column for the title of each movie. You may assume that there is only one person in the database with the name Johnny Depp. You may assume that there is only one person in the database with the name Helena Bonham Carter. SELECT title FROM people JOIN stars ON stars . person_id = people . id JOIN movies ON stars . movie_id = movies . id WHERE name = \"Johnny Depp\" AND movie_id IN ( SELECT movie_id FROM people JOIN stars ON stars . person_id = people . id WHERE name = \"Helena Bonham Carter\" ); Write a SQL query to list the names of all people who starred in a movie in which Kevin Bacon also starred. Your query should output a table with a single column for the name of each person. There may be multiple people named Kevin Bacon in the database. Be sure to only select the Kevin Bacon born in 1958. Kevin Bacon himself should not be included in the resulting list. SELECT DISTINCT name FROM people JOIN stars ON stars . person_id = people . id WHERE name != \"Kevin Bacon\" AND movie_id IN ( SELECT movie_id FROM people JOIN stars ON stars . person_id = people . id WHERE name = \"Kevin Bacon\" AND birth = 1958 ) Houses Exercise We are now going to implement a program to import Hogwarts student data into a database, and then produce class roseters. For this exercise we are going to use the files found in houses.zip . You will find the files characters.csv , import.py , roster.py , and students.db . We will import all of the school's data into a database and write a Python program to query that database to get house rosters. Breakdown In import.py , we will write a program that imports data from a CSV spreadsheet. The program should accept the name of a CSV file as a command-line argument. If the incorrect number of command-line arguments are provided, our program should print an error and exit. We are going to assume that the CSV file exists, and will have columns name , house , and birth . For each student in the CSV file, we are going to insert the student into the students table in the students.db database. While the CSV file provided in houses.zip has just a name column, that database has separate columns for first , middle , and last names. We will then want to first parse each name and separate it into first, middle, and last names. We are going to assume that each person's name field will contain either two space-separated names (a first and last name) or three space-separated names (a first, middle, and last name). For students without a middle name, we will leave their middle name field as NULL in the table. In roster.py , we will write a program that prints a list of students for a given house in alphabetical order. We will make the program accept the name of a house as a command-line argument. If the incorrect number of command-line arguments are provided, we will print an error or exit. Our program will query the students table in the students.db database for all students in the specified house. Or program should then print out each student's full name and birth year (formatted as, e.g., Harry James Potter, born 1980 or Luna Lovegood, born 1981 ). Each student will be printed on their own line. Students should be ordered by last name. If students share the same last name, we will order them by first name. Solution import.py from cs50 import SQL from sys import argv from sys import exit import csv #splits the names from the name column into their own array def partition_name ( full_name ): names = full_name . split () return names if len ( names ) >= 3 else [ names [ 0 ], None , names [ 1 ]] #checks argument count if len ( argv ) != 2 : print ( \"Arguments error\" ) exit ( 1 ) db = SQL ( \"sqlite:///students.db\" ) csv_path = argv [ 1 ] with open ( csv_path ) as csv_file : reader = csv . DictReader ( csv_file ) for row in reader : names = partition_name ( row [ \"name\" ]) #partition_name gives an array db . execute ( \"INSERT INTO students(first, middle, last, house, birth) VALUES(?, ?, ?, ?, ?)\" , names [ 0 ], names [ 1 ], names [ 2 ], row [ \"house\" ], row [ \"birth\" ]) roster.py from cs50 import SQL from sys import argv from sys import exit if len ( argv ) != 2 : print ( \"Argument Error\" ) exit ( 1 ) db = SQL ( \"sqlite:///students.db\" ) house_chosen = argv [ 1 ] rows = db . execute ( \"SELECT * FROM students WHERE house = ? ORDER BY last, first\" , house_chosen ) for row in rows : first , middle , last , birth = row [ \"first\" ], row [ \"middle\" ], row [ \"last\" ], row [ \"birth\" ] if row [ \"middle\" ] == None : print ( f \" { first } { last } , born { birth } \" ) else : print ( f \" { first } { middle } { last } , born { birth } \" ) Now try running the following commands and check your answer: $ python import.py characters.csv $ python roster.py Gryffindor Lavender Brown, born 1979 Colin Creevey, born 1981 Seamus Finnigan, born 1979 Hermione Jean Granger, born 1979 Neville Longbottom, born 1980 Parvati Patil, born 1979 Harry James Potter, born 1980 Dean Thomas, born 1980 Romilda Vane, born 1981 Ginevra Molly Weasley, born 1981 Ronald Bilius Weasley, born 1980","title":"Random Problems"},{"location":"sql-random/#random-sql-problems","text":"","title":"Random SQL Problems"},{"location":"sql-random/#movies-exercise","text":"In the following problems we will be using movies.db . This database is made of of multiple tables: movies, ratings, stars, and directors. We will need to JOIN some of these tables to answer some of the following problems: Write a SQL query to list the titles of all movies released in 2008. Your query should output a table with a single column for the title of each movie. SELECT title FROM movies WHERE year = 2008 ; Write a SQL query to determine the birth year of Emma Stone. Your query should output a table with a single column and a single row (plus optional header) containing Emma Stone\u2019s birth year. You may assume that there is only one person in the database with the name Emma Stone. SELECT birth FROM people WHERE name = 'Emma Stone' ; Write a SQL query to list the titles of all movies with a release date on or after 2018, in alphabetical order. Your query should output a table with a single column for the title of each movie. Movies released in 2018 should be included, as should movies with release dates in the future. SELECT title FROM movies WHERE year >= 2018 ORDER BY title ; Write a SQL query to determine the number of movies with an IMDb rating of 10.0. Your query should output a table with a single column and a single row (plus optional header) containing the number of movies with a 10.0 rating. SELECT COUNT ( * ) AS NumberOfMoviesWith10Rating FROM ratings WHERE rating = 10 ; Write a SQL query to list the titles and release years of all Harry Potter movies, in chronological order. Your query should output a table with two columns, one for the title of each movie and one for the release year of each movie. You may assume that the title of all Harry Potter movies will begin with the words \u201cHarry Potter\u201d, and that if a movie title begins with the words \u201cHarry Potter\u201d, it is a Harry Potter movie. SELECT title , year FROM movies WHERE title LIKE \"Harry Potter%\" ORDER BY year ; Write a SQL query to determine the average rating of all movies released in 2012. Your query should output a table with a single column and a single row (plus optional header) containing the average rating. SELECT AVG ( rating ) FROM ratings JOIN movies ON movies . id = ratings . movie_id WHERE year = 2012 ; Write a SQL query to list all movies released in 2010 and their ratings, in descending order by rating. For movies with the same rating, order them alphabetically by title. Your query should output a table with two columns, one for the title of each movie and one for the rating of each movie. Movies that do not have ratings should not be included in the result. SELECT title , rating FROM movies JOIN ratings on movies . id = ratings . movie_id WHERE year = 2010 ORDER BY rating DESC , title ; Write a SQL query to list the names of all people who starred in Toy Story. Your query should output a table with a single column for the name of each person. You may assume that there is only one movie in the database with the title Toy Story. SELECT name FROM people JOIN stars ON people . id = stars . person_id JOIN movies ON movies . id = stars . movie_id WHERE title = \"Toy Story\" ; Write a SQL query to list the names of all people who starred in a movie released in 2004, ordered by birth year. Your query should output a table with a single column for the name of each person. People with the same birth year may be listed in any order. No need to worry about people who have no birth year listed, so long as those who do have a birth year are listed in order. If a person appeared in more than one movie in 2004, they should only appear in your results once. SELECT DISTINCT name FROM people JOIN stars ON people . id = stars . person_id JOIN movies on movies . id = stars . movie_id WHERE year = 2004 ORDER BY birth ; Write a SQL query to list the names of all people who have directed a movie that received a rating of at least 9.0. Your query should output a table with a single column for the name of each person. SELECT name FROM people JOIN directors ON directors . person_id = people . id JOIN ratings ON directors . movie_id = ratings . movie_id WHERE rating >= 9 . 0 ; Write a SQL query to list the titles of the five highest rated movies (in order) that Chadwick Boseman starred in, starting with the highest rated. Your query should output a table with a single column for the title of each movie. You may assume that there is only one person in the database with the name Chadwick Boseman. SELECT DISTINCT title FROM people JOIN stars ON people . id = stars . person_id JOIN ratings ON ratings . movie_id = stars . movie_id JOIN movies ON movies . id = stars . movie_id WHERE name = \"Chadwick Boseman\" ORDER BY rating DESC LIMIT 5 ; Write a SQL query to list the titles of all movies in which both Johnny Depp and Helena Bonham Carter starred. Your query should output a table with a single column for the title of each movie. You may assume that there is only one person in the database with the name Johnny Depp. You may assume that there is only one person in the database with the name Helena Bonham Carter. SELECT title FROM people JOIN stars ON stars . person_id = people . id JOIN movies ON stars . movie_id = movies . id WHERE name = \"Johnny Depp\" AND movie_id IN ( SELECT movie_id FROM people JOIN stars ON stars . person_id = people . id WHERE name = \"Helena Bonham Carter\" ); Write a SQL query to list the names of all people who starred in a movie in which Kevin Bacon also starred. Your query should output a table with a single column for the name of each person. There may be multiple people named Kevin Bacon in the database. Be sure to only select the Kevin Bacon born in 1958. Kevin Bacon himself should not be included in the resulting list. SELECT DISTINCT name FROM people JOIN stars ON stars . person_id = people . id WHERE name != \"Kevin Bacon\" AND movie_id IN ( SELECT movie_id FROM people JOIN stars ON stars . person_id = people . id WHERE name = \"Kevin Bacon\" AND birth = 1958 )","title":"Movies Exercise"},{"location":"sql-random/#houses-exercise","text":"We are now going to implement a program to import Hogwarts student data into a database, and then produce class roseters. For this exercise we are going to use the files found in houses.zip . You will find the files characters.csv , import.py , roster.py , and students.db . We will import all of the school's data into a database and write a Python program to query that database to get house rosters.","title":"Houses Exercise"},{"location":"sql-random/#breakdown","text":"In import.py , we will write a program that imports data from a CSV spreadsheet. The program should accept the name of a CSV file as a command-line argument. If the incorrect number of command-line arguments are provided, our program should print an error and exit. We are going to assume that the CSV file exists, and will have columns name , house , and birth . For each student in the CSV file, we are going to insert the student into the students table in the students.db database. While the CSV file provided in houses.zip has just a name column, that database has separate columns for first , middle , and last names. We will then want to first parse each name and separate it into first, middle, and last names. We are going to assume that each person's name field will contain either two space-separated names (a first and last name) or three space-separated names (a first, middle, and last name). For students without a middle name, we will leave their middle name field as NULL in the table. In roster.py , we will write a program that prints a list of students for a given house in alphabetical order. We will make the program accept the name of a house as a command-line argument. If the incorrect number of command-line arguments are provided, we will print an error or exit. Our program will query the students table in the students.db database for all students in the specified house. Or program should then print out each student's full name and birth year (formatted as, e.g., Harry James Potter, born 1980 or Luna Lovegood, born 1981 ). Each student will be printed on their own line. Students should be ordered by last name. If students share the same last name, we will order them by first name.","title":"Breakdown"},{"location":"sql-random/#solution","text":"import.py from cs50 import SQL from sys import argv from sys import exit import csv #splits the names from the name column into their own array def partition_name ( full_name ): names = full_name . split () return names if len ( names ) >= 3 else [ names [ 0 ], None , names [ 1 ]] #checks argument count if len ( argv ) != 2 : print ( \"Arguments error\" ) exit ( 1 ) db = SQL ( \"sqlite:///students.db\" ) csv_path = argv [ 1 ] with open ( csv_path ) as csv_file : reader = csv . DictReader ( csv_file ) for row in reader : names = partition_name ( row [ \"name\" ]) #partition_name gives an array db . execute ( \"INSERT INTO students(first, middle, last, house, birth) VALUES(?, ?, ?, ?, ?)\" , names [ 0 ], names [ 1 ], names [ 2 ], row [ \"house\" ], row [ \"birth\" ]) roster.py from cs50 import SQL from sys import argv from sys import exit if len ( argv ) != 2 : print ( \"Argument Error\" ) exit ( 1 ) db = SQL ( \"sqlite:///students.db\" ) house_chosen = argv [ 1 ] rows = db . execute ( \"SELECT * FROM students WHERE house = ? ORDER BY last, first\" , house_chosen ) for row in rows : first , middle , last , birth = row [ \"first\" ], row [ \"middle\" ], row [ \"last\" ], row [ \"birth\" ] if row [ \"middle\" ] == None : print ( f \" { first } { last } , born { birth } \" ) else : print ( f \" { first } { middle } { last } , born { birth } \" ) Now try running the following commands and check your answer: $ python import.py characters.csv $ python roster.py Gryffindor Lavender Brown, born 1979 Colin Creevey, born 1981 Seamus Finnigan, born 1979 Hermione Jean Granger, born 1979 Neville Longbottom, born 1980 Parvati Patil, born 1979 Harry James Potter, born 1980 Dean Thomas, born 1980 Romilda Vane, born 1981 Ginevra Molly Weasley, born 1981 Ronald Bilius Weasley, born 1980","title":"Solution"},{"location":"sql/","text":"SQL Basics SQL (Structured Query Language) is a language designed to allow both technical and non-technical users query, manipulate, and transform data from a relational database. And due to its simplicity, SQL databases provide safe and scalable storage for millions of websites and mobile applications. Often times, in order for us to build the most function website we can, we depend on a database to store information. Databases often are set up as tables with information in columns and rows (e.g. Excel Spreadsheets & Google Sheets). Quick Links SQL Cheat Sheets Free SQL Course SQL for Dummies (PDF) Additional SQL Reference Material For the following examples we will be using sqlite3, which is a SQL command line program, on the CS50 IDE . We will also be using the following .csv file which contains a database with data about some of Pixar's classic movies. Let's import this into the IDE. First drag and drop the file into the left side of the IDE, preferably a folder. Next, let's run the following commands: sqlite3 movies.db This creates a new database called 'movies' . .mode csv This changes mode of the program to be able to read .csv files. .import \"Movies.csv\" movies This imports the Movies.csv file into a table called \"movies\". We should now be able to see and interact with the data inside our database. SELECT Queries 101 To retrieve data from a SQL database, we need to write SELECT statements, which are often colloquially refered to as queries . A query itself is just a statement which declares what data we are looking for, where to find it in the database, and optionally, how to transform it before it is returned. We can think of a table in SQL as a type of entity (i.e. dogs) and each row in that table as a specific instance of that type (i.e. pug, beagle, border collie, etc.). This means that the columns would then represent the common properties shared by all instances of that entity (i.e. color of fur, length of tail, etc.). And given a table of data, the most basic query we could write would be one that selects for a couple columns (properties) of the table with all the rows (instances), SELECT column , another_column , ... FROM mytable ; The result of this query will be a two-dimensional set of rows and columns, effectively a copy of the table, but only with the columns that we requested. If we want to retrieve all the columns of data from a table, we can then use the asterisk ( * ) shorthand in place of listing all the column names individually. SELECT * from mytable ; This query, in particular, is really useful because it's a simple way to inspect a table by dumping all the data at once. Now, lets begin using the .csv file from above for some exercises: Find the title of each film: SELECT title FROM movies ; Find the director of each film: SELECT director FROM movies ; Find the title and director of each film: SELECT title , director FROM movies ; Find the title and year of each film: SELECT title , year FROM movies ; Find all information about each film: SELECT * FROM movies ; Queries with Constraints Now we know how to select for specific columns of data from a table, but if you had a table with a hundred million rows of data, reading through all the rows would be inefficient and perhaps even impossible. In order to filter certain results from being returned, we need to use a WHERE clause in the query. The clause is applied to each row of data by checking specific column values to determine whether it should be included in the results or not. SELECT column , another_column , ... FROM mytable WHERE condition AND / OR another_condition AND / OR ...; More complex clauses can be constructed by joining numerous AND or OR logical keywords (i.e. num_wheels >= 4 AND doors <= 2). Below are some useful operators that you can use for numerical data (i.e. integer or floating point): Operator Condition SQL Example =, !=, <, <=, >, >= Standard numerical operators col_name ! = 4 BETWEEN ... AND ... Number is within a range of two values (inclusive) col_name BETWEEN 1.5 AND 10.5 NOT BETWEEN ... AND ... Number is not within range of two values (inclusive) col_name NOT BETWEEN 1 AND 10 IN (...) Number exists in a list col_name IN (2, 4, 6) NOT IN (...) Number does not exist in a list col_name NOT IN (1, 3, 5) In addition to making the results more manageable to understand, writing clauses to constrain the set of rows returned also allows the query to run faster due to the reduction in unnecessary data being returned. SQL Syntax As you may have noticed by now, SQL doesn't require you to write the keywords all capitalized, but as convention, it helps people distinguish SQL keywords from column and table names, and makes the query code easier to read. Now let's do some exercises using the same .csv from above: Find the movie with a row id of 6 : SELECT id , title FROM movies WHERE id = 6 ; Find the movies released in the year s between 2000 and 2010: SELECT title , year FROM movies WHERE year BETWEEN 2000 AND 2010 ; Find the movies not released in the year s between 2000 and 2010: SELECT title , year FROM movies WHERE year NOT BETWEEN 2000 AND 2010 ; Find the first 5 Pizar movies and their release year : SELECT title , year FROM movies WHERE year <= 2003 ; When Writing WHERE clauses with columns containing text data, SQL supports a number of useful operators to do things like case-insensitive string comparison and wildcard pattern matching. Below are a few common text-data specific operators: Operator Condition SQL Example = Case sensitive exact string comparison ( notice the single equals ) col_name = \"abc\" != or <> Case sensitive exact string inequality comparison col_name != \"abcd\" LIKE Case insensitive exact string comparison col_name LIKE \"ABC\" NOT LIKE Case insensitive exact string inequality comparison col_name NOT LIKE \"ABCD\" % Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) col_name LIKE \"%AT%\" (matches \"AT\", \"ATTIC\", \"CAT\" or even \"BATS\") _ Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) col_name LIKE \"AN_\" (matches \"AND\" but not \"AN\") IN (...) String exists in a list col_name IN (\"A\", \"B\", \"C\") NOT IN (...) String does not exist in a list col_name NOT IN (\"D\", \"E\", \"F\") String Quotes All strings must be quoted so that the query parser can distinguish words in the string from SQL keywords. We should not that while most database implementations are quite efficient when using these operators, full-text search is best left to dedicated libraries like Apache Lucene or Sphinx . These libraries are designed specifically to do full text search, and as a result are more efficient and can support a wider variety of search features including internationalization and advanced queries. Now let's test these operators using the same .csv from above: Find all the Toy Story movies: SELECT title , director FROM movies WHERE title LIKE \"Toy Story%\" ; Find all the movies directed by John Lasseter: SELECT title , director FROM movies WHERE director LIKE \"John Lasseter\" ; Find all the movies (and director) not directed by John Lasseter: SELECT title , director FROM movies WHERE director NOT LIKE \"John Lasseter\" ; Find all the WALL-* movies: SELECT title FROM movies WHERE title LIKE \"WALL-_\" ; Filtering and Sorting Query Results Even though the data in a database may be unique, the results of any particular query may not be - take our Movies table for example, many different movies can be released the same year. In such cases, SQL provides a convenient way to discard rows that have a duplicate column value by using the DISTINCT keyword. SELECT DISTINCT column , another_column , ... FROM mytable WHERE condition ( s ); Since the DISTINCT keyword will blindly remove duplicate values, we will learn in a future lesson how to discard duplicated based on specific columns using grouping and the GROUP BY cluase. Ordering Results Unlike our neatly ordered table in the last few lessons, most data in real databases are added in no particular column order. As a result, it can be difficult to read through and understand the results of a query as the size of a table increases to thousands or even millions of rows. To help with this, SQL provides a way to sort your results by a given column in ascending or descending order using the ORDER BY clause: SELECT column , another_column , ... FROM mytable WHERE condition ( s ) ORDER BY column ASC / DESC ; When an ORDER BY clause is specified, each row is sorted alpha-numerically based on the specified column's value. In some databases, you can also specify a collation to better sort data containing international text. Limiting Results to a Subset Another clause which is commonly used with the ORDER BY clause are the LIMIT and OFFSET clauses, which are a useful optimization to indicate to the database the subset of the results you care about. The LIMIT will reduce the number of rows to return, and the optional OFFSET will specify where to begin counting the number rows from: SELECT column , another_column , ... FROM mytable WHERE condition ( s ) ORDER BY column ASC / DESC LIMIT num_limit OFFSET num_offset ; If you think about websites like Reddit or Pinterest, the front page is a list of links sorted by popularity and time, and each subsequent page can be represented by sets of links at different offsets in the database. Using these clauses, the database can then execute queries faster and more efficiently by processing and returning only the requested content. Order of Execution LIMIT and OFFSET are applied relative to the other parts of a query, generally done last after other clauses have been aplied. Now let's do some exercises using the previous .csv used above: List all directors of Pixar movies (alphabetically), without duplicates: SELECT DISTINCT director FROM movies ORDER BY director ASC ; List the last four Pixar movies released (ordered from most recent to last): SELECT title FROM movies ORDER BY year DESC LIMIT 4 ; List the first 5 Pixar movies sorted alphabetically: SELECT title FROM movies ORDER BY title ASC LIMIT 5 ; List the next 5 Pixar movies sorted alphabetically: SELECT title FROM movies ORDER BY title ASC LIMIT 5 OFFSET 5 ; Review Exercises Let's take a new .csv file containing a few of the most populous cities in North America and do some review exercises from what has been learned above: List all the Canadian cities and their populations: SELECT city , population FROM north_american_cities WHERE country = \"Canada\" ; Order all the cities in the United States by their latitude from north to south: SELECT city , latitude FROM north_american_cities WHERE country = \"United States\" ORDER BY latitude DESC ; List all the cities west of Chicago, ordered from west to east: SELECT city , longitude FROM north_american_cities WHERE longitude < - 87 . 629798 ORDER BY longitude ASC ; List the two largest cities in Mexico (by population): SELECT city , population FROM north_american_cities WHERE country = \"Mexico\" ORDER BY population DESC LIMIT 2 ; List the third and fourth largest cities (by population) in the United States and their population: SELECT city , population FROM north_american_cities WHERE country = \"United States\" ORDER BY population DESC LIMIT 2 OFFSET 2 ;","title":"SQL Basics"},{"location":"sql/#sql-basics","text":"SQL (Structured Query Language) is a language designed to allow both technical and non-technical users query, manipulate, and transform data from a relational database. And due to its simplicity, SQL databases provide safe and scalable storage for millions of websites and mobile applications. Often times, in order for us to build the most function website we can, we depend on a database to store information. Databases often are set up as tables with information in columns and rows (e.g. Excel Spreadsheets & Google Sheets). Quick Links SQL Cheat Sheets Free SQL Course SQL for Dummies (PDF) Additional SQL Reference Material For the following examples we will be using sqlite3, which is a SQL command line program, on the CS50 IDE . We will also be using the following .csv file which contains a database with data about some of Pixar's classic movies. Let's import this into the IDE. First drag and drop the file into the left side of the IDE, preferably a folder. Next, let's run the following commands: sqlite3 movies.db This creates a new database called 'movies' . .mode csv This changes mode of the program to be able to read .csv files. .import \"Movies.csv\" movies This imports the Movies.csv file into a table called \"movies\". We should now be able to see and interact with the data inside our database.","title":"SQL Basics"},{"location":"sql/#select-queries-101","text":"To retrieve data from a SQL database, we need to write SELECT statements, which are often colloquially refered to as queries . A query itself is just a statement which declares what data we are looking for, where to find it in the database, and optionally, how to transform it before it is returned. We can think of a table in SQL as a type of entity (i.e. dogs) and each row in that table as a specific instance of that type (i.e. pug, beagle, border collie, etc.). This means that the columns would then represent the common properties shared by all instances of that entity (i.e. color of fur, length of tail, etc.). And given a table of data, the most basic query we could write would be one that selects for a couple columns (properties) of the table with all the rows (instances), SELECT column , another_column , ... FROM mytable ; The result of this query will be a two-dimensional set of rows and columns, effectively a copy of the table, but only with the columns that we requested. If we want to retrieve all the columns of data from a table, we can then use the asterisk ( * ) shorthand in place of listing all the column names individually. SELECT * from mytable ; This query, in particular, is really useful because it's a simple way to inspect a table by dumping all the data at once. Now, lets begin using the .csv file from above for some exercises: Find the title of each film: SELECT title FROM movies ; Find the director of each film: SELECT director FROM movies ; Find the title and director of each film: SELECT title , director FROM movies ; Find the title and year of each film: SELECT title , year FROM movies ; Find all information about each film: SELECT * FROM movies ;","title":"SELECT Queries 101"},{"location":"sql/#queries-with-constraints","text":"Now we know how to select for specific columns of data from a table, but if you had a table with a hundred million rows of data, reading through all the rows would be inefficient and perhaps even impossible. In order to filter certain results from being returned, we need to use a WHERE clause in the query. The clause is applied to each row of data by checking specific column values to determine whether it should be included in the results or not. SELECT column , another_column , ... FROM mytable WHERE condition AND / OR another_condition AND / OR ...; More complex clauses can be constructed by joining numerous AND or OR logical keywords (i.e. num_wheels >= 4 AND doors <= 2). Below are some useful operators that you can use for numerical data (i.e. integer or floating point): Operator Condition SQL Example =, !=, <, <=, >, >= Standard numerical operators col_name ! = 4 BETWEEN ... AND ... Number is within a range of two values (inclusive) col_name BETWEEN 1.5 AND 10.5 NOT BETWEEN ... AND ... Number is not within range of two values (inclusive) col_name NOT BETWEEN 1 AND 10 IN (...) Number exists in a list col_name IN (2, 4, 6) NOT IN (...) Number does not exist in a list col_name NOT IN (1, 3, 5) In addition to making the results more manageable to understand, writing clauses to constrain the set of rows returned also allows the query to run faster due to the reduction in unnecessary data being returned. SQL Syntax As you may have noticed by now, SQL doesn't require you to write the keywords all capitalized, but as convention, it helps people distinguish SQL keywords from column and table names, and makes the query code easier to read. Now let's do some exercises using the same .csv from above: Find the movie with a row id of 6 : SELECT id , title FROM movies WHERE id = 6 ; Find the movies released in the year s between 2000 and 2010: SELECT title , year FROM movies WHERE year BETWEEN 2000 AND 2010 ; Find the movies not released in the year s between 2000 and 2010: SELECT title , year FROM movies WHERE year NOT BETWEEN 2000 AND 2010 ; Find the first 5 Pizar movies and their release year : SELECT title , year FROM movies WHERE year <= 2003 ; When Writing WHERE clauses with columns containing text data, SQL supports a number of useful operators to do things like case-insensitive string comparison and wildcard pattern matching. Below are a few common text-data specific operators: Operator Condition SQL Example = Case sensitive exact string comparison ( notice the single equals ) col_name = \"abc\" != or <> Case sensitive exact string inequality comparison col_name != \"abcd\" LIKE Case insensitive exact string comparison col_name LIKE \"ABC\" NOT LIKE Case insensitive exact string inequality comparison col_name NOT LIKE \"ABCD\" % Used anywhere in a string to match a sequence of zero or more characters (only with LIKE or NOT LIKE) col_name LIKE \"%AT%\" (matches \"AT\", \"ATTIC\", \"CAT\" or even \"BATS\") _ Used anywhere in a string to match a single character (only with LIKE or NOT LIKE) col_name LIKE \"AN_\" (matches \"AND\" but not \"AN\") IN (...) String exists in a list col_name IN (\"A\", \"B\", \"C\") NOT IN (...) String does not exist in a list col_name NOT IN (\"D\", \"E\", \"F\") String Quotes All strings must be quoted so that the query parser can distinguish words in the string from SQL keywords. We should not that while most database implementations are quite efficient when using these operators, full-text search is best left to dedicated libraries like Apache Lucene or Sphinx . These libraries are designed specifically to do full text search, and as a result are more efficient and can support a wider variety of search features including internationalization and advanced queries. Now let's test these operators using the same .csv from above: Find all the Toy Story movies: SELECT title , director FROM movies WHERE title LIKE \"Toy Story%\" ; Find all the movies directed by John Lasseter: SELECT title , director FROM movies WHERE director LIKE \"John Lasseter\" ; Find all the movies (and director) not directed by John Lasseter: SELECT title , director FROM movies WHERE director NOT LIKE \"John Lasseter\" ; Find all the WALL-* movies: SELECT title FROM movies WHERE title LIKE \"WALL-_\" ;","title":"Queries with Constraints"},{"location":"sql/#filtering-and-sorting-query-results","text":"Even though the data in a database may be unique, the results of any particular query may not be - take our Movies table for example, many different movies can be released the same year. In such cases, SQL provides a convenient way to discard rows that have a duplicate column value by using the DISTINCT keyword. SELECT DISTINCT column , another_column , ... FROM mytable WHERE condition ( s ); Since the DISTINCT keyword will blindly remove duplicate values, we will learn in a future lesson how to discard duplicated based on specific columns using grouping and the GROUP BY cluase.","title":"Filtering and Sorting Query Results"},{"location":"sql/#ordering-results","text":"Unlike our neatly ordered table in the last few lessons, most data in real databases are added in no particular column order. As a result, it can be difficult to read through and understand the results of a query as the size of a table increases to thousands or even millions of rows. To help with this, SQL provides a way to sort your results by a given column in ascending or descending order using the ORDER BY clause: SELECT column , another_column , ... FROM mytable WHERE condition ( s ) ORDER BY column ASC / DESC ; When an ORDER BY clause is specified, each row is sorted alpha-numerically based on the specified column's value. In some databases, you can also specify a collation to better sort data containing international text.","title":"Ordering Results"},{"location":"sql/#limiting-results-to-a-subset","text":"Another clause which is commonly used with the ORDER BY clause are the LIMIT and OFFSET clauses, which are a useful optimization to indicate to the database the subset of the results you care about. The LIMIT will reduce the number of rows to return, and the optional OFFSET will specify where to begin counting the number rows from: SELECT column , another_column , ... FROM mytable WHERE condition ( s ) ORDER BY column ASC / DESC LIMIT num_limit OFFSET num_offset ; If you think about websites like Reddit or Pinterest, the front page is a list of links sorted by popularity and time, and each subsequent page can be represented by sets of links at different offsets in the database. Using these clauses, the database can then execute queries faster and more efficiently by processing and returning only the requested content. Order of Execution LIMIT and OFFSET are applied relative to the other parts of a query, generally done last after other clauses have been aplied. Now let's do some exercises using the previous .csv used above: List all directors of Pixar movies (alphabetically), without duplicates: SELECT DISTINCT director FROM movies ORDER BY director ASC ; List the last four Pixar movies released (ordered from most recent to last): SELECT title FROM movies ORDER BY year DESC LIMIT 4 ; List the first 5 Pixar movies sorted alphabetically: SELECT title FROM movies ORDER BY title ASC LIMIT 5 ; List the next 5 Pixar movies sorted alphabetically: SELECT title FROM movies ORDER BY title ASC LIMIT 5 OFFSET 5 ;","title":"Limiting Results to a Subset"},{"location":"sql/#review-exercises","text":"Let's take a new .csv file containing a few of the most populous cities in North America and do some review exercises from what has been learned above: List all the Canadian cities and their populations: SELECT city , population FROM north_american_cities WHERE country = \"Canada\" ; Order all the cities in the United States by their latitude from north to south: SELECT city , latitude FROM north_american_cities WHERE country = \"United States\" ORDER BY latitude DESC ; List all the cities west of Chicago, ordered from west to east: SELECT city , longitude FROM north_american_cities WHERE longitude < - 87 . 629798 ORDER BY longitude ASC ; List the two largest cities in Mexico (by population): SELECT city , population FROM north_american_cities WHERE country = \"Mexico\" ORDER BY population DESC LIMIT 2 ; List the third and fourth largest cities (by population) in the United States and their population: SELECT city , population FROM north_american_cities WHERE country = \"United States\" ORDER BY population DESC LIMIT 2 OFFSET 2 ;","title":"Review Exercises"},{"location":"ttt/","text":"Tic-Tac-Toe Explained Rules Tic-Tac-Toe is a classic two-player game where the object is to get three of your marks in a row. Both players need to choose their mark - either an \u2018X\u2019 or an \u2018O\u2019 before the game begins. Players can win the game by getting three of their marks in a row horizontally, vertically, or diagonally. The game grid is created by drawing two vertical lines intersected by two horizontal lines, roughly of equal spacing, which should create a 3x3 grid. The game grid should resemble the following image: Players will alternate turns, starting with \u2018X\u2019, by putting their mark in any open square. If no player is able to get three of their marks in a row and no spaces are left, the game is considered a tie. Below is an example of a winning game and a tie game: As you can see above in the game on the left, \u2018X\u2019 was able to put three of their marks in a row horizontally (marked with yellow line), which resulted in a win. On the right, no player was able to get three of their marks in a row, which resulted in a tie game. Strategy Tic-Tac-Toe may seem like a very simple game but making a good start and thinking ahead can lead to a win! Players who start the game are given a major advantage because they are able to choose anywhere on the board to play. The best method for the starting player is to play their \u2018X\u2019 into any of the four corners. If the other player (\u2018O\u2019) does not play their first move into the center, \u2018X\u2019 is almost guaranteed to win. If the second player does play in the middle, the game is almost guaranteed to be a tie, unless they make a mistake. If you do not start the game, the main goal is to force a tie. If the starting player plays their \u2018X\u2019 into the middle square, play your \u2018O\u2019 into any corner square and force a tie! If the starting player plays their \u2018X\u2019 into a corner, play your \u2018O\u2019 into the middle square to remove the possibility for \u2018X\u2019 to get a diagonal win. Conclusion Tic-Tac-Toe is a timeless, simple, and quick game that can be played by children as young as three years old. If both players are knowledgeable in the game, it will almost always result in a tie. One great advantage of Tic-Tac-Toe is that it can be played almost anywhere, from pencil and paper, sand at the beach, computer, and mobile applications, etc. Google offers a quick and easy way to play Tic-Tac-Toe by simply searching, \u201c tic tac toe \u201d. You can choose your difficulty (East, Medium, Impossible, or Play against a friend) and play against a computer or someone that also has access to your device. Have fun!","title":"Tic-Tac-Toe Explained"},{"location":"ttt/#tic-tac-toe-explained","text":"","title":"Tic-Tac-Toe Explained"},{"location":"ttt/#rules","text":"Tic-Tac-Toe is a classic two-player game where the object is to get three of your marks in a row. Both players need to choose their mark - either an \u2018X\u2019 or an \u2018O\u2019 before the game begins. Players can win the game by getting three of their marks in a row horizontally, vertically, or diagonally. The game grid is created by drawing two vertical lines intersected by two horizontal lines, roughly of equal spacing, which should create a 3x3 grid. The game grid should resemble the following image: Players will alternate turns, starting with \u2018X\u2019, by putting their mark in any open square. If no player is able to get three of their marks in a row and no spaces are left, the game is considered a tie. Below is an example of a winning game and a tie game: As you can see above in the game on the left, \u2018X\u2019 was able to put three of their marks in a row horizontally (marked with yellow line), which resulted in a win. On the right, no player was able to get three of their marks in a row, which resulted in a tie game.","title":"Rules"},{"location":"ttt/#strategy","text":"Tic-Tac-Toe may seem like a very simple game but making a good start and thinking ahead can lead to a win! Players who start the game are given a major advantage because they are able to choose anywhere on the board to play. The best method for the starting player is to play their \u2018X\u2019 into any of the four corners. If the other player (\u2018O\u2019) does not play their first move into the center, \u2018X\u2019 is almost guaranteed to win. If the second player does play in the middle, the game is almost guaranteed to be a tie, unless they make a mistake. If you do not start the game, the main goal is to force a tie. If the starting player plays their \u2018X\u2019 into the middle square, play your \u2018O\u2019 into any corner square and force a tie! If the starting player plays their \u2018X\u2019 into a corner, play your \u2018O\u2019 into the middle square to remove the possibility for \u2018X\u2019 to get a diagonal win.","title":"Strategy"},{"location":"ttt/#conclusion","text":"Tic-Tac-Toe is a timeless, simple, and quick game that can be played by children as young as three years old. If both players are knowledgeable in the game, it will almost always result in a tie. One great advantage of Tic-Tac-Toe is that it can be played almost anywhere, from pencil and paper, sand at the beach, computer, and mobile applications, etc. Google offers a quick and easy way to play Tic-Tac-Toe by simply searching, \u201c tic tac toe \u201d. You can choose your difficulty (East, Medium, Impossible, or Play against a friend) and play against a computer or someone that also has access to your device. Have fun!","title":"Conclusion"}]}